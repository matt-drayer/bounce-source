import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  date: any;
  geography: any;
  geometry: any;
  jsonb: any;
  numeric: any;
  timestamptz: any;
  uuid: any;
};

/** columns and relationships of "amenities" */
export type Amenities = {
  __typename?: 'Amenities';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "amenities". All fields are combined with a logical 'AND'. */
export type AmenitiesBoolExp = {
  _and?: InputMaybe<Array<AmenitiesBoolExp>>;
  _not?: InputMaybe<AmenitiesBoolExp>;
  _or?: InputMaybe<Array<AmenitiesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum AmenitiesEnum {
  Food = 'FOOD',
  Lights = 'LIGHTS',
  LockerRooms = 'LOCKER_ROOMS',
  ProShop = 'PRO_SHOP',
  Restrooms = 'RESTROOMS',
  Training = 'TRAINING',
  Water = 'WATER',
  WheelchairAccessible = 'WHEELCHAIR_ACCESSIBLE'
}

/** Boolean expression to compare columns of type "AmenitiesEnum". All fields are combined with logical 'AND'. */
export type AmenitiesEnumComparisonExp = {
  _eq?: InputMaybe<AmenitiesEnum>;
  _in?: InputMaybe<Array<AmenitiesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<AmenitiesEnum>;
  _nin?: InputMaybe<Array<AmenitiesEnum>>;
};

/** Ordering options when selecting data from "amenities". */
export type AmenitiesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "amenities" */
export enum AmenitiesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "amenities" */
export type AmenitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AmenitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AmenitiesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "app_personas" */
export type AppPersonas = {
  __typename?: 'AppPersonas';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "app_personas". All fields are combined with a logical 'AND'. */
export type AppPersonasBoolExp = {
  _and?: InputMaybe<Array<AppPersonasBoolExp>>;
  _not?: InputMaybe<AppPersonasBoolExp>;
  _or?: InputMaybe<Array<AppPersonasBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum AppPersonasEnum {
  Admin = 'ADMIN',
  Coach = 'COACH',
  Organizer = 'ORGANIZER',
  Player = 'PLAYER',
  System = 'SYSTEM'
}

/** Boolean expression to compare columns of type "AppPersonasEnum". All fields are combined with logical 'AND'. */
export type AppPersonasEnumComparisonExp = {
  _eq?: InputMaybe<AppPersonasEnum>;
  _in?: InputMaybe<Array<AppPersonasEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<AppPersonasEnum>;
  _nin?: InputMaybe<Array<AppPersonasEnum>>;
};

/** Ordering options when selecting data from "app_personas". */
export type AppPersonasOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "app_personas" */
export enum AppPersonasSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "app_personas" */
export type AppPersonasStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AppPersonasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AppPersonasStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "app_pings" */
export type AppPings = {
  __typename?: 'AppPings';
  id: Scalars['uuid'];
  /** An object relationship */
  user?: Maybe<Users>;
};

/** Boolean expression to filter rows from the table "app_pings". All fields are combined with a logical 'AND'. */
export type AppPingsBoolExp = {
  _and?: InputMaybe<Array<AppPingsBoolExp>>;
  _not?: InputMaybe<AppPingsBoolExp>;
  _or?: InputMaybe<Array<AppPingsBoolExp>>;
  id?: InputMaybe<UuidComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "app_pings" */
export enum AppPingsConstraint {
  /** unique or primary key constraint on columns "id" */
  AppPingsPkey = 'app_pings_pkey'
}

/** input type for inserting data into table "app_pings" */
export type AppPingsInsertInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  firebaseId?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  ipResponse?: InputMaybe<Scalars['jsonb']>;
  pathname?: InputMaybe<Scalars['String']>;
  /** iOS, Android, Web */
  platform?: InputMaybe<Scalars['String']>;
  queryString?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** response of any mutation on the table "app_pings" */
export type AppPingsMutationResponse = {
  __typename?: 'AppPingsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AppPings>;
};

/** on_conflict condition type for table "app_pings" */
export type AppPingsOnConflict = {
  constraint: AppPingsConstraint;
  updateColumns?: Array<AppPingsUpdateColumn>;
  where?: InputMaybe<AppPingsBoolExp>;
};

/** Ordering options when selecting data from "app_pings". */
export type AppPingsOrderBy = {
  id?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** select columns of table "app_pings" */
export enum AppPingsSelectColumn {
  /** column name */
  Id = 'id'
}

/** Streaming cursor of the table "app_pings" */
export type AppPingsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AppPingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AppPingsStreamCursorValueInput = {
  id?: InputMaybe<Scalars['uuid']>;
};

/** placeholder for update columns of table "app_pings" (current role has no relevant permissions) */
export enum AppPingsUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "ball_types" */
export type BallTypes = {
  __typename?: 'BallTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "ball_types". All fields are combined with a logical 'AND'. */
export type BallTypesBoolExp = {
  _and?: InputMaybe<Array<BallTypesBoolExp>>;
  _not?: InputMaybe<BallTypesBoolExp>;
  _or?: InputMaybe<Array<BallTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum BallTypesEnum {
  Custom = 'CUSTOM',
  FranklinX_40Pickleball = 'FRANKLIN_X_40_PICKLEBALL',
  GammaPhotonPickleball = 'GAMMA_PHOTON_PICKLEBALL',
  NotSelected = 'NOT_SELECTED',
  OnixDuraFast_40Pickleball = 'ONIX_DURA_FAST_40_PICKLEBALL',
  OnixFuseG2Pickleball = 'ONIX_FUSE_G2_PICKLEBALL',
  SelkirkProS1Pickleball = 'SELKIRK_PRO_S1_PICKLEBALL'
}

/** Boolean expression to compare columns of type "BallTypesEnum". All fields are combined with logical 'AND'. */
export type BallTypesEnumComparisonExp = {
  _eq?: InputMaybe<BallTypesEnum>;
  _in?: InputMaybe<Array<BallTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<BallTypesEnum>;
  _nin?: InputMaybe<Array<BallTypesEnum>>;
};

/** Ordering options when selecting data from "ball_types". */
export type BallTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "ball_types" */
export enum BallTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "ball_types" */
export type BallTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BallTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BallTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

/** columns and relationships of "cities" */
export type Cities = {
  __typename?: 'Cities';
  citySlug: Scalars['String'];
  /** An object relationship */
  countrySubdivision: CountrySubdivisions;
  countrySubdivisionId: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  geometry?: Maybe<Scalars['geography']>;
  /** An array relationship */
  groups: Array<Groups>;
  id: Scalars['uuid'];
  isActive: Scalars['Boolean'];
  latitude: Scalars['numeric'];
  longitude: Scalars['numeric'];
  name: Scalars['String'];
  slug: Scalars['String'];
  timezone?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  venues: Array<Venues>;
};


/** columns and relationships of "cities" */
export type CitiesGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


/** columns and relationships of "cities" */
export type CitiesVenuesArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};

/** order by aggregate values of table "cities" */
export type CitiesAggregateOrderBy = {
  avg?: InputMaybe<CitiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CitiesMaxOrderBy>;
  min?: InputMaybe<CitiesMinOrderBy>;
  stddev?: InputMaybe<CitiesStddevOrderBy>;
  stddevPop?: InputMaybe<CitiesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<CitiesStddevSampOrderBy>;
  sum?: InputMaybe<CitiesSumOrderBy>;
  varPop?: InputMaybe<CitiesVarPopOrderBy>;
  varSamp?: InputMaybe<CitiesVarSampOrderBy>;
  variance?: InputMaybe<CitiesVarianceOrderBy>;
};

/** order by avg() on columns of table "cities" */
export type CitiesAvgOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "cities". All fields are combined with a logical 'AND'. */
export type CitiesBoolExp = {
  _and?: InputMaybe<Array<CitiesBoolExp>>;
  _not?: InputMaybe<CitiesBoolExp>;
  _or?: InputMaybe<Array<CitiesBoolExp>>;
  citySlug?: InputMaybe<StringComparisonExp>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsBoolExp>;
  countrySubdivisionId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groups?: InputMaybe<GroupsBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venues?: InputMaybe<VenuesBoolExp>;
};

/** order by max() on columns of table "cities" */
export type CitiesMaxOrderBy = {
  citySlug?: InputMaybe<OrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "cities" */
export type CitiesMinOrderBy = {
  citySlug?: InputMaybe<OrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "cities". */
export type CitiesOrderBy = {
  citySlug?: InputMaybe<OrderBy>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsOrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<GroupsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venuesAggregate?: InputMaybe<VenuesAggregateOrderBy>;
};

/** select columns of table "cities" */
export enum CitiesSelectColumn {
  /** column name */
  CitySlug = 'citySlug',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "cities" */
export type CitiesStddevOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "cities" */
export type CitiesStddevPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "cities" */
export type CitiesStddevSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "cities" */
export type CitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CitiesStreamCursorValueInput = {
  citySlug?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "cities" */
export type CitiesSumOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "cities" */
export type CitiesVarPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "cities" */
export type CitiesVarSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "cities" */
export type CitiesVarianceOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** columns and relationships of "coach_qualification_groups" */
export type CoachQualificationGroups = {
  __typename?: 'CoachQualificationGroups';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "coach_qualification_groups". All fields are combined with a logical 'AND'. */
export type CoachQualificationGroupsBoolExp = {
  _and?: InputMaybe<Array<CoachQualificationGroupsBoolExp>>;
  _not?: InputMaybe<CoachQualificationGroupsBoolExp>;
  _or?: InputMaybe<Array<CoachQualificationGroupsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CoachQualificationGroupsEnum {
  Certificate = 'CERTIFICATE',
  CurrentCollegePlayer = 'CURRENT_COLLEGE_PLAYER',
  FormerCollegePlayer = 'FORMER_COLLEGE_PLAYER'
}

/** Boolean expression to compare columns of type "CoachQualificationGroupsEnum". All fields are combined with logical 'AND'. */
export type CoachQualificationGroupsEnumComparisonExp = {
  _eq?: InputMaybe<CoachQualificationGroupsEnum>;
  _in?: InputMaybe<Array<CoachQualificationGroupsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CoachQualificationGroupsEnum>;
  _nin?: InputMaybe<Array<CoachQualificationGroupsEnum>>;
};

/** Ordering options when selecting data from "coach_qualification_groups". */
export type CoachQualificationGroupsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "coach_qualification_groups" */
export enum CoachQualificationGroupsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "coach_qualification_groups" */
export type CoachQualificationGroupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachQualificationGroupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachQualificationGroupsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export enum CoachQualificationStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "CoachQualificationStatusesEnum". All fields are combined with logical 'AND'. */
export type CoachQualificationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<CoachQualificationStatusesEnum>;
  _in?: InputMaybe<Array<CoachQualificationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CoachQualificationStatusesEnum>;
  _nin?: InputMaybe<Array<CoachQualificationStatusesEnum>>;
};

/** columns and relationships of "coach_qualifications" */
export type CoachQualifications = {
  __typename?: 'CoachQualifications';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayKey: Scalars['String'];
  groupId?: Maybe<CoachQualificationGroupsEnum>;
  id: Scalars['uuid'];
  name: Scalars['String'];
  order: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "coach_qualifications". All fields are combined with a logical 'AND'. */
export type CoachQualificationsBoolExp = {
  _and?: InputMaybe<Array<CoachQualificationsBoolExp>>;
  _not?: InputMaybe<CoachQualificationsBoolExp>;
  _or?: InputMaybe<Array<CoachQualificationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  displayKey?: InputMaybe<StringComparisonExp>;
  groupId?: InputMaybe<CoachQualificationGroupsEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** Ordering options when selecting data from "coach_qualifications". */
export type CoachQualificationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayKey?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "coach_qualifications" */
export enum CoachQualificationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayKey = 'displayKey',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "coach_qualifications" */
export type CoachQualificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachQualificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachQualificationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayKey?: InputMaybe<Scalars['String']>;
  groupId?: InputMaybe<CoachQualificationGroupsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "coach_status" */
export type CoachStatus = {
  __typename?: 'CoachStatus';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "coach_status". All fields are combined with a logical 'AND'. */
export type CoachStatusBoolExp = {
  _and?: InputMaybe<Array<CoachStatusBoolExp>>;
  _not?: InputMaybe<CoachStatusBoolExp>;
  _or?: InputMaybe<Array<CoachStatusBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CoachStatusEnum {
  Active = 'ACTIVE',
  Blocked = 'BLOCKED',
  Inactive = 'INACTIVE',
  None = 'NONE'
}

/** Boolean expression to compare columns of type "CoachStatusEnum". All fields are combined with logical 'AND'. */
export type CoachStatusEnumComparisonExp = {
  _eq?: InputMaybe<CoachStatusEnum>;
  _in?: InputMaybe<Array<CoachStatusEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CoachStatusEnum>;
  _nin?: InputMaybe<Array<CoachStatusEnum>>;
};

/** Ordering options when selecting data from "coach_status". */
export type CoachStatusOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "coach_status" */
export enum CoachStatusSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "coach_status" */
export type CoachStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachStatusStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "comment_vote" */
export type CommentVote = {
  __typename?: 'CommentVote';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "comment_vote". All fields are combined with a logical 'AND'. */
export type CommentVoteBoolExp = {
  _and?: InputMaybe<Array<CommentVoteBoolExp>>;
  _not?: InputMaybe<CommentVoteBoolExp>;
  _or?: InputMaybe<Array<CommentVoteBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CommentVoteEnum {
  Negative = 'NEGATIVE',
  None = 'NONE',
  Positive = 'POSITIVE'
}

/** Boolean expression to compare columns of type "CommentVoteEnum". All fields are combined with logical 'AND'. */
export type CommentVoteEnumComparisonExp = {
  _eq?: InputMaybe<CommentVoteEnum>;
  _in?: InputMaybe<Array<CommentVoteEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CommentVoteEnum>;
  _nin?: InputMaybe<Array<CommentVoteEnum>>;
};

/** Ordering options when selecting data from "comment_vote". */
export type CommentVoteOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "comment_vote" */
export enum CommentVoteSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "comment_vote" */
export type CommentVoteStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CommentVoteStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CommentVoteStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "communication_preference_statuses" */
export type CommunicationPreferenceStatuses = {
  __typename?: 'CommunicationPreferenceStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "communication_preference_statuses". All fields are combined with a logical 'AND'. */
export type CommunicationPreferenceStatusesBoolExp = {
  _and?: InputMaybe<Array<CommunicationPreferenceStatusesBoolExp>>;
  _not?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
  _or?: InputMaybe<Array<CommunicationPreferenceStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CommunicationPreferenceStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "CommunicationPreferenceStatusesEnum". All fields are combined with logical 'AND'. */
export type CommunicationPreferenceStatusesEnumComparisonExp = {
  _eq?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  _in?: InputMaybe<Array<CommunicationPreferenceStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  _nin?: InputMaybe<Array<CommunicationPreferenceStatusesEnum>>;
};

/** Ordering options when selecting data from "communication_preference_statuses". */
export type CommunicationPreferenceStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "communication_preference_statuses" */
export enum CommunicationPreferenceStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "communication_preference_statuses" */
export type CommunicationPreferenceStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CommunicationPreferenceStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CommunicationPreferenceStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "competition_formats" */
export type CompetitionFormats = {
  __typename?: 'CompetitionFormats';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "competition_formats". All fields are combined with a logical 'AND'. */
export type CompetitionFormatsBoolExp = {
  _and?: InputMaybe<Array<CompetitionFormatsBoolExp>>;
  _not?: InputMaybe<CompetitionFormatsBoolExp>;
  _or?: InputMaybe<Array<CompetitionFormatsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CompetitionFormatsEnum {
  Custom = 'CUSTOM',
  DoubleElimination = 'DOUBLE_ELIMINATION',
  RoundRobin = 'ROUND_ROBIN',
  SingleElimination = 'SINGLE_ELIMINATION'
}

/** Boolean expression to compare columns of type "CompetitionFormatsEnum". All fields are combined with logical 'AND'. */
export type CompetitionFormatsEnumComparisonExp = {
  _eq?: InputMaybe<CompetitionFormatsEnum>;
  _in?: InputMaybe<Array<CompetitionFormatsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CompetitionFormatsEnum>;
  _nin?: InputMaybe<Array<CompetitionFormatsEnum>>;
};

/** Ordering options when selecting data from "competition_formats". */
export type CompetitionFormatsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "competition_formats" */
export enum CompetitionFormatsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "competition_formats" */
export type CompetitionFormatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CompetitionFormatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CompetitionFormatsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "competition_gender" */
export type CompetitionGender = {
  __typename?: 'CompetitionGender';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "competition_gender". All fields are combined with a logical 'AND'. */
export type CompetitionGenderBoolExp = {
  _and?: InputMaybe<Array<CompetitionGenderBoolExp>>;
  _not?: InputMaybe<CompetitionGenderBoolExp>;
  _or?: InputMaybe<Array<CompetitionGenderBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CompetitionGenderEnum {
  Female = 'FEMALE',
  Male = 'MALE',
  Mixed = 'MIXED'
}

/** Boolean expression to compare columns of type "CompetitionGenderEnum". All fields are combined with logical 'AND'. */
export type CompetitionGenderEnumComparisonExp = {
  _eq?: InputMaybe<CompetitionGenderEnum>;
  _in?: InputMaybe<Array<CompetitionGenderEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CompetitionGenderEnum>;
  _nin?: InputMaybe<Array<CompetitionGenderEnum>>;
};

/** Ordering options when selecting data from "competition_gender". */
export type CompetitionGenderOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "competition_gender" */
export enum CompetitionGenderSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "competition_gender" */
export type CompetitionGenderStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CompetitionGenderStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CompetitionGenderStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Note that this breaks from the standard and uses the country iso3 as a text field for the id */
export type Countries = {
  __typename?: 'Countries';
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  emoji: Scalars['String'];
  geometry?: Maybe<Scalars['geography']>;
  id: Scalars['String'];
  iso2: Scalars['String'];
  iso3: Scalars['String'];
  latitude: Scalars['numeric'];
  longitude: Scalars['numeric'];
  name: Scalars['String'];
  nameSlug: Scalars['String'];
  numericCode: Scalars['String'];
  phoneCode: Scalars['String'];
  slug: Scalars['String'];
  /** An array relationship */
  subdivisions: Array<CountrySubdivisions>;
  updatedAt: Scalars['timestamptz'];
};


/** Note that this breaks from the standard and uses the country iso3 as a text field for the id */
export type CountriesSubdivisionsArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};

/** Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'. */
export type CountriesBoolExp = {
  _and?: InputMaybe<Array<CountriesBoolExp>>;
  _not?: InputMaybe<CountriesBoolExp>;
  _or?: InputMaybe<Array<CountriesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  emoji?: InputMaybe<StringComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  iso2?: InputMaybe<StringComparisonExp>;
  iso3?: InputMaybe<StringComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  nameSlug?: InputMaybe<StringComparisonExp>;
  numericCode?: InputMaybe<StringComparisonExp>;
  phoneCode?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  subdivisions?: InputMaybe<CountrySubdivisionsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** Ordering options when selecting data from "countries". */
export type CountriesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  emoji?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  iso2?: InputMaybe<OrderBy>;
  iso3?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  nameSlug?: InputMaybe<OrderBy>;
  numericCode?: InputMaybe<OrderBy>;
  phoneCode?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  subdivisionsAggregate?: InputMaybe<CountrySubdivisionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "countries" */
export enum CountriesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Emoji = 'emoji',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  Iso2 = 'iso2',
  /** column name */
  Iso3 = 'iso3',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  NameSlug = 'nameSlug',
  /** column name */
  NumericCode = 'numericCode',
  /** column name */
  PhoneCode = 'phoneCode',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "countries" */
export type CountriesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CountriesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CountriesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  emoji?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['String']>;
  iso2?: InputMaybe<Scalars['String']>;
  iso3?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  nameSlug?: InputMaybe<Scalars['String']>;
  numericCode?: InputMaybe<Scalars['String']>;
  phoneCode?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "country_subdivisions" */
export type CountrySubdivisions = {
  __typename?: 'CountrySubdivisions';
  /** An array relationship */
  cities: Array<Cities>;
  code: Scalars['String'];
  /** An object relationship */
  country: Countries;
  countryId: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  geometry?: Maybe<Scalars['geography']>;
  id: Scalars['uuid'];
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name: Scalars['String'];
  slug: Scalars['String'];
  type: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "country_subdivisions" */
export type CountrySubdivisionsCitiesArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};

/** order by aggregate values of table "country_subdivisions" */
export type CountrySubdivisionsAggregateOrderBy = {
  avg?: InputMaybe<CountrySubdivisionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CountrySubdivisionsMaxOrderBy>;
  min?: InputMaybe<CountrySubdivisionsMinOrderBy>;
  stddev?: InputMaybe<CountrySubdivisionsStddevOrderBy>;
  stddevPop?: InputMaybe<CountrySubdivisionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<CountrySubdivisionsStddevSampOrderBy>;
  sum?: InputMaybe<CountrySubdivisionsSumOrderBy>;
  varPop?: InputMaybe<CountrySubdivisionsVarPopOrderBy>;
  varSamp?: InputMaybe<CountrySubdivisionsVarSampOrderBy>;
  variance?: InputMaybe<CountrySubdivisionsVarianceOrderBy>;
};

/** order by avg() on columns of table "country_subdivisions" */
export type CountrySubdivisionsAvgOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "country_subdivisions". All fields are combined with a logical 'AND'. */
export type CountrySubdivisionsBoolExp = {
  _and?: InputMaybe<Array<CountrySubdivisionsBoolExp>>;
  _not?: InputMaybe<CountrySubdivisionsBoolExp>;
  _or?: InputMaybe<Array<CountrySubdivisionsBoolExp>>;
  cities?: InputMaybe<CitiesBoolExp>;
  code?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<CountriesBoolExp>;
  countryId?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "country_subdivisions" */
export type CountrySubdivisionsMaxOrderBy = {
  code?: InputMaybe<OrderBy>;
  countryId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "country_subdivisions" */
export type CountrySubdivisionsMinOrderBy = {
  code?: InputMaybe<OrderBy>;
  countryId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "country_subdivisions". */
export type CountrySubdivisionsOrderBy = {
  citiesAggregate?: InputMaybe<CitiesAggregateOrderBy>;
  code?: InputMaybe<OrderBy>;
  country?: InputMaybe<CountriesOrderBy>;
  countryId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "country_subdivisions" */
export enum CountrySubdivisionsSelectColumn {
  /** column name */
  Code = 'code',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "country_subdivisions" */
export type CountrySubdivisionsStddevOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "country_subdivisions" */
export type CountrySubdivisionsStddevPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "country_subdivisions" */
export type CountrySubdivisionsStddevSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "country_subdivisions" */
export type CountrySubdivisionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CountrySubdivisionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CountrySubdivisionsStreamCursorValueInput = {
  code?: InputMaybe<Scalars['String']>;
  countryId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "country_subdivisions" */
export type CountrySubdivisionsSumOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "country_subdivisions" */
export type CountrySubdivisionsVarPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "country_subdivisions" */
export type CountrySubdivisionsVarSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "country_subdivisions" */
export type CountrySubdivisionsVarianceOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** columns and relationships of "court_surfaces" */
export type CourtSurfaces = {
  __typename?: 'CourtSurfaces';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "court_surfaces". All fields are combined with a logical 'AND'. */
export type CourtSurfacesBoolExp = {
  _and?: InputMaybe<Array<CourtSurfacesBoolExp>>;
  _not?: InputMaybe<CourtSurfacesBoolExp>;
  _or?: InputMaybe<Array<CourtSurfacesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum CourtSurfacesEnum {
  Acrylic = 'ACRYLIC',
  Asphalt = 'ASPHALT',
  Carpet = 'CARPET',
  Clay = 'CLAY',
  Concrete = 'CONCRETE',
  Grass = 'GRASS',
  Hard = 'HARD',
  Wood = 'WOOD'
}

/** Boolean expression to compare columns of type "CourtSurfacesEnum". All fields are combined with logical 'AND'. */
export type CourtSurfacesEnumComparisonExp = {
  _eq?: InputMaybe<CourtSurfacesEnum>;
  _in?: InputMaybe<Array<CourtSurfacesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CourtSurfacesEnum>;
  _nin?: InputMaybe<Array<CourtSurfacesEnum>>;
};

/** Ordering options when selecting data from "court_surfaces". */
export type CourtSurfacesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "court_surfaces" */
export enum CourtSurfacesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "court_surfaces" */
export type CourtSurfacesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CourtSurfacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CourtSurfacesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  _eq?: InputMaybe<Scalars['date']>;
  _gt?: InputMaybe<Scalars['date']>;
  _gte?: InputMaybe<Scalars['date']>;
  _in?: InputMaybe<Array<Scalars['date']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['date']>;
  _lte?: InputMaybe<Scalars['date']>;
  _neq?: InputMaybe<Scalars['date']>;
  _nin?: InputMaybe<Array<Scalars['date']>>;
};

/** columns and relationships of "event_contact_details" */
export type EventContactDetails = {
  __typename?: 'EventContactDetails';
  contactUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email: Scalars['String'];
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  phoneNumber: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "event_contact_details". All fields are combined with a logical 'AND'. */
export type EventContactDetailsBoolExp = {
  _and?: InputMaybe<Array<EventContactDetailsBoolExp>>;
  _not?: InputMaybe<EventContactDetailsBoolExp>;
  _or?: InputMaybe<Array<EventContactDetailsBoolExp>>;
  contactUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** response of any mutation on the table "event_contact_details" */
export type EventContactDetailsMutationResponse = {
  __typename?: 'EventContactDetailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventContactDetails>;
};

/** Ordering options when selecting data from "event_contact_details". */
export type EventContactDetailsOrderBy = {
  contactUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_contact_details */
export type EventContactDetailsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_contact_details" */
export enum EventContactDetailsSelectColumn {
  /** column name */
  ContactUrl = 'contactUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_contact_details" */
export type EventContactDetailsSetInput = {
  contactUrl?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_contact_details" */
export type EventContactDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventContactDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventContactDetailsStreamCursorValueInput = {
  contactUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

export type EventContactDetailsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventContactDetailsSetInput>;
  /** filter the rows which have to be updated */
  where: EventContactDetailsBoolExp;
};

/** columns and relationships of "event_court_statuses" */
export type EventCourtStatuses = {
  __typename?: 'EventCourtStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_court_statuses". All fields are combined with a logical 'AND'. */
export type EventCourtStatusesBoolExp = {
  _and?: InputMaybe<Array<EventCourtStatusesBoolExp>>;
  _not?: InputMaybe<EventCourtStatusesBoolExp>;
  _or?: InputMaybe<Array<EventCourtStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventCourtStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "EventCourtStatusesEnum". All fields are combined with logical 'AND'. */
export type EventCourtStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventCourtStatusesEnum>;
  _in?: InputMaybe<Array<EventCourtStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventCourtStatusesEnum>;
  _nin?: InputMaybe<Array<EventCourtStatusesEnum>>;
};

/** Ordering options when selecting data from "event_court_statuses". */
export type EventCourtStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_court_statuses" */
export enum EventCourtStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_court_statuses" */
export type EventCourtStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventCourtStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventCourtStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Note: This table may be overly structured with the foreign keys. Consider removing some if they're not needed. */
export type EventCourts = {
  __typename?: 'EventCourts';
  activeEventGroupId?: Maybe<Scalars['uuid']>;
  activeEventGroupPoolId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  activeGroup?: Maybe<EventGroups>;
  /** An object relationship */
  activeMatch?: Maybe<EventMatches>;
  activeMatchId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  activePool?: Maybe<EventGroupPools>;
  courtNumber: Scalars['Int'];
  courtStatus: EventCourtStatusesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatches>;
  updatedAt: Scalars['timestamptz'];
};


/** Note: This table may be overly structured with the foreign keys. Consider removing some if they're not needed. */
export type EventCourtsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};

/** order by aggregate values of table "event_courts" */
export type EventCourtsAggregateOrderBy = {
  avg?: InputMaybe<EventCourtsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventCourtsMaxOrderBy>;
  min?: InputMaybe<EventCourtsMinOrderBy>;
  stddev?: InputMaybe<EventCourtsStddevOrderBy>;
  stddevPop?: InputMaybe<EventCourtsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventCourtsStddevSampOrderBy>;
  sum?: InputMaybe<EventCourtsSumOrderBy>;
  varPop?: InputMaybe<EventCourtsVarPopOrderBy>;
  varSamp?: InputMaybe<EventCourtsVarSampOrderBy>;
  variance?: InputMaybe<EventCourtsVarianceOrderBy>;
};

/** order by avg() on columns of table "event_courts" */
export type EventCourtsAvgOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_courts". All fields are combined with a logical 'AND'. */
export type EventCourtsBoolExp = {
  _and?: InputMaybe<Array<EventCourtsBoolExp>>;
  _not?: InputMaybe<EventCourtsBoolExp>;
  _or?: InputMaybe<Array<EventCourtsBoolExp>>;
  activeEventGroupId?: InputMaybe<UuidComparisonExp>;
  activeEventGroupPoolId?: InputMaybe<UuidComparisonExp>;
  activeGroup?: InputMaybe<EventGroupsBoolExp>;
  activeMatch?: InputMaybe<EventMatchesBoolExp>;
  activeMatchId?: InputMaybe<UuidComparisonExp>;
  activePool?: InputMaybe<EventGroupPoolsBoolExp>;
  courtNumber?: InputMaybe<IntComparisonExp>;
  courtStatus?: InputMaybe<EventCourtStatusesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_courts" */
export type EventCourtsMaxOrderBy = {
  activeEventGroupId?: InputMaybe<OrderBy>;
  activeEventGroupPoolId?: InputMaybe<OrderBy>;
  activeMatchId?: InputMaybe<OrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_courts" */
export type EventCourtsMinOrderBy = {
  activeEventGroupId?: InputMaybe<OrderBy>;
  activeEventGroupPoolId?: InputMaybe<OrderBy>;
  activeMatchId?: InputMaybe<OrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_courts" */
export type EventCourtsMutationResponse = {
  __typename?: 'EventCourtsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventCourts>;
};

/** Ordering options when selecting data from "event_courts". */
export type EventCourtsOrderBy = {
  activeEventGroupId?: InputMaybe<OrderBy>;
  activeEventGroupPoolId?: InputMaybe<OrderBy>;
  activeGroup?: InputMaybe<EventGroupsOrderBy>;
  activeMatch?: InputMaybe<EventMatchesOrderBy>;
  activeMatchId?: InputMaybe<OrderBy>;
  activePool?: InputMaybe<EventGroupPoolsOrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  courtStatus?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_courts */
export type EventCourtsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_courts" */
export enum EventCourtsSelectColumn {
  /** column name */
  ActiveEventGroupId = 'activeEventGroupId',
  /** column name */
  ActiveEventGroupPoolId = 'activeEventGroupPoolId',
  /** column name */
  ActiveMatchId = 'activeMatchId',
  /** column name */
  CourtNumber = 'courtNumber',
  /** column name */
  CourtStatus = 'courtStatus',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_courts" */
export type EventCourtsSetInput = {
  activeEventGroupId?: InputMaybe<Scalars['uuid']>;
  activeEventGroupPoolId?: InputMaybe<Scalars['uuid']>;
  activeMatchId?: InputMaybe<Scalars['uuid']>;
  courtStatus?: InputMaybe<EventCourtStatusesEnum>;
};

/** order by stddev() on columns of table "event_courts" */
export type EventCourtsStddevOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_courts" */
export type EventCourtsStddevPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_courts" */
export type EventCourtsStddevSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_courts" */
export type EventCourtsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventCourtsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventCourtsStreamCursorValueInput = {
  activeEventGroupId?: InputMaybe<Scalars['uuid']>;
  activeEventGroupPoolId?: InputMaybe<Scalars['uuid']>;
  activeMatchId?: InputMaybe<Scalars['uuid']>;
  courtNumber?: InputMaybe<Scalars['Int']>;
  courtStatus?: InputMaybe<EventCourtStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_courts" */
export type EventCourtsSumOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

export type EventCourtsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventCourtsSetInput>;
  /** filter the rows which have to be updated */
  where: EventCourtsBoolExp;
};

/** order by varPop() on columns of table "event_courts" */
export type EventCourtsVarPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_courts" */
export type EventCourtsVarSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_courts" */
export type EventCourtsVarianceOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_faqs" */
export type EventFaqs = {
  __typename?: 'EventFaqs';
  answer: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  question: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_faqs" */
export type EventFaqsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventFaqsMaxOrderBy>;
  min?: InputMaybe<EventFaqsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_faqs". All fields are combined with a logical 'AND'. */
export type EventFaqsBoolExp = {
  _and?: InputMaybe<Array<EventFaqsBoolExp>>;
  _not?: InputMaybe<EventFaqsBoolExp>;
  _or?: InputMaybe<Array<EventFaqsBoolExp>>;
  answer?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  question?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_faqs" */
export enum EventFaqsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventFaqsPkey = 'event_faqs_pkey'
}

/** input type for inserting data into table "event_faqs" */
export type EventFaqsInsertInput = {
  answer?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
};

/** order by max() on columns of table "event_faqs" */
export type EventFaqsMaxOrderBy = {
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_faqs" */
export type EventFaqsMinOrderBy = {
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_faqs" */
export type EventFaqsMutationResponse = {
  __typename?: 'EventFaqsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventFaqs>;
};

/** on_conflict condition type for table "event_faqs" */
export type EventFaqsOnConflict = {
  constraint: EventFaqsConstraint;
  updateColumns?: Array<EventFaqsUpdateColumn>;
  where?: InputMaybe<EventFaqsBoolExp>;
};

/** Ordering options when selecting data from "event_faqs". */
export type EventFaqsOrderBy = {
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_faqs */
export type EventFaqsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_faqs" */
export enum EventFaqsSelectColumn {
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Question = 'question',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_faqs" */
export type EventFaqsSetInput = {
  answer?: InputMaybe<Scalars['String']>;
  question?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_faqs" */
export type EventFaqsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventFaqsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventFaqsStreamCursorValueInput = {
  answer?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_faqs" */
export enum EventFaqsUpdateColumn {
  /** column name */
  Answer = 'answer',
  /** column name */
  Question = 'question'
}

export type EventFaqsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventFaqsSetInput>;
  /** filter the rows which have to be updated */
  where: EventFaqsBoolExp;
};

/** NOTE: We are currently not using this table, but it was considered as there were many complex game and team structures discussed. For now we are storing scores in event_match_games, but we can backfill this one if needed. */
export type EventGameScores = {
  __typename?: 'EventGameScores';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  game: EventMatchGames;
  gameId: Scalars['uuid'];
  id: Scalars['uuid'];
  score: Scalars['Int'];
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_game_scores" */
export type EventGameScoresAggregateOrderBy = {
  avg?: InputMaybe<EventGameScoresAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGameScoresMaxOrderBy>;
  min?: InputMaybe<EventGameScoresMinOrderBy>;
  stddev?: InputMaybe<EventGameScoresStddevOrderBy>;
  stddevPop?: InputMaybe<EventGameScoresStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGameScoresStddevSampOrderBy>;
  sum?: InputMaybe<EventGameScoresSumOrderBy>;
  varPop?: InputMaybe<EventGameScoresVarPopOrderBy>;
  varSamp?: InputMaybe<EventGameScoresVarSampOrderBy>;
  variance?: InputMaybe<EventGameScoresVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_game_scores" */
export type EventGameScoresArrRelInsertInput = {
  data: Array<EventGameScoresInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGameScoresOnConflict>;
};

/** order by avg() on columns of table "event_game_scores" */
export type EventGameScoresAvgOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_game_scores". All fields are combined with a logical 'AND'. */
export type EventGameScoresBoolExp = {
  _and?: InputMaybe<Array<EventGameScoresBoolExp>>;
  _not?: InputMaybe<EventGameScoresBoolExp>;
  _or?: InputMaybe<Array<EventGameScoresBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  game?: InputMaybe<EventMatchGamesBoolExp>;
  gameId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  score?: InputMaybe<IntComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_game_scores" */
export enum EventGameScoresConstraint {
  /** unique or primary key constraint on columns "game_id", "team_id" */
  EventGameScoresGameIdTeamIdKey = 'event_game_scores_game_id_team_id_key',
  /** unique or primary key constraint on columns "id" */
  EventGameScoresPkey = 'event_game_scores_pkey'
}

/** input type for incrementing numeric columns in table "event_game_scores" */
export type EventGameScoresIncInput = {
  score?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_game_scores" */
export type EventGameScoresInsertInput = {
  game?: InputMaybe<EventMatchGamesObjRelInsertInput>;
  gameId?: InputMaybe<Scalars['uuid']>;
  score?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_game_scores" */
export type EventGameScoresMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_game_scores" */
export type EventGameScoresMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_game_scores" */
export type EventGameScoresMutationResponse = {
  __typename?: 'EventGameScoresMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGameScores>;
};

/** on_conflict condition type for table "event_game_scores" */
export type EventGameScoresOnConflict = {
  constraint: EventGameScoresConstraint;
  updateColumns?: Array<EventGameScoresUpdateColumn>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};

/** Ordering options when selecting data from "event_game_scores". */
export type EventGameScoresOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  game?: InputMaybe<EventMatchGamesOrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_game_scores */
export type EventGameScoresPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_game_scores" */
export enum EventGameScoresSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GameId = 'gameId',
  /** column name */
  Id = 'id',
  /** column name */
  Score = 'score',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_game_scores" */
export type EventGameScoresSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  score?: InputMaybe<Scalars['Int']>;
};

/** order by stddev() on columns of table "event_game_scores" */
export type EventGameScoresStddevOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_game_scores" */
export type EventGameScoresStddevPopOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_game_scores" */
export type EventGameScoresStddevSampOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_game_scores" */
export type EventGameScoresStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGameScoresStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGameScoresStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  gameId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  score?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_game_scores" */
export type EventGameScoresSumOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** update columns of table "event_game_scores" */
export enum EventGameScoresUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Score = 'score'
}

export type EventGameScoresUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventGameScoresIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGameScoresSetInput>;
  /** filter the rows which have to be updated */
  where: EventGameScoresBoolExp;
};

/** order by varPop() on columns of table "event_game_scores" */
export type EventGameScoresVarPopOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_game_scores" */
export type EventGameScoresVarSampOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_game_scores" */
export type EventGameScoresVarianceOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_group_formats" */
export type EventGroupFormats = {
  __typename?: 'EventGroupFormats';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_group_formats". All fields are combined with a logical 'AND'. */
export type EventGroupFormatsBoolExp = {
  _and?: InputMaybe<Array<EventGroupFormatsBoolExp>>;
  _not?: InputMaybe<EventGroupFormatsBoolExp>;
  _or?: InputMaybe<Array<EventGroupFormatsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventGroupFormatsEnum {
  Custom = 'CUSTOM',
  RoundRobin = 'ROUND_ROBIN',
  RoundRobinSingleElimination = 'ROUND_ROBIN_SINGLE_ELIMINATION',
  SingleElimination = 'SINGLE_ELIMINATION'
}

/** Boolean expression to compare columns of type "EventGroupFormatsEnum". All fields are combined with logical 'AND'. */
export type EventGroupFormatsEnumComparisonExp = {
  _eq?: InputMaybe<EventGroupFormatsEnum>;
  _in?: InputMaybe<Array<EventGroupFormatsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventGroupFormatsEnum>;
  _nin?: InputMaybe<Array<EventGroupFormatsEnum>>;
};

/** Ordering options when selecting data from "event_group_formats". */
export type EventGroupFormatsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_group_formats" */
export enum EventGroupFormatsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_group_formats" */
export type EventGroupFormatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupFormatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupFormatsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_group_pools" */
export type EventGroupPools = {
  __typename?: 'EventGroupPools';
  /** An array relationship */
  courts: Array<EventCourts>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatches>;
  /** An array relationship */
  rounds: Array<EventPoolRounds>;
  /** An object relationship */
  sequence: EventGroupSequences;
  sequenceId: Scalars['uuid'];
  startsAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  teams: Array<EventPoolsTeams>;
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsRoundsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};

/** order by aggregate values of table "event_group_pools" */
export type EventGroupPoolsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupPoolsMaxOrderBy>;
  min?: InputMaybe<EventGroupPoolsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_group_pools". All fields are combined with a logical 'AND'. */
export type EventGroupPoolsBoolExp = {
  _and?: InputMaybe<Array<EventGroupPoolsBoolExp>>;
  _not?: InputMaybe<EventGroupPoolsBoolExp>;
  _or?: InputMaybe<Array<EventGroupPoolsBoolExp>>;
  courts?: InputMaybe<EventCourtsBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  endsAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesBoolExp>;
  rounds?: InputMaybe<EventPoolRoundsBoolExp>;
  sequence?: InputMaybe<EventGroupSequencesBoolExp>;
  sequenceId?: InputMaybe<UuidComparisonExp>;
  startsAt?: InputMaybe<TimestamptzComparisonExp>;
  teams?: InputMaybe<EventPoolsTeamsBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_group_pools" */
export type EventGroupPoolsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_group_pools" */
export type EventGroupPoolsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_group_pools". */
export type EventGroupPoolsOrderBy = {
  courtsAggregate?: InputMaybe<EventCourtsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  roundsAggregate?: InputMaybe<EventPoolRoundsAggregateOrderBy>;
  sequence?: InputMaybe<EventGroupSequencesOrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamsAggregate?: InputMaybe<EventPoolsTeamsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_group_pools" */
export enum EventGroupPoolsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndsAt = 'endsAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  SequenceId = 'sequenceId',
  /** column name */
  StartsAt = 'startsAt',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "event_group_pools" */
export type EventGroupPoolsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupPoolsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupPoolsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  sequenceId?: InputMaybe<Scalars['uuid']>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "event_group_registration_statuses" */
export type EventGroupRegistrationStatuses = {
  __typename?: 'EventGroupRegistrationStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_group_registration_statuses". All fields are combined with a logical 'AND'. */
export type EventGroupRegistrationStatusesBoolExp = {
  _and?: InputMaybe<Array<EventGroupRegistrationStatusesBoolExp>>;
  _not?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
  _or?: InputMaybe<Array<EventGroupRegistrationStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventGroupRegistrationStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventGroupRegistrationStatusesEnum". All fields are combined with logical 'AND'. */
export type EventGroupRegistrationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  _in?: InputMaybe<Array<EventGroupRegistrationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  _nin?: InputMaybe<Array<EventGroupRegistrationStatusesEnum>>;
};

/** Ordering options when selecting data from "event_group_registration_statuses". */
export type EventGroupRegistrationStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_group_registration_statuses" */
export enum EventGroupRegistrationStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupRegistrationStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupRegistrationStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrations = {
  __typename?: 'EventGroupRegistrations';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An array relationship */
  invitations: Array<EventInvitations>;
  status: EventGroupRegistrationStatusesEnum;
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  /** An array relationship */
  transactionItems: Array<EventTransactionItems>;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrationsInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrationsTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** order by aggregate values of table "event_group_registrations" */
export type EventGroupRegistrationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupRegistrationsMaxOrderBy>;
  min?: InputMaybe<EventGroupRegistrationsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_group_registrations". All fields are combined with a logical 'AND'. */
export type EventGroupRegistrationsBoolExp = {
  _and?: InputMaybe<Array<EventGroupRegistrationsBoolExp>>;
  _not?: InputMaybe<EventGroupRegistrationsBoolExp>;
  _or?: InputMaybe<Array<EventGroupRegistrationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitations?: InputMaybe<EventInvitationsBoolExp>;
  status?: InputMaybe<EventGroupRegistrationStatusesEnumComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  transactionItems?: InputMaybe<EventTransactionItemsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** order by max() on columns of table "event_group_registrations" */
export type EventGroupRegistrationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_group_registrations" */
export type EventGroupRegistrationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_group_registrations". */
export type EventGroupRegistrationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationsAggregate?: InputMaybe<EventInvitationsAggregateOrderBy>;
  status?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** select columns of table "event_group_registrations" */
export enum EventGroupRegistrationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "event_group_registrations" */
export type EventGroupRegistrationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupRegistrationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupRegistrationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "event_group_sequence_seeding" */
export type EventGroupSequenceSeeding = {
  __typename?: 'EventGroupSequenceSeeding';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventGroupSequenceId: Scalars['uuid'];
  eventTeamId: Scalars['uuid'];
  id: Scalars['uuid'];
  seed: Scalars['Int'];
  /** An object relationship */
  sequence: EventGroupSequences;
  /** An object relationship */
  team: EventTeams;
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAggregateOrderBy = {
  avg?: InputMaybe<EventGroupSequenceSeedingAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupSequenceSeedingMaxOrderBy>;
  min?: InputMaybe<EventGroupSequenceSeedingMinOrderBy>;
  stddev?: InputMaybe<EventGroupSequenceSeedingStddevOrderBy>;
  stddevPop?: InputMaybe<EventGroupSequenceSeedingStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGroupSequenceSeedingStddevSampOrderBy>;
  sum?: InputMaybe<EventGroupSequenceSeedingSumOrderBy>;
  varPop?: InputMaybe<EventGroupSequenceSeedingVarPopOrderBy>;
  varSamp?: InputMaybe<EventGroupSequenceSeedingVarSampOrderBy>;
  variance?: InputMaybe<EventGroupSequenceSeedingVarianceOrderBy>;
};

/** order by avg() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAvgOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_group_sequence_seeding". All fields are combined with a logical 'AND'. */
export type EventGroupSequenceSeedingBoolExp = {
  _and?: InputMaybe<Array<EventGroupSequenceSeedingBoolExp>>;
  _not?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
  _or?: InputMaybe<Array<EventGroupSequenceSeedingBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  eventGroupSequenceId?: InputMaybe<UuidComparisonExp>;
  eventTeamId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  seed?: InputMaybe<IntComparisonExp>;
  sequence?: InputMaybe<EventGroupSequencesBoolExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventGroupSequenceId?: InputMaybe<OrderBy>;
  eventTeamId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  seed?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventGroupSequenceId?: InputMaybe<OrderBy>;
  eventTeamId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  seed?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_group_sequence_seeding". */
export type EventGroupSequenceSeedingOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventGroupSequenceId?: InputMaybe<OrderBy>;
  eventTeamId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  seed?: InputMaybe<OrderBy>;
  sequence?: InputMaybe<EventGroupSequencesOrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_group_sequence_seeding" */
export enum EventGroupSequenceSeedingSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventGroupSequenceId = 'eventGroupSequenceId',
  /** column name */
  EventTeamId = 'eventTeamId',
  /** column name */
  Id = 'id',
  /** column name */
  Seed = 'seed',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStddevOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStddevPopOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStddevSampOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupSequenceSeedingStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupSequenceSeedingStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventGroupSequenceId?: InputMaybe<Scalars['uuid']>;
  eventTeamId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  seed?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingSumOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingVarPopOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingVarSampOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingVarianceOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_group_sequences" */
export type EventGroupSequences = {
  __typename?: 'EventGroupSequences';
  competitionFormat: CompetitionFormatsEnum;
  completeReason: EventSequenceCompleteReasonsEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  isSequenceComplete: Scalars['Boolean'];
  /** An object relationship */
  nextSequence?: Maybe<EventGroupSequences>;
  nextSequenceId?: Maybe<Scalars['uuid']>;
  order: Scalars['Int'];
  /** An array relationship */
  pools: Array<EventGroupPools>;
  /** An array relationship */
  seeding: Array<EventGroupSequenceSeeding>;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_group_sequences" */
export type EventGroupSequencesPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


/** columns and relationships of "event_group_sequences" */
export type EventGroupSequencesSeedingArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};

/** order by aggregate values of table "event_group_sequences" */
export type EventGroupSequencesAggregateOrderBy = {
  avg?: InputMaybe<EventGroupSequencesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupSequencesMaxOrderBy>;
  min?: InputMaybe<EventGroupSequencesMinOrderBy>;
  stddev?: InputMaybe<EventGroupSequencesStddevOrderBy>;
  stddevPop?: InputMaybe<EventGroupSequencesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGroupSequencesStddevSampOrderBy>;
  sum?: InputMaybe<EventGroupSequencesSumOrderBy>;
  varPop?: InputMaybe<EventGroupSequencesVarPopOrderBy>;
  varSamp?: InputMaybe<EventGroupSequencesVarSampOrderBy>;
  variance?: InputMaybe<EventGroupSequencesVarianceOrderBy>;
};

/** order by avg() on columns of table "event_group_sequences" */
export type EventGroupSequencesAvgOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_group_sequences". All fields are combined with a logical 'AND'. */
export type EventGroupSequencesBoolExp = {
  _and?: InputMaybe<Array<EventGroupSequencesBoolExp>>;
  _not?: InputMaybe<EventGroupSequencesBoolExp>;
  _or?: InputMaybe<Array<EventGroupSequencesBoolExp>>;
  competitionFormat?: InputMaybe<CompetitionFormatsEnumComparisonExp>;
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isSequenceComplete?: InputMaybe<BooleanComparisonExp>;
  nextSequence?: InputMaybe<EventGroupSequencesBoolExp>;
  nextSequenceId?: InputMaybe<UuidComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  pools?: InputMaybe<EventGroupPoolsBoolExp>;
  seeding?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_group_sequences" */
export type EventGroupSequencesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  nextSequenceId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_group_sequences" */
export type EventGroupSequencesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  nextSequenceId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_group_sequences" */
export type EventGroupSequencesMutationResponse = {
  __typename?: 'EventGroupSequencesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupSequences>;
};

/** Ordering options when selecting data from "event_group_sequences". */
export type EventGroupSequencesOrderBy = {
  competitionFormat?: InputMaybe<OrderBy>;
  completeReason?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isSequenceComplete?: InputMaybe<OrderBy>;
  nextSequence?: InputMaybe<EventGroupSequencesOrderBy>;
  nextSequenceId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  poolsAggregate?: InputMaybe<EventGroupPoolsAggregateOrderBy>;
  seedingAggregate?: InputMaybe<EventGroupSequenceSeedingAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_group_sequences */
export type EventGroupSequencesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_group_sequences" */
export enum EventGroupSequencesSelectColumn {
  /** column name */
  CompetitionFormat = 'competitionFormat',
  /** column name */
  CompleteReason = 'completeReason',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsSequenceComplete = 'isSequenceComplete',
  /** column name */
  NextSequenceId = 'nextSequenceId',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_group_sequences" */
export type EventGroupSequencesSetInput = {
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  isSequenceComplete?: InputMaybe<Scalars['Boolean']>;
};

/** order by stddev() on columns of table "event_group_sequences" */
export type EventGroupSequencesStddevOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_group_sequences" */
export type EventGroupSequencesStddevPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_group_sequences" */
export type EventGroupSequencesStddevSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_group_sequences" */
export type EventGroupSequencesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupSequencesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupSequencesStreamCursorValueInput = {
  competitionFormat?: InputMaybe<CompetitionFormatsEnum>;
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isSequenceComplete?: InputMaybe<Scalars['Boolean']>;
  nextSequenceId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_group_sequences" */
export type EventGroupSequencesSumOrderBy = {
  order?: InputMaybe<OrderBy>;
};

export type EventGroupSequencesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupSequencesSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupSequencesBoolExp;
};

/** order by varPop() on columns of table "event_group_sequences" */
export type EventGroupSequencesVarPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_group_sequences" */
export type EventGroupSequencesVarSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_group_sequences" */
export type EventGroupSequencesVarianceOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_groups" */
export type EventGroups = {
  __typename?: 'EventGroups';
  /** An array relationship */
  courts: Array<EventCourts>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  format: EventGroupFormatsEnum;
  formatCustomName: Scalars['String'];
  gamesPerMatch: Scalars['Int'];
  gender: CompetitionGenderEnum;
  id: Scalars['uuid'];
  maximumAge?: Maybe<Scalars['Int']>;
  maximumRating?: Maybe<Scalars['numeric']>;
  minimumAge?: Maybe<Scalars['Int']>;
  minimumNumberOfGames: Scalars['Int'];
  minimumRating?: Maybe<Scalars['numeric']>;
  numberOfEliminationTeams?: Maybe<Scalars['Int']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Int']>;
  /** An array relationship */
  pools: Array<EventGroupPools>;
  priceUnitAmount: Scalars['Int'];
  /** An array relationship */
  registrations: Array<EventGroupRegistrations>;
  scoringFormat: ScoringFormatEnum;
  /** An array relationship */
  sequences: Array<EventGroupSequences>;
  startsAt?: Maybe<Scalars['timestamptz']>;
  teamLimit: Scalars['Int'];
  teamType: TeamTypesEnum;
  /** An array relationship */
  teams: Array<EventTeams>;
  title: Scalars['String'];
  totalPoints: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  winBy?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsSequencesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};

/** order by aggregate values of table "event_groups" */
export type EventGroupsAggregateOrderBy = {
  avg?: InputMaybe<EventGroupsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupsMaxOrderBy>;
  min?: InputMaybe<EventGroupsMinOrderBy>;
  stddev?: InputMaybe<EventGroupsStddevOrderBy>;
  stddevPop?: InputMaybe<EventGroupsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGroupsStddevSampOrderBy>;
  sum?: InputMaybe<EventGroupsSumOrderBy>;
  varPop?: InputMaybe<EventGroupsVarPopOrderBy>;
  varSamp?: InputMaybe<EventGroupsVarSampOrderBy>;
  variance?: InputMaybe<EventGroupsVarianceOrderBy>;
};

/** order by avg() on columns of table "event_groups" */
export type EventGroupsAvgOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_groups". All fields are combined with a logical 'AND'. */
export type EventGroupsBoolExp = {
  _and?: InputMaybe<Array<EventGroupsBoolExp>>;
  _not?: InputMaybe<EventGroupsBoolExp>;
  _or?: InputMaybe<Array<EventGroupsBoolExp>>;
  courts?: InputMaybe<EventCourtsBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  endsAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  format?: InputMaybe<EventGroupFormatsEnumComparisonExp>;
  formatCustomName?: InputMaybe<StringComparisonExp>;
  gamesPerMatch?: InputMaybe<IntComparisonExp>;
  gender?: InputMaybe<CompetitionGenderEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  maximumAge?: InputMaybe<IntComparisonExp>;
  maximumRating?: InputMaybe<NumericComparisonExp>;
  minimumAge?: InputMaybe<IntComparisonExp>;
  minimumNumberOfGames?: InputMaybe<IntComparisonExp>;
  minimumRating?: InputMaybe<NumericComparisonExp>;
  numberOfEliminationTeams?: InputMaybe<IntComparisonExp>;
  numberOfEstimatedCourts?: InputMaybe<IntComparisonExp>;
  pools?: InputMaybe<EventGroupPoolsBoolExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  registrations?: InputMaybe<EventGroupRegistrationsBoolExp>;
  scoringFormat?: InputMaybe<ScoringFormatEnumComparisonExp>;
  sequences?: InputMaybe<EventGroupSequencesBoolExp>;
  startsAt?: InputMaybe<TimestamptzComparisonExp>;
  teamLimit?: InputMaybe<IntComparisonExp>;
  teamType?: InputMaybe<TeamTypesEnumComparisonExp>;
  teams?: InputMaybe<EventTeamsBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  totalPoints?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  winBy?: InputMaybe<IntComparisonExp>;
};

/** input type for incrementing numeric columns in table "event_groups" */
export type EventGroupsIncInput = {
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** order by max() on columns of table "event_groups" */
export type EventGroupsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  formatCustomName?: InputMaybe<OrderBy>;
  gamesPerMatch?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_groups" */
export type EventGroupsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  formatCustomName?: InputMaybe<OrderBy>;
  gamesPerMatch?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_groups" */
export type EventGroupsMutationResponse = {
  __typename?: 'EventGroupsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroups>;
};

/** Ordering options when selecting data from "event_groups". */
export type EventGroupsOrderBy = {
  courtsAggregate?: InputMaybe<EventCourtsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  format?: InputMaybe<OrderBy>;
  formatCustomName?: InputMaybe<OrderBy>;
  gamesPerMatch?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  poolsAggregate?: InputMaybe<EventGroupPoolsAggregateOrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  registrationsAggregate?: InputMaybe<EventGroupRegistrationsAggregateOrderBy>;
  scoringFormat?: InputMaybe<OrderBy>;
  sequencesAggregate?: InputMaybe<EventGroupSequencesAggregateOrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  teamType?: InputMaybe<OrderBy>;
  teamsAggregate?: InputMaybe<EventTeamsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_groups */
export type EventGroupsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_groups" */
export enum EventGroupsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndsAt = 'endsAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Format = 'format',
  /** column name */
  FormatCustomName = 'formatCustomName',
  /** column name */
  GamesPerMatch = 'gamesPerMatch',
  /** column name */
  Gender = 'gender',
  /** column name */
  Id = 'id',
  /** column name */
  MaximumAge = 'maximumAge',
  /** column name */
  MaximumRating = 'maximumRating',
  /** column name */
  MinimumAge = 'minimumAge',
  /** column name */
  MinimumNumberOfGames = 'minimumNumberOfGames',
  /** column name */
  MinimumRating = 'minimumRating',
  /** column name */
  NumberOfEliminationTeams = 'numberOfEliminationTeams',
  /** column name */
  NumberOfEstimatedCourts = 'numberOfEstimatedCourts',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  ScoringFormat = 'scoringFormat',
  /** column name */
  StartsAt = 'startsAt',
  /** column name */
  TeamLimit = 'teamLimit',
  /** column name */
  TeamType = 'teamType',
  /** column name */
  Title = 'title',
  /** column name */
  TotalPoints = 'totalPoints',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinBy = 'winBy'
}

/** input type for updating data in table "event_groups" */
export type EventGroupsSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  format?: InputMaybe<EventGroupFormatsEnum>;
  formatCustomName?: InputMaybe<Scalars['String']>;
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  gender?: InputMaybe<CompetitionGenderEnum>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  teamType?: InputMaybe<TeamTypesEnum>;
  title?: InputMaybe<Scalars['String']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** order by stddev() on columns of table "event_groups" */
export type EventGroupsStddevOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_groups" */
export type EventGroupsStddevPopOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_groups" */
export type EventGroupsStddevSampOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_groups" */
export type EventGroupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  format?: InputMaybe<EventGroupFormatsEnum>;
  formatCustomName?: InputMaybe<Scalars['String']>;
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  gender?: InputMaybe<CompetitionGenderEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  teamType?: InputMaybe<TeamTypesEnum>;
  title?: InputMaybe<Scalars['String']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_groups" */
export type EventGroupsSumOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

export type EventGroupsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventGroupsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupsSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupsBoolExp;
};

/** order by varPop() on columns of table "event_groups" */
export type EventGroupsVarPopOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_groups" */
export type EventGroupsVarSampOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_groups" */
export type EventGroupsVarianceOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_invitation_statuses" */
export type EventInvitationStatuses = {
  __typename?: 'EventInvitationStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_invitation_statuses". All fields are combined with a logical 'AND'. */
export type EventInvitationStatusesBoolExp = {
  _and?: InputMaybe<Array<EventInvitationStatusesBoolExp>>;
  _not?: InputMaybe<EventInvitationStatusesBoolExp>;
  _or?: InputMaybe<Array<EventInvitationStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventInvitationStatusesEnum {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventInvitationStatusesEnum". All fields are combined with logical 'AND'. */
export type EventInvitationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventInvitationStatusesEnum>;
  _in?: InputMaybe<Array<EventInvitationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventInvitationStatusesEnum>;
  _nin?: InputMaybe<Array<EventInvitationStatusesEnum>>;
};

/** Ordering options when selecting data from "event_invitation_statuses". */
export type EventInvitationStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_invitation_statuses" */
export enum EventInvitationStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_invitation_statuses" */
export type EventInvitationStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventInvitationStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventInvitationStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_invitations" */
export type EventInvitations = {
  __typename?: 'EventInvitations';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  /** An object relationship */
  groupRegistration?: Maybe<EventGroupRegistrations>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  invitationEmail: Scalars['String'];
  invitationName?: Maybe<Scalars['String']>;
  /** An object relationship */
  invitedUser?: Maybe<Users>;
  invitedUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  invitedUserProfile?: Maybe<UserProfiles>;
  /** An object relationship */
  senderUser: Users;
  senderUserId: Scalars['uuid'];
  /** An object relationship */
  senderUserProfile?: Maybe<UserProfiles>;
  status: EventInvitationStatusesEnum;
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_invitations" */
export type EventInvitationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventInvitationsMaxOrderBy>;
  min?: InputMaybe<EventInvitationsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_invitations". All fields are combined with a logical 'AND'. */
export type EventInvitationsBoolExp = {
  _and?: InputMaybe<Array<EventInvitationsBoolExp>>;
  _not?: InputMaybe<EventInvitationsBoolExp>;
  _or?: InputMaybe<Array<EventInvitationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsBoolExp>;
  groupRegistrationId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitationEmail?: InputMaybe<StringComparisonExp>;
  invitationName?: InputMaybe<StringComparisonExp>;
  invitedUser?: InputMaybe<UsersBoolExp>;
  invitedUserId?: InputMaybe<UuidComparisonExp>;
  invitedUserProfile?: InputMaybe<UserProfilesBoolExp>;
  senderUser?: InputMaybe<UsersBoolExp>;
  senderUserId?: InputMaybe<UuidComparisonExp>;
  senderUserProfile?: InputMaybe<UserProfilesBoolExp>;
  status?: InputMaybe<EventInvitationStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_invitations" */
export enum EventInvitationsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventInvitationsPkey = 'event_invitations_pkey'
}

/** input type for inserting data into table "event_invitations" */
export type EventInvitationsInsertInput = {
  eventId?: InputMaybe<Scalars['uuid']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  invitationEmail?: InputMaybe<Scalars['String']>;
  invitationName?: InputMaybe<Scalars['String']>;
  senderUserId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_invitations" */
export type EventInvitationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationEmail?: InputMaybe<OrderBy>;
  invitationName?: InputMaybe<OrderBy>;
  invitedUserId?: InputMaybe<OrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_invitations" */
export type EventInvitationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationEmail?: InputMaybe<OrderBy>;
  invitationName?: InputMaybe<OrderBy>;
  invitedUserId?: InputMaybe<OrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_invitations" */
export type EventInvitationsMutationResponse = {
  __typename?: 'EventInvitationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventInvitations>;
};

/** on_conflict condition type for table "event_invitations" */
export type EventInvitationsOnConflict = {
  constraint: EventInvitationsConstraint;
  updateColumns?: Array<EventInvitationsUpdateColumn>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};

/** Ordering options when selecting data from "event_invitations". */
export type EventInvitationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsOrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationEmail?: InputMaybe<OrderBy>;
  invitationName?: InputMaybe<OrderBy>;
  invitedUser?: InputMaybe<UsersOrderBy>;
  invitedUserId?: InputMaybe<OrderBy>;
  invitedUserProfile?: InputMaybe<UserProfilesOrderBy>;
  senderUser?: InputMaybe<UsersOrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  senderUserProfile?: InputMaybe<UserProfilesOrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_invitations" */
export enum EventInvitationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupRegistrationId = 'groupRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationEmail = 'invitationEmail',
  /** column name */
  InvitationName = 'invitationName',
  /** column name */
  InvitedUserId = 'invitedUserId',
  /** column name */
  SenderUserId = 'senderUserId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "event_invitations" */
export type EventInvitationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventInvitationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventInvitationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitationEmail?: InputMaybe<Scalars['String']>;
  invitationName?: InputMaybe<Scalars['String']>;
  invitedUserId?: InputMaybe<Scalars['uuid']>;
  senderUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventInvitationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** placeholder for update columns of table "event_invitations" (current role has no relevant permissions) */
export enum EventInvitationsUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "event_listing_fees" */
export type EventListingFees = {
  __typename?: 'EventListingFees';
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creditCard: UserCreditCards;
  /** An object relationship */
  customer: Users;
  /** An object relationship */
  customerProfile?: Maybe<UserProfiles>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  orderSubtotalUnitAmount: Scalars['Int'];
  orderTotalUnitAmount: Scalars['Int'];
  paidUnitAmount: Scalars['Int'];
  paymentProcessor: PaymentProcessorsEnum;
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  status: OrderStatusesEnum;
  stripeCustomerId: Scalars['String'];
  stripePaymentStatus: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  userCreditCardId: Scalars['uuid'];
  userId: Scalars['uuid'];
};

/** order by aggregate values of table "event_listing_fees" */
export type EventListingFeesAggregateOrderBy = {
  avg?: InputMaybe<EventListingFeesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventListingFeesMaxOrderBy>;
  min?: InputMaybe<EventListingFeesMinOrderBy>;
  stddev?: InputMaybe<EventListingFeesStddevOrderBy>;
  stddevPop?: InputMaybe<EventListingFeesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventListingFeesStddevSampOrderBy>;
  sum?: InputMaybe<EventListingFeesSumOrderBy>;
  varPop?: InputMaybe<EventListingFeesVarPopOrderBy>;
  varSamp?: InputMaybe<EventListingFeesVarSampOrderBy>;
  variance?: InputMaybe<EventListingFeesVarianceOrderBy>;
};

/** order by avg() on columns of table "event_listing_fees" */
export type EventListingFeesAvgOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_listing_fees". All fields are combined with a logical 'AND'. */
export type EventListingFeesBoolExp = {
  _and?: InputMaybe<Array<EventListingFeesBoolExp>>;
  _not?: InputMaybe<EventListingFeesBoolExp>;
  _or?: InputMaybe<Array<EventListingFeesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creditCard?: InputMaybe<UserCreditCardsBoolExp>;
  customer?: InputMaybe<UsersBoolExp>;
  customerProfile?: InputMaybe<UserProfilesBoolExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  orderSubtotalUnitAmount?: InputMaybe<IntComparisonExp>;
  orderTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  paidUnitAmount?: InputMaybe<IntComparisonExp>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnumComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripePaymentStatus?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCreditCardId?: InputMaybe<UuidComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** order by max() on columns of table "event_listing_fees" */
export type EventListingFeesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_listing_fees" */
export type EventListingFeesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_listing_fees". */
export type EventListingFeesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  creditCard?: InputMaybe<UserCreditCardsOrderBy>;
  customer?: InputMaybe<UsersOrderBy>;
  customerProfile?: InputMaybe<UserProfilesOrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  paymentProcessor?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "event_listing_fees" */
export enum EventListingFeesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId',
  /** column name */
  UserId = 'userId'
}

/** order by stddev() on columns of table "event_listing_fees" */
export type EventListingFeesStddevOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_listing_fees" */
export type EventListingFeesStddevPopOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_listing_fees" */
export type EventListingFeesStddevSampOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_listing_fees" */
export type EventListingFeesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventListingFeesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventListingFeesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "event_listing_fees" */
export type EventListingFeesSumOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "event_listing_fees" */
export type EventListingFeesVarPopOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_listing_fees" */
export type EventListingFeesVarSampOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_listing_fees" */
export type EventListingFeesVarianceOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_match_games" */
export type EventMatchGames = {
  __typename?: 'EventMatchGames';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  losingTeam: EventTeams;
  losingTeamId: Scalars['uuid'];
  /** An object relationship */
  match: EventMatches;
  matchId: Scalars['uuid'];
  /** An array relationship */
  scores: Array<EventGameScores>;
  /** An object relationship */
  team1: EventTeams;
  team1Id: Scalars['uuid'];
  team1Score: Scalars['numeric'];
  /** An object relationship */
  team2: EventTeams;
  team2Id: Scalars['uuid'];
  team2Score: Scalars['numeric'];
  updatedAt: Scalars['timestamptz'];
  winReason: WinReasonsEnum;
  /** An object relationship */
  winningTeam: EventTeams;
  winningTeamId: Scalars['uuid'];
};


/** columns and relationships of "event_match_games" */
export type EventMatchGamesScoresArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};

/** order by aggregate values of table "event_match_games" */
export type EventMatchGamesAggregateOrderBy = {
  avg?: InputMaybe<EventMatchGamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventMatchGamesMaxOrderBy>;
  min?: InputMaybe<EventMatchGamesMinOrderBy>;
  stddev?: InputMaybe<EventMatchGamesStddevOrderBy>;
  stddevPop?: InputMaybe<EventMatchGamesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventMatchGamesStddevSampOrderBy>;
  sum?: InputMaybe<EventMatchGamesSumOrderBy>;
  varPop?: InputMaybe<EventMatchGamesVarPopOrderBy>;
  varSamp?: InputMaybe<EventMatchGamesVarSampOrderBy>;
  variance?: InputMaybe<EventMatchGamesVarianceOrderBy>;
};

/** order by avg() on columns of table "event_match_games" */
export type EventMatchGamesAvgOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_match_games". All fields are combined with a logical 'AND'. */
export type EventMatchGamesBoolExp = {
  _and?: InputMaybe<Array<EventMatchGamesBoolExp>>;
  _not?: InputMaybe<EventMatchGamesBoolExp>;
  _or?: InputMaybe<Array<EventMatchGamesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  losingTeam?: InputMaybe<EventTeamsBoolExp>;
  losingTeamId?: InputMaybe<UuidComparisonExp>;
  match?: InputMaybe<EventMatchesBoolExp>;
  matchId?: InputMaybe<UuidComparisonExp>;
  scores?: InputMaybe<EventGameScoresBoolExp>;
  team1?: InputMaybe<EventTeamsBoolExp>;
  team1Id?: InputMaybe<UuidComparisonExp>;
  team1Score?: InputMaybe<NumericComparisonExp>;
  team2?: InputMaybe<EventTeamsBoolExp>;
  team2Id?: InputMaybe<UuidComparisonExp>;
  team2Score?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  winReason?: InputMaybe<WinReasonsEnumComparisonExp>;
  winningTeam?: InputMaybe<EventTeamsBoolExp>;
  winningTeamId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "event_match_games" */
export enum EventMatchGamesConstraint {
  /** unique or primary key constraint on columns "id" */
  EventMatchGamesPkey = 'event_match_games_pkey'
}

/** input type for incrementing numeric columns in table "event_match_games" */
export type EventMatchGamesIncInput = {
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "event_match_games" */
export type EventMatchGamesInsertInput = {
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  scores?: InputMaybe<EventGameScoresArrRelInsertInput>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_match_games" */
export type EventMatchGamesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team1Score?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_match_games" */
export type EventMatchGamesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team1Score?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_match_games" */
export type EventMatchGamesMutationResponse = {
  __typename?: 'EventMatchGamesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventMatchGames>;
};

/** input type for inserting object relation for remote table "event_match_games" */
export type EventMatchGamesObjRelInsertInput = {
  data: EventMatchGamesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};

/** on_conflict condition type for table "event_match_games" */
export type EventMatchGamesOnConflict = {
  constraint: EventMatchGamesConstraint;
  updateColumns?: Array<EventMatchGamesUpdateColumn>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};

/** Ordering options when selecting data from "event_match_games". */
export type EventMatchGamesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeam?: InputMaybe<EventTeamsOrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  match?: InputMaybe<EventMatchesOrderBy>;
  matchId?: InputMaybe<OrderBy>;
  scoresAggregate?: InputMaybe<EventGameScoresAggregateOrderBy>;
  team1?: InputMaybe<EventTeamsOrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team1Score?: InputMaybe<OrderBy>;
  team2?: InputMaybe<EventTeamsOrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winReason?: InputMaybe<OrderBy>;
  winningTeam?: InputMaybe<EventTeamsOrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_match_games */
export type EventMatchGamesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_match_games" */
export enum EventMatchGamesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  MatchId = 'matchId',
  /** column name */
  Team1Id = 'team1Id',
  /** column name */
  Team1Score = 'team1Score',
  /** column name */
  Team2Id = 'team2Id',
  /** column name */
  Team2Score = 'team2Score',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

/** input type for updating data in table "event_match_games" */
export type EventMatchGamesSetInput = {
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** order by stddev() on columns of table "event_match_games" */
export type EventMatchGamesStddevOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_match_games" */
export type EventMatchGamesStddevPopOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_match_games" */
export type EventMatchGamesStddevSampOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_match_games" */
export type EventMatchGamesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventMatchGamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventMatchGamesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "event_match_games" */
export type EventMatchGamesSumOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** update columns of table "event_match_games" */
export enum EventMatchGamesUpdateColumn {
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  Team1Score = 'team1Score',
  /** column name */
  Team2Score = 'team2Score',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

export type EventMatchGamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventMatchGamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventMatchGamesSetInput>;
  /** filter the rows which have to be updated */
  where: EventMatchGamesBoolExp;
};

/** order by varPop() on columns of table "event_match_games" */
export type EventMatchGamesVarPopOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_match_games" */
export type EventMatchGamesVarSampOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_match_games" */
export type EventMatchGamesVarianceOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatches = {
  __typename?: 'EventMatches';
  /** An object relationship */
  court?: Maybe<EventCourts>;
  courtNumber?: Maybe<Scalars['Int']>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventCourtId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  games: Array<EventMatchGames>;
  id: Scalars['uuid'];
  isBye: Scalars['Boolean'];
  /** An object relationship */
  losingTeam?: Maybe<EventTeams>;
  losingTeamId?: Maybe<Scalars['uuid']>;
  matchOrder: Scalars['Int'];
  /** An object relationship */
  pool?: Maybe<EventGroupPools>;
  poolId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  previousMatch1?: Maybe<EventMatches>;
  previousMatch1Id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  previousMatch2?: Maybe<EventMatches>;
  previousMatch2Id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  round: EventPoolRounds;
  roundId: Scalars['uuid'];
  selectionCriteriaPreviousMatch1?: Maybe<MatchSelectionCriteriaEnum>;
  selectionCriteriaPreviousMatch2?: Maybe<MatchSelectionCriteriaEnum>;
  /** An object relationship */
  team1?: Maybe<EventTeams>;
  team1Id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  team2?: Maybe<EventTeams>;
  team2Id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  teams: Array<EventMatchesTeams>;
  updatedAt: Scalars['timestamptz'];
  winReason?: Maybe<WinReasonsEnum>;
  /** An object relationship */
  winningTeam?: Maybe<EventTeams>;
  winningTeamId?: Maybe<Scalars['uuid']>;
};


/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatchesGamesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatchesTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};

/** order by aggregate values of table "event_matches" */
export type EventMatchesAggregateOrderBy = {
  avg?: InputMaybe<EventMatchesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventMatchesMaxOrderBy>;
  min?: InputMaybe<EventMatchesMinOrderBy>;
  stddev?: InputMaybe<EventMatchesStddevOrderBy>;
  stddevPop?: InputMaybe<EventMatchesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventMatchesStddevSampOrderBy>;
  sum?: InputMaybe<EventMatchesSumOrderBy>;
  varPop?: InputMaybe<EventMatchesVarPopOrderBy>;
  varSamp?: InputMaybe<EventMatchesVarSampOrderBy>;
  variance?: InputMaybe<EventMatchesVarianceOrderBy>;
};

/** order by avg() on columns of table "event_matches" */
export type EventMatchesAvgOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_matches". All fields are combined with a logical 'AND'. */
export type EventMatchesBoolExp = {
  _and?: InputMaybe<Array<EventMatchesBoolExp>>;
  _not?: InputMaybe<EventMatchesBoolExp>;
  _or?: InputMaybe<Array<EventMatchesBoolExp>>;
  court?: InputMaybe<EventCourtsBoolExp>;
  courtNumber?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  eventCourtId?: InputMaybe<UuidComparisonExp>;
  games?: InputMaybe<EventMatchGamesBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBye?: InputMaybe<BooleanComparisonExp>;
  losingTeam?: InputMaybe<EventTeamsBoolExp>;
  losingTeamId?: InputMaybe<UuidComparisonExp>;
  matchOrder?: InputMaybe<IntComparisonExp>;
  pool?: InputMaybe<EventGroupPoolsBoolExp>;
  poolId?: InputMaybe<UuidComparisonExp>;
  previousMatch1?: InputMaybe<EventMatchesBoolExp>;
  previousMatch1Id?: InputMaybe<UuidComparisonExp>;
  previousMatch2?: InputMaybe<EventMatchesBoolExp>;
  previousMatch2Id?: InputMaybe<UuidComparisonExp>;
  round?: InputMaybe<EventPoolRoundsBoolExp>;
  roundId?: InputMaybe<UuidComparisonExp>;
  selectionCriteriaPreviousMatch1?: InputMaybe<MatchSelectionCriteriaEnumComparisonExp>;
  selectionCriteriaPreviousMatch2?: InputMaybe<MatchSelectionCriteriaEnumComparisonExp>;
  team1?: InputMaybe<EventTeamsBoolExp>;
  team1Id?: InputMaybe<UuidComparisonExp>;
  team2?: InputMaybe<EventTeamsBoolExp>;
  team2Id?: InputMaybe<UuidComparisonExp>;
  teams?: InputMaybe<EventMatchesTeamsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  winReason?: InputMaybe<WinReasonsEnumComparisonExp>;
  winningTeam?: InputMaybe<EventTeamsBoolExp>;
  winningTeamId?: InputMaybe<UuidComparisonExp>;
};

/** input type for incrementing numeric columns in table "event_matches" */
export type EventMatchesIncInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
};

/** order by max() on columns of table "event_matches" */
export type EventMatchesMaxOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventCourtId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  previousMatch1Id?: InputMaybe<OrderBy>;
  previousMatch2Id?: InputMaybe<OrderBy>;
  roundId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_matches" */
export type EventMatchesMinOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventCourtId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  previousMatch1Id?: InputMaybe<OrderBy>;
  previousMatch2Id?: InputMaybe<OrderBy>;
  roundId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_matches" */
export type EventMatchesMutationResponse = {
  __typename?: 'EventMatchesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventMatches>;
};

/** Ordering options when selecting data from "event_matches". */
export type EventMatchesOrderBy = {
  court?: InputMaybe<EventCourtsOrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventCourtId?: InputMaybe<OrderBy>;
  gamesAggregate?: InputMaybe<EventMatchGamesAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isBye?: InputMaybe<OrderBy>;
  losingTeam?: InputMaybe<EventTeamsOrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
  pool?: InputMaybe<EventGroupPoolsOrderBy>;
  poolId?: InputMaybe<OrderBy>;
  previousMatch1?: InputMaybe<EventMatchesOrderBy>;
  previousMatch1Id?: InputMaybe<OrderBy>;
  previousMatch2?: InputMaybe<EventMatchesOrderBy>;
  previousMatch2Id?: InputMaybe<OrderBy>;
  round?: InputMaybe<EventPoolRoundsOrderBy>;
  roundId?: InputMaybe<OrderBy>;
  selectionCriteriaPreviousMatch1?: InputMaybe<OrderBy>;
  selectionCriteriaPreviousMatch2?: InputMaybe<OrderBy>;
  team1?: InputMaybe<EventTeamsOrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team2?: InputMaybe<EventTeamsOrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  teamsAggregate?: InputMaybe<EventMatchesTeamsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winReason?: InputMaybe<OrderBy>;
  winningTeam?: InputMaybe<EventTeamsOrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_matches */
export type EventMatchesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_matches" */
export enum EventMatchesSelectColumn {
  /** column name */
  CourtNumber = 'courtNumber',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventCourtId = 'eventCourtId',
  /** column name */
  Id = 'id',
  /** column name */
  IsBye = 'isBye',
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  MatchOrder = 'matchOrder',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  PreviousMatch1Id = 'previousMatch1Id',
  /** column name */
  PreviousMatch2Id = 'previousMatch2Id',
  /** column name */
  RoundId = 'roundId',
  /** column name */
  SelectionCriteriaPreviousMatch1 = 'selectionCriteriaPreviousMatch1',
  /** column name */
  SelectionCriteriaPreviousMatch2 = 'selectionCriteriaPreviousMatch2',
  /** column name */
  Team1Id = 'team1Id',
  /** column name */
  Team2Id = 'team2Id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

/** input type for updating data in table "event_matches" */
export type EventMatchesSetInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
  eventCourtId?: InputMaybe<Scalars['uuid']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** order by stddev() on columns of table "event_matches" */
export type EventMatchesStddevOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_matches" */
export type EventMatchesStddevPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_matches" */
export type EventMatchesStddevSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_matches" */
export type EventMatchesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventMatchesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventMatchesStreamCursorValueInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventCourtId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isBye?: InputMaybe<Scalars['Boolean']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchOrder?: InputMaybe<Scalars['Int']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  previousMatch1Id?: InputMaybe<Scalars['uuid']>;
  previousMatch2Id?: InputMaybe<Scalars['uuid']>;
  roundId?: InputMaybe<Scalars['uuid']>;
  selectionCriteriaPreviousMatch1?: InputMaybe<MatchSelectionCriteriaEnum>;
  selectionCriteriaPreviousMatch2?: InputMaybe<MatchSelectionCriteriaEnum>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "event_matches" */
export type EventMatchesSumOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_matches_teams" */
export type EventMatchesTeams = {
  __typename?: 'EventMatchesTeams';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  match: EventMatches;
  matchId: Scalars['uuid'];
  order: Scalars['Int'];
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_matches_teams" */
export type EventMatchesTeamsAggregateOrderBy = {
  avg?: InputMaybe<EventMatchesTeamsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventMatchesTeamsMaxOrderBy>;
  min?: InputMaybe<EventMatchesTeamsMinOrderBy>;
  stddev?: InputMaybe<EventMatchesTeamsStddevOrderBy>;
  stddevPop?: InputMaybe<EventMatchesTeamsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventMatchesTeamsStddevSampOrderBy>;
  sum?: InputMaybe<EventMatchesTeamsSumOrderBy>;
  varPop?: InputMaybe<EventMatchesTeamsVarPopOrderBy>;
  varSamp?: InputMaybe<EventMatchesTeamsVarSampOrderBy>;
  variance?: InputMaybe<EventMatchesTeamsVarianceOrderBy>;
};

/** order by avg() on columns of table "event_matches_teams" */
export type EventMatchesTeamsAvgOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_matches_teams". All fields are combined with a logical 'AND'. */
export type EventMatchesTeamsBoolExp = {
  _and?: InputMaybe<Array<EventMatchesTeamsBoolExp>>;
  _not?: InputMaybe<EventMatchesTeamsBoolExp>;
  _or?: InputMaybe<Array<EventMatchesTeamsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  match?: InputMaybe<EventMatchesBoolExp>;
  matchId?: InputMaybe<UuidComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_matches_teams" */
export type EventMatchesTeamsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_matches_teams" */
export type EventMatchesTeamsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_matches_teams". */
export type EventMatchesTeamsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  match?: InputMaybe<EventMatchesOrderBy>;
  matchId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_matches_teams" */
export enum EventMatchesTeamsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  MatchId = 'matchId',
  /** column name */
  Order = 'order',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "event_matches_teams" */
export type EventMatchesTeamsStddevOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_matches_teams" */
export type EventMatchesTeamsStddevPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_matches_teams" */
export type EventMatchesTeamsStddevSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_matches_teams" */
export type EventMatchesTeamsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventMatchesTeamsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventMatchesTeamsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_matches_teams" */
export type EventMatchesTeamsSumOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "event_matches_teams" */
export type EventMatchesTeamsVarPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_matches_teams" */
export type EventMatchesTeamsVarSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_matches_teams" */
export type EventMatchesTeamsVarianceOrderBy = {
  order?: InputMaybe<OrderBy>;
};

export type EventMatchesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventMatchesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventMatchesSetInput>;
  /** filter the rows which have to be updated */
  where: EventMatchesBoolExp;
};

/** order by varPop() on columns of table "event_matches" */
export type EventMatchesVarPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_matches" */
export type EventMatchesVarSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_matches" */
export type EventMatchesVarianceOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_organizer_account_types" */
export type EventOrganizerAccountTypes = {
  __typename?: 'EventOrganizerAccountTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_organizer_account_types". All fields are combined with a logical 'AND'. */
export type EventOrganizerAccountTypesBoolExp = {
  _and?: InputMaybe<Array<EventOrganizerAccountTypesBoolExp>>;
  _not?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
  _or?: InputMaybe<Array<EventOrganizerAccountTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventOrganizerAccountTypesEnum {
  Club = 'CLUB',
  Inactive = 'INACTIVE',
  Individual = 'INDIVIDUAL',
  Other = 'OTHER',
  Tour = 'TOUR'
}

/** Boolean expression to compare columns of type "EventOrganizerAccountTypesEnum". All fields are combined with logical 'AND'. */
export type EventOrganizerAccountTypesEnumComparisonExp = {
  _eq?: InputMaybe<EventOrganizerAccountTypesEnum>;
  _in?: InputMaybe<Array<EventOrganizerAccountTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventOrganizerAccountTypesEnum>;
  _nin?: InputMaybe<Array<EventOrganizerAccountTypesEnum>>;
};

/** Ordering options when selecting data from "event_organizer_account_types". */
export type EventOrganizerAccountTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_organizer_account_types" */
export enum EventOrganizerAccountTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_organizer_account_types" */
export type EventOrganizerAccountTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventOrganizerAccountTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventOrganizerAccountTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_pool_rounds" */
export type EventPoolRounds = {
  __typename?: 'EventPoolRounds';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatches>;
  /** An object relationship */
  pool: EventGroupPools;
  poolId: Scalars['uuid'];
  roundOrder: Scalars['Int'];
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_pool_rounds" */
export type EventPoolRoundsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};

/** order by aggregate values of table "event_pool_rounds" */
export type EventPoolRoundsAggregateOrderBy = {
  avg?: InputMaybe<EventPoolRoundsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventPoolRoundsMaxOrderBy>;
  min?: InputMaybe<EventPoolRoundsMinOrderBy>;
  stddev?: InputMaybe<EventPoolRoundsStddevOrderBy>;
  stddevPop?: InputMaybe<EventPoolRoundsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventPoolRoundsStddevSampOrderBy>;
  sum?: InputMaybe<EventPoolRoundsSumOrderBy>;
  varPop?: InputMaybe<EventPoolRoundsVarPopOrderBy>;
  varSamp?: InputMaybe<EventPoolRoundsVarSampOrderBy>;
  variance?: InputMaybe<EventPoolRoundsVarianceOrderBy>;
};

/** order by avg() on columns of table "event_pool_rounds" */
export type EventPoolRoundsAvgOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_pool_rounds". All fields are combined with a logical 'AND'. */
export type EventPoolRoundsBoolExp = {
  _and?: InputMaybe<Array<EventPoolRoundsBoolExp>>;
  _not?: InputMaybe<EventPoolRoundsBoolExp>;
  _or?: InputMaybe<Array<EventPoolRoundsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesBoolExp>;
  pool?: InputMaybe<EventGroupPoolsBoolExp>;
  poolId?: InputMaybe<UuidComparisonExp>;
  roundOrder?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_pool_rounds" */
export type EventPoolRoundsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  roundOrder?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_pool_rounds" */
export type EventPoolRoundsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  roundOrder?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_pool_rounds". */
export type EventPoolRoundsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  pool?: InputMaybe<EventGroupPoolsOrderBy>;
  poolId?: InputMaybe<OrderBy>;
  roundOrder?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_pool_rounds" */
export enum EventPoolRoundsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  RoundOrder = 'roundOrder',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "event_pool_rounds" */
export type EventPoolRoundsStddevOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_pool_rounds" */
export type EventPoolRoundsStddevPopOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_pool_rounds" */
export type EventPoolRoundsStddevSampOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_pool_rounds" */
export type EventPoolRoundsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventPoolRoundsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventPoolRoundsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  roundOrder?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_pool_rounds" */
export type EventPoolRoundsSumOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "event_pool_rounds" */
export type EventPoolRoundsVarPopOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_pool_rounds" */
export type EventPoolRoundsVarSampOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_pool_rounds" */
export type EventPoolRoundsVarianceOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_pools_teams" */
export type EventPoolsTeams = {
  __typename?: 'EventPoolsTeams';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  pool: EventGroupPools;
  poolId: Scalars['uuid'];
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_pools_teams" */
export type EventPoolsTeamsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventPoolsTeamsMaxOrderBy>;
  min?: InputMaybe<EventPoolsTeamsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_pools_teams". All fields are combined with a logical 'AND'. */
export type EventPoolsTeamsBoolExp = {
  _and?: InputMaybe<Array<EventPoolsTeamsBoolExp>>;
  _not?: InputMaybe<EventPoolsTeamsBoolExp>;
  _or?: InputMaybe<Array<EventPoolsTeamsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  pool?: InputMaybe<EventGroupPoolsBoolExp>;
  poolId?: InputMaybe<UuidComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_pools_teams" */
export type EventPoolsTeamsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_pools_teams" */
export type EventPoolsTeamsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_pools_teams". */
export type EventPoolsTeamsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  pool?: InputMaybe<EventGroupPoolsOrderBy>;
  poolId?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_pools_teams" */
export enum EventPoolsTeamsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "event_pools_teams" */
export type EventPoolsTeamsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventPoolsTeamsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventPoolsTeamsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "event_privacy" */
export type EventPrivacy = {
  __typename?: 'EventPrivacy';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_privacy". All fields are combined with a logical 'AND'. */
export type EventPrivacyBoolExp = {
  _and?: InputMaybe<Array<EventPrivacyBoolExp>>;
  _not?: InputMaybe<EventPrivacyBoolExp>;
  _or?: InputMaybe<Array<EventPrivacyBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventPrivacyEnum {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Unlisted = 'UNLISTED'
}

/** Boolean expression to compare columns of type "EventPrivacyEnum". All fields are combined with logical 'AND'. */
export type EventPrivacyEnumComparisonExp = {
  _eq?: InputMaybe<EventPrivacyEnum>;
  _in?: InputMaybe<Array<EventPrivacyEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventPrivacyEnum>;
  _nin?: InputMaybe<Array<EventPrivacyEnum>>;
};

/** Ordering options when selecting data from "event_privacy". */
export type EventPrivacyOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_privacy" */
export enum EventPrivacySelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_privacy" */
export type EventPrivacyStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventPrivacyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventPrivacyStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_registration_details" */
export type EventRegistrationDetails = {
  __typename?: 'EventRegistrationDetails';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventRegistrationId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  registration: EventRegistrations;
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "event_registration_details". All fields are combined with a logical 'AND'. */
export type EventRegistrationDetailsBoolExp = {
  _and?: InputMaybe<Array<EventRegistrationDetailsBoolExp>>;
  _not?: InputMaybe<EventRegistrationDetailsBoolExp>;
  _or?: InputMaybe<Array<EventRegistrationDetailsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  duprId?: InputMaybe<StringComparisonExp>;
  eventRegistrationId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  registration?: InputMaybe<EventRegistrationsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_registration_details" */
export enum EventRegistrationDetailsConstraint {
  /** unique or primary key constraint on columns "event_registration_id" */
  EventRegistrationDetailsEventRegistrationIdKey = 'event_registration_details_event_registration_id_key',
  /** unique or primary key constraint on columns "id" */
  EventRegistrationDetailsPkey = 'event_registration_details_pkey'
}

/** input type for inserting data into table "event_registration_details" */
export type EventRegistrationDetailsInsertInput = {
  duprId?: InputMaybe<Scalars['String']>;
  eventRegistrationId?: InputMaybe<Scalars['uuid']>;
};

/** response of any mutation on the table "event_registration_details" */
export type EventRegistrationDetailsMutationResponse = {
  __typename?: 'EventRegistrationDetailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventRegistrationDetails>;
};

/** on_conflict condition type for table "event_registration_details" */
export type EventRegistrationDetailsOnConflict = {
  constraint: EventRegistrationDetailsConstraint;
  updateColumns?: Array<EventRegistrationDetailsUpdateColumn>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};

/** Ordering options when selecting data from "event_registration_details". */
export type EventRegistrationDetailsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  duprId?: InputMaybe<OrderBy>;
  eventRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  registration?: InputMaybe<EventRegistrationsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_registration_details" */
export enum EventRegistrationDetailsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  EventRegistrationId = 'eventRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "event_registration_details" */
export type EventRegistrationDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventRegistrationDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventRegistrationDetailsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** placeholder for update columns of table "event_registration_details" (current role has no relevant permissions) */
export enum EventRegistrationDetailsUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "event_registrations" */
export type EventRegistrations = {
  __typename?: 'EventRegistrations';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  registrationDetails?: Maybe<EventRegistrationDetails>;
  /** An array relationship */
  transactionItems: Array<EventTransactionItems>;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "event_registrations" */
export type EventRegistrationsTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** order by aggregate values of table "event_registrations" */
export type EventRegistrationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventRegistrationsMaxOrderBy>;
  min?: InputMaybe<EventRegistrationsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_registrations". All fields are combined with a logical 'AND'. */
export type EventRegistrationsBoolExp = {
  _and?: InputMaybe<Array<EventRegistrationsBoolExp>>;
  _not?: InputMaybe<EventRegistrationsBoolExp>;
  _or?: InputMaybe<Array<EventRegistrationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  registrationDetails?: InputMaybe<EventRegistrationDetailsBoolExp>;
  transactionItems?: InputMaybe<EventTransactionItemsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** order by max() on columns of table "event_registrations" */
export type EventRegistrationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_registrations" */
export type EventRegistrationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_registrations". */
export type EventRegistrationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  registrationDetails?: InputMaybe<EventRegistrationDetailsOrderBy>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** select columns of table "event_registrations" */
export enum EventRegistrationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "event_registrations" */
export type EventRegistrationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventRegistrationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventRegistrationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasons = {
  __typename?: 'EventSequenceCompleteReasons';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_sequence_complete_reasons". All fields are combined with a logical 'AND'. */
export type EventSequenceCompleteReasonsBoolExp = {
  _and?: InputMaybe<Array<EventSequenceCompleteReasonsBoolExp>>;
  _not?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
  _or?: InputMaybe<Array<EventSequenceCompleteReasonsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventSequenceCompleteReasonsEnum {
  AllScores = 'ALL_SCORES',
  OrganizerSelected = 'ORGANIZER_SELECTED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventSequenceCompleteReasonsEnum". All fields are combined with logical 'AND'. */
export type EventSequenceCompleteReasonsEnumComparisonExp = {
  _eq?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  _in?: InputMaybe<Array<EventSequenceCompleteReasonsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  _nin?: InputMaybe<Array<EventSequenceCompleteReasonsEnum>>;
};

/** Ordering options when selecting data from "event_sequence_complete_reasons". */
export type EventSequenceCompleteReasonsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_sequence_complete_reasons" */
export enum EventSequenceCompleteReasonsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventSequenceCompleteReasonsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventSequenceCompleteReasonsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_sponsors" */
export type EventSponsors = {
  __typename?: 'EventSponsors';
  categoryName: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  imageFileName: Scalars['String'];
  imageFileType: Scalars['String'];
  imageHost: Scalars['String'];
  imagePath: Scalars['String'];
  imageProvider: Scalars['String'];
  imageProviderUrl: Scalars['String'];
  imageUrl: Scalars['String'];
  isTitleSponsor: Scalars['Boolean'];
  name: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_sponsors" */
export type EventSponsorsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventSponsorsMaxOrderBy>;
  min?: InputMaybe<EventSponsorsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_sponsors". All fields are combined with a logical 'AND'. */
export type EventSponsorsBoolExp = {
  _and?: InputMaybe<Array<EventSponsorsBoolExp>>;
  _not?: InputMaybe<EventSponsorsBoolExp>;
  _or?: InputMaybe<Array<EventSponsorsBoolExp>>;
  categoryName?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  imageFileName?: InputMaybe<StringComparisonExp>;
  imageFileType?: InputMaybe<StringComparisonExp>;
  imageHost?: InputMaybe<StringComparisonExp>;
  imagePath?: InputMaybe<StringComparisonExp>;
  imageProvider?: InputMaybe<StringComparisonExp>;
  imageProviderUrl?: InputMaybe<StringComparisonExp>;
  imageUrl?: InputMaybe<StringComparisonExp>;
  isTitleSponsor?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_sponsors" */
export enum EventSponsorsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventSponsorsPkey = 'event_sponsors_pkey'
}

/** input type for inserting data into table "event_sponsors" */
export type EventSponsorsInsertInput = {
  categoryName?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  imageFileName?: InputMaybe<Scalars['String']>;
  imageFileType?: InputMaybe<Scalars['String']>;
  imageHost?: InputMaybe<Scalars['String']>;
  imagePath?: InputMaybe<Scalars['String']>;
  imageProvider?: InputMaybe<Scalars['String']>;
  imageProviderUrl?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  isTitleSponsor?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
};

/** order by max() on columns of table "event_sponsors" */
export type EventSponsorsMaxOrderBy = {
  categoryName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageFileName?: InputMaybe<OrderBy>;
  imageFileType?: InputMaybe<OrderBy>;
  imageHost?: InputMaybe<OrderBy>;
  imagePath?: InputMaybe<OrderBy>;
  imageProvider?: InputMaybe<OrderBy>;
  imageProviderUrl?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_sponsors" */
export type EventSponsorsMinOrderBy = {
  categoryName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageFileName?: InputMaybe<OrderBy>;
  imageFileType?: InputMaybe<OrderBy>;
  imageHost?: InputMaybe<OrderBy>;
  imagePath?: InputMaybe<OrderBy>;
  imageProvider?: InputMaybe<OrderBy>;
  imageProviderUrl?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_sponsors" */
export type EventSponsorsMutationResponse = {
  __typename?: 'EventSponsorsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventSponsors>;
};

/** on_conflict condition type for table "event_sponsors" */
export type EventSponsorsOnConflict = {
  constraint: EventSponsorsConstraint;
  updateColumns?: Array<EventSponsorsUpdateColumn>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};

/** Ordering options when selecting data from "event_sponsors". */
export type EventSponsorsOrderBy = {
  categoryName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageFileName?: InputMaybe<OrderBy>;
  imageFileType?: InputMaybe<OrderBy>;
  imageHost?: InputMaybe<OrderBy>;
  imagePath?: InputMaybe<OrderBy>;
  imageProvider?: InputMaybe<OrderBy>;
  imageProviderUrl?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  isTitleSponsor?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_sponsors */
export type EventSponsorsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_sponsors" */
export enum EventSponsorsSelectColumn {
  /** column name */
  CategoryName = 'categoryName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  ImageFileName = 'imageFileName',
  /** column name */
  ImageFileType = 'imageFileType',
  /** column name */
  ImageHost = 'imageHost',
  /** column name */
  ImagePath = 'imagePath',
  /** column name */
  ImageProvider = 'imageProvider',
  /** column name */
  ImageProviderUrl = 'imageProviderUrl',
  /** column name */
  ImageUrl = 'imageUrl',
  /** column name */
  IsTitleSponsor = 'isTitleSponsor',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_sponsors" */
export type EventSponsorsSetInput = {
  categoryName?: InputMaybe<Scalars['String']>;
  imageFileName?: InputMaybe<Scalars['String']>;
  imageFileType?: InputMaybe<Scalars['String']>;
  imageHost?: InputMaybe<Scalars['String']>;
  imagePath?: InputMaybe<Scalars['String']>;
  imageProvider?: InputMaybe<Scalars['String']>;
  imageProviderUrl?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  isTitleSponsor?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_sponsors" */
export type EventSponsorsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventSponsorsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventSponsorsStreamCursorValueInput = {
  categoryName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  imageFileName?: InputMaybe<Scalars['String']>;
  imageFileType?: InputMaybe<Scalars['String']>;
  imageHost?: InputMaybe<Scalars['String']>;
  imagePath?: InputMaybe<Scalars['String']>;
  imageProvider?: InputMaybe<Scalars['String']>;
  imageProviderUrl?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  isTitleSponsor?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_sponsors" */
export enum EventSponsorsUpdateColumn {
  /** column name */
  CategoryName = 'categoryName',
  /** column name */
  ImageFileName = 'imageFileName',
  /** column name */
  ImageFileType = 'imageFileType',
  /** column name */
  ImageHost = 'imageHost',
  /** column name */
  ImagePath = 'imagePath',
  /** column name */
  ImageProvider = 'imageProvider',
  /** column name */
  ImageProviderUrl = 'imageProviderUrl',
  /** column name */
  ImageUrl = 'imageUrl',
  /** column name */
  IsTitleSponsor = 'isTitleSponsor',
  /** column name */
  Name = 'name'
}

export type EventSponsorsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventSponsorsSetInput>;
  /** filter the rows which have to be updated */
  where: EventSponsorsBoolExp;
};

/** columns and relationships of "event_statuses" */
export type EventStatuses = {
  __typename?: 'EventStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_statuses". All fields are combined with a logical 'AND'. */
export type EventStatusesBoolExp = {
  _and?: InputMaybe<Array<EventStatusesBoolExp>>;
  _not?: InputMaybe<EventStatusesBoolExp>;
  _or?: InputMaybe<Array<EventStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventStatusesEnum {
  Canceled = 'CANCELED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

/** Boolean expression to compare columns of type "EventStatusesEnum". All fields are combined with logical 'AND'. */
export type EventStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventStatusesEnum>;
  _in?: InputMaybe<Array<EventStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventStatusesEnum>;
  _nin?: InputMaybe<Array<EventStatusesEnum>>;
};

/** Ordering options when selecting data from "event_statuses". */
export type EventStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_statuses" */
export enum EventStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_statuses" */
export type EventStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_team_member_statuses" */
export type EventTeamMemberStatuses = {
  __typename?: 'EventTeamMemberStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_team_member_statuses". All fields are combined with a logical 'AND'. */
export type EventTeamMemberStatusesBoolExp = {
  _and?: InputMaybe<Array<EventTeamMemberStatusesBoolExp>>;
  _not?: InputMaybe<EventTeamMemberStatusesBoolExp>;
  _or?: InputMaybe<Array<EventTeamMemberStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventTeamMemberStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventTeamMemberStatusesEnum". All fields are combined with logical 'AND'. */
export type EventTeamMemberStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventTeamMemberStatusesEnum>;
  _in?: InputMaybe<Array<EventTeamMemberStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventTeamMemberStatusesEnum>;
  _nin?: InputMaybe<Array<EventTeamMemberStatusesEnum>>;
};

/** Ordering options when selecting data from "event_team_member_statuses". */
export type EventTeamMemberStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_team_member_statuses" */
export enum EventTeamMemberStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_team_member_statuses" */
export type EventTeamMemberStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTeamMemberStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTeamMemberStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_team_members" */
export type EventTeamMembers = {
  __typename?: 'EventTeamMembers';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  status: EventTeamMemberStatusesEnum;
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** order by aggregate values of table "event_team_members" */
export type EventTeamMembersAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTeamMembersMaxOrderBy>;
  min?: InputMaybe<EventTeamMembersMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_team_members". All fields are combined with a logical 'AND'. */
export type EventTeamMembersBoolExp = {
  _and?: InputMaybe<Array<EventTeamMembersBoolExp>>;
  _not?: InputMaybe<EventTeamMembersBoolExp>;
  _or?: InputMaybe<Array<EventTeamMembersBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<EventTeamMemberStatusesEnumComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** order by max() on columns of table "event_team_members" */
export type EventTeamMembersMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_team_members" */
export type EventTeamMembersMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_team_members". */
export type EventTeamMembersOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** select columns of table "event_team_members" */
export enum EventTeamMembersSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "event_team_members" */
export type EventTeamMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTeamMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTeamMembersStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventTeamMemberStatusesEnum>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "event_teams" */
export type EventTeams = {
  __typename?: 'EventTeams';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  gamesWon: Array<EventMatchGames>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  /** An array relationship */
  groupRegistrations: Array<EventGroupRegistrations>;
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatchesTeams>;
  /** An array relationship */
  matchesLost: Array<EventMatches>;
  /** An array relationship */
  matchesWon: Array<EventMatches>;
  /** An array relationship */
  members: Array<EventTeamMembers>;
  /** An array relationship */
  pools: Array<EventPoolsTeams>;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_teams" */
export type EventTeamsGamesWonArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsGroupRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesLostArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesWonArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMembersArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};

/** order by aggregate values of table "event_teams" */
export type EventTeamsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTeamsMaxOrderBy>;
  min?: InputMaybe<EventTeamsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "event_teams". All fields are combined with a logical 'AND'. */
export type EventTeamsBoolExp = {
  _and?: InputMaybe<Array<EventTeamsBoolExp>>;
  _not?: InputMaybe<EventTeamsBoolExp>;
  _or?: InputMaybe<Array<EventTeamsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  gamesWon?: InputMaybe<EventMatchGamesBoolExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupRegistrations?: InputMaybe<EventGroupRegistrationsBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesTeamsBoolExp>;
  matchesLost?: InputMaybe<EventMatchesBoolExp>;
  matchesWon?: InputMaybe<EventMatchesBoolExp>;
  members?: InputMaybe<EventTeamMembersBoolExp>;
  pools?: InputMaybe<EventPoolsTeamsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_teams" */
export type EventTeamsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_teams" */
export type EventTeamsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_teams". */
export type EventTeamsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  gamesWonAggregate?: InputMaybe<EventMatchGamesAggregateOrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistrationsAggregate?: InputMaybe<EventGroupRegistrationsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesTeamsAggregateOrderBy>;
  matchesLostAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  matchesWonAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  membersAggregate?: InputMaybe<EventTeamMembersAggregateOrderBy>;
  poolsAggregate?: InputMaybe<EventPoolsTeamsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_teams" */
export enum EventTeamsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "event_teams" */
export type EventTeamsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTeamsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTeamsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "event_transaction_item_types" */
export type EventTransactionItemTypes = {
  __typename?: 'EventTransactionItemTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_transaction_item_types". All fields are combined with a logical 'AND'. */
export type EventTransactionItemTypesBoolExp = {
  _and?: InputMaybe<Array<EventTransactionItemTypesBoolExp>>;
  _not?: InputMaybe<EventTransactionItemTypesBoolExp>;
  _or?: InputMaybe<Array<EventTransactionItemTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventTransactionItemTypesEnum {
  EventGroupRegistration = 'EVENT_GROUP_REGISTRATION',
  EventRegistration = 'EVENT_REGISTRATION'
}

/** Boolean expression to compare columns of type "EventTransactionItemTypesEnum". All fields are combined with logical 'AND'. */
export type EventTransactionItemTypesEnumComparisonExp = {
  _eq?: InputMaybe<EventTransactionItemTypesEnum>;
  _in?: InputMaybe<Array<EventTransactionItemTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventTransactionItemTypesEnum>;
  _nin?: InputMaybe<Array<EventTransactionItemTypesEnum>>;
};

/** Ordering options when selecting data from "event_transaction_item_types". */
export type EventTransactionItemTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_transaction_item_types" */
export enum EventTransactionItemTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_transaction_item_types" */
export type EventTransactionItemTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTransactionItemTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTransactionItemTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "event_transaction_items" */
export type EventTransactionItems = {
  __typename?: 'EventTransactionItems';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  groupRegistration?: Maybe<EventGroupRegistrations>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  priceUnitAmount: Scalars['Int'];
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  registration?: Maybe<EventRegistrations>;
  registrationId?: Maybe<Scalars['uuid']>;
  status: OrderStatusesEnum;
  totalUnitAmount: Scalars['Int'];
  /** An object relationship */
  transaction: EventTransactions;
  transactionId: Scalars['uuid'];
  type: EventTransactionItemTypesEnum;
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "event_transaction_items" */
export type EventTransactionItemsAggregateOrderBy = {
  avg?: InputMaybe<EventTransactionItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTransactionItemsMaxOrderBy>;
  min?: InputMaybe<EventTransactionItemsMinOrderBy>;
  stddev?: InputMaybe<EventTransactionItemsStddevOrderBy>;
  stddevPop?: InputMaybe<EventTransactionItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventTransactionItemsStddevSampOrderBy>;
  sum?: InputMaybe<EventTransactionItemsSumOrderBy>;
  varPop?: InputMaybe<EventTransactionItemsVarPopOrderBy>;
  varSamp?: InputMaybe<EventTransactionItemsVarSampOrderBy>;
  variance?: InputMaybe<EventTransactionItemsVarianceOrderBy>;
};

/** order by avg() on columns of table "event_transaction_items" */
export type EventTransactionItemsAvgOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_transaction_items". All fields are combined with a logical 'AND'. */
export type EventTransactionItemsBoolExp = {
  _and?: InputMaybe<Array<EventTransactionItemsBoolExp>>;
  _not?: InputMaybe<EventTransactionItemsBoolExp>;
  _or?: InputMaybe<Array<EventTransactionItemsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsBoolExp>;
  groupRegistrationId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  registration?: InputMaybe<EventRegistrationsBoolExp>;
  registrationId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  totalUnitAmount?: InputMaybe<IntComparisonExp>;
  transaction?: InputMaybe<EventTransactionsBoolExp>;
  transactionId?: InputMaybe<UuidComparisonExp>;
  type?: InputMaybe<EventTransactionItemTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "event_transaction_items" */
export type EventTransactionItemsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  registrationId?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  transactionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_transaction_items" */
export type EventTransactionItemsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  registrationId?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  transactionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_transaction_items". */
export type EventTransactionItemsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsOrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  registration?: InputMaybe<EventRegistrationsOrderBy>;
  registrationId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  transaction?: InputMaybe<EventTransactionsOrderBy>;
  transactionId?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "event_transaction_items" */
export enum EventTransactionItemsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupRegistrationId = 'groupRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  RegistrationId = 'registrationId',
  /** column name */
  Status = 'status',
  /** column name */
  TotalUnitAmount = 'totalUnitAmount',
  /** column name */
  TransactionId = 'transactionId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "event_transaction_items" */
export type EventTransactionItemsStddevOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_transaction_items" */
export type EventTransactionItemsStddevPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_transaction_items" */
export type EventTransactionItemsStddevSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_transaction_items" */
export type EventTransactionItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTransactionItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTransactionItemsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  registrationId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  transactionId?: InputMaybe<Scalars['uuid']>;
  type?: InputMaybe<EventTransactionItemTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "event_transaction_items" */
export type EventTransactionItemsSumOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "event_transaction_items" */
export type EventTransactionItemsVarPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_transaction_items" */
export type EventTransactionItemsVarSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_transaction_items" */
export type EventTransactionItemsVarianceOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_transactions" */
export type EventTransactions = {
  __typename?: 'EventTransactions';
  applicationFeeTotalUnitAmount: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  customer: Users;
  customerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  customerProfile?: Maybe<UserProfiles>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  orderSubtotalUnitAmount: Scalars['Int'];
  orderTotalUnitAmount: Scalars['Int'];
  paidUnitAmount: Scalars['Int'];
  /** An object relationship */
  paymentMethodUsed?: Maybe<UserCreditCards>;
  paymentProcessor: PaymentProcessorsEnum;
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  seller: Users;
  sellerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  sellerProfile?: Maybe<UserProfiles>;
  sellerUserId: Scalars['uuid'];
  status: OrderStatusesEnum;
  stripeCustomerId: Scalars['String'];
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus: Scalars['String'];
  /** An array relationship */
  transactionItems: Array<EventTransactionItems>;
  transferUnitAmount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  userCreditCardId?: Maybe<Scalars['uuid']>;
  userId: Scalars['uuid'];
};


/** columns and relationships of "event_transactions" */
export type EventTransactionsTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** order by aggregate values of table "event_transactions" */
export type EventTransactionsAggregateOrderBy = {
  avg?: InputMaybe<EventTransactionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTransactionsMaxOrderBy>;
  min?: InputMaybe<EventTransactionsMinOrderBy>;
  stddev?: InputMaybe<EventTransactionsStddevOrderBy>;
  stddevPop?: InputMaybe<EventTransactionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventTransactionsStddevSampOrderBy>;
  sum?: InputMaybe<EventTransactionsSumOrderBy>;
  varPop?: InputMaybe<EventTransactionsVarPopOrderBy>;
  varSamp?: InputMaybe<EventTransactionsVarSampOrderBy>;
  variance?: InputMaybe<EventTransactionsVarianceOrderBy>;
};

/** order by avg() on columns of table "event_transactions" */
export type EventTransactionsAvgOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_transactions". All fields are combined with a logical 'AND'. */
export type EventTransactionsBoolExp = {
  _and?: InputMaybe<Array<EventTransactionsBoolExp>>;
  _not?: InputMaybe<EventTransactionsBoolExp>;
  _or?: InputMaybe<Array<EventTransactionsBoolExp>>;
  applicationFeeTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  customer?: InputMaybe<UsersBoolExp>;
  customerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  customerProfile?: InputMaybe<UserProfilesBoolExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  orderSubtotalUnitAmount?: InputMaybe<IntComparisonExp>;
  orderTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  paidUnitAmount?: InputMaybe<IntComparisonExp>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsBoolExp>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnumComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  seller?: InputMaybe<UsersBoolExp>;
  sellerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  sellerProfile?: InputMaybe<UserProfilesBoolExp>;
  sellerUserId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripeMerchantId?: InputMaybe<StringComparisonExp>;
  stripePaymentStatus?: InputMaybe<StringComparisonExp>;
  transactionItems?: InputMaybe<EventTransactionItemsBoolExp>;
  transferUnitAmount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCreditCardId?: InputMaybe<UuidComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** order by max() on columns of table "event_transactions" */
export type EventTransactionsMaxOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "event_transactions" */
export type EventTransactionsMinOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "event_transactions". */
export type EventTransactionsOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customer?: InputMaybe<UsersOrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  customerProfile?: InputMaybe<UserProfilesOrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsOrderBy>;
  paymentProcessor?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  seller?: InputMaybe<UsersOrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerProfile?: InputMaybe<UserProfilesOrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateOrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "event_transactions" */
export enum EventTransactionsSelectColumn {
  /** column name */
  ApplicationFeeTotalUnitAmount = 'applicationFeeTotalUnitAmount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerApplicationFeeUnitAmount = 'customerApplicationFeeUnitAmount',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  SellerApplicationFeeUnitAmount = 'sellerApplicationFeeUnitAmount',
  /** column name */
  SellerUserId = 'sellerUserId',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  TransferUnitAmount = 'transferUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId',
  /** column name */
  UserId = 'userId'
}

/** order by stddev() on columns of table "event_transactions" */
export type EventTransactionsStddevOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "event_transactions" */
export type EventTransactionsStddevPopOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "event_transactions" */
export type EventTransactionsStddevSampOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_transactions" */
export type EventTransactionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTransactionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTransactionsStreamCursorValueInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "event_transactions" */
export type EventTransactionsSumOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "event_transactions" */
export type EventTransactionsVarPopOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "event_transactions" */
export type EventTransactionsVarSampOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "event_transactions" */
export type EventTransactionsVarianceOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_types" */
export type EventTypes = {
  __typename?: 'EventTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "event_types". All fields are combined with a logical 'AND'. */
export type EventTypesBoolExp = {
  _and?: InputMaybe<Array<EventTypesBoolExp>>;
  _not?: InputMaybe<EventTypesBoolExp>;
  _or?: InputMaybe<Array<EventTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum EventTypesEnum {
  GeneralEvent = 'GENERAL_EVENT',
  League = 'LEAGUE',
  Tournament = 'TOURNAMENT'
}

/** Boolean expression to compare columns of type "EventTypesEnum". All fields are combined with logical 'AND'. */
export type EventTypesEnumComparisonExp = {
  _eq?: InputMaybe<EventTypesEnum>;
  _in?: InputMaybe<Array<EventTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventTypesEnum>;
  _nin?: InputMaybe<Array<EventTypesEnum>>;
};

/** Ordering options when selecting data from "event_types". */
export type EventTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "event_types" */
export enum EventTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "event_types" */
export type EventTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "events" */
export type Events = {
  __typename?: 'Events';
  addressString?: Maybe<Scalars['String']>;
  archivedAt?: Maybe<Scalars['timestamptz']>;
  ballCustomName: Scalars['String'];
  ballType: BallTypesEnum;
  cancelReason: Scalars['String'];
  canceledAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  city?: Maybe<Cities>;
  cityId?: Maybe<Scalars['uuid']>;
  cityString: Scalars['String'];
  /** An object relationship */
  contactDetails?: Maybe<EventContactDetails>;
  countryString: Scalars['String'];
  /** An array relationship */
  courts: Array<EventCourts>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImageFileType?: Maybe<Scalars['String']>;
  coverImageHost?: Maybe<Scalars['String']>;
  coverImageOriginalFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  /** Fallback for when we don't have a city_id */
  displayLocation: Scalars['String'];
  endDate: Scalars['date'];
  endDateTime: Scalars['timestamptz'];
  externalUrl?: Maybe<Scalars['String']>;
  /** An array relationship */
  faqs: Array<EventFaqs>;
  geometry?: Maybe<Scalars['geography']>;
  groupFormat?: Maybe<EventGroupFormatsEnum>;
  /** An array relationship */
  groups: Array<EventGroups>;
  hasPrizes: Scalars['Boolean'];
  /** An object relationship */
  hostUser?: Maybe<Users>;
  hostUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  hostUserProfile?: Maybe<UserProfiles>;
  id: Scalars['uuid'];
  /** An array relationship */
  invitations: Array<EventInvitations>;
  isExternal: Scalars['Boolean'];
  isRatingRequired: Scalars['Boolean'];
  isRegisterOffPlatform: Scalars['Boolean'];
  isSanctioned: Scalars['Boolean'];
  latitude?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  listingFees: Array<EventListingFees>;
  locale: Scalars['String'];
  longitude?: Maybe<Scalars['numeric']>;
  organizerImageFileName?: Maybe<Scalars['String']>;
  organizerImageFileType?: Maybe<Scalars['String']>;
  organizerImageHost?: Maybe<Scalars['String']>;
  organizerImageOriginalFileName?: Maybe<Scalars['String']>;
  organizerImagePath?: Maybe<Scalars['String']>;
  organizerImageProvider?: Maybe<Scalars['String']>;
  organizerImageProviderUrl?: Maybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: Maybe<Scalars['String']>;
  /** An object relationship */
  pickleballRatingScale?: Maybe<PickleballRatingScales>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  privacy: EventPrivacyEnum;
  prizeDescription: Scalars['String'];
  publishedAt?: Maybe<Scalars['timestamptz']>;
  regionString: Scalars['String'];
  registrationClosedAt?: Maybe<Scalars['timestamptz']>;
  registrationDeadlineDate: Scalars['date'];
  registrationDeadlineDateTime?: Maybe<Scalars['timestamptz']>;
  registrationOpenDate?: Maybe<Scalars['date']>;
  registrationOpenDateTime?: Maybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount: Scalars['Int'];
  /** An array relationship */
  registrations: Array<EventRegistrations>;
  scoringFormat: ScoringFormatEnum;
  showInPublicDate?: Maybe<Scalars['date']>;
  showInPublicDateTime?: Maybe<Scalars['timestamptz']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  sourceOrganizerTitle?: Maybe<Scalars['String']>;
  sourceRegistrationCount: Scalars['Int'];
  /** An array relationship */
  sponsors: Array<EventSponsors>;
  sport: SportsEnum;
  startDate: Scalars['date'];
  startDateTime: Scalars['timestamptz'];
  status: EventStatusesEnum;
  streetPrimaryString: Scalars['String'];
  streetSecondaryString: Scalars['String'];
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title: Scalars['String'];
  /** An array relationship */
  transactions: Array<EventTransactions>;
  type: EventTypesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue?: Maybe<Venues>;
  venueId?: Maybe<Scalars['uuid']>;
  zipcodeString: Scalars['String'];
};


/** columns and relationships of "events" */
export type EventsCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsFaqsArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsGroupsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsListingFeesArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


/** columns and relationships of "events" */
export type EventsRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsSponsorsArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsTransactionsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};

/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
export type EventsBoolExp = {
  _and?: InputMaybe<Array<EventsBoolExp>>;
  _not?: InputMaybe<EventsBoolExp>;
  _or?: InputMaybe<Array<EventsBoolExp>>;
  addressString?: InputMaybe<StringComparisonExp>;
  archivedAt?: InputMaybe<TimestamptzComparisonExp>;
  ballCustomName?: InputMaybe<StringComparisonExp>;
  ballType?: InputMaybe<BallTypesEnumComparisonExp>;
  cancelReason?: InputMaybe<StringComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  city?: InputMaybe<CitiesBoolExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  cityString?: InputMaybe<StringComparisonExp>;
  contactDetails?: InputMaybe<EventContactDetailsBoolExp>;
  countryString?: InputMaybe<StringComparisonExp>;
  courts?: InputMaybe<EventCourtsBoolExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImageFileType?: InputMaybe<StringComparisonExp>;
  coverImageHost?: InputMaybe<StringComparisonExp>;
  coverImageOriginalFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  displayLocation?: InputMaybe<StringComparisonExp>;
  endDate?: InputMaybe<DateComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  externalUrl?: InputMaybe<StringComparisonExp>;
  faqs?: InputMaybe<EventFaqsBoolExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groupFormat?: InputMaybe<EventGroupFormatsEnumComparisonExp>;
  groups?: InputMaybe<EventGroupsBoolExp>;
  hasPrizes?: InputMaybe<BooleanComparisonExp>;
  hostUser?: InputMaybe<UsersBoolExp>;
  hostUserId?: InputMaybe<UuidComparisonExp>;
  hostUserProfile?: InputMaybe<UserProfilesBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitations?: InputMaybe<EventInvitationsBoolExp>;
  isExternal?: InputMaybe<BooleanComparisonExp>;
  isRatingRequired?: InputMaybe<BooleanComparisonExp>;
  isRegisterOffPlatform?: InputMaybe<BooleanComparisonExp>;
  isSanctioned?: InputMaybe<BooleanComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  listingFees?: InputMaybe<EventListingFeesBoolExp>;
  locale?: InputMaybe<StringComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  organizerImageFileName?: InputMaybe<StringComparisonExp>;
  organizerImageFileType?: InputMaybe<StringComparisonExp>;
  organizerImageHost?: InputMaybe<StringComparisonExp>;
  organizerImageOriginalFileName?: InputMaybe<StringComparisonExp>;
  organizerImagePath?: InputMaybe<StringComparisonExp>;
  organizerImageProvider?: InputMaybe<StringComparisonExp>;
  organizerImageProviderUrl?: InputMaybe<StringComparisonExp>;
  organizerImageUrl?: InputMaybe<StringComparisonExp>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesBoolExp>;
  pickleballRatingScaleId?: InputMaybe<UuidComparisonExp>;
  privacy?: InputMaybe<EventPrivacyEnumComparisonExp>;
  prizeDescription?: InputMaybe<StringComparisonExp>;
  publishedAt?: InputMaybe<TimestamptzComparisonExp>;
  regionString?: InputMaybe<StringComparisonExp>;
  registrationClosedAt?: InputMaybe<TimestamptzComparisonExp>;
  registrationDeadlineDate?: InputMaybe<DateComparisonExp>;
  registrationDeadlineDateTime?: InputMaybe<TimestamptzComparisonExp>;
  registrationOpenDate?: InputMaybe<DateComparisonExp>;
  registrationOpenDateTime?: InputMaybe<TimestamptzComparisonExp>;
  registrationPriceUnitAmount?: InputMaybe<IntComparisonExp>;
  registrations?: InputMaybe<EventRegistrationsBoolExp>;
  scoringFormat?: InputMaybe<ScoringFormatEnumComparisonExp>;
  showInPublicDate?: InputMaybe<DateComparisonExp>;
  showInPublicDateTime?: InputMaybe<TimestamptzComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  source?: InputMaybe<StringComparisonExp>;
  sourceOrganizerTitle?: InputMaybe<StringComparisonExp>;
  sourceRegistrationCount?: InputMaybe<IntComparisonExp>;
  sponsors?: InputMaybe<EventSponsorsBoolExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  startDate?: InputMaybe<DateComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<EventStatusesEnumComparisonExp>;
  streetPrimaryString?: InputMaybe<StringComparisonExp>;
  streetSecondaryString?: InputMaybe<StringComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  timezoneAbbreviation?: InputMaybe<StringComparisonExp>;
  timezoneName?: InputMaybe<StringComparisonExp>;
  timezoneOffsetMinutes?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  transactions?: InputMaybe<EventTransactionsBoolExp>;
  type?: InputMaybe<EventTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
  zipcodeString?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "events" */
export type EventsIncInput = {
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** response of any mutation on the table "events" */
export type EventsMutationResponse = {
  __typename?: 'EventsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Events>;
};

/** Ordering options when selecting data from "events". */
export type EventsOrderBy = {
  addressString?: InputMaybe<OrderBy>;
  archivedAt?: InputMaybe<OrderBy>;
  ballCustomName?: InputMaybe<OrderBy>;
  ballType?: InputMaybe<OrderBy>;
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  city?: InputMaybe<CitiesOrderBy>;
  cityId?: InputMaybe<OrderBy>;
  cityString?: InputMaybe<OrderBy>;
  contactDetails?: InputMaybe<EventContactDetailsOrderBy>;
  countryString?: InputMaybe<OrderBy>;
  courtsAggregate?: InputMaybe<EventCourtsAggregateOrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImageFileType?: InputMaybe<OrderBy>;
  coverImageHost?: InputMaybe<OrderBy>;
  coverImageOriginalFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  displayLocation?: InputMaybe<OrderBy>;
  endDate?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  externalUrl?: InputMaybe<OrderBy>;
  faqsAggregate?: InputMaybe<EventFaqsAggregateOrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupFormat?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<EventGroupsAggregateOrderBy>;
  hasPrizes?: InputMaybe<OrderBy>;
  hostUser?: InputMaybe<UsersOrderBy>;
  hostUserId?: InputMaybe<OrderBy>;
  hostUserProfile?: InputMaybe<UserProfilesOrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationsAggregate?: InputMaybe<EventInvitationsAggregateOrderBy>;
  isExternal?: InputMaybe<OrderBy>;
  isRatingRequired?: InputMaybe<OrderBy>;
  isRegisterOffPlatform?: InputMaybe<OrderBy>;
  isSanctioned?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  listingFeesAggregate?: InputMaybe<EventListingFeesAggregateOrderBy>;
  locale?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  organizerImageFileName?: InputMaybe<OrderBy>;
  organizerImageFileType?: InputMaybe<OrderBy>;
  organizerImageHost?: InputMaybe<OrderBy>;
  organizerImageOriginalFileName?: InputMaybe<OrderBy>;
  organizerImagePath?: InputMaybe<OrderBy>;
  organizerImageProvider?: InputMaybe<OrderBy>;
  organizerImageProviderUrl?: InputMaybe<OrderBy>;
  organizerImageUrl?: InputMaybe<OrderBy>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesOrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  prizeDescription?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  regionString?: InputMaybe<OrderBy>;
  registrationClosedAt?: InputMaybe<OrderBy>;
  registrationDeadlineDate?: InputMaybe<OrderBy>;
  registrationDeadlineDateTime?: InputMaybe<OrderBy>;
  registrationOpenDate?: InputMaybe<OrderBy>;
  registrationOpenDateTime?: InputMaybe<OrderBy>;
  registrationPriceUnitAmount?: InputMaybe<OrderBy>;
  registrationsAggregate?: InputMaybe<EventRegistrationsAggregateOrderBy>;
  scoringFormat?: InputMaybe<OrderBy>;
  showInPublicDate?: InputMaybe<OrderBy>;
  showInPublicDateTime?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceOrganizerTitle?: InputMaybe<OrderBy>;
  sourceRegistrationCount?: InputMaybe<OrderBy>;
  sponsorsAggregate?: InputMaybe<EventSponsorsAggregateOrderBy>;
  sport?: InputMaybe<OrderBy>;
  startDate?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  streetPrimaryString?: InputMaybe<OrderBy>;
  streetSecondaryString?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  transactionsAggregate?: InputMaybe<EventTransactionsAggregateOrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
  zipcodeString?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: events */
export type EventsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "events" */
export enum EventsSelectColumn {
  /** column name */
  AddressString = 'addressString',
  /** column name */
  ArchivedAt = 'archivedAt',
  /** column name */
  BallCustomName = 'ballCustomName',
  /** column name */
  BallType = 'ballType',
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CityId = 'cityId',
  /** column name */
  CityString = 'cityString',
  /** column name */
  CountryString = 'countryString',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImageFileType = 'coverImageFileType',
  /** column name */
  CoverImageHost = 'coverImageHost',
  /** column name */
  CoverImageOriginalFileName = 'coverImageOriginalFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DisplayLocation = 'displayLocation',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExternalUrl = 'externalUrl',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  GroupFormat = 'groupFormat',
  /** column name */
  HasPrizes = 'hasPrizes',
  /** column name */
  HostUserId = 'hostUserId',
  /** column name */
  Id = 'id',
  /** column name */
  IsExternal = 'isExternal',
  /** column name */
  IsRatingRequired = 'isRatingRequired',
  /** column name */
  IsRegisterOffPlatform = 'isRegisterOffPlatform',
  /** column name */
  IsSanctioned = 'isSanctioned',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Locale = 'locale',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  OrganizerImageFileName = 'organizerImageFileName',
  /** column name */
  OrganizerImageFileType = 'organizerImageFileType',
  /** column name */
  OrganizerImageHost = 'organizerImageHost',
  /** column name */
  OrganizerImageOriginalFileName = 'organizerImageOriginalFileName',
  /** column name */
  OrganizerImagePath = 'organizerImagePath',
  /** column name */
  OrganizerImageProvider = 'organizerImageProvider',
  /** column name */
  OrganizerImageProviderUrl = 'organizerImageProviderUrl',
  /** column name */
  OrganizerImageUrl = 'organizerImageUrl',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PrizeDescription = 'prizeDescription',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  RegionString = 'regionString',
  /** column name */
  RegistrationClosedAt = 'registrationClosedAt',
  /** column name */
  RegistrationDeadlineDate = 'registrationDeadlineDate',
  /** column name */
  RegistrationDeadlineDateTime = 'registrationDeadlineDateTime',
  /** column name */
  RegistrationOpenDate = 'registrationOpenDate',
  /** column name */
  RegistrationOpenDateTime = 'registrationOpenDateTime',
  /** column name */
  RegistrationPriceUnitAmount = 'registrationPriceUnitAmount',
  /** column name */
  ScoringFormat = 'scoringFormat',
  /** column name */
  ShowInPublicDate = 'showInPublicDate',
  /** column name */
  ShowInPublicDateTime = 'showInPublicDateTime',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceOrganizerTitle = 'sourceOrganizerTitle',
  /** column name */
  SourceRegistrationCount = 'sourceRegistrationCount',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  StreetPrimaryString = 'streetPrimaryString',
  /** column name */
  StreetSecondaryString = 'streetSecondaryString',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId',
  /** column name */
  ZipcodeString = 'zipcodeString'
}

/** input type for updating data in table "events" */
export type EventsSetInput = {
  addressString?: InputMaybe<Scalars['String']>;
  ballCustomName?: InputMaybe<Scalars['String']>;
  ballType?: InputMaybe<BallTypesEnum>;
  cityId?: InputMaybe<Scalars['uuid']>;
  cityString?: InputMaybe<Scalars['String']>;
  countryString?: InputMaybe<Scalars['String']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImageFileType?: InputMaybe<Scalars['String']>;
  coverImageHost?: InputMaybe<Scalars['String']>;
  coverImageOriginalFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['date']>;
  externalUrl?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groupFormat?: InputMaybe<EventGroupFormatsEnum>;
  hasPrizes?: InputMaybe<Scalars['Boolean']>;
  isRatingRequired?: InputMaybe<Scalars['Boolean']>;
  isSanctioned?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  locale?: InputMaybe<Scalars['String']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  organizerImageFileName?: InputMaybe<Scalars['String']>;
  organizerImageFileType?: InputMaybe<Scalars['String']>;
  organizerImageHost?: InputMaybe<Scalars['String']>;
  organizerImageOriginalFileName?: InputMaybe<Scalars['String']>;
  organizerImagePath?: InputMaybe<Scalars['String']>;
  organizerImageProvider?: InputMaybe<Scalars['String']>;
  organizerImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: InputMaybe<Scalars['String']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<EventPrivacyEnum>;
  prizeDescription?: InputMaybe<Scalars['String']>;
  regionString?: InputMaybe<Scalars['String']>;
  registrationDeadlineDate?: InputMaybe<Scalars['date']>;
  registrationDeadlineDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationOpenDate?: InputMaybe<Scalars['date']>;
  registrationOpenDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  sport?: InputMaybe<SportsEnum>;
  startDate?: InputMaybe<Scalars['date']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  streetPrimaryString?: InputMaybe<Scalars['String']>;
  streetSecondaryString?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  venueId?: InputMaybe<Scalars['uuid']>;
  zipcodeString?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "events" */
export type EventsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventsStreamCursorValueInput = {
  addressString?: InputMaybe<Scalars['String']>;
  archivedAt?: InputMaybe<Scalars['timestamptz']>;
  ballCustomName?: InputMaybe<Scalars['String']>;
  ballType?: InputMaybe<BallTypesEnum>;
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  cityString?: InputMaybe<Scalars['String']>;
  countryString?: InputMaybe<Scalars['String']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImageFileType?: InputMaybe<Scalars['String']>;
  coverImageHost?: InputMaybe<Scalars['String']>;
  coverImageOriginalFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  /** Fallback for when we don't have a city_id */
  displayLocation?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['date']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  externalUrl?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groupFormat?: InputMaybe<EventGroupFormatsEnum>;
  hasPrizes?: InputMaybe<Scalars['Boolean']>;
  hostUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  isRatingRequired?: InputMaybe<Scalars['Boolean']>;
  isRegisterOffPlatform?: InputMaybe<Scalars['Boolean']>;
  isSanctioned?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  locale?: InputMaybe<Scalars['String']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  organizerImageFileName?: InputMaybe<Scalars['String']>;
  organizerImageFileType?: InputMaybe<Scalars['String']>;
  organizerImageHost?: InputMaybe<Scalars['String']>;
  organizerImageOriginalFileName?: InputMaybe<Scalars['String']>;
  organizerImagePath?: InputMaybe<Scalars['String']>;
  organizerImageProvider?: InputMaybe<Scalars['String']>;
  organizerImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: InputMaybe<Scalars['String']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<EventPrivacyEnum>;
  prizeDescription?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  regionString?: InputMaybe<Scalars['String']>;
  registrationClosedAt?: InputMaybe<Scalars['timestamptz']>;
  registrationDeadlineDate?: InputMaybe<Scalars['date']>;
  registrationDeadlineDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationOpenDate?: InputMaybe<Scalars['date']>;
  registrationOpenDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  showInPublicDate?: InputMaybe<Scalars['date']>;
  showInPublicDateTime?: InputMaybe<Scalars['timestamptz']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceOrganizerTitle?: InputMaybe<Scalars['String']>;
  sourceRegistrationCount?: InputMaybe<Scalars['Int']>;
  sport?: InputMaybe<SportsEnum>;
  startDate?: InputMaybe<Scalars['date']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<EventStatusesEnum>;
  streetPrimaryString?: InputMaybe<Scalars['String']>;
  streetSecondaryString?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<EventTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
  zipcodeString?: InputMaybe<Scalars['String']>;
};

export type EventsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventsSetInput>;
  /** filter the rows which have to be updated */
  where: EventsBoolExp;
};

export enum FollowStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "FollowStatusesEnum". All fields are combined with logical 'AND'. */
export type FollowStatusesEnumComparisonExp = {
  _eq?: InputMaybe<FollowStatusesEnum>;
  _in?: InputMaybe<Array<FollowStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<FollowStatusesEnum>;
  _nin?: InputMaybe<Array<FollowStatusesEnum>>;
};

/** columns and relationships of "gender" */
export type Gender = {
  __typename?: 'Gender';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'. */
export type GenderBoolExp = {
  _and?: InputMaybe<Array<GenderBoolExp>>;
  _not?: InputMaybe<GenderBoolExp>;
  _or?: InputMaybe<Array<GenderBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum GenderEnum {
  Female = 'FEMALE',
  Male = 'MALE',
  /** State your preference in a free text field */
  Preferred = 'PREFERRED',
  /** Choose not to disclose any gender */
  Private = 'PRIVATE'
}

/** Boolean expression to compare columns of type "GenderEnum". All fields are combined with logical 'AND'. */
export type GenderEnumComparisonExp = {
  _eq?: InputMaybe<GenderEnum>;
  _in?: InputMaybe<Array<GenderEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<GenderEnum>;
  _nin?: InputMaybe<Array<GenderEnum>>;
};

/** Ordering options when selecting data from "gender". */
export type GenderOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "gender" */
export enum GenderSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "gender" */
export type GenderStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GenderStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GenderStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type GeographyCastExp = {
  geometry?: InputMaybe<GeometryComparisonExp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type GeographyComparisonExp = {
  _cast?: InputMaybe<GeographyCastExp>;
  _eq?: InputMaybe<Scalars['geography']>;
  _gt?: InputMaybe<Scalars['geography']>;
  _gte?: InputMaybe<Scalars['geography']>;
  _in?: InputMaybe<Array<Scalars['geography']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['geography']>;
  _lte?: InputMaybe<Scalars['geography']>;
  _neq?: InputMaybe<Scalars['geography']>;
  _nin?: InputMaybe<Array<Scalars['geography']>>;
  /** is the column within a given distance from the given geography value */
  _stDWithin?: InputMaybe<St_D_Within_Geography_Input>;
  /** does the column spatially intersect the given geography value */
  _stIntersects?: InputMaybe<Scalars['geography']>;
};

export type GeometryCastExp = {
  geography?: InputMaybe<GeographyComparisonExp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type GeometryComparisonExp = {
  _cast?: InputMaybe<GeometryCastExp>;
  _eq?: InputMaybe<Scalars['geometry']>;
  _gt?: InputMaybe<Scalars['geometry']>;
  _gte?: InputMaybe<Scalars['geometry']>;
  _in?: InputMaybe<Array<Scalars['geometry']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['geometry']>;
  _lte?: InputMaybe<Scalars['geometry']>;
  _neq?: InputMaybe<Scalars['geometry']>;
  _nin?: InputMaybe<Array<Scalars['geometry']>>;
  /** is the column within a given 3D distance from the given geometry value */
  _st3dDWithin?: InputMaybe<St_D_Within_Input>;
  /** does the column spatially intersect the given geometry value in 3D */
  _st3dIntersects?: InputMaybe<Scalars['geometry']>;
  /** does the column contain the given geometry value */
  _stContains?: InputMaybe<Scalars['geometry']>;
  /** does the column cross the given geometry value */
  _stCrosses?: InputMaybe<Scalars['geometry']>;
  /** is the column within a given distance from the given geometry value */
  _stDWithin?: InputMaybe<St_D_Within_Input>;
  /** is the column equal to given geometry value (directionality is ignored) */
  _stEquals?: InputMaybe<Scalars['geometry']>;
  /** does the column spatially intersect the given geometry value */
  _stIntersects?: InputMaybe<Scalars['geometry']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  _stOverlaps?: InputMaybe<Scalars['geometry']>;
  /** does the column have atleast one point in common with the given geometry value */
  _stTouches?: InputMaybe<Scalars['geometry']>;
  /** is the column contained in the given geometry value */
  _stWithin?: InputMaybe<Scalars['geometry']>;
};

/** columns and relationships of "group_comment_votes" */
export type GroupCommentVotes = {
  __typename?: 'GroupCommentVotes';
  /** An object relationship */
  comment: GroupThreadComments;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupThreadCommentId: Scalars['uuid'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  vote: CommentVoteEnum;
};

/** aggregated selection of "group_comment_votes" */
export type GroupCommentVotesAggregate = {
  __typename?: 'GroupCommentVotesAggregate';
  aggregate?: Maybe<GroupCommentVotesAggregateFields>;
  nodes: Array<GroupCommentVotes>;
};

export type GroupCommentVotesAggregateBoolExp = {
  count?: InputMaybe<GroupCommentVotesAggregateBoolExpCount>;
};

/** aggregate fields of "group_comment_votes" */
export type GroupCommentVotesAggregateFields = {
  __typename?: 'GroupCommentVotesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupCommentVotesMaxFields>;
  min?: Maybe<GroupCommentVotesMinFields>;
};


/** aggregate fields of "group_comment_votes" */
export type GroupCommentVotesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_comment_votes" */
export type GroupCommentVotesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupCommentVotesMaxOrderBy>;
  min?: InputMaybe<GroupCommentVotesMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_comment_votes" */
export type GroupCommentVotesArrRelInsertInput = {
  data: Array<GroupCommentVotesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupCommentVotesOnConflict>;
};

/** Boolean expression to filter rows from the table "group_comment_votes". All fields are combined with a logical 'AND'. */
export type GroupCommentVotesBoolExp = {
  _and?: InputMaybe<Array<GroupCommentVotesBoolExp>>;
  _not?: InputMaybe<GroupCommentVotesBoolExp>;
  _or?: InputMaybe<Array<GroupCommentVotesBoolExp>>;
  comment?: InputMaybe<GroupThreadCommentsBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  groupThreadCommentId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  vote?: InputMaybe<CommentVoteEnumComparisonExp>;
};

/** unique or primary key constraints on table "group_comment_votes" */
export enum GroupCommentVotesConstraint {
  /** unique or primary key constraint on columns "user_id", "group_thread_comment_id" */
  GroupCommentVotesGroupThreadCommentIdUserIdKey = 'group_comment_votes_group_thread_comment_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupCommentVotesPkey = 'group_comment_votes_pkey'
}

/** input type for inserting data into table "group_comment_votes" */
export type GroupCommentVotesInsertInput = {
  comment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
  vote?: InputMaybe<CommentVoteEnum>;
};

/** aggregate max on columns */
export type GroupCommentVotesMaxFields = {
  __typename?: 'GroupCommentVotesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_comment_votes" */
export type GroupCommentVotesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupCommentVotesMinFields = {
  __typename?: 'GroupCommentVotesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_comment_votes" */
export type GroupCommentVotesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_comment_votes" */
export type GroupCommentVotesMutationResponse = {
  __typename?: 'GroupCommentVotesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupCommentVotes>;
};

/** on_conflict condition type for table "group_comment_votes" */
export type GroupCommentVotesOnConflict = {
  constraint: GroupCommentVotesConstraint;
  updateColumns?: Array<GroupCommentVotesUpdateColumn>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};

/** Ordering options when selecting data from "group_comment_votes". */
export type GroupCommentVotesOrderBy = {
  comment?: InputMaybe<GroupThreadCommentsOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  vote?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_comment_votes */
export type GroupCommentVotesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_comment_votes" */
export enum GroupCommentVotesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Vote = 'vote'
}

/** input type for updating data in table "group_comment_votes" */
export type GroupCommentVotesSetInput = {
  vote?: InputMaybe<CommentVoteEnum>;
};

/** Streaming cursor of the table "group_comment_votes" */
export type GroupCommentVotesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupCommentVotesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupCommentVotesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  vote?: InputMaybe<CommentVoteEnum>;
};

/** update columns of table "group_comment_votes" */
export enum GroupCommentVotesUpdateColumn {
  /** column name */
  Vote = 'vote'
}

export type GroupCommentVotesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupCommentVotesSetInput>;
  /** filter the rows which have to be updated */
  where: GroupCommentVotesBoolExp;
};

/** columns and relationships of "group_members" */
export type GroupMembers = {
  __typename?: 'GroupMembers';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  isActive: Scalars['Boolean'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "group_members" */
export type GroupMembersAggregate = {
  __typename?: 'GroupMembersAggregate';
  aggregate?: Maybe<GroupMembersAggregateFields>;
  nodes: Array<GroupMembers>;
};

export type GroupMembersAggregateBoolExp = {
  bool_and?: InputMaybe<GroupMembersAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<GroupMembersAggregateBoolExpBool_Or>;
  count?: InputMaybe<GroupMembersAggregateBoolExpCount>;
};

/** aggregate fields of "group_members" */
export type GroupMembersAggregateFields = {
  __typename?: 'GroupMembersAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupMembersMaxFields>;
  min?: Maybe<GroupMembersMinFields>;
};


/** aggregate fields of "group_members" */
export type GroupMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_members" */
export type GroupMembersAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupMembersMaxOrderBy>;
  min?: InputMaybe<GroupMembersMinOrderBy>;
};

/** Boolean expression to filter rows from the table "group_members". All fields are combined with a logical 'AND'. */
export type GroupMembersBoolExp = {
  _and?: InputMaybe<Array<GroupMembersBoolExp>>;
  _not?: InputMaybe<GroupMembersBoolExp>;
  _or?: InputMaybe<Array<GroupMembersBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "group_members" */
export enum GroupMembersConstraint {
  /** unique or primary key constraint on columns "user_id", "group_id" */
  GroupMembersGroupIdUserIdKey = 'group_members_group_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupMembersPkey = 'group_members_pkey'
}

/** input type for inserting data into table "group_members" */
export type GroupMembersInsertInput = {
  groupId?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type GroupMembersMaxFields = {
  __typename?: 'GroupMembersMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_members" */
export type GroupMembersMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupMembersMinFields = {
  __typename?: 'GroupMembersMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_members" */
export type GroupMembersMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_members" */
export type GroupMembersMutationResponse = {
  __typename?: 'GroupMembersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupMembers>;
};

/** on_conflict condition type for table "group_members" */
export type GroupMembersOnConflict = {
  constraint: GroupMembersConstraint;
  updateColumns?: Array<GroupMembersUpdateColumn>;
  where?: InputMaybe<GroupMembersBoolExp>;
};

/** Ordering options when selecting data from "group_members". */
export type GroupMembersOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: group_members */
export type GroupMembersPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_members" */
export enum GroupMembersSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "groupMembersAggregateBoolExpBool_andArgumentsColumns" columns of table "group_members" */
export enum GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsActive = 'isActive'
}

/** select "groupMembersAggregateBoolExpBool_orArgumentsColumns" columns of table "group_members" */
export enum GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsActive = 'isActive'
}

/** input type for updating data in table "group_members" */
export type GroupMembersSetInput = {
  isActive?: InputMaybe<Scalars['Boolean']>;
};

/** Streaming cursor of the table "group_members" */
export type GroupMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupMembersStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_members" */
export enum GroupMembersUpdateColumn {
  /** column name */
  IsActive = 'isActive'
}

export type GroupMembersUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupMembersSetInput>;
  /** filter the rows which have to be updated */
  where: GroupMembersBoolExp;
};

/** columns and relationships of "group_thread_comment_files" */
export type GroupThreadCommentFiles = {
  __typename?: 'GroupThreadCommentFiles';
  /** An object relationship */
  comment: GroupThreadComments;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName: Scalars['String'];
  fileType: Scalars['String'];
  groupThreadCommentId: Scalars['uuid'];
  host: Scalars['String'];
  id: Scalars['uuid'];
  isVisible: Scalars['Boolean'];
  originalFileName?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  provider: Scalars['String'];
  providerUrl: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  url: Scalars['String'];
  userId: Scalars['uuid'];
};

/** order by aggregate values of table "group_thread_comment_files" */
export type GroupThreadCommentFilesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupThreadCommentFilesMaxOrderBy>;
  min?: InputMaybe<GroupThreadCommentFilesMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_thread_comment_files" */
export type GroupThreadCommentFilesArrRelInsertInput = {
  data: Array<GroupThreadCommentFilesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadCommentFilesOnConflict>;
};

/** Boolean expression to filter rows from the table "group_thread_comment_files". All fields are combined with a logical 'AND'. */
export type GroupThreadCommentFilesBoolExp = {
  _and?: InputMaybe<Array<GroupThreadCommentFilesBoolExp>>;
  _not?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  _or?: InputMaybe<Array<GroupThreadCommentFilesBoolExp>>;
  comment?: InputMaybe<GroupThreadCommentsBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fileName?: InputMaybe<StringComparisonExp>;
  fileType?: InputMaybe<StringComparisonExp>;
  groupThreadCommentId?: InputMaybe<UuidComparisonExp>;
  host?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isVisible?: InputMaybe<BooleanComparisonExp>;
  originalFileName?: InputMaybe<StringComparisonExp>;
  path?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerUrl?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "group_thread_comment_files" */
export enum GroupThreadCommentFilesConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupThreadCommentFilesPkey = 'group_thread_comment_files_pkey'
}

/** input type for inserting data into table "group_thread_comment_files" */
export type GroupThreadCommentFilesInsertInput = {
  comment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  host?: InputMaybe<Scalars['String']>;
  originalFileName?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_thread_comment_files" */
export type GroupThreadCommentFilesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalFileName?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "group_thread_comment_files" */
export type GroupThreadCommentFilesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalFileName?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_thread_comment_files" */
export type GroupThreadCommentFilesMutationResponse = {
  __typename?: 'GroupThreadCommentFilesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupThreadCommentFiles>;
};

/** on_conflict condition type for table "group_thread_comment_files" */
export type GroupThreadCommentFilesOnConflict = {
  constraint: GroupThreadCommentFilesConstraint;
  updateColumns?: Array<GroupThreadCommentFilesUpdateColumn>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};

/** Ordering options when selecting data from "group_thread_comment_files". */
export type GroupThreadCommentFilesOrderBy = {
  comment?: InputMaybe<GroupThreadCommentsOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isVisible?: InputMaybe<OrderBy>;
  originalFileName?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_thread_comment_files */
export type GroupThreadCommentFilesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_thread_comment_files" */
export enum GroupThreadCommentFilesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  FileType = 'fileType',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  Host = 'host',
  /** column name */
  Id = 'id',
  /** column name */
  IsVisible = 'isVisible',
  /** column name */
  OriginalFileName = 'originalFileName',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "group_thread_comment_files" */
export type GroupThreadCommentFilesSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "group_thread_comment_files" */
export type GroupThreadCommentFilesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupThreadCommentFilesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupThreadCommentFilesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  originalFileName?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_thread_comment_files" */
export enum GroupThreadCommentFilesUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt'
}

export type GroupThreadCommentFilesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupThreadCommentFilesSetInput>;
  /** filter the rows which have to be updated */
  where: GroupThreadCommentFilesBoolExp;
};

/** columns and relationships of "group_thread_comments" */
export type GroupThreadComments = {
  __typename?: 'GroupThreadComments';
  /** An array relationship */
  allChildComments: Array<GroupThreadComments>;
  /** An aggregate relationship */
  allChildCommentsAggregate: GroupThreadCommentsAggregate;
  content: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  files: Array<GroupThreadCommentFiles>;
  groupCommentId?: Maybe<Scalars['uuid']>;
  groupRootCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId: Scalars['uuid'];
  id: Scalars['uuid'];
  isOriginalThreadComment: Scalars['Boolean'];
  /** An object relationship */
  parentComment?: Maybe<GroupThreadComments>;
  /** An array relationship */
  replies: Array<GroupThreadComments>;
  /** An aggregate relationship */
  repliesAggregate: GroupThreadCommentsAggregate;
  /** An object relationship */
  rootComment?: Maybe<GroupThreadComments>;
  /** An object relationship */
  thread: GroupThreads;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
  /** An array relationship */
  votes: Array<GroupCommentVotes>;
  /** An aggregate relationship */
  votesAggregate: GroupCommentVotesAggregate;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsAllChildCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsAllChildCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsFilesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsRepliesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsRepliesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsVotesArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsVotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};

/** aggregated selection of "group_thread_comments" */
export type GroupThreadCommentsAggregate = {
  __typename?: 'GroupThreadCommentsAggregate';
  aggregate?: Maybe<GroupThreadCommentsAggregateFields>;
  nodes: Array<GroupThreadComments>;
};

export type GroupThreadCommentsAggregateBoolExp = {
  bool_and?: InputMaybe<GroupThreadCommentsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<GroupThreadCommentsAggregateBoolExpBool_Or>;
  count?: InputMaybe<GroupThreadCommentsAggregateBoolExpCount>;
};

/** aggregate fields of "group_thread_comments" */
export type GroupThreadCommentsAggregateFields = {
  __typename?: 'GroupThreadCommentsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupThreadCommentsMaxFields>;
  min?: Maybe<GroupThreadCommentsMinFields>;
};


/** aggregate fields of "group_thread_comments" */
export type GroupThreadCommentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_thread_comments" */
export type GroupThreadCommentsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupThreadCommentsMaxOrderBy>;
  min?: InputMaybe<GroupThreadCommentsMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_thread_comments" */
export type GroupThreadCommentsArrRelInsertInput = {
  data: Array<GroupThreadCommentsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};

/** Boolean expression to filter rows from the table "group_thread_comments". All fields are combined with a logical 'AND'. */
export type GroupThreadCommentsBoolExp = {
  _and?: InputMaybe<Array<GroupThreadCommentsBoolExp>>;
  _not?: InputMaybe<GroupThreadCommentsBoolExp>;
  _or?: InputMaybe<Array<GroupThreadCommentsBoolExp>>;
  allChildComments?: InputMaybe<GroupThreadCommentsBoolExp>;
  allChildCommentsAggregate?: InputMaybe<GroupThreadCommentsAggregateBoolExp>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  files?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  groupCommentId?: InputMaybe<UuidComparisonExp>;
  groupRootCommentId?: InputMaybe<UuidComparisonExp>;
  groupThreadId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isOriginalThreadComment?: InputMaybe<BooleanComparisonExp>;
  parentComment?: InputMaybe<GroupThreadCommentsBoolExp>;
  replies?: InputMaybe<GroupThreadCommentsBoolExp>;
  repliesAggregate?: InputMaybe<GroupThreadCommentsAggregateBoolExp>;
  rootComment?: InputMaybe<GroupThreadCommentsBoolExp>;
  thread?: InputMaybe<GroupThreadsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
  votes?: InputMaybe<GroupCommentVotesBoolExp>;
  votesAggregate?: InputMaybe<GroupCommentVotesAggregateBoolExp>;
};

/** unique or primary key constraints on table "group_thread_comments" */
export enum GroupThreadCommentsConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupThreadCommentsPkey = 'group_thread_comments_pkey'
}

/** input type for inserting data into table "group_thread_comments" */
export type GroupThreadCommentsInsertInput = {
  allChildComments?: InputMaybe<GroupThreadCommentsArrRelInsertInput>;
  content?: InputMaybe<Scalars['String']>;
  files?: InputMaybe<GroupThreadCommentFilesArrRelInsertInput>;
  groupCommentId?: InputMaybe<Scalars['uuid']>;
  groupRootCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  isOriginalThreadComment?: InputMaybe<Scalars['Boolean']>;
  parentComment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  replies?: InputMaybe<GroupThreadCommentsArrRelInsertInput>;
  rootComment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  thread?: InputMaybe<GroupThreadsObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  votes?: InputMaybe<GroupCommentVotesArrRelInsertInput>;
};

/** aggregate max on columns */
export type GroupThreadCommentsMaxFields = {
  __typename?: 'GroupThreadCommentsMaxFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupCommentId?: Maybe<Scalars['uuid']>;
  groupRootCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_thread_comments" */
export type GroupThreadCommentsMaxOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupCommentId?: InputMaybe<OrderBy>;
  groupRootCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupThreadCommentsMinFields = {
  __typename?: 'GroupThreadCommentsMinFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupCommentId?: Maybe<Scalars['uuid']>;
  groupRootCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_thread_comments" */
export type GroupThreadCommentsMinOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupCommentId?: InputMaybe<OrderBy>;
  groupRootCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_thread_comments" */
export type GroupThreadCommentsMutationResponse = {
  __typename?: 'GroupThreadCommentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupThreadComments>;
};

/** input type for inserting object relation for remote table "group_thread_comments" */
export type GroupThreadCommentsObjRelInsertInput = {
  data: GroupThreadCommentsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};

/** on_conflict condition type for table "group_thread_comments" */
export type GroupThreadCommentsOnConflict = {
  constraint: GroupThreadCommentsConstraint;
  updateColumns?: Array<GroupThreadCommentsUpdateColumn>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};

/** Ordering options when selecting data from "group_thread_comments". */
export type GroupThreadCommentsOrderBy = {
  allChildCommentsAggregate?: InputMaybe<GroupThreadCommentsAggregateOrderBy>;
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  filesAggregate?: InputMaybe<GroupThreadCommentFilesAggregateOrderBy>;
  groupCommentId?: InputMaybe<OrderBy>;
  groupRootCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isOriginalThreadComment?: InputMaybe<OrderBy>;
  parentComment?: InputMaybe<GroupThreadCommentsOrderBy>;
  repliesAggregate?: InputMaybe<GroupThreadCommentsAggregateOrderBy>;
  rootComment?: InputMaybe<GroupThreadCommentsOrderBy>;
  thread?: InputMaybe<GroupThreadsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
  votesAggregate?: InputMaybe<GroupCommentVotesAggregateOrderBy>;
};

/** primary key columns input for table: group_thread_comments */
export type GroupThreadCommentsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_thread_comments" */
export enum GroupThreadCommentsSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupCommentId = 'groupCommentId',
  /** column name */
  GroupRootCommentId = 'groupRootCommentId',
  /** column name */
  GroupThreadId = 'groupThreadId',
  /** column name */
  Id = 'id',
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "groupThreadCommentsAggregateBoolExpBool_andArgumentsColumns" columns of table "group_thread_comments" */
export enum GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment'
}

/** select "groupThreadCommentsAggregateBoolExpBool_orArgumentsColumns" columns of table "group_thread_comments" */
export enum GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment'
}

/** input type for updating data in table "group_thread_comments" */
export type GroupThreadCommentsSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "group_thread_comments" */
export type GroupThreadCommentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupThreadCommentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupThreadCommentsStreamCursorValueInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupCommentId?: InputMaybe<Scalars['uuid']>;
  groupRootCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isOriginalThreadComment?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_thread_comments" */
export enum GroupThreadCommentsUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt'
}

export type GroupThreadCommentsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupThreadCommentsSetInput>;
  /** filter the rows which have to be updated */
  where: GroupThreadCommentsBoolExp;
};

/** columns and relationships of "group_threads" */
export type GroupThreads = {
  __typename?: 'GroupThreads';
  /** An array relationship */
  comments: Array<GroupThreadComments>;
  /** An aggregate relationship */
  commentsAggregate: GroupThreadCommentsAggregate;
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creator: Users;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  userId: Scalars['uuid'];
};


/** columns and relationships of "group_threads" */
export type GroupThreadsCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_threads" */
export type GroupThreadsCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};

/** order by aggregate values of table "group_threads" */
export type GroupThreadsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupThreadsMaxOrderBy>;
  min?: InputMaybe<GroupThreadsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "group_threads". All fields are combined with a logical 'AND'. */
export type GroupThreadsBoolExp = {
  _and?: InputMaybe<Array<GroupThreadsBoolExp>>;
  _not?: InputMaybe<GroupThreadsBoolExp>;
  _or?: InputMaybe<Array<GroupThreadsBoolExp>>;
  comments?: InputMaybe<GroupThreadCommentsBoolExp>;
  commentsAggregate?: InputMaybe<GroupThreadCommentsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creator?: InputMaybe<UsersBoolExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "group_threads" */
export enum GroupThreadsConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupThreadsPkey = 'group_threads_pkey'
}

/** input type for inserting data into table "group_threads" */
export type GroupThreadsInsertInput = {
  comments?: InputMaybe<GroupThreadCommentsArrRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_threads" */
export type GroupThreadsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "group_threads" */
export type GroupThreadsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_threads" */
export type GroupThreadsMutationResponse = {
  __typename?: 'GroupThreadsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupThreads>;
};

/** input type for inserting object relation for remote table "group_threads" */
export type GroupThreadsObjRelInsertInput = {
  data: GroupThreadsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};

/** on_conflict condition type for table "group_threads" */
export type GroupThreadsOnConflict = {
  constraint: GroupThreadsConstraint;
  updateColumns?: Array<GroupThreadsUpdateColumn>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};

/** Ordering options when selecting data from "group_threads". */
export type GroupThreadsOrderBy = {
  commentsAggregate?: InputMaybe<GroupThreadCommentsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creator?: InputMaybe<UsersOrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "group_threads" */
export enum GroupThreadsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "group_threads" */
export type GroupThreadsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupThreadsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupThreadsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** placeholder for update columns of table "group_threads" (current role has no relevant permissions) */
export enum GroupThreadsUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "group_venues" */
export type GroupVenues = {
  __typename?: 'GroupVenues';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "group_venues" */
export type GroupVenuesAggregate = {
  __typename?: 'GroupVenuesAggregate';
  aggregate?: Maybe<GroupVenuesAggregateFields>;
  nodes: Array<GroupVenues>;
};

export type GroupVenuesAggregateBoolExp = {
  count?: InputMaybe<GroupVenuesAggregateBoolExpCount>;
};

/** aggregate fields of "group_venues" */
export type GroupVenuesAggregateFields = {
  __typename?: 'GroupVenuesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupVenuesMaxFields>;
  min?: Maybe<GroupVenuesMinFields>;
};


/** aggregate fields of "group_venues" */
export type GroupVenuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_venues" */
export type GroupVenuesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupVenuesMaxOrderBy>;
  min?: InputMaybe<GroupVenuesMinOrderBy>;
};

/** Boolean expression to filter rows from the table "group_venues". All fields are combined with a logical 'AND'. */
export type GroupVenuesBoolExp = {
  _and?: InputMaybe<Array<GroupVenuesBoolExp>>;
  _not?: InputMaybe<GroupVenuesBoolExp>;
  _or?: InputMaybe<Array<GroupVenuesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** aggregate max on columns */
export type GroupVenuesMaxFields = {
  __typename?: 'GroupVenuesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_venues" */
export type GroupVenuesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupVenuesMinFields = {
  __typename?: 'GroupVenuesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_venues" */
export type GroupVenuesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "group_venues". */
export type GroupVenuesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** select columns of table "group_venues" */
export enum GroupVenuesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

/** Streaming cursor of the table "group_venues" */
export type GroupVenuesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupVenuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupVenuesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "groups" */
export type Groups = {
  __typename?: 'Groups';
  accessCode?: Maybe<Scalars['String']>;
  allowMemberInvites: Scalars['Boolean'];
  allowMemberSessionInvites: Scalars['Boolean'];
  /** An object relationship */
  city: Cities;
  cityId: Scalars['uuid'];
  contactEmail?: Maybe<Scalars['String']>;
  contactMessage?: Maybe<Scalars['String']>;
  contactPhoneNumber?: Maybe<Scalars['String']>;
  contactUrl?: Maybe<Scalars['String']>;
  coverPhotoUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  displayOwnerContactInfo: Scalars['Boolean'];
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  headline: Scalars['String'];
  id: Scalars['uuid'];
  isPrivate: Scalars['Boolean'];
  /** An array relationship */
  members: Array<GroupMembers>;
  /** An aggregate relationship */
  membersAggregate: GroupMembersAggregate;
  /** An object relationship */
  owner?: Maybe<Users>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  ownerUserProfile?: Maybe<UserProfiles>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  primarySport?: Maybe<SportsEnum>;
  profilePhotoUrl: Scalars['String'];
  skillLevelMaximum?: Maybe<Scalars['numeric']>;
  skillLevelMinimum?: Maybe<Scalars['numeric']>;
  slug: Scalars['String'];
  /** An array relationship */
  threads: Array<GroupThreads>;
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  venues: Array<GroupVenues>;
  /** An aggregate relationship */
  venuesAggregate: GroupVenuesAggregate;
};


/** columns and relationships of "groups" */
export type GroupsGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsMembersArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsThreadsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsVenuesArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};

/** order by aggregate values of table "groups" */
export type GroupsAggregateOrderBy = {
  avg?: InputMaybe<GroupsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupsMaxOrderBy>;
  min?: InputMaybe<GroupsMinOrderBy>;
  stddev?: InputMaybe<GroupsStddevOrderBy>;
  stddevPop?: InputMaybe<GroupsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<GroupsStddevSampOrderBy>;
  sum?: InputMaybe<GroupsSumOrderBy>;
  varPop?: InputMaybe<GroupsVarPopOrderBy>;
  varSamp?: InputMaybe<GroupsVarSampOrderBy>;
  variance?: InputMaybe<GroupsVarianceOrderBy>;
};

/** order by avg() on columns of table "groups" */
export type GroupsAvgOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'. */
export type GroupsBoolExp = {
  _and?: InputMaybe<Array<GroupsBoolExp>>;
  _not?: InputMaybe<GroupsBoolExp>;
  _or?: InputMaybe<Array<GroupsBoolExp>>;
  accessCode?: InputMaybe<StringComparisonExp>;
  allowMemberInvites?: InputMaybe<BooleanComparisonExp>;
  allowMemberSessionInvites?: InputMaybe<BooleanComparisonExp>;
  city?: InputMaybe<CitiesBoolExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  contactEmail?: InputMaybe<StringComparisonExp>;
  contactMessage?: InputMaybe<StringComparisonExp>;
  contactPhoneNumber?: InputMaybe<StringComparisonExp>;
  contactUrl?: InputMaybe<StringComparisonExp>;
  coverPhotoUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  displayOwnerContactInfo?: InputMaybe<BooleanComparisonExp>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsBoolExp>;
  headline?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isPrivate?: InputMaybe<BooleanComparisonExp>;
  members?: InputMaybe<GroupMembersBoolExp>;
  membersAggregate?: InputMaybe<GroupMembersAggregateBoolExp>;
  owner?: InputMaybe<UsersBoolExp>;
  ownerUserId?: InputMaybe<UuidComparisonExp>;
  ownerUserProfile?: InputMaybe<UserProfilesBoolExp>;
  playSessions?: InputMaybe<PlaySessionsBoolExp>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateBoolExp>;
  primarySport?: InputMaybe<SportsEnumComparisonExp>;
  profilePhotoUrl?: InputMaybe<StringComparisonExp>;
  skillLevelMaximum?: InputMaybe<NumericComparisonExp>;
  skillLevelMinimum?: InputMaybe<NumericComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  threads?: InputMaybe<GroupThreadsBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venues?: InputMaybe<GroupVenuesBoolExp>;
  venuesAggregate?: InputMaybe<GroupVenuesAggregateBoolExp>;
};

/** order by max() on columns of table "groups" */
export type GroupsMaxOrderBy = {
  accessCode?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactMessage?: InputMaybe<OrderBy>;
  contactPhoneNumber?: InputMaybe<OrderBy>;
  contactUrl?: InputMaybe<OrderBy>;
  coverPhotoUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  headline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  profilePhotoUrl?: InputMaybe<OrderBy>;
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "groups" */
export type GroupsMinOrderBy = {
  accessCode?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactMessage?: InputMaybe<OrderBy>;
  contactPhoneNumber?: InputMaybe<OrderBy>;
  contactUrl?: InputMaybe<OrderBy>;
  coverPhotoUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  headline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  profilePhotoUrl?: InputMaybe<OrderBy>;
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "groups". */
export type GroupsOrderBy = {
  accessCode?: InputMaybe<OrderBy>;
  allowMemberInvites?: InputMaybe<OrderBy>;
  allowMemberSessionInvites?: InputMaybe<OrderBy>;
  city?: InputMaybe<CitiesOrderBy>;
  cityId?: InputMaybe<OrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactMessage?: InputMaybe<OrderBy>;
  contactPhoneNumber?: InputMaybe<OrderBy>;
  contactUrl?: InputMaybe<OrderBy>;
  coverPhotoUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  displayOwnerContactInfo?: InputMaybe<OrderBy>;
  groupsPlaySessionsAggregate?: InputMaybe<GroupsPlaySessionsAggregateOrderBy>;
  headline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPrivate?: InputMaybe<OrderBy>;
  membersAggregate?: InputMaybe<GroupMembersAggregateOrderBy>;
  owner?: InputMaybe<UsersOrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  ownerUserProfile?: InputMaybe<UserProfilesOrderBy>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateOrderBy>;
  primarySport?: InputMaybe<OrderBy>;
  profilePhotoUrl?: InputMaybe<OrderBy>;
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  threadsAggregate?: InputMaybe<GroupThreadsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venuesAggregate?: InputMaybe<GroupVenuesAggregateOrderBy>;
};

/** columns and relationships of "groups_play_sessions" */
export type GroupsPlaySessions = {
  __typename?: 'GroupsPlaySessions';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  playSession: PlaySessions;
  playSessionId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "groups_play_sessions" */
export type GroupsPlaySessionsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupsPlaySessionsMaxOrderBy>;
  min?: InputMaybe<GroupsPlaySessionsMinOrderBy>;
};

/** input type for inserting array relation for remote table "groups_play_sessions" */
export type GroupsPlaySessionsArrRelInsertInput = {
  data: Array<GroupsPlaySessionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupsPlaySessionsOnConflict>;
};

/** Boolean expression to filter rows from the table "groups_play_sessions". All fields are combined with a logical 'AND'. */
export type GroupsPlaySessionsBoolExp = {
  _and?: InputMaybe<Array<GroupsPlaySessionsBoolExp>>;
  _not?: InputMaybe<GroupsPlaySessionsBoolExp>;
  _or?: InputMaybe<Array<GroupsPlaySessionsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "groups_play_sessions" */
export enum GroupsPlaySessionsConstraint {
  /** unique or primary key constraint on columns "play_session_id", "group_id" */
  GroupsPlaySessionsGroupIdPlaySessionIdKey = 'groups_play_sessions_group_id_play_session_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupsPlaySessionsPkey = 'groups_play_sessions_pkey'
}

/** input type for inserting data into table "groups_play_sessions" */
export type GroupsPlaySessionsInsertInput = {
  groupId?: InputMaybe<Scalars['uuid']>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "groups_play_sessions" */
export type GroupsPlaySessionsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "groups_play_sessions" */
export type GroupsPlaySessionsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "groups_play_sessions" */
export type GroupsPlaySessionsMutationResponse = {
  __typename?: 'GroupsPlaySessionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupsPlaySessions>;
};

/** on_conflict condition type for table "groups_play_sessions" */
export type GroupsPlaySessionsOnConflict = {
  constraint: GroupsPlaySessionsConstraint;
  updateColumns?: Array<GroupsPlaySessionsUpdateColumn>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};

/** Ordering options when selecting data from "groups_play_sessions". */
export type GroupsPlaySessionsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: groups_play_sessions */
export type GroupsPlaySessionsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "groups_play_sessions" */
export enum GroupsPlaySessionsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "groups_play_sessions" */
export type GroupsPlaySessionsSetInput = {
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "groups_play_sessions" */
export type GroupsPlaySessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupsPlaySessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupsPlaySessionsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "groups_play_sessions" */
export enum GroupsPlaySessionsUpdateColumn {
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type GroupsPlaySessionsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupsPlaySessionsSetInput>;
  /** filter the rows which have to be updated */
  where: GroupsPlaySessionsBoolExp;
};

/** select columns of table "groups" */
export enum GroupsSelectColumn {
  /** column name */
  AccessCode = 'accessCode',
  /** column name */
  AllowMemberInvites = 'allowMemberInvites',
  /** column name */
  AllowMemberSessionInvites = 'allowMemberSessionInvites',
  /** column name */
  CityId = 'cityId',
  /** column name */
  ContactEmail = 'contactEmail',
  /** column name */
  ContactMessage = 'contactMessage',
  /** column name */
  ContactPhoneNumber = 'contactPhoneNumber',
  /** column name */
  ContactUrl = 'contactUrl',
  /** column name */
  CoverPhotoUrl = 'coverPhotoUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DisplayOwnerContactInfo = 'displayOwnerContactInfo',
  /** column name */
  Headline = 'headline',
  /** column name */
  Id = 'id',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  OwnerUserId = 'ownerUserId',
  /** column name */
  PrimarySport = 'primarySport',
  /** column name */
  ProfilePhotoUrl = 'profilePhotoUrl',
  /** column name */
  SkillLevelMaximum = 'skillLevelMaximum',
  /** column name */
  SkillLevelMinimum = 'skillLevelMinimum',
  /** column name */
  Slug = 'slug',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "groups" */
export type GroupsStddevOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "groups" */
export type GroupsStddevPopOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "groups" */
export type GroupsStddevSampOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "groups" */
export type GroupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupsStreamCursorValueInput = {
  accessCode?: InputMaybe<Scalars['String']>;
  allowMemberInvites?: InputMaybe<Scalars['Boolean']>;
  allowMemberSessionInvites?: InputMaybe<Scalars['Boolean']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  contactEmail?: InputMaybe<Scalars['String']>;
  contactMessage?: InputMaybe<Scalars['String']>;
  contactPhoneNumber?: InputMaybe<Scalars['String']>;
  contactUrl?: InputMaybe<Scalars['String']>;
  coverPhotoUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  displayOwnerContactInfo?: InputMaybe<Scalars['Boolean']>;
  headline?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  primarySport?: InputMaybe<SportsEnum>;
  profilePhotoUrl?: InputMaybe<Scalars['String']>;
  skillLevelMaximum?: InputMaybe<Scalars['numeric']>;
  skillLevelMinimum?: InputMaybe<Scalars['numeric']>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "groups" */
export type GroupsSumOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "groups" */
export type GroupsVarPopOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "groups" */
export type GroupsVarSampOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "groups" */
export type GroupsVarianceOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _containedIn?: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']>;
  _eq?: InputMaybe<Scalars['jsonb']>;
  _gt?: InputMaybe<Scalars['jsonb']>;
  _gte?: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _hasKey?: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _hasKeysAll?: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _hasKeysAny?: InputMaybe<Array<Scalars['String']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['jsonb']>;
  _lte?: InputMaybe<Scalars['jsonb']>;
  _neq?: InputMaybe<Scalars['jsonb']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']>>;
};

/** columns and relationships of "lesson_equipment" */
export type LessonEquipment = {
  __typename?: 'LessonEquipment';
  createdAt: Scalars['timestamptz'];
  customName?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  equipmentOptionId: LessonEquipmentOptionsEnum;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "lesson_equipment" */
export type LessonEquipmentAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonEquipmentMaxOrderBy>;
  min?: InputMaybe<LessonEquipmentMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_equipment" */
export type LessonEquipmentArrRelInsertInput = {
  data: Array<LessonEquipmentInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonEquipmentOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_equipment". All fields are combined with a logical 'AND'. */
export type LessonEquipmentBoolExp = {
  _and?: InputMaybe<Array<LessonEquipmentBoolExp>>;
  _not?: InputMaybe<LessonEquipmentBoolExp>;
  _or?: InputMaybe<Array<LessonEquipmentBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  customName?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "lesson_equipment" */
export enum LessonEquipmentConstraint {
  /** unique or primary key constraint on columns "lesson_id", "equipment_option_id" */
  LessonEquipmentLessonIdEquipmentOptionIdKey = 'lesson_equipment_lesson_id_equipment_option_id_key',
  /** unique or primary key constraint on columns "id" */
  LessonEquipmentPkey = 'lesson_equipment_pkey'
}

/** input type for inserting data into table "lesson_equipment" */
export type LessonEquipmentInsertInput = {
  customName?: InputMaybe<Scalars['String']>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnum>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_equipment" */
export type LessonEquipmentMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "lesson_equipment" */
export type LessonEquipmentMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_equipment" */
export type LessonEquipmentMutationResponse = {
  __typename?: 'LessonEquipmentMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonEquipment>;
};

/** on_conflict condition type for table "lesson_equipment" */
export type LessonEquipmentOnConflict = {
  constraint: LessonEquipmentConstraint;
  updateColumns?: Array<LessonEquipmentUpdateColumn>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};

/** columns and relationships of "lesson_equipment_options" */
export type LessonEquipmentOptions = {
  __typename?: 'LessonEquipmentOptions';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "lesson_equipment_options". All fields are combined with a logical 'AND'. */
export type LessonEquipmentOptionsBoolExp = {
  _and?: InputMaybe<Array<LessonEquipmentOptionsBoolExp>>;
  _not?: InputMaybe<LessonEquipmentOptionsBoolExp>;
  _or?: InputMaybe<Array<LessonEquipmentOptionsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum LessonEquipmentOptionsEnum {
  CourtShoes = 'COURT_SHOES',
  HeartRateMonitor = 'HEART_RATE_MONITOR',
  Racket = 'RACKET',
  Towel = 'TOWEL',
  WaterBottle = 'WATER_BOTTLE'
}

/** Boolean expression to compare columns of type "LessonEquipmentOptionsEnum". All fields are combined with logical 'AND'. */
export type LessonEquipmentOptionsEnumComparisonExp = {
  _eq?: InputMaybe<LessonEquipmentOptionsEnum>;
  _in?: InputMaybe<Array<LessonEquipmentOptionsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonEquipmentOptionsEnum>;
  _nin?: InputMaybe<Array<LessonEquipmentOptionsEnum>>;
};

/** Ordering options when selecting data from "lesson_equipment_options". */
export type LessonEquipmentOptionsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_equipment_options" */
export enum LessonEquipmentOptionsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "lesson_equipment_options" */
export type LessonEquipmentOptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonEquipmentOptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonEquipmentOptionsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Ordering options when selecting data from "lesson_equipment". */
export type LessonEquipmentOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  equipmentOptionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_equipment */
export type LessonEquipmentPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_equipment" */
export enum LessonEquipmentSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomName = 'customName',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EquipmentOptionId = 'equipmentOptionId',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "lesson_equipment" */
export type LessonEquipmentSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "lesson_equipment" */
export type LessonEquipmentStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonEquipmentStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonEquipmentStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customName?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "lesson_equipment" */
export enum LessonEquipmentUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt'
}

export type LessonEquipmentUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonEquipmentSetInput>;
  /** filter the rows which have to be updated */
  where: LessonEquipmentBoolExp;
};

/** columns and relationships of "lesson_order_items" */
export type LessonOrderItems = {
  __typename?: 'LessonOrderItems';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  lessonOrderId: Scalars['uuid'];
  /** An object relationship */
  lessonParticipant: LessonParticipants;
  lessonParticipantId: Scalars['uuid'];
  /** An object relationship */
  order: LessonOrders;
  priceUnitAmount: Scalars['Int'];
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  status: OrderStatusesEnum;
  totalUnitAmount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "lesson_order_items" */
export type LessonOrderItemsAggregateOrderBy = {
  avg?: InputMaybe<LessonOrderItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonOrderItemsMaxOrderBy>;
  min?: InputMaybe<LessonOrderItemsMinOrderBy>;
  stddev?: InputMaybe<LessonOrderItemsStddevOrderBy>;
  stddevPop?: InputMaybe<LessonOrderItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LessonOrderItemsStddevSampOrderBy>;
  sum?: InputMaybe<LessonOrderItemsSumOrderBy>;
  varPop?: InputMaybe<LessonOrderItemsVarPopOrderBy>;
  varSamp?: InputMaybe<LessonOrderItemsVarSampOrderBy>;
  variance?: InputMaybe<LessonOrderItemsVarianceOrderBy>;
};

/** order by avg() on columns of table "lesson_order_items" */
export type LessonOrderItemsAvgOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lesson_order_items". All fields are combined with a logical 'AND'. */
export type LessonOrderItemsBoolExp = {
  _and?: InputMaybe<Array<LessonOrderItemsBoolExp>>;
  _not?: InputMaybe<LessonOrderItemsBoolExp>;
  _or?: InputMaybe<Array<LessonOrderItemsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lessonOrderId?: InputMaybe<UuidComparisonExp>;
  lessonParticipant?: InputMaybe<LessonParticipantsBoolExp>;
  lessonParticipantId?: InputMaybe<UuidComparisonExp>;
  order?: InputMaybe<LessonOrdersBoolExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  totalUnitAmount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** order by max() on columns of table "lesson_order_items" */
export type LessonOrderItemsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonOrderId?: InputMaybe<OrderBy>;
  lessonParticipantId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "lesson_order_items" */
export type LessonOrderItemsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonOrderId?: InputMaybe<OrderBy>;
  lessonParticipantId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "lesson_order_items". */
export type LessonOrderItemsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonOrderId?: InputMaybe<OrderBy>;
  lessonParticipant?: InputMaybe<LessonParticipantsOrderBy>;
  lessonParticipantId?: InputMaybe<OrderBy>;
  order?: InputMaybe<LessonOrdersOrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_order_items" */
export enum LessonOrderItemsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonOrderId = 'lessonOrderId',
  /** column name */
  LessonParticipantId = 'lessonParticipantId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  TotalUnitAmount = 'totalUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** order by stddev() on columns of table "lesson_order_items" */
export type LessonOrderItemsStddevOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "lesson_order_items" */
export type LessonOrderItemsStddevPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "lesson_order_items" */
export type LessonOrderItemsStddevSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lesson_order_items" */
export type LessonOrderItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonOrderItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonOrderItemsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonOrderId?: InputMaybe<Scalars['uuid']>;
  lessonParticipantId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** order by sum() on columns of table "lesson_order_items" */
export type LessonOrderItemsSumOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "lesson_order_items" */
export type LessonOrderItemsVarPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "lesson_order_items" */
export type LessonOrderItemsVarSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "lesson_order_items" */
export type LessonOrderItemsVarianceOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "lesson_orders" */
export type LessonOrders = {
  __typename?: 'LessonOrders';
  applicationFeeTotalUnitAmount: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creditCard?: Maybe<UserCreditCards>;
  /** An object relationship */
  customer: Users;
  customerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  customerProfile?: Maybe<UserProfiles>;
  customerUserId: Scalars['uuid'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  /** An array relationship */
  items: Array<LessonOrderItems>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount: Scalars['Int'];
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount: Scalars['Int'];
  paidUnitAmount: Scalars['Int'];
  paymentProcessor: PaymentProcessorsEnum;
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  seller: Users;
  sellerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  sellerProfile?: Maybe<UserProfiles>;
  sellerUserId: Scalars['uuid'];
  status: OrderStatusesEnum;
  stripeCustomerId: Scalars['String'];
  stripeMerchantId: Scalars['String'];
  stripePaymentStatus: Scalars['String'];
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  userCreditCardId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "lesson_orders" */
export type LessonOrdersItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};

/** aggregated selection of "lesson_orders" */
export type LessonOrdersAggregate = {
  __typename?: 'LessonOrdersAggregate';
  aggregate?: Maybe<LessonOrdersAggregateFields>;
  nodes: Array<LessonOrders>;
};

/** aggregate fields of "lesson_orders" */
export type LessonOrdersAggregateFields = {
  __typename?: 'LessonOrdersAggregateFields';
  avg?: Maybe<LessonOrdersAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LessonOrdersMaxFields>;
  min?: Maybe<LessonOrdersMinFields>;
  stddev?: Maybe<LessonOrdersStddevFields>;
  stddevPop?: Maybe<LessonOrdersStddevPopFields>;
  stddevSamp?: Maybe<LessonOrdersStddevSampFields>;
  sum?: Maybe<LessonOrdersSumFields>;
  varPop?: Maybe<LessonOrdersVarPopFields>;
  varSamp?: Maybe<LessonOrdersVarSampFields>;
  variance?: Maybe<LessonOrdersVarianceFields>;
};


/** aggregate fields of "lesson_orders" */
export type LessonOrdersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LessonOrdersAvgFields = {
  __typename?: 'LessonOrdersAvgFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "lesson_orders". All fields are combined with a logical 'AND'. */
export type LessonOrdersBoolExp = {
  _and?: InputMaybe<Array<LessonOrdersBoolExp>>;
  _not?: InputMaybe<LessonOrdersBoolExp>;
  _or?: InputMaybe<Array<LessonOrdersBoolExp>>;
  applicationFeeTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creditCard?: InputMaybe<UserCreditCardsBoolExp>;
  customer?: InputMaybe<UsersBoolExp>;
  customerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  customerProfile?: InputMaybe<UserProfilesBoolExp>;
  customerUserId?: InputMaybe<UuidComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  items?: InputMaybe<LessonOrderItemsBoolExp>;
  orderSubtotalUnitAmount?: InputMaybe<IntComparisonExp>;
  orderTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  paidUnitAmount?: InputMaybe<IntComparisonExp>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnumComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  seller?: InputMaybe<UsersBoolExp>;
  sellerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  sellerProfile?: InputMaybe<UserProfilesBoolExp>;
  sellerUserId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripeMerchantId?: InputMaybe<StringComparisonExp>;
  stripePaymentStatus?: InputMaybe<StringComparisonExp>;
  transferUnitAmount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCreditCardId?: InputMaybe<UuidComparisonExp>;
};

/** aggregate max on columns */
export type LessonOrdersMaxFields = {
  __typename?: 'LessonOrdersMaxFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  customerUserId?: Maybe<Scalars['uuid']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  sellerUserId?: Maybe<Scalars['uuid']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type LessonOrdersMinFields = {
  __typename?: 'LessonOrdersMinFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  customerUserId?: Maybe<Scalars['uuid']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  sellerUserId?: Maybe<Scalars['uuid']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
};

/** Ordering options when selecting data from "lesson_orders". */
export type LessonOrdersOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creditCard?: InputMaybe<UserCreditCardsOrderBy>;
  customer?: InputMaybe<UsersOrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  customerProfile?: InputMaybe<UserProfilesOrderBy>;
  customerUserId?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  itemsAggregate?: InputMaybe<LessonOrderItemsAggregateOrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  paymentProcessor?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  seller?: InputMaybe<UsersOrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerProfile?: InputMaybe<UserProfilesOrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_orders" */
export enum LessonOrdersSelectColumn {
  /** column name */
  ApplicationFeeTotalUnitAmount = 'applicationFeeTotalUnitAmount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerApplicationFeeUnitAmount = 'customerApplicationFeeUnitAmount',
  /** column name */
  CustomerUserId = 'customerUserId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  SellerApplicationFeeUnitAmount = 'sellerApplicationFeeUnitAmount',
  /** column name */
  SellerUserId = 'sellerUserId',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  TransferUnitAmount = 'transferUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId'
}

/** aggregate stddev on columns */
export type LessonOrdersStddevFields = {
  __typename?: 'LessonOrdersStddevFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type LessonOrdersStddevPopFields = {
  __typename?: 'LessonOrdersStddevPopFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type LessonOrdersStddevSampFields = {
  __typename?: 'LessonOrdersStddevSampFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "lesson_orders" */
export type LessonOrdersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonOrdersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonOrdersStreamCursorValueInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  customerUserId?: InputMaybe<Scalars['uuid']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type LessonOrdersSumFields = {
  __typename?: 'LessonOrdersSumFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Int']>;
};

/** aggregate varPop on columns */
export type LessonOrdersVarPopFields = {
  __typename?: 'LessonOrdersVarPopFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type LessonOrdersVarSampFields = {
  __typename?: 'LessonOrdersVarSampFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LessonOrdersVarianceFields = {
  __typename?: 'LessonOrdersVarianceFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "lesson_participant_statuses" */
export type LessonParticipantStatuses = {
  __typename?: 'LessonParticipantStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "lesson_participant_statuses". All fields are combined with a logical 'AND'. */
export type LessonParticipantStatusesBoolExp = {
  _and?: InputMaybe<Array<LessonParticipantStatusesBoolExp>>;
  _not?: InputMaybe<LessonParticipantStatusesBoolExp>;
  _or?: InputMaybe<Array<LessonParticipantStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum LessonParticipantStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "LessonParticipantStatusesEnum". All fields are combined with logical 'AND'. */
export type LessonParticipantStatusesEnumComparisonExp = {
  _eq?: InputMaybe<LessonParticipantStatusesEnum>;
  _in?: InputMaybe<Array<LessonParticipantStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonParticipantStatusesEnum>;
  _nin?: InputMaybe<Array<LessonParticipantStatusesEnum>>;
};

/** Ordering options when selecting data from "lesson_participant_statuses". */
export type LessonParticipantStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_participant_statuses" */
export enum LessonParticipantStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "lesson_participant_statuses" */
export type LessonParticipantStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonParticipantStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonParticipantStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "lesson_participants" */
export type LessonParticipants = {
  __typename?: 'LessonParticipants';
  addedAt?: Maybe<Scalars['timestamptz']>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  /** An array relationship */
  orderItems: Array<LessonOrderItems>;
  paidAt?: Maybe<Scalars['timestamptz']>;
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  status: LessonParticipantStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "lesson_participants" */
export type LessonParticipantsOrderItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};

/** aggregated selection of "lesson_participants" */
export type LessonParticipantsAggregate = {
  __typename?: 'LessonParticipantsAggregate';
  aggregate?: Maybe<LessonParticipantsAggregateFields>;
  nodes: Array<LessonParticipants>;
};

export type LessonParticipantsAggregateBoolExp = {
  count?: InputMaybe<LessonParticipantsAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_participants" */
export type LessonParticipantsAggregateFields = {
  __typename?: 'LessonParticipantsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonParticipantsMaxFields>;
  min?: Maybe<LessonParticipantsMinFields>;
};


/** aggregate fields of "lesson_participants" */
export type LessonParticipantsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_participants" */
export type LessonParticipantsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonParticipantsMaxOrderBy>;
  min?: InputMaybe<LessonParticipantsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "lesson_participants". All fields are combined with a logical 'AND'. */
export type LessonParticipantsBoolExp = {
  _and?: InputMaybe<Array<LessonParticipantsBoolExp>>;
  _not?: InputMaybe<LessonParticipantsBoolExp>;
  _or?: InputMaybe<Array<LessonParticipantsBoolExp>>;
  addedAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  orderItems?: InputMaybe<LessonOrderItemsBoolExp>;
  paidAt?: InputMaybe<TimestamptzComparisonExp>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnumComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  removedAt?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<LessonParticipantStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** aggregate max on columns */
export type LessonParticipantsMaxFields = {
  __typename?: 'LessonParticipantsMaxFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  paidAt?: Maybe<Scalars['timestamptz']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_participants" */
export type LessonParticipantsMaxOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  paidAt?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonParticipantsMinFields = {
  __typename?: 'LessonParticipantsMinFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  paidAt?: Maybe<Scalars['timestamptz']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lesson_participants" */
export type LessonParticipantsMinOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  paidAt?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "lesson_participants". */
export type LessonParticipantsOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  orderItemsAggregate?: InputMaybe<LessonOrderItemsAggregateOrderBy>;
  paidAt?: InputMaybe<OrderBy>;
  paymentFulfillmentChannel?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** select columns of table "lesson_participants" */
export enum LessonParticipantsSelectColumn {
  /** column name */
  AddedAt = 'addedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  PaidAt = 'paidAt',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RemovedAt = 'removedAt',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "lesson_participants" */
export type LessonParticipantsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonParticipantsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonParticipantsStreamCursorValueInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  paidAt?: InputMaybe<Scalars['timestamptz']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "lesson_privacy" */
export type LessonPrivacy = {
  __typename?: 'LessonPrivacy';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "lesson_privacy". All fields are combined with a logical 'AND'. */
export type LessonPrivacyBoolExp = {
  _and?: InputMaybe<Array<LessonPrivacyBoolExp>>;
  _not?: InputMaybe<LessonPrivacyBoolExp>;
  _or?: InputMaybe<Array<LessonPrivacyBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum LessonPrivacyEnum {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** Boolean expression to compare columns of type "LessonPrivacyEnum". All fields are combined with logical 'AND'. */
export type LessonPrivacyEnumComparisonExp = {
  _eq?: InputMaybe<LessonPrivacyEnum>;
  _in?: InputMaybe<Array<LessonPrivacyEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonPrivacyEnum>;
  _nin?: InputMaybe<Array<LessonPrivacyEnum>>;
};

/** Ordering options when selecting data from "lesson_privacy". */
export type LessonPrivacyOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_privacy" */
export enum LessonPrivacySelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "lesson_privacy" */
export type LessonPrivacyStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonPrivacyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonPrivacyStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "lesson_statuses" */
export type LessonStatuses = {
  __typename?: 'LessonStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "lesson_statuses". All fields are combined with a logical 'AND'. */
export type LessonStatusesBoolExp = {
  _and?: InputMaybe<Array<LessonStatusesBoolExp>>;
  _not?: InputMaybe<LessonStatusesBoolExp>;
  _or?: InputMaybe<Array<LessonStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum LessonStatusesEnum {
  Active = 'ACTIVE',
  Canceled = 'CANCELED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "LessonStatusesEnum". All fields are combined with logical 'AND'. */
export type LessonStatusesEnumComparisonExp = {
  _eq?: InputMaybe<LessonStatusesEnum>;
  _in?: InputMaybe<Array<LessonStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonStatusesEnum>;
  _nin?: InputMaybe<Array<LessonStatusesEnum>>;
};

/** Ordering options when selecting data from "lesson_statuses". */
export type LessonStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_statuses" */
export enum LessonStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "lesson_statuses" */
export type LessonStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "lesson_templates" */
export type LessonTemplates = {
  __typename?: 'LessonTemplates';
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  id: Scalars['uuid'];
  /** An object relationship */
  originalLesson?: Maybe<Lessons>;
  originalLessonId?: Maybe<Scalars['uuid']>;
  participantLimit: Scalars['Int'];
  priceUnitAmount: Scalars['Int'];
  privacy?: Maybe<LessonPrivacyEnum>;
  sport?: Maybe<SportsEnum>;
  templateName: Scalars['String'];
  title: Scalars['String'];
  type: LessonTypesEnum;
  typeCustom: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by aggregate values of table "lesson_templates" */
export type LessonTemplatesAggregateOrderBy = {
  avg?: InputMaybe<LessonTemplatesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonTemplatesMaxOrderBy>;
  min?: InputMaybe<LessonTemplatesMinOrderBy>;
  stddev?: InputMaybe<LessonTemplatesStddevOrderBy>;
  stddevPop?: InputMaybe<LessonTemplatesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LessonTemplatesStddevSampOrderBy>;
  sum?: InputMaybe<LessonTemplatesSumOrderBy>;
  varPop?: InputMaybe<LessonTemplatesVarPopOrderBy>;
  varSamp?: InputMaybe<LessonTemplatesVarSampOrderBy>;
  variance?: InputMaybe<LessonTemplatesVarianceOrderBy>;
};

/** order by avg() on columns of table "lesson_templates" */
export type LessonTemplatesAvgOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lesson_templates". All fields are combined with a logical 'AND'. */
export type LessonTemplatesBoolExp = {
  _and?: InputMaybe<Array<LessonTemplatesBoolExp>>;
  _not?: InputMaybe<LessonTemplatesBoolExp>;
  _or?: InputMaybe<Array<LessonTemplatesBoolExp>>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  originalLesson?: InputMaybe<LessonsBoolExp>;
  originalLessonId?: InputMaybe<UuidComparisonExp>;
  participantLimit?: InputMaybe<IntComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  privacy?: InputMaybe<LessonPrivacyEnumComparisonExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  templateName?: InputMaybe<StringComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<LessonTypesEnumComparisonExp>;
  typeCustom?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userCustomCourtId?: InputMaybe<UuidComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "lesson_templates" */
export enum LessonTemplatesConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonTemplatesPkey = 'lesson_templates_pkey'
}

/** input type for incrementing numeric columns in table "lesson_templates" */
export type LessonTemplatesIncInput = {
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lesson_templates" */
export type LessonTemplatesInsertInput = {
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  originalLesson?: InputMaybe<LessonsObjRelInsertInput>;
  originalLessonId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  sport?: InputMaybe<SportsEnum>;
  templateName?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_templates" */
export type LessonTemplatesMaxOrderBy = {
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalLessonId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  templateName?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "lesson_templates" */
export type LessonTemplatesMinOrderBy = {
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalLessonId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  templateName?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_templates" */
export type LessonTemplatesMutationResponse = {
  __typename?: 'LessonTemplatesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonTemplates>;
};

/** input type for inserting object relation for remote table "lesson_templates" */
export type LessonTemplatesObjRelInsertInput = {
  data: LessonTemplatesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};

/** on_conflict condition type for table "lesson_templates" */
export type LessonTemplatesOnConflict = {
  constraint: LessonTemplatesConstraint;
  updateColumns?: Array<LessonTemplatesUpdateColumn>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};

/** Ordering options when selecting data from "lesson_templates". */
export type LessonTemplatesOrderBy = {
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalLesson?: InputMaybe<LessonsOrderBy>;
  originalLessonId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  sport?: InputMaybe<OrderBy>;
  templateName?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_templates */
export type LessonTemplatesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_templates" */
export enum LessonTemplatesSelectColumn {
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  OriginalLessonId = 'originalLessonId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  Sport = 'sport',
  /** column name */
  TemplateName = 'templateName',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "lesson_templates" */
export type LessonTemplatesSetInput = {
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  sport?: InputMaybe<SportsEnum>;
  templateName?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
};

/** order by stddev() on columns of table "lesson_templates" */
export type LessonTemplatesStddevOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "lesson_templates" */
export type LessonTemplatesStddevPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "lesson_templates" */
export type LessonTemplatesStddevSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lesson_templates" */
export type LessonTemplatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonTemplatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonTemplatesStreamCursorValueInput = {
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  originalLessonId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  sport?: InputMaybe<SportsEnum>;
  templateName?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "lesson_templates" */
export type LessonTemplatesSumOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "lesson_templates" */
export enum LessonTemplatesUpdateColumn {
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  Sport = 'sport',
  /** column name */
  TemplateName = 'templateName',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId'
}

export type LessonTemplatesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LessonTemplatesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonTemplatesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonTemplatesBoolExp;
};

/** order by varPop() on columns of table "lesson_templates" */
export type LessonTemplatesVarPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "lesson_templates" */
export type LessonTemplatesVarSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "lesson_templates" */
export type LessonTemplatesVarianceOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** While thinking through how we handle events with multiple dates or times (ie. a camp), this table was made. It will be actively used once that logic has been thought through more. HOWEVER, another option would be to put an FK on lessons that points to a parent lesson that drives it. This would also allow for things like descriptions for each individual lesson. This is a little more complex though. */
export type LessonTimes = {
  __typename?: 'LessonTimes';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endDateTime: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  startDateTime: Scalars['timestamptz'];
  updatedAt: Scalars['timestamptz'];
};

/** order by aggregate values of table "lesson_times" */
export type LessonTimesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonTimesMaxOrderBy>;
  min?: InputMaybe<LessonTimesMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_times" */
export type LessonTimesArrRelInsertInput = {
  data: Array<LessonTimesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonTimesOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_times". All fields are combined with a logical 'AND'. */
export type LessonTimesBoolExp = {
  _and?: InputMaybe<Array<LessonTimesBoolExp>>;
  _not?: InputMaybe<LessonTimesBoolExp>;
  _or?: InputMaybe<Array<LessonTimesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "lesson_times" */
export enum LessonTimesConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonTimesPkey = 'lesson_times_pkey'
}

/** input type for inserting data into table "lesson_times" */
export type LessonTimesInsertInput = {
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "lesson_times" */
export type LessonTimesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "lesson_times" */
export type LessonTimesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_times" */
export type LessonTimesMutationResponse = {
  __typename?: 'LessonTimesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonTimes>;
};

/** on_conflict condition type for table "lesson_times" */
export type LessonTimesOnConflict = {
  constraint: LessonTimesConstraint;
  updateColumns?: Array<LessonTimesUpdateColumn>;
  where?: InputMaybe<LessonTimesBoolExp>;
};

/** Ordering options when selecting data from "lesson_times". */
export type LessonTimesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_times" */
export enum LessonTimesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "lesson_times" */
export type LessonTimesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonTimesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonTimesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** placeholder for update columns of table "lesson_times" (current role has no relevant permissions) */
export enum LessonTimesUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "lesson_types" */
export type LessonTypes = {
  __typename?: 'LessonTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "lesson_types". All fields are combined with a logical 'AND'. */
export type LessonTypesBoolExp = {
  _and?: InputMaybe<Array<LessonTypesBoolExp>>;
  _not?: InputMaybe<LessonTypesBoolExp>;
  _or?: InputMaybe<Array<LessonTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum LessonTypesEnum {
  Camp = 'CAMP',
  Cardio = 'CARDIO',
  Clinic = 'CLINIC',
  Custom = 'CUSTOM',
  Individual = 'INDIVIDUAL'
}

/** Boolean expression to compare columns of type "LessonTypesEnum". All fields are combined with logical 'AND'. */
export type LessonTypesEnumComparisonExp = {
  _eq?: InputMaybe<LessonTypesEnum>;
  _in?: InputMaybe<Array<LessonTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonTypesEnum>;
  _nin?: InputMaybe<Array<LessonTypesEnum>>;
};

/** Ordering options when selecting data from "lesson_types". */
export type LessonTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_types" */
export enum LessonTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "lesson_types" */
export type LessonTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "lesson_waitlist_statuses" */
export type LessonWaitlistStatuses = {
  __typename?: 'LessonWaitlistStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "lesson_waitlist_statuses". All fields are combined with a logical 'AND'. */
export type LessonWaitlistStatusesBoolExp = {
  _and?: InputMaybe<Array<LessonWaitlistStatusesBoolExp>>;
  _not?: InputMaybe<LessonWaitlistStatusesBoolExp>;
  _or?: InputMaybe<Array<LessonWaitlistStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum LessonWaitlistStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "LessonWaitlistStatusesEnum". All fields are combined with logical 'AND'. */
export type LessonWaitlistStatusesEnumComparisonExp = {
  _eq?: InputMaybe<LessonWaitlistStatusesEnum>;
  _in?: InputMaybe<Array<LessonWaitlistStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonWaitlistStatusesEnum>;
  _nin?: InputMaybe<Array<LessonWaitlistStatusesEnum>>;
};

/** Ordering options when selecting data from "lesson_waitlist_statuses". */
export type LessonWaitlistStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "lesson_waitlist_statuses" */
export enum LessonWaitlistStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonWaitlistStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonWaitlistStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "lesson_waitlists" */
export type LessonWaitlists = {
  __typename?: 'LessonWaitlists';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  status: LessonWaitlistStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "lesson_waitlists" */
export type LessonWaitlistsAggregate = {
  __typename?: 'LessonWaitlistsAggregate';
  aggregate?: Maybe<LessonWaitlistsAggregateFields>;
  nodes: Array<LessonWaitlists>;
};

export type LessonWaitlistsAggregateBoolExp = {
  count?: InputMaybe<LessonWaitlistsAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_waitlists" */
export type LessonWaitlistsAggregateFields = {
  __typename?: 'LessonWaitlistsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonWaitlistsMaxFields>;
  min?: Maybe<LessonWaitlistsMinFields>;
};


/** aggregate fields of "lesson_waitlists" */
export type LessonWaitlistsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_waitlists" */
export type LessonWaitlistsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonWaitlistsMaxOrderBy>;
  min?: InputMaybe<LessonWaitlistsMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_waitlists" */
export type LessonWaitlistsArrRelInsertInput = {
  data: Array<LessonWaitlistsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonWaitlistsOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_waitlists". All fields are combined with a logical 'AND'. */
export type LessonWaitlistsBoolExp = {
  _and?: InputMaybe<Array<LessonWaitlistsBoolExp>>;
  _not?: InputMaybe<LessonWaitlistsBoolExp>;
  _or?: InputMaybe<Array<LessonWaitlistsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<LessonWaitlistStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "lesson_waitlists" */
export enum LessonWaitlistsConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonWaitlistsPkey = 'lesson_waitlists_pkey',
  /** unique or primary key constraint on columns "lesson_id", "user_id" */
  LessonWaitlistsUserIdLessonIdKey = 'lesson_waitlists_user_id_lesson_id_key'
}

/** input type for inserting data into table "lesson_waitlists" */
export type LessonWaitlistsInsertInput = {
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<LessonWaitlistStatusesEnum>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type LessonWaitlistsMaxFields = {
  __typename?: 'LessonWaitlistsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_waitlists" */
export type LessonWaitlistsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonWaitlistsMinFields = {
  __typename?: 'LessonWaitlistsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lesson_waitlists" */
export type LessonWaitlistsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_waitlists" */
export type LessonWaitlistsMutationResponse = {
  __typename?: 'LessonWaitlistsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonWaitlists>;
};

/** on_conflict condition type for table "lesson_waitlists" */
export type LessonWaitlistsOnConflict = {
  constraint: LessonWaitlistsConstraint;
  updateColumns?: Array<LessonWaitlistsUpdateColumn>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};

/** Ordering options when selecting data from "lesson_waitlists". */
export type LessonWaitlistsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: lesson_waitlists */
export type LessonWaitlistsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_waitlists" */
export enum LessonWaitlistsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "lesson_waitlists" */
export type LessonWaitlistsSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonWaitlistStatusesEnum>;
};

/** Streaming cursor of the table "lesson_waitlists" */
export type LessonWaitlistsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonWaitlistsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonWaitlistsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<LessonWaitlistStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "lesson_waitlists" */
export enum LessonWaitlistsUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Status = 'status'
}

export type LessonWaitlistsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonWaitlistsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonWaitlistsBoolExp;
};

/** columns and relationships of "lessons" */
export type Lessons = {
  __typename?: 'Lessons';
  cancelReason: Scalars['String'];
  canceledAt?: Maybe<Scalars['timestamptz']>;
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  endDateTime?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  equipment: Array<LessonEquipment>;
  id: Scalars['uuid'];
  locale: Scalars['String'];
  /** An object relationship */
  owner?: Maybe<Users>;
  /** An object relationship */
  ownerProfile?: Maybe<UserProfiles>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** An array relationship */
  participants: Array<LessonParticipants>;
  /** An aggregate relationship */
  participantsAggregate: LessonParticipantsAggregate;
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount: Scalars['Int'];
  privacy: LessonPrivacyEnum;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  sport: SportsEnum;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  status: LessonStatusesEnum;
  /** An array relationship */
  times: Array<LessonTimes>;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title: Scalars['String'];
  type: LessonTypesEnum;
  typeCustom: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  usedTemplate?: Maybe<LessonTemplates>;
  usedTemplateId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  userCustomCourt?: Maybe<UserCustomCourts>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  waitlist: Array<LessonWaitlists>;
  /** An aggregate relationship */
  waitlistAggregate: LessonWaitlistsAggregate;
};


/** columns and relationships of "lessons" */
export type LessonsEquipmentArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsParticipantsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsTimesArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsWaitlistArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsWaitlistAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};

/** aggregated selection of "lessons" */
export type LessonsAggregate = {
  __typename?: 'LessonsAggregate';
  aggregate?: Maybe<LessonsAggregateFields>;
  nodes: Array<Lessons>;
};

export type LessonsAggregateBoolExp = {
  count?: InputMaybe<LessonsAggregateBoolExpCount>;
};

/** aggregate fields of "lessons" */
export type LessonsAggregateFields = {
  __typename?: 'LessonsAggregateFields';
  avg?: Maybe<LessonsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LessonsMaxFields>;
  min?: Maybe<LessonsMinFields>;
  stddev?: Maybe<LessonsStddevFields>;
  stddevPop?: Maybe<LessonsStddevPopFields>;
  stddevSamp?: Maybe<LessonsStddevSampFields>;
  sum?: Maybe<LessonsSumFields>;
  varPop?: Maybe<LessonsVarPopFields>;
  varSamp?: Maybe<LessonsVarSampFields>;
  variance?: Maybe<LessonsVarianceFields>;
};


/** aggregate fields of "lessons" */
export type LessonsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lessons" */
export type LessonsAggregateOrderBy = {
  avg?: InputMaybe<LessonsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonsMaxOrderBy>;
  min?: InputMaybe<LessonsMinOrderBy>;
  stddev?: InputMaybe<LessonsStddevOrderBy>;
  stddevPop?: InputMaybe<LessonsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LessonsStddevSampOrderBy>;
  sum?: InputMaybe<LessonsSumOrderBy>;
  varPop?: InputMaybe<LessonsVarPopOrderBy>;
  varSamp?: InputMaybe<LessonsVarSampOrderBy>;
  variance?: InputMaybe<LessonsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "lessons" */
export type LessonsArrRelInsertInput = {
  data: Array<LessonsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonsOnConflict>;
};

/** aggregate avg on columns */
export type LessonsAvgFields = {
  __typename?: 'LessonsAvgFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "lessons" */
export type LessonsAvgOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lessons". All fields are combined with a logical 'AND'. */
export type LessonsBoolExp = {
  _and?: InputMaybe<Array<LessonsBoolExp>>;
  _not?: InputMaybe<LessonsBoolExp>;
  _or?: InputMaybe<Array<LessonsBoolExp>>;
  cancelReason?: InputMaybe<StringComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderId?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  equipment?: InputMaybe<LessonEquipmentBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  locale?: InputMaybe<StringComparisonExp>;
  owner?: InputMaybe<UsersBoolExp>;
  ownerProfile?: InputMaybe<UserProfilesBoolExp>;
  ownerUserId?: InputMaybe<UuidComparisonExp>;
  participantLimit?: InputMaybe<IntComparisonExp>;
  participants?: InputMaybe<LessonParticipantsBoolExp>;
  participantsAggregate?: InputMaybe<LessonParticipantsAggregateBoolExp>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnumComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  privacy?: InputMaybe<LessonPrivacyEnumComparisonExp>;
  publishedAt?: InputMaybe<TimestamptzComparisonExp>;
  reminderEventId?: InputMaybe<UuidComparisonExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<LessonStatusesEnumComparisonExp>;
  times?: InputMaybe<LessonTimesBoolExp>;
  timezoneAbbreviation?: InputMaybe<StringComparisonExp>;
  timezoneName?: InputMaybe<StringComparisonExp>;
  timezoneOffsetMinutes?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<LessonTypesEnumComparisonExp>;
  typeCustom?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  usedTemplate?: InputMaybe<LessonTemplatesBoolExp>;
  usedTemplateId?: InputMaybe<UuidComparisonExp>;
  userCustomCourt?: InputMaybe<UserCustomCourtsBoolExp>;
  userCustomCourtId?: InputMaybe<UuidComparisonExp>;
  waitlist?: InputMaybe<LessonWaitlistsBoolExp>;
  waitlistAggregate?: InputMaybe<LessonWaitlistsAggregateBoolExp>;
};

/** unique or primary key constraints on table "lessons" */
export enum LessonsConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonsPkey = 'lessons_pkey'
}

/** input type for incrementing numeric columns in table "lessons" */
export type LessonsIncInput = {
  participantLimit?: InputMaybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lessons" */
export type LessonsInsertInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  equipment?: InputMaybe<LessonEquipmentArrRelInsertInput>;
  locale?: InputMaybe<Scalars['String']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonStatusesEnum>;
  times?: InputMaybe<LessonTimesArrRelInsertInput>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  usedTemplate?: InputMaybe<LessonTemplatesObjRelInsertInput>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourt?: InputMaybe<UserCustomCourtsObjRelInsertInput>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  waitlist?: InputMaybe<LessonWaitlistsArrRelInsertInput>;
};

/** aggregate max on columns */
export type LessonsMaxFields = {
  __typename?: 'LessonsMaxFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  typeCustom?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  usedTemplateId?: Maybe<Scalars['uuid']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lessons" */
export type LessonsMaxOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  usedTemplateId?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonsMinFields = {
  __typename?: 'LessonsMinFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  typeCustom?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  usedTemplateId?: Maybe<Scalars['uuid']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lessons" */
export type LessonsMinOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  usedTemplateId?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lessons" */
export type LessonsMutationResponse = {
  __typename?: 'LessonsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Lessons>;
};

/** input type for inserting object relation for remote table "lessons" */
export type LessonsObjRelInsertInput = {
  data: LessonsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LessonsOnConflict>;
};

/** on_conflict condition type for table "lessons" */
export type LessonsOnConflict = {
  constraint: LessonsConstraint;
  updateColumns?: Array<LessonsUpdateColumn>;
  where?: InputMaybe<LessonsBoolExp>;
};

/** Ordering options when selecting data from "lessons". */
export type LessonsOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  equipmentAggregate?: InputMaybe<LessonEquipmentAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  owner?: InputMaybe<UsersOrderBy>;
  ownerProfile?: InputMaybe<UserProfilesOrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  participantsAggregate?: InputMaybe<LessonParticipantsAggregateOrderBy>;
  paymentFulfillmentChannel?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  sport?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timesAggregate?: InputMaybe<LessonTimesAggregateOrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  usedTemplate?: InputMaybe<LessonTemplatesOrderBy>;
  usedTemplateId?: InputMaybe<OrderBy>;
  userCustomCourt?: InputMaybe<UserCustomCourtsOrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  waitlistAggregate?: InputMaybe<LessonWaitlistsAggregateOrderBy>;
};

/** primary key columns input for table: lessons */
export type LessonsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lessons" */
export enum LessonsSelectColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  OwnerUserId = 'ownerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  ReminderEventId = 'reminderEventId',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedTemplateId = 'usedTemplateId',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId'
}

/** input type for updating data in table "lessons" */
export type LessonsSetInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  locale?: InputMaybe<Scalars['String']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonStatusesEnum>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type LessonsStddevFields = {
  __typename?: 'LessonsStddevFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "lessons" */
export type LessonsStddevOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type LessonsStddevPopFields = {
  __typename?: 'LessonsStddevPopFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "lessons" */
export type LessonsStddevPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type LessonsStddevSampFields = {
  __typename?: 'LessonsStddevSampFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "lessons" */
export type LessonsStddevSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lessons" */
export type LessonsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonsStreamCursorValueInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  locale?: InputMaybe<Scalars['String']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonStatusesEnum>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type LessonsSumFields = {
  __typename?: 'LessonsSumFields';
  participantLimit?: Maybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Int']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "lessons" */
export type LessonsSumOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** update columns of table "lessons" */
export enum LessonsUpdateColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  Currency = 'currency',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Locale = 'locale',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UsedTemplateId = 'usedTemplateId',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId'
}

export type LessonsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LessonsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonsBoolExp;
};

/** aggregate varPop on columns */
export type LessonsVarPopFields = {
  __typename?: 'LessonsVarPopFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "lessons" */
export type LessonsVarPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type LessonsVarSampFields = {
  __typename?: 'LessonsVarSampFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "lessons" */
export type LessonsVarSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LessonsVarianceFields = {
  __typename?: 'LessonsVarianceFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "lessons" */
export type LessonsVarianceOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** columns and relationships of "match_selection_criteria" */
export type MatchSelectionCriteria = {
  __typename?: 'MatchSelectionCriteria';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "match_selection_criteria". All fields are combined with a logical 'AND'. */
export type MatchSelectionCriteriaBoolExp = {
  _and?: InputMaybe<Array<MatchSelectionCriteriaBoolExp>>;
  _not?: InputMaybe<MatchSelectionCriteriaBoolExp>;
  _or?: InputMaybe<Array<MatchSelectionCriteriaBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum MatchSelectionCriteriaEnum {
  Loser = 'LOSER',
  Winner = 'WINNER'
}

/** Boolean expression to compare columns of type "MatchSelectionCriteriaEnum". All fields are combined with logical 'AND'. */
export type MatchSelectionCriteriaEnumComparisonExp = {
  _eq?: InputMaybe<MatchSelectionCriteriaEnum>;
  _in?: InputMaybe<Array<MatchSelectionCriteriaEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<MatchSelectionCriteriaEnum>;
  _nin?: InputMaybe<Array<MatchSelectionCriteriaEnum>>;
};

/** Ordering options when selecting data from "match_selection_criteria". */
export type MatchSelectionCriteriaOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "match_selection_criteria" */
export enum MatchSelectionCriteriaSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "match_selection_criteria" */
export type MatchSelectionCriteriaStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MatchSelectionCriteriaStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MatchSelectionCriteriaStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export enum NotificationActionTypesEnum {
  FollowerUserNew = 'FOLLOWER_USER_NEW',
  GroupCommentReply = 'GROUP_COMMENT_REPLY',
  GroupCommentUpvote = 'GROUP_COMMENT_UPVOTE',
  LessonCoachCancel = 'LESSON_COACH_CANCEL',
  LessonParticipantJoin = 'LESSON_PARTICIPANT_JOIN',
  LessonParticipantLeave = 'LESSON_PARTICIPANT_LEAVE',
  LessonStartReminder = 'LESSON_START_REMINDER',
  PlaySessionCommentSubmit = 'PLAY_SESSION_COMMENT_SUBMIT',
  PlaySessionDetailsUpdate = 'PLAY_SESSION_DETAILS_UPDATE',
  PlaySessionOrganizerCancel = 'PLAY_SESSION_ORGANIZER_CANCEL',
  PlaySessionParticipantJoin = 'PLAY_SESSION_PARTICIPANT_JOIN',
  PlaySessionParticipantLeave = 'PLAY_SESSION_PARTICIPANT_LEAVE',
  PlaySessionStartReminder = 'PLAY_SESSION_START_REMINDER'
}

/** Boolean expression to compare columns of type "NotificationActionTypesEnum". All fields are combined with logical 'AND'. */
export type NotificationActionTypesEnumComparisonExp = {
  _eq?: InputMaybe<NotificationActionTypesEnum>;
  _in?: InputMaybe<Array<NotificationActionTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<NotificationActionTypesEnum>;
  _nin?: InputMaybe<Array<NotificationActionTypesEnum>>;
};

export enum NotificationStatusesEnum {
  Read = 'READ',
  Unread = 'UNREAD'
}

/** Boolean expression to compare columns of type "NotificationStatusesEnum". All fields are combined with logical 'AND'. */
export type NotificationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<NotificationStatusesEnum>;
  _in?: InputMaybe<Array<NotificationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<NotificationStatusesEnum>;
  _nin?: InputMaybe<Array<NotificationStatusesEnum>>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']>;
  _gt?: InputMaybe<Scalars['numeric']>;
  _gte?: InputMaybe<Scalars['numeric']>;
  _in?: InputMaybe<Array<Scalars['numeric']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['numeric']>;
  _lte?: InputMaybe<Scalars['numeric']>;
  _neq?: InputMaybe<Scalars['numeric']>;
  _nin?: InputMaybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'ASC',
  /** in ascending order, nulls first */
  AscNullsFirst = 'ASC_NULLS_FIRST',
  /** in ascending order, nulls last */
  AscNullsLast = 'ASC_NULLS_LAST',
  /** in descending order, nulls first */
  Desc = 'DESC',
  /** in descending order, nulls first */
  DescNullsFirst = 'DESC_NULLS_FIRST',
  /** in descending order, nulls last */
  DescNullsLast = 'DESC_NULLS_LAST'
}

export enum OrderStatusesEnum {
  Canceled = 'CANCELED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Refunded = 'REFUNDED',
  Succeeded = 'SUCCEEDED'
}

/** Boolean expression to compare columns of type "OrderStatusesEnum". All fields are combined with logical 'AND'. */
export type OrderStatusesEnumComparisonExp = {
  _eq?: InputMaybe<OrderStatusesEnum>;
  _in?: InputMaybe<Array<OrderStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<OrderStatusesEnum>;
  _nin?: InputMaybe<Array<OrderStatusesEnum>>;
};

/** columns and relationships of "payment_fulfillment_channels" */
export type PaymentFulfillmentChannels = {
  __typename?: 'PaymentFulfillmentChannels';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "payment_fulfillment_channels". All fields are combined with a logical 'AND'. */
export type PaymentFulfillmentChannelsBoolExp = {
  _and?: InputMaybe<Array<PaymentFulfillmentChannelsBoolExp>>;
  _not?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
  _or?: InputMaybe<Array<PaymentFulfillmentChannelsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PaymentFulfillmentChannelsEnum {
  OffPlatform = 'OFF_PLATFORM',
  OnPlatform = 'ON_PLATFORM',
  ParticipantsChoice = 'PARTICIPANTS_CHOICE'
}

/** Boolean expression to compare columns of type "PaymentFulfillmentChannelsEnum". All fields are combined with logical 'AND'. */
export type PaymentFulfillmentChannelsEnumComparisonExp = {
  _eq?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  _in?: InputMaybe<Array<PaymentFulfillmentChannelsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  _nin?: InputMaybe<Array<PaymentFulfillmentChannelsEnum>>;
};

/** Ordering options when selecting data from "payment_fulfillment_channels". */
export type PaymentFulfillmentChannelsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "payment_fulfillment_channels" */
export enum PaymentFulfillmentChannelsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PaymentFulfillmentChannelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PaymentFulfillmentChannelsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export enum PaymentProcessorsEnum {
  Stripe = 'STRIPE'
}

/** Boolean expression to compare columns of type "PaymentProcessorsEnum". All fields are combined with logical 'AND'. */
export type PaymentProcessorsEnumComparisonExp = {
  _eq?: InputMaybe<PaymentProcessorsEnum>;
  _in?: InputMaybe<Array<PaymentProcessorsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PaymentProcessorsEnum>;
  _nin?: InputMaybe<Array<PaymentProcessorsEnum>>;
};

/** columns and relationships of "pickleball_rating_scales" */
export type PickleballRatingScales = {
  __typename?: 'PickleballRatingScales';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  maximum: Scalars['numeric'];
  minimum: Scalars['numeric'];
  name: Scalars['String'];
  order: Scalars['Int'];
  shortName: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "pickleball_rating_scales". All fields are combined with a logical 'AND'. */
export type PickleballRatingScalesBoolExp = {
  _and?: InputMaybe<Array<PickleballRatingScalesBoolExp>>;
  _not?: InputMaybe<PickleballRatingScalesBoolExp>;
  _or?: InputMaybe<Array<PickleballRatingScalesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  minimum?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  shortName?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** Ordering options when selecting data from "pickleball_rating_scales". */
export type PickleballRatingScalesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  minimum?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  shortName?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "pickleball_rating_scales" */
export enum PickleballRatingScalesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Maximum = 'maximum',
  /** column name */
  Minimum = 'minimum',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "pickleball_rating_scales" */
export type PickleballRatingScalesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PickleballRatingScalesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PickleballRatingScalesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "play_session_comments" */
export type PlaySessionComments = {
  __typename?: 'PlaySessionComments';
  /** An array relationship */
  allChildComments: Array<PlaySessionComments>;
  /** An aggregate relationship */
  allChildCommentsAggregate: PlaySessionCommentsAggregate;
  content: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  playSession: PlaySessions;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId: Scalars['uuid'];
  playSessionRootCommentId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  replies: Array<PlaySessionComments>;
  /** An aggregate relationship */
  repliesAggregate: PlaySessionCommentsAggregate;
  updatedAt: Scalars['timestamptz'];
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsAllChildCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsAllChildCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsRepliesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsRepliesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};

/** aggregated selection of "play_session_comments" */
export type PlaySessionCommentsAggregate = {
  __typename?: 'PlaySessionCommentsAggregate';
  aggregate?: Maybe<PlaySessionCommentsAggregateFields>;
  nodes: Array<PlaySessionComments>;
};

export type PlaySessionCommentsAggregateBoolExp = {
  count?: InputMaybe<PlaySessionCommentsAggregateBoolExpCount>;
};

/** aggregate fields of "play_session_comments" */
export type PlaySessionCommentsAggregateFields = {
  __typename?: 'PlaySessionCommentsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionCommentsMaxFields>;
  min?: Maybe<PlaySessionCommentsMinFields>;
};


/** aggregate fields of "play_session_comments" */
export type PlaySessionCommentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "play_session_comments" */
export type PlaySessionCommentsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PlaySessionCommentsMaxOrderBy>;
  min?: InputMaybe<PlaySessionCommentsMinOrderBy>;
};

/** input type for inserting array relation for remote table "play_session_comments" */
export type PlaySessionCommentsArrRelInsertInput = {
  data: Array<PlaySessionCommentsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};

/** Boolean expression to filter rows from the table "play_session_comments". All fields are combined with a logical 'AND'. */
export type PlaySessionCommentsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionCommentsBoolExp>>;
  _not?: InputMaybe<PlaySessionCommentsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionCommentsBoolExp>>;
  allChildComments?: InputMaybe<PlaySessionCommentsBoolExp>;
  allChildCommentsAggregate?: InputMaybe<PlaySessionCommentsAggregateBoolExp>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionCommentId?: InputMaybe<UuidComparisonExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  playSessionRootCommentId?: InputMaybe<UuidComparisonExp>;
  replies?: InputMaybe<PlaySessionCommentsBoolExp>;
  repliesAggregate?: InputMaybe<PlaySessionCommentsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "play_session_comments" */
export enum PlaySessionCommentsConstraint {
  /** unique or primary key constraint on columns "id" */
  PlaySessionCommentsPkey = 'play_session_comments_pkey'
}

/** input type for inserting data into table "play_session_comments" */
export type PlaySessionCommentsInsertInput = {
  allChildComments?: InputMaybe<PlaySessionCommentsArrRelInsertInput>;
  content?: InputMaybe<Scalars['String']>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  playSessionRootCommentId?: InputMaybe<Scalars['uuid']>;
  replies?: InputMaybe<PlaySessionCommentsArrRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type PlaySessionCommentsMaxFields = {
  __typename?: 'PlaySessionCommentsMaxFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  playSessionRootCommentId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "play_session_comments" */
export type PlaySessionCommentsMaxOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  playSessionRootCommentId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PlaySessionCommentsMinFields = {
  __typename?: 'PlaySessionCommentsMinFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  playSessionRootCommentId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "play_session_comments" */
export type PlaySessionCommentsMinOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  playSessionRootCommentId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "play_session_comments" */
export type PlaySessionCommentsMutationResponse = {
  __typename?: 'PlaySessionCommentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionComments>;
};

/** on_conflict condition type for table "play_session_comments" */
export type PlaySessionCommentsOnConflict = {
  constraint: PlaySessionCommentsConstraint;
  updateColumns?: Array<PlaySessionCommentsUpdateColumn>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};

/** Ordering options when selecting data from "play_session_comments". */
export type PlaySessionCommentsOrderBy = {
  allChildCommentsAggregate?: InputMaybe<PlaySessionCommentsAggregateOrderBy>;
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  playSessionRootCommentId?: InputMaybe<OrderBy>;
  repliesAggregate?: InputMaybe<PlaySessionCommentsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: play_session_comments */
export type PlaySessionCommentsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "play_session_comments" */
export enum PlaySessionCommentsSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionCommentId = 'playSessionCommentId',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  PlaySessionRootCommentId = 'playSessionRootCommentId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "play_session_comments" */
export type PlaySessionCommentsSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "play_session_comments" */
export type PlaySessionCommentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionCommentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionCommentsStreamCursorValueInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  playSessionRootCommentId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "play_session_comments" */
export enum PlaySessionCommentsUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt'
}

export type PlaySessionCommentsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionCommentsSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionCommentsBoolExp;
};

/** columns and relationships of "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatuses = {
  __typename?: 'PlaySessionCourtBookingStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "play_session_court_booking_statuses". All fields are combined with a logical 'AND'. */
export type PlaySessionCourtBookingStatusesBoolExp = {
  _and?: InputMaybe<Array<PlaySessionCourtBookingStatusesBoolExp>>;
  _not?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
  _or?: InputMaybe<Array<PlaySessionCourtBookingStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PlaySessionCourtBookingStatusesEnum {
  Booked = 'BOOKED',
  NotBooked = 'NOT_BOOKED'
}

/** Boolean expression to compare columns of type "PlaySessionCourtBookingStatusesEnum". All fields are combined with logical 'AND'. */
export type PlaySessionCourtBookingStatusesEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  _in?: InputMaybe<Array<PlaySessionCourtBookingStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  _nin?: InputMaybe<Array<PlaySessionCourtBookingStatusesEnum>>;
};

/** Ordering options when selecting data from "play_session_court_booking_statuses". */
export type PlaySessionCourtBookingStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "play_session_court_booking_statuses" */
export enum PlaySessionCourtBookingStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionCourtBookingStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionCourtBookingStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "play_session_formats" */
export type PlaySessionFormats = {
  __typename?: 'PlaySessionFormats';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "play_session_formats". All fields are combined with a logical 'AND'. */
export type PlaySessionFormatsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionFormatsBoolExp>>;
  _not?: InputMaybe<PlaySessionFormatsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionFormatsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PlaySessionFormatsEnum {
  Doubles = 'DOUBLES',
  OpenPlay = 'OPEN_PLAY',
  Singles = 'SINGLES'
}

/** Boolean expression to compare columns of type "PlaySessionFormatsEnum". All fields are combined with logical 'AND'. */
export type PlaySessionFormatsEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionFormatsEnum>;
  _in?: InputMaybe<Array<PlaySessionFormatsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionFormatsEnum>;
  _nin?: InputMaybe<Array<PlaySessionFormatsEnum>>;
};

/** Ordering options when selecting data from "play_session_formats". */
export type PlaySessionFormatsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "play_session_formats" */
export enum PlaySessionFormatsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "play_session_formats" */
export type PlaySessionFormatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionFormatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionFormatsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitiveness = {
  __typename?: 'PlaySessionMatchCompetitiveness';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "play_session_match_competitiveness". All fields are combined with a logical 'AND'. */
export type PlaySessionMatchCompetitivenessBoolExp = {
  _and?: InputMaybe<Array<PlaySessionMatchCompetitivenessBoolExp>>;
  _not?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
  _or?: InputMaybe<Array<PlaySessionMatchCompetitivenessBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PlaySessionMatchCompetitivenessEnum {
  Casual = 'CASUAL',
  Match = 'MATCH',
  Practice = 'PRACTICE'
}

/** Boolean expression to compare columns of type "PlaySessionMatchCompetitivenessEnum". All fields are combined with logical 'AND'. */
export type PlaySessionMatchCompetitivenessEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  _in?: InputMaybe<Array<PlaySessionMatchCompetitivenessEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  _nin?: InputMaybe<Array<PlaySessionMatchCompetitivenessEnum>>;
};

/** Ordering options when selecting data from "play_session_match_competitiveness". */
export type PlaySessionMatchCompetitivenessOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "play_session_match_competitiveness" */
export enum PlaySessionMatchCompetitivenessSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionMatchCompetitivenessStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionMatchCompetitivenessStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "play_session_participant_statuses" */
export type PlaySessionParticipantStatuses = {
  __typename?: 'PlaySessionParticipantStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "play_session_participant_statuses". All fields are combined with a logical 'AND'. */
export type PlaySessionParticipantStatusesBoolExp = {
  _and?: InputMaybe<Array<PlaySessionParticipantStatusesBoolExp>>;
  _not?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
  _or?: InputMaybe<Array<PlaySessionParticipantStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PlaySessionParticipantStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "PlaySessionParticipantStatusesEnum". All fields are combined with logical 'AND'. */
export type PlaySessionParticipantStatusesEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  _in?: InputMaybe<Array<PlaySessionParticipantStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  _nin?: InputMaybe<Array<PlaySessionParticipantStatusesEnum>>;
};

/** Ordering options when selecting data from "play_session_participant_statuses". */
export type PlaySessionParticipantStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "play_session_participant_statuses" */
export enum PlaySessionParticipantStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionParticipantStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionParticipantStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "play_session_participants" */
export type PlaySessionParticipants = {
  __typename?: 'PlaySessionParticipants';
  addedAt?: Maybe<Scalars['timestamptz']>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  playSession: PlaySessions;
  playSessionId: Scalars['uuid'];
  removedAt?: Maybe<Scalars['timestamptz']>;
  status: PlaySessionParticipantStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "play_session_participants" */
export type PlaySessionParticipantsAggregate = {
  __typename?: 'PlaySessionParticipantsAggregate';
  aggregate?: Maybe<PlaySessionParticipantsAggregateFields>;
  nodes: Array<PlaySessionParticipants>;
};

export type PlaySessionParticipantsAggregateBoolExp = {
  count?: InputMaybe<PlaySessionParticipantsAggregateBoolExpCount>;
};

/** aggregate fields of "play_session_participants" */
export type PlaySessionParticipantsAggregateFields = {
  __typename?: 'PlaySessionParticipantsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionParticipantsMaxFields>;
  min?: Maybe<PlaySessionParticipantsMinFields>;
};


/** aggregate fields of "play_session_participants" */
export type PlaySessionParticipantsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "play_session_participants" */
export type PlaySessionParticipantsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PlaySessionParticipantsMaxOrderBy>;
  min?: InputMaybe<PlaySessionParticipantsMinOrderBy>;
};

/** input type for inserting array relation for remote table "play_session_participants" */
export type PlaySessionParticipantsArrRelInsertInput = {
  data: Array<PlaySessionParticipantsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionParticipantsOnConflict>;
};

/** Boolean expression to filter rows from the table "play_session_participants". All fields are combined with a logical 'AND'. */
export type PlaySessionParticipantsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionParticipantsBoolExp>>;
  _not?: InputMaybe<PlaySessionParticipantsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionParticipantsBoolExp>>;
  addedAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  removedAt?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "play_session_participants" */
export enum PlaySessionParticipantsConstraint {
  /** unique or primary key constraint on columns "id" */
  PlaySessionParticipantsPkey = 'play_session_participants_pkey',
  /** unique or primary key constraint on columns "user_id", "play_session_id" */
  PlaySessionParticipantsPlaySessionIdUserIdKey = 'play_session_participants_play_session_id_user_id_key'
}

/** input type for inserting data into table "play_session_participants" */
export type PlaySessionParticipantsInsertInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type PlaySessionParticipantsMaxFields = {
  __typename?: 'PlaySessionParticipantsMaxFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "play_session_participants" */
export type PlaySessionParticipantsMaxOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PlaySessionParticipantsMinFields = {
  __typename?: 'PlaySessionParticipantsMinFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "play_session_participants" */
export type PlaySessionParticipantsMinOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "play_session_participants" */
export type PlaySessionParticipantsMutationResponse = {
  __typename?: 'PlaySessionParticipantsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionParticipants>;
};

/** on_conflict condition type for table "play_session_participants" */
export type PlaySessionParticipantsOnConflict = {
  constraint: PlaySessionParticipantsConstraint;
  updateColumns?: Array<PlaySessionParticipantsUpdateColumn>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};

/** Ordering options when selecting data from "play_session_participants". */
export type PlaySessionParticipantsOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** select columns of table "play_session_participants" */
export enum PlaySessionParticipantsSelectColumn {
  /** column name */
  AddedAt = 'addedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  RemovedAt = 'removedAt',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "play_session_participants" */
export type PlaySessionParticipantsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionParticipantsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionParticipantsStreamCursorValueInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** placeholder for update columns of table "play_session_participants" (current role has no relevant permissions) */
export enum PlaySessionParticipantsUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "play_session_privacy" */
export type PlaySessionPrivacy = {
  __typename?: 'PlaySessionPrivacy';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "play_session_privacy". All fields are combined with a logical 'AND'. */
export type PlaySessionPrivacyBoolExp = {
  _and?: InputMaybe<Array<PlaySessionPrivacyBoolExp>>;
  _not?: InputMaybe<PlaySessionPrivacyBoolExp>;
  _or?: InputMaybe<Array<PlaySessionPrivacyBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PlaySessionPrivacyEnum {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** Boolean expression to compare columns of type "PlaySessionPrivacyEnum". All fields are combined with logical 'AND'. */
export type PlaySessionPrivacyEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionPrivacyEnum>;
  _in?: InputMaybe<Array<PlaySessionPrivacyEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionPrivacyEnum>;
  _nin?: InputMaybe<Array<PlaySessionPrivacyEnum>>;
};

/** Ordering options when selecting data from "play_session_privacy". */
export type PlaySessionPrivacyOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "play_session_privacy" */
export enum PlaySessionPrivacySelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "play_session_privacy" */
export type PlaySessionPrivacyStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionPrivacyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionPrivacyStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "play_session_statuses" */
export type PlaySessionStatuses = {
  __typename?: 'PlaySessionStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "play_session_statuses". All fields are combined with a logical 'AND'. */
export type PlaySessionStatusesBoolExp = {
  _and?: InputMaybe<Array<PlaySessionStatusesBoolExp>>;
  _not?: InputMaybe<PlaySessionStatusesBoolExp>;
  _or?: InputMaybe<Array<PlaySessionStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum PlaySessionStatusesEnum {
  Active = 'ACTIVE',
  Canceled = 'CANCELED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "PlaySessionStatusesEnum". All fields are combined with logical 'AND'. */
export type PlaySessionStatusesEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionStatusesEnum>;
  _in?: InputMaybe<Array<PlaySessionStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionStatusesEnum>;
  _nin?: InputMaybe<Array<PlaySessionStatusesEnum>>;
};

/** Ordering options when selecting data from "play_session_statuses". */
export type PlaySessionStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "play_session_statuses" */
export enum PlaySessionStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "play_session_statuses" */
export type PlaySessionStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "play_sessions" */
export type PlaySessions = {
  __typename?: 'PlaySessions';
  cancelReason: Scalars['String'];
  canceledAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  comments: Array<PlaySessionComments>;
  /** An aggregate relationship */
  commentsAggregate: PlaySessionCommentsAggregate;
  competitiveness?: Maybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus: PlaySessionCourtBookingStatusesEnum;
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  endDateTime?: Maybe<Scalars['timestamptz']>;
  extraRacketCount?: Maybe<Scalars['Int']>;
  format: PlaySessionFormatsEnum;
  /** An object relationship */
  group?: Maybe<Groups>;
  groupId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  id: Scalars['uuid'];
  isBringingNet: Scalars['Boolean'];
  locale: Scalars['String'];
  /** An object relationship */
  organizer?: Maybe<Users>;
  /** An object relationship */
  organizerProfile?: Maybe<UserProfiles>;
  organizerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** An array relationship */
  participants: Array<PlaySessionParticipants>;
  /** An aggregate relationship */
  participantsAggregate: PlaySessionParticipantsAggregate;
  /** An object relationship */
  pickleballRatingScale?: Maybe<PickleballRatingScales>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  priceUnitAmount: Scalars['Int'];
  privacy: PlaySessionPrivacyEnum;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  sport: SportsEnum;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  status: PlaySessionStatusesEnum;
  targetSkillLevel?: Maybe<Scalars['String']>;
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  userCustomCourt?: Maybe<UserCustomCourts>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  venue?: Maybe<Venues>;
  venueId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsParticipantsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};

/** aggregated selection of "play_sessions" */
export type PlaySessionsAggregate = {
  __typename?: 'PlaySessionsAggregate';
  aggregate?: Maybe<PlaySessionsAggregateFields>;
  nodes: Array<PlaySessions>;
};

export type PlaySessionsAggregateBoolExp = {
  bool_and?: InputMaybe<PlaySessionsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<PlaySessionsAggregateBoolExpBool_Or>;
  count?: InputMaybe<PlaySessionsAggregateBoolExpCount>;
};

/** aggregate fields of "play_sessions" */
export type PlaySessionsAggregateFields = {
  __typename?: 'PlaySessionsAggregateFields';
  avg?: Maybe<PlaySessionsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PlaySessionsMaxFields>;
  min?: Maybe<PlaySessionsMinFields>;
  stddev?: Maybe<PlaySessionsStddevFields>;
  stddevPop?: Maybe<PlaySessionsStddevPopFields>;
  stddevSamp?: Maybe<PlaySessionsStddevSampFields>;
  sum?: Maybe<PlaySessionsSumFields>;
  varPop?: Maybe<PlaySessionsVarPopFields>;
  varSamp?: Maybe<PlaySessionsVarSampFields>;
  variance?: Maybe<PlaySessionsVarianceFields>;
};


/** aggregate fields of "play_sessions" */
export type PlaySessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "play_sessions" */
export type PlaySessionsAggregateOrderBy = {
  avg?: InputMaybe<PlaySessionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PlaySessionsMaxOrderBy>;
  min?: InputMaybe<PlaySessionsMinOrderBy>;
  stddev?: InputMaybe<PlaySessionsStddevOrderBy>;
  stddevPop?: InputMaybe<PlaySessionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<PlaySessionsStddevSampOrderBy>;
  sum?: InputMaybe<PlaySessionsSumOrderBy>;
  varPop?: InputMaybe<PlaySessionsVarPopOrderBy>;
  varSamp?: InputMaybe<PlaySessionsVarSampOrderBy>;
  variance?: InputMaybe<PlaySessionsVarianceOrderBy>;
};

/** aggregate avg on columns */
export type PlaySessionsAvgFields = {
  __typename?: 'PlaySessionsAvgFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "play_sessions" */
export type PlaySessionsAvgOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "play_sessions". All fields are combined with a logical 'AND'. */
export type PlaySessionsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionsBoolExp>>;
  _not?: InputMaybe<PlaySessionsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionsBoolExp>>;
  cancelReason?: InputMaybe<StringComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  comments?: InputMaybe<PlaySessionCommentsBoolExp>;
  commentsAggregate?: InputMaybe<PlaySessionCommentsAggregateBoolExp>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnumComparisonExp>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  extraRacketCount?: InputMaybe<IntComparisonExp>;
  format?: InputMaybe<PlaySessionFormatsEnumComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBringingNet?: InputMaybe<BooleanComparisonExp>;
  locale?: InputMaybe<StringComparisonExp>;
  organizer?: InputMaybe<UsersBoolExp>;
  organizerProfile?: InputMaybe<UserProfilesBoolExp>;
  organizerUserId?: InputMaybe<UuidComparisonExp>;
  participantLimit?: InputMaybe<IntComparisonExp>;
  participants?: InputMaybe<PlaySessionParticipantsBoolExp>;
  participantsAggregate?: InputMaybe<PlaySessionParticipantsAggregateBoolExp>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesBoolExp>;
  pickleballRatingScaleId?: InputMaybe<UuidComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  privacy?: InputMaybe<PlaySessionPrivacyEnumComparisonExp>;
  publishedAt?: InputMaybe<TimestamptzComparisonExp>;
  reminderEventId?: InputMaybe<UuidComparisonExp>;
  skillRatingMaximum?: InputMaybe<NumericComparisonExp>;
  skillRatingMinimum?: InputMaybe<NumericComparisonExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<PlaySessionStatusesEnumComparisonExp>;
  targetSkillLevel?: InputMaybe<StringComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  timezoneAbbreviation?: InputMaybe<StringComparisonExp>;
  timezoneName?: InputMaybe<StringComparisonExp>;
  timezoneOffsetMinutes?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCustomCourt?: InputMaybe<UserCustomCourtsBoolExp>;
  userCustomCourtId?: InputMaybe<UuidComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "play_sessions" */
export enum PlaySessionsConstraint {
  /** unique or primary key constraint on columns "id" */
  PlaySessionsPkey = 'play_sessions_pkey'
}

/** input type for incrementing numeric columns in table "play_sessions" */
export type PlaySessionsIncInput = {
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "play_sessions" */
export type PlaySessionsInsertInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<PlaySessionCommentsArrRelInsertInput>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  currency?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<PlaySessionFormatsEnum>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsArrRelInsertInput>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale?: InputMaybe<Scalars['String']>;
  organizerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  participants?: InputMaybe<PlaySessionParticipantsArrRelInsertInput>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourt?: InputMaybe<UserCustomCourtsObjRelInsertInput>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type PlaySessionsMaxFields = {
  __typename?: 'PlaySessionsMaxFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  extraRacketCount?: Maybe<Scalars['Int']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  organizerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  targetSkillLevel?: Maybe<Scalars['String']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "play_sessions" */
export type PlaySessionsMaxOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  extraRacketCount?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  organizerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  targetSkillLevel?: InputMaybe<OrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PlaySessionsMinFields = {
  __typename?: 'PlaySessionsMinFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  extraRacketCount?: Maybe<Scalars['Int']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  organizerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  targetSkillLevel?: Maybe<Scalars['String']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "play_sessions" */
export type PlaySessionsMinOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  extraRacketCount?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  organizerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  targetSkillLevel?: InputMaybe<OrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "play_sessions" */
export type PlaySessionsMutationResponse = {
  __typename?: 'PlaySessionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessions>;
};

/** input type for inserting object relation for remote table "play_sessions" */
export type PlaySessionsObjRelInsertInput = {
  data: PlaySessionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};

/** on_conflict condition type for table "play_sessions" */
export type PlaySessionsOnConflict = {
  constraint: PlaySessionsConstraint;
  updateColumns?: Array<PlaySessionsUpdateColumn>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};

/** Ordering options when selecting data from "play_sessions". */
export type PlaySessionsOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  commentsAggregate?: InputMaybe<PlaySessionCommentsAggregateOrderBy>;
  competitiveness?: InputMaybe<OrderBy>;
  courtBookingStatus?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  extraRacketCount?: InputMaybe<OrderBy>;
  format?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupsPlaySessionsAggregate?: InputMaybe<GroupsPlaySessionsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isBringingNet?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  organizer?: InputMaybe<UsersOrderBy>;
  organizerProfile?: InputMaybe<UserProfilesOrderBy>;
  organizerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  participantsAggregate?: InputMaybe<PlaySessionParticipantsAggregateOrderBy>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesOrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  sport?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  targetSkillLevel?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourt?: InputMaybe<UserCustomCourtsOrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_sessions */
export type PlaySessionsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "play_sessions" */
export enum PlaySessionsSelectColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  Competitiveness = 'competitiveness',
  /** column name */
  CourtBookingStatus = 'courtBookingStatus',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExtraRacketCount = 'extraRacketCount',
  /** column name */
  Format = 'format',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsBringingNet = 'isBringingNet',
  /** column name */
  Locale = 'locale',
  /** column name */
  OrganizerUserId = 'organizerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  ReminderEventId = 'reminderEventId',
  /** column name */
  SkillRatingMaximum = 'skillRatingMaximum',
  /** column name */
  SkillRatingMinimum = 'skillRatingMinimum',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TargetSkillLevel = 'targetSkillLevel',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  VenueId = 'venueId'
}

/** select "playSessionsAggregateBoolExpBool_andArgumentsColumns" columns of table "play_sessions" */
export enum PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsBringingNet = 'isBringingNet'
}

/** select "playSessionsAggregateBoolExpBool_orArgumentsColumns" columns of table "play_sessions" */
export enum PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsBringingNet = 'isBringingNet'
}

/** input type for updating data in table "play_sessions" */
export type PlaySessionsSetInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  currency?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<PlaySessionFormatsEnum>;
  groupId?: InputMaybe<Scalars['uuid']>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale?: InputMaybe<Scalars['String']>;
  organizerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type PlaySessionsStddevFields = {
  __typename?: 'PlaySessionsStddevFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "play_sessions" */
export type PlaySessionsStddevOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type PlaySessionsStddevPopFields = {
  __typename?: 'PlaySessionsStddevPopFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "play_sessions" */
export type PlaySessionsStddevPopOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type PlaySessionsStddevSampFields = {
  __typename?: 'PlaySessionsStddevSampFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "play_sessions" */
export type PlaySessionsStddevSampOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "play_sessions" */
export type PlaySessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionsStreamCursorValueInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<PlaySessionFormatsEnum>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale?: InputMaybe<Scalars['String']>;
  organizerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type PlaySessionsSumFields = {
  __typename?: 'PlaySessionsSumFields';
  extraRacketCount?: Maybe<Scalars['Int']>;
  participantLimit?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "play_sessions" */
export type PlaySessionsSumOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** update columns of table "play_sessions" */
export enum PlaySessionsUpdateColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  Competitiveness = 'competitiveness',
  /** column name */
  CourtBookingStatus = 'courtBookingStatus',
  /** column name */
  Currency = 'currency',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExtraRacketCount = 'extraRacketCount',
  /** column name */
  Format = 'format',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  IsBringingNet = 'isBringingNet',
  /** column name */
  Locale = 'locale',
  /** column name */
  OrganizerUserId = 'organizerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  SkillRatingMaximum = 'skillRatingMaximum',
  /** column name */
  SkillRatingMinimum = 'skillRatingMinimum',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TargetSkillLevel = 'targetSkillLevel',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  VenueId = 'venueId'
}

export type PlaySessionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PlaySessionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionsSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionsBoolExp;
};

/** aggregate varPop on columns */
export type PlaySessionsVarPopFields = {
  __typename?: 'PlaySessionsVarPopFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "play_sessions" */
export type PlaySessionsVarPopOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type PlaySessionsVarSampFields = {
  __typename?: 'PlaySessionsVarSampFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "play_sessions" */
export type PlaySessionsVarSampOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PlaySessionsVarianceFields = {
  __typename?: 'PlaySessionsVarianceFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "play_sessions" */
export type PlaySessionsVarianceOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** columns and relationships of "scoring_format" */
export type ScoringFormat = {
  __typename?: 'ScoringFormat';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "scoring_format". All fields are combined with a logical 'AND'. */
export type ScoringFormatBoolExp = {
  _and?: InputMaybe<Array<ScoringFormatBoolExp>>;
  _not?: InputMaybe<ScoringFormatBoolExp>;
  _or?: InputMaybe<Array<ScoringFormatBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum ScoringFormatEnum {
  Rally = 'RALLY',
  Traditional = 'TRADITIONAL'
}

/** Boolean expression to compare columns of type "ScoringFormatEnum". All fields are combined with logical 'AND'. */
export type ScoringFormatEnumComparisonExp = {
  _eq?: InputMaybe<ScoringFormatEnum>;
  _in?: InputMaybe<Array<ScoringFormatEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<ScoringFormatEnum>;
  _nin?: InputMaybe<Array<ScoringFormatEnum>>;
};

/** Ordering options when selecting data from "scoring_format". */
export type ScoringFormatOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "scoring_format" */
export enum ScoringFormatSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "scoring_format" */
export type ScoringFormatStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ScoringFormatStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ScoringFormatStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "signup_requests" */
export type SignupRequests = {
  __typename?: 'SignupRequests';
  id: Scalars['uuid'];
};

/** Boolean expression to filter rows from the table "signup_requests". All fields are combined with a logical 'AND'. */
export type SignupRequestsBoolExp = {
  _and?: InputMaybe<Array<SignupRequestsBoolExp>>;
  _not?: InputMaybe<SignupRequestsBoolExp>;
  _or?: InputMaybe<Array<SignupRequestsBoolExp>>;
  id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "signup_requests" */
export enum SignupRequestsConstraint {
  /** unique or primary key constraint on columns "id" */
  SignupRequestsPkey = 'signup_requests_pkey'
}

/** input type for inserting data into table "signup_requests" */
export type SignupRequestsInsertInput = {
  accountType?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  fullName?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** response of any mutation on the table "signup_requests" */
export type SignupRequestsMutationResponse = {
  __typename?: 'SignupRequestsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<SignupRequests>;
};

/** on_conflict condition type for table "signup_requests" */
export type SignupRequestsOnConflict = {
  constraint: SignupRequestsConstraint;
  updateColumns?: Array<SignupRequestsUpdateColumn>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};

/** Ordering options when selecting data from "signup_requests". */
export type SignupRequestsOrderBy = {
  id?: InputMaybe<OrderBy>;
};

/** select columns of table "signup_requests" */
export enum SignupRequestsSelectColumn {
  /** column name */
  Id = 'id'
}

/** Streaming cursor of the table "signup_requests" */
export type SignupRequestsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SignupRequestsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SignupRequestsStreamCursorValueInput = {
  id?: InputMaybe<Scalars['uuid']>;
};

/** placeholder for update columns of table "signup_requests" (current role has no relevant permissions) */
export enum SignupRequestsUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "skill_levels" */
export type SkillLevels = {
  __typename?: 'SkillLevels';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName: Scalars['String'];
  id: Scalars['String'];
  isDisplayed: Scalars['Boolean'];
  rank: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "skill_levels". All fields are combined with a logical 'AND'. */
export type SkillLevelsBoolExp = {
  _and?: InputMaybe<Array<SkillLevelsBoolExp>>;
  _not?: InputMaybe<SkillLevelsBoolExp>;
  _or?: InputMaybe<Array<SkillLevelsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  displayName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  isDisplayed?: InputMaybe<BooleanComparisonExp>;
  rank?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** Ordering options when selecting data from "skill_levels". */
export type SkillLevelsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isDisplayed?: InputMaybe<OrderBy>;
  rank?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "skill_levels" */
export enum SkillLevelsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  IsDisplayed = 'isDisplayed',
  /** column name */
  Rank = 'rank',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "skill_levels" */
export type SkillLevelsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SkillLevelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SkillLevelsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  isDisplayed?: InputMaybe<Scalars['Boolean']>;
  rank?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "sports" */
export type Sports = {
  __typename?: 'Sports';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "sports". All fields are combined with a logical 'AND'. */
export type SportsBoolExp = {
  _and?: InputMaybe<Array<SportsBoolExp>>;
  _not?: InputMaybe<SportsBoolExp>;
  _or?: InputMaybe<Array<SportsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum SportsEnum {
  Pickleball = 'PICKLEBALL',
  Tennis = 'TENNIS'
}

/** Boolean expression to compare columns of type "SportsEnum". All fields are combined with logical 'AND'. */
export type SportsEnumComparisonExp = {
  _eq?: InputMaybe<SportsEnum>;
  _in?: InputMaybe<Array<SportsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<SportsEnum>;
  _nin?: InputMaybe<Array<SportsEnum>>;
};

/** Ordering options when selecting data from "sports". */
export type SportsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "sports" */
export enum SportsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "sports" */
export type SportsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SportsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SportsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "team_types" */
export type TeamTypes = {
  __typename?: 'TeamTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "team_types". All fields are combined with a logical 'AND'. */
export type TeamTypesBoolExp = {
  _and?: InputMaybe<Array<TeamTypesBoolExp>>;
  _not?: InputMaybe<TeamTypesBoolExp>;
  _or?: InputMaybe<Array<TeamTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum TeamTypesEnum {
  Doubles = 'DOUBLES',
  Singles = 'SINGLES'
}

/** Boolean expression to compare columns of type "TeamTypesEnum". All fields are combined with logical 'AND'. */
export type TeamTypesEnumComparisonExp = {
  _eq?: InputMaybe<TeamTypesEnum>;
  _in?: InputMaybe<Array<TeamTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<TeamTypesEnum>;
  _nin?: InputMaybe<Array<TeamTypesEnum>>;
};

/** Ordering options when selecting data from "team_types". */
export type TeamTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "team_types" */
export enum TeamTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "team_types" */
export type TeamTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TeamTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeamTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "tennis_rating_scales" */
export type TennisRatingScales = {
  __typename?: 'TennisRatingScales';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  maximum: Scalars['numeric'];
  minimum: Scalars['numeric'];
  name: Scalars['String'];
  order: Scalars['Int'];
  shortName: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "tennis_rating_scales". All fields are combined with a logical 'AND'. */
export type TennisRatingScalesBoolExp = {
  _and?: InputMaybe<Array<TennisRatingScalesBoolExp>>;
  _not?: InputMaybe<TennisRatingScalesBoolExp>;
  _or?: InputMaybe<Array<TennisRatingScalesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  minimum?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  shortName?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** Ordering options when selecting data from "tennis_rating_scales". */
export type TennisRatingScalesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  minimum?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  shortName?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "tennis_rating_scales" */
export enum TennisRatingScalesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Maximum = 'maximum',
  /** column name */
  Minimum = 'minimum',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "tennis_rating_scales" */
export type TennisRatingScalesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TennisRatingScalesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TennisRatingScalesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']>;
  _gt?: InputMaybe<Scalars['timestamptz']>;
  _gte?: InputMaybe<Scalars['timestamptz']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamptz']>;
  _lte?: InputMaybe<Scalars['timestamptz']>;
  _neq?: InputMaybe<Scalars['timestamptz']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** columns and relationships of "user_coach_services" */
export type UserCoachServices = {
  __typename?: 'UserCoachServices';
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  id: Scalars['uuid'];
  priceUnitAmount: Scalars['Int'];
  title: Scalars['String'];
  type?: Maybe<LessonTypesEnum>;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** order by aggregate values of table "user_coach_services" */
export type UserCoachServicesAggregateOrderBy = {
  avg?: InputMaybe<UserCoachServicesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCoachServicesMaxOrderBy>;
  min?: InputMaybe<UserCoachServicesMinOrderBy>;
  stddev?: InputMaybe<UserCoachServicesStddevOrderBy>;
  stddevPop?: InputMaybe<UserCoachServicesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<UserCoachServicesStddevSampOrderBy>;
  sum?: InputMaybe<UserCoachServicesSumOrderBy>;
  varPop?: InputMaybe<UserCoachServicesVarPopOrderBy>;
  varSamp?: InputMaybe<UserCoachServicesVarSampOrderBy>;
  variance?: InputMaybe<UserCoachServicesVarianceOrderBy>;
};

/** order by avg() on columns of table "user_coach_services" */
export type UserCoachServicesAvgOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_coach_services". All fields are combined with a logical 'AND'. */
export type UserCoachServicesBoolExp = {
  _and?: InputMaybe<Array<UserCoachServicesBoolExp>>;
  _not?: InputMaybe<UserCoachServicesBoolExp>;
  _or?: InputMaybe<Array<UserCoachServicesBoolExp>>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderId?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<LessonTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "user_coach_services" */
export enum UserCoachServicesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserCoachServicesPkey = 'user_coach_services_pkey'
}

/** input type for incrementing numeric columns in table "user_coach_services" */
export type UserCoachServicesIncInput = {
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_coach_services" */
export type UserCoachServicesInsertInput = {
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_coach_services" */
export type UserCoachServicesMaxOrderBy = {
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "user_coach_services" */
export type UserCoachServicesMinOrderBy = {
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_coach_services" */
export type UserCoachServicesMutationResponse = {
  __typename?: 'UserCoachServicesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCoachServices>;
};

/** on_conflict condition type for table "user_coach_services" */
export type UserCoachServicesOnConflict = {
  constraint: UserCoachServicesConstraint;
  updateColumns?: Array<UserCoachServicesUpdateColumn>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};

/** Ordering options when selecting data from "user_coach_services". */
export type UserCoachServicesOrderBy = {
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: user_coach_services */
export type UserCoachServicesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_coach_services" */
export enum UserCoachServicesSelectColumn {
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_coach_services" */
export type UserCoachServicesSetInput = {
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
};

/** order by stddev() on columns of table "user_coach_services" */
export type UserCoachServicesStddevOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "user_coach_services" */
export type UserCoachServicesStddevPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "user_coach_services" */
export type UserCoachServicesStddevSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_coach_services" */
export type UserCoachServicesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCoachServicesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCoachServicesStreamCursorValueInput = {
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "user_coach_services" */
export type UserCoachServicesSumOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "user_coach_services" */
export enum UserCoachServicesUpdateColumn {
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type'
}

export type UserCoachServicesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserCoachServicesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCoachServicesSetInput>;
  /** filter the rows which have to be updated */
  where: UserCoachServicesBoolExp;
};

/** order by varPop() on columns of table "user_coach_services" */
export type UserCoachServicesVarPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "user_coach_services" */
export type UserCoachServicesVarSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "user_coach_services" */
export type UserCoachServicesVarianceOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "user_communication_preferences" */
export type UserCommunicationPreferences = {
  __typename?: 'UserCommunicationPreferences';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id: Scalars['uuid'];
  lessonBookedEmail: CommunicationPreferenceStatusesEnum;
  lessonBookedPush: CommunicationPreferenceStatusesEnum;
  lessonCanceledEmail: CommunicationPreferenceStatusesEnum;
  lessonCanceledPushed: CommunicationPreferenceStatusesEnum;
  lessonReminderEmail: CommunicationPreferenceStatusesEnum;
  lessonReminderPush: CommunicationPreferenceStatusesEnum;
  marketingEmail: CommunicationPreferenceStatusesEnum;
  marketingPush: CommunicationPreferenceStatusesEnum;
  newFollowerEmail: CommunicationPreferenceStatusesEnum;
  newFollowerPush: CommunicationPreferenceStatusesEnum;
  newLessonPublishedEmail: CommunicationPreferenceStatusesEnum;
  newLessonPublishedPush: CommunicationPreferenceStatusesEnum;
  participantLeftLessonEmail: CommunicationPreferenceStatusesEnum;
  participantLeftLessonPush: CommunicationPreferenceStatusesEnum;
  payoutEmail: CommunicationPreferenceStatusesEnum;
  payoutPush: CommunicationPreferenceStatusesEnum;
  playSessionCanceledEmail: CommunicationPreferenceStatusesEnum;
  playSessionCanceledPush: CommunicationPreferenceStatusesEnum;
  playSessionParticipantJoinedEmail: CommunicationPreferenceStatusesEnum;
  playSessionParticipantJoinedPush: CommunicationPreferenceStatusesEnum;
  playSessionParticipantLeftEmail: CommunicationPreferenceStatusesEnum;
  playSessionParticipantLeftPush: CommunicationPreferenceStatusesEnum;
  playSessionReminderEmail: CommunicationPreferenceStatusesEnum;
  playSessionReminderPush: CommunicationPreferenceStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
};

/** Boolean expression to filter rows from the table "user_communication_preferences". All fields are combined with a logical 'AND'. */
export type UserCommunicationPreferencesBoolExp = {
  _and?: InputMaybe<Array<UserCommunicationPreferencesBoolExp>>;
  _not?: InputMaybe<UserCommunicationPreferencesBoolExp>;
  _or?: InputMaybe<Array<UserCommunicationPreferencesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** response of any mutation on the table "user_communication_preferences" */
export type UserCommunicationPreferencesMutationResponse = {
  __typename?: 'UserCommunicationPreferencesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCommunicationPreferences>;
};

/** Ordering options when selecting data from "user_communication_preferences". */
export type UserCommunicationPreferencesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonBookedEmail?: InputMaybe<OrderBy>;
  lessonBookedPush?: InputMaybe<OrderBy>;
  lessonCanceledEmail?: InputMaybe<OrderBy>;
  lessonCanceledPushed?: InputMaybe<OrderBy>;
  lessonReminderEmail?: InputMaybe<OrderBy>;
  lessonReminderPush?: InputMaybe<OrderBy>;
  marketingEmail?: InputMaybe<OrderBy>;
  marketingPush?: InputMaybe<OrderBy>;
  newFollowerEmail?: InputMaybe<OrderBy>;
  newFollowerPush?: InputMaybe<OrderBy>;
  newLessonPublishedEmail?: InputMaybe<OrderBy>;
  newLessonPublishedPush?: InputMaybe<OrderBy>;
  participantLeftLessonEmail?: InputMaybe<OrderBy>;
  participantLeftLessonPush?: InputMaybe<OrderBy>;
  payoutEmail?: InputMaybe<OrderBy>;
  payoutPush?: InputMaybe<OrderBy>;
  playSessionCanceledEmail?: InputMaybe<OrderBy>;
  playSessionCanceledPush?: InputMaybe<OrderBy>;
  playSessionParticipantJoinedEmail?: InputMaybe<OrderBy>;
  playSessionParticipantJoinedPush?: InputMaybe<OrderBy>;
  playSessionParticipantLeftEmail?: InputMaybe<OrderBy>;
  playSessionParticipantLeftPush?: InputMaybe<OrderBy>;
  playSessionReminderEmail?: InputMaybe<OrderBy>;
  playSessionReminderPush?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: user_communication_preferences */
export type UserCommunicationPreferencesPkColumnsInput = {
  /** This will match the users UUID since it's 1-1 relationship */
  id: Scalars['uuid'];
};

/** select columns of table "user_communication_preferences" */
export enum UserCommunicationPreferencesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonBookedEmail = 'lessonBookedEmail',
  /** column name */
  LessonBookedPush = 'lessonBookedPush',
  /** column name */
  LessonCanceledEmail = 'lessonCanceledEmail',
  /** column name */
  LessonCanceledPushed = 'lessonCanceledPushed',
  /** column name */
  LessonReminderEmail = 'lessonReminderEmail',
  /** column name */
  LessonReminderPush = 'lessonReminderPush',
  /** column name */
  MarketingEmail = 'marketingEmail',
  /** column name */
  MarketingPush = 'marketingPush',
  /** column name */
  NewFollowerEmail = 'newFollowerEmail',
  /** column name */
  NewFollowerPush = 'newFollowerPush',
  /** column name */
  NewLessonPublishedEmail = 'newLessonPublishedEmail',
  /** column name */
  NewLessonPublishedPush = 'newLessonPublishedPush',
  /** column name */
  ParticipantLeftLessonEmail = 'participantLeftLessonEmail',
  /** column name */
  ParticipantLeftLessonPush = 'participantLeftLessonPush',
  /** column name */
  PayoutEmail = 'payoutEmail',
  /** column name */
  PayoutPush = 'payoutPush',
  /** column name */
  PlaySessionCanceledEmail = 'playSessionCanceledEmail',
  /** column name */
  PlaySessionCanceledPush = 'playSessionCanceledPush',
  /** column name */
  PlaySessionParticipantJoinedEmail = 'playSessionParticipantJoinedEmail',
  /** column name */
  PlaySessionParticipantJoinedPush = 'playSessionParticipantJoinedPush',
  /** column name */
  PlaySessionParticipantLeftEmail = 'playSessionParticipantLeftEmail',
  /** column name */
  PlaySessionParticipantLeftPush = 'playSessionParticipantLeftPush',
  /** column name */
  PlaySessionReminderEmail = 'playSessionReminderEmail',
  /** column name */
  PlaySessionReminderPush = 'playSessionReminderPush',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "user_communication_preferences" */
export type UserCommunicationPreferencesSetInput = {
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
};

/** Streaming cursor of the table "user_communication_preferences" */
export type UserCommunicationPreferencesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCommunicationPreferencesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCommunicationPreferencesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id?: InputMaybe<Scalars['uuid']>;
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

export type UserCommunicationPreferencesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCommunicationPreferencesSetInput>;
  /** filter the rows which have to be updated */
  where: UserCommunicationPreferencesBoolExp;
};

/** columns and relationships of "user_credit_cards" */
export type UserCreditCards = {
  __typename?: 'UserCreditCards';
  billingCity?: Maybe<Scalars['String']>;
  billingCountry?: Maybe<Scalars['String']>;
  billingEmail?: Maybe<Scalars['String']>;
  billingLine1?: Maybe<Scalars['String']>;
  billingLine2?: Maybe<Scalars['String']>;
  billingName?: Maybe<Scalars['String']>;
  billingPhone?: Maybe<Scalars['String']>;
  billingPostalCode?: Maybe<Scalars['String']>;
  billingState?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  country: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  expireMonth: Scalars['Int'];
  expireYear: Scalars['Int'];
  fingerprint: Scalars['String'];
  funding: Scalars['String'];
  id: Scalars['uuid'];
  last4: Scalars['String'];
  provider: Scalars['String'];
  providerCardId: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** order by aggregate values of table "user_credit_cards" */
export type UserCreditCardsAggregateOrderBy = {
  avg?: InputMaybe<UserCreditCardsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCreditCardsMaxOrderBy>;
  min?: InputMaybe<UserCreditCardsMinOrderBy>;
  stddev?: InputMaybe<UserCreditCardsStddevOrderBy>;
  stddevPop?: InputMaybe<UserCreditCardsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<UserCreditCardsStddevSampOrderBy>;
  sum?: InputMaybe<UserCreditCardsSumOrderBy>;
  varPop?: InputMaybe<UserCreditCardsVarPopOrderBy>;
  varSamp?: InputMaybe<UserCreditCardsVarSampOrderBy>;
  variance?: InputMaybe<UserCreditCardsVarianceOrderBy>;
};

/** order by avg() on columns of table "user_credit_cards" */
export type UserCreditCardsAvgOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_credit_cards". All fields are combined with a logical 'AND'. */
export type UserCreditCardsBoolExp = {
  _and?: InputMaybe<Array<UserCreditCardsBoolExp>>;
  _not?: InputMaybe<UserCreditCardsBoolExp>;
  _or?: InputMaybe<Array<UserCreditCardsBoolExp>>;
  billingCity?: InputMaybe<StringComparisonExp>;
  billingCountry?: InputMaybe<StringComparisonExp>;
  billingEmail?: InputMaybe<StringComparisonExp>;
  billingLine1?: InputMaybe<StringComparisonExp>;
  billingLine2?: InputMaybe<StringComparisonExp>;
  billingName?: InputMaybe<StringComparisonExp>;
  billingPhone?: InputMaybe<StringComparisonExp>;
  billingPostalCode?: InputMaybe<StringComparisonExp>;
  billingState?: InputMaybe<StringComparisonExp>;
  brand?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  expireMonth?: InputMaybe<IntComparisonExp>;
  expireYear?: InputMaybe<IntComparisonExp>;
  fingerprint?: InputMaybe<StringComparisonExp>;
  funding?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  last4?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerCardId?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** order by max() on columns of table "user_credit_cards" */
export type UserCreditCardsMaxOrderBy = {
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingLine1?: InputMaybe<OrderBy>;
  billingLine2?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPhone?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  brand?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
  fingerprint?: InputMaybe<OrderBy>;
  funding?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  last4?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerCardId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "user_credit_cards" */
export type UserCreditCardsMinOrderBy = {
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingLine1?: InputMaybe<OrderBy>;
  billingLine2?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPhone?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  brand?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
  fingerprint?: InputMaybe<OrderBy>;
  funding?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  last4?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerCardId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "user_credit_cards". */
export type UserCreditCardsOrderBy = {
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingLine1?: InputMaybe<OrderBy>;
  billingLine2?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPhone?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  brand?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
  fingerprint?: InputMaybe<OrderBy>;
  funding?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  last4?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerCardId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "user_credit_cards" */
export enum UserCreditCardsSelectColumn {
  /** column name */
  BillingCity = 'billingCity',
  /** column name */
  BillingCountry = 'billingCountry',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingLine1 = 'billingLine1',
  /** column name */
  BillingLine2 = 'billingLine2',
  /** column name */
  BillingName = 'billingName',
  /** column name */
  BillingPhone = 'billingPhone',
  /** column name */
  BillingPostalCode = 'billingPostalCode',
  /** column name */
  BillingState = 'billingState',
  /** column name */
  Brand = 'brand',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpireMonth = 'expireMonth',
  /** column name */
  ExpireYear = 'expireYear',
  /** column name */
  Fingerprint = 'fingerprint',
  /** column name */
  Funding = 'funding',
  /** column name */
  Id = 'id',
  /** column name */
  Last4 = 'last4',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderCardId = 'providerCardId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** order by stddev() on columns of table "user_credit_cards" */
export type UserCreditCardsStddevOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "user_credit_cards" */
export type UserCreditCardsStddevPopOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "user_credit_cards" */
export type UserCreditCardsStddevSampOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_credit_cards" */
export type UserCreditCardsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCreditCardsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCreditCardsStreamCursorValueInput = {
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingEmail?: InputMaybe<Scalars['String']>;
  billingLine1?: InputMaybe<Scalars['String']>;
  billingLine2?: InputMaybe<Scalars['String']>;
  billingName?: InputMaybe<Scalars['String']>;
  billingPhone?: InputMaybe<Scalars['String']>;
  billingPostalCode?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expireMonth?: InputMaybe<Scalars['Int']>;
  expireYear?: InputMaybe<Scalars['Int']>;
  fingerprint?: InputMaybe<Scalars['String']>;
  funding?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  last4?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerCardId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by sum() on columns of table "user_credit_cards" */
export type UserCreditCardsSumOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "user_credit_cards" */
export type UserCreditCardsVarPopOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "user_credit_cards" */
export type UserCreditCardsVarSampOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "user_credit_cards" */
export type UserCreditCardsVarianceOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** columns and relationships of "user_custom_courts" */
export type UserCustomCourts = {
  __typename?: 'UserCustomCourts';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fullAddress: Scalars['String'];
  id: Scalars['uuid'];
  /** An array relationship */
  lessons: Array<Lessons>;
  /** An aggregate relationship */
  lessonsAggregate: LessonsAggregate;
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};


/** columns and relationships of "user_custom_courts" */
export type UserCustomCourtsLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "user_custom_courts" */
export type UserCustomCourtsLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};

/** order by aggregate values of table "user_custom_courts" */
export type UserCustomCourtsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCustomCourtsMaxOrderBy>;
  min?: InputMaybe<UserCustomCourtsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "user_custom_courts". All fields are combined with a logical 'AND'. */
export type UserCustomCourtsBoolExp = {
  _and?: InputMaybe<Array<UserCustomCourtsBoolExp>>;
  _not?: InputMaybe<UserCustomCourtsBoolExp>;
  _or?: InputMaybe<Array<UserCustomCourtsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fullAddress?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lessons?: InputMaybe<LessonsBoolExp>;
  lessonsAggregate?: InputMaybe<LessonsAggregateBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_custom_courts" */
export enum UserCustomCourtsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserCustomCourtsPkey = 'user_custom_courts_pkey'
}

/** input type for inserting data into table "user_custom_courts" */
export type UserCustomCourtsInsertInput = {
  fullAddress?: InputMaybe<Scalars['String']>;
  lessons?: InputMaybe<LessonsArrRelInsertInput>;
  title?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_custom_courts" */
export type UserCustomCourtsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullAddress?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "user_custom_courts" */
export type UserCustomCourtsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullAddress?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_custom_courts" */
export type UserCustomCourtsMutationResponse = {
  __typename?: 'UserCustomCourtsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCustomCourts>;
};

/** input type for inserting object relation for remote table "user_custom_courts" */
export type UserCustomCourtsObjRelInsertInput = {
  data: UserCustomCourtsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};

/** on_conflict condition type for table "user_custom_courts" */
export type UserCustomCourtsOnConflict = {
  constraint: UserCustomCourtsConstraint;
  updateColumns?: Array<UserCustomCourtsUpdateColumn>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};

/** Ordering options when selecting data from "user_custom_courts". */
export type UserCustomCourtsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullAddress?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonsAggregate?: InputMaybe<LessonsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_custom_courts */
export type UserCustomCourtsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_custom_courts" */
export enum UserCustomCourtsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FullAddress = 'fullAddress',
  /** column name */
  Id = 'id',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_custom_courts" */
export type UserCustomCourtsSetInput = {
  fullAddress?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "user_custom_courts" */
export type UserCustomCourtsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCustomCourtsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCustomCourtsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullAddress?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_custom_courts" */
export enum UserCustomCourtsUpdateColumn {
  /** column name */
  FullAddress = 'fullAddress',
  /** column name */
  Title = 'title'
}

export type UserCustomCourtsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCustomCourtsSetInput>;
  /** filter the rows which have to be updated */
  where: UserCustomCourtsBoolExp;
};

/** columns and relationships of "user_follows" */
export type UserFollows = {
  __typename?: 'UserFollows';
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  followedProfile?: Maybe<UserProfiles>;
  followedUserId: Scalars['uuid'];
  /** An object relationship */
  followerProfile?: Maybe<UserProfiles>;
  followerUserId: Scalars['uuid'];
  id: Scalars['uuid'];
  status: FollowStatusesEnum;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "user_follows" */
export type UserFollowsAggregate = {
  __typename?: 'UserFollowsAggregate';
  aggregate?: Maybe<UserFollowsAggregateFields>;
  nodes: Array<UserFollows>;
};

export type UserFollowsAggregateBoolExp = {
  count?: InputMaybe<UserFollowsAggregateBoolExpCount>;
};

/** aggregate fields of "user_follows" */
export type UserFollowsAggregateFields = {
  __typename?: 'UserFollowsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserFollowsMaxFields>;
  min?: Maybe<UserFollowsMinFields>;
};


/** aggregate fields of "user_follows" */
export type UserFollowsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserFollowsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_follows" */
export type UserFollowsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserFollowsMaxOrderBy>;
  min?: InputMaybe<UserFollowsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "user_follows". All fields are combined with a logical 'AND'. */
export type UserFollowsBoolExp = {
  _and?: InputMaybe<Array<UserFollowsBoolExp>>;
  _not?: InputMaybe<UserFollowsBoolExp>;
  _or?: InputMaybe<Array<UserFollowsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  followedProfile?: InputMaybe<UserProfilesBoolExp>;
  followedUserId?: InputMaybe<UuidComparisonExp>;
  followerProfile?: InputMaybe<UserProfilesBoolExp>;
  followerUserId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<FollowStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "user_follows" */
export enum UserFollowsConstraint {
  /** unique or primary key constraint on columns "followed_user_id", "follower_user_id" */
  UserFollowsFollowedUserIdFollowerUserIdKey = 'user_follows_followed_user_id_follower_user_id_key',
  /** unique or primary key constraint on columns "id" */
  UserFollowsPkey = 'user_follows_pkey'
}

/** input type for inserting data into table "user_follows" */
export type UserFollowsInsertInput = {
  followedUserId?: InputMaybe<Scalars['uuid']>;
  followerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
};

/** aggregate max on columns */
export type UserFollowsMaxFields = {
  __typename?: 'UserFollowsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  followedUserId?: Maybe<Scalars['uuid']>;
  followerUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "user_follows" */
export type UserFollowsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  followedUserId?: InputMaybe<OrderBy>;
  followerUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserFollowsMinFields = {
  __typename?: 'UserFollowsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  followedUserId?: Maybe<Scalars['uuid']>;
  followerUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "user_follows" */
export type UserFollowsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  followedUserId?: InputMaybe<OrderBy>;
  followerUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_follows" */
export type UserFollowsMutationResponse = {
  __typename?: 'UserFollowsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserFollows>;
};

/** on_conflict condition type for table "user_follows" */
export type UserFollowsOnConflict = {
  constraint: UserFollowsConstraint;
  updateColumns?: Array<UserFollowsUpdateColumn>;
  where?: InputMaybe<UserFollowsBoolExp>;
};

/** Ordering options when selecting data from "user_follows". */
export type UserFollowsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  followedProfile?: InputMaybe<UserProfilesOrderBy>;
  followedUserId?: InputMaybe<OrderBy>;
  followerProfile?: InputMaybe<UserProfilesOrderBy>;
  followerUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_follows */
export type UserFollowsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_follows" */
export enum UserFollowsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FollowedUserId = 'followedUserId',
  /** column name */
  FollowerUserId = 'followerUserId',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "user_follows" */
export type UserFollowsSetInput = {
  status?: InputMaybe<FollowStatusesEnum>;
};

/** Streaming cursor of the table "user_follows" */
export type UserFollowsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserFollowsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserFollowsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  followedUserId?: InputMaybe<Scalars['uuid']>;
  followerUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "user_follows" */
export enum UserFollowsUpdateColumn {
  /** column name */
  Status = 'status'
}

export type UserFollowsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserFollowsSetInput>;
  /** filter the rows which have to be updated */
  where: UserFollowsBoolExp;
};

/** columns and relationships of "user_image_log" */
export type UserImageLog = {
  __typename?: 'UserImageLog';
  createdAt: Scalars['timestamptz'];
  fileName: Scalars['String'];
  id: Scalars['uuid'];
  path: Scalars['String'];
  provider: Scalars['String'];
  providerId: Scalars['String'];
  providerUrl: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  userId?: Maybe<Scalars['uuid']>;
};

/** Boolean expression to filter rows from the table "user_image_log". All fields are combined with a logical 'AND'. */
export type UserImageLogBoolExp = {
  _and?: InputMaybe<Array<UserImageLogBoolExp>>;
  _not?: InputMaybe<UserImageLogBoolExp>;
  _or?: InputMaybe<Array<UserImageLogBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  fileName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  path?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerId?: InputMaybe<StringComparisonExp>;
  providerUrl?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_image_log" */
export enum UserImageLogConstraint {
  /** unique or primary key constraint on columns "id" */
  UserImageLogPkey = 'user_image_log_pkey'
}

/** input type for inserting data into table "user_image_log" */
export type UserImageLogInsertInput = {
  fileName?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** response of any mutation on the table "user_image_log" */
export type UserImageLogMutationResponse = {
  __typename?: 'UserImageLogMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserImageLog>;
};

/** on_conflict condition type for table "user_image_log" */
export type UserImageLogOnConflict = {
  constraint: UserImageLogConstraint;
  updateColumns?: Array<UserImageLogUpdateColumn>;
  where?: InputMaybe<UserImageLogBoolExp>;
};

/** Ordering options when selecting data from "user_image_log". */
export type UserImageLogOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "user_image_log" */
export enum UserImageLogSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  Id = 'id',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "user_image_log" */
export type UserImageLogStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserImageLogStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserImageLogStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** placeholder for update columns of table "user_image_log" (current role has no relevant permissions) */
export enum UserImageLogUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "user_notification_details" */
export type UserNotificationDetails = {
  __typename?: 'UserNotificationDetails';
  actionType: NotificationActionTypesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  primaryEntity: UserNotificationEntities;
  updatedAt: Scalars['timestamptz'];
  userNotificationEntityId: Scalars['uuid'];
  /** An array relationship */
  userNotifications: Array<UserNotifications>;
  /** An aggregate relationship */
  userNotificationsAggregate: UserNotificationsAggregate;
};


/** columns and relationships of "user_notification_details" */
export type UserNotificationDetailsUserNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


/** columns and relationships of "user_notification_details" */
export type UserNotificationDetailsUserNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};

/** Boolean expression to filter rows from the table "user_notification_details". All fields are combined with a logical 'AND'. */
export type UserNotificationDetailsBoolExp = {
  _and?: InputMaybe<Array<UserNotificationDetailsBoolExp>>;
  _not?: InputMaybe<UserNotificationDetailsBoolExp>;
  _or?: InputMaybe<Array<UserNotificationDetailsBoolExp>>;
  actionType?: InputMaybe<NotificationActionTypesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  primaryEntity?: InputMaybe<UserNotificationEntitiesBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userNotificationEntityId?: InputMaybe<UuidComparisonExp>;
  userNotifications?: InputMaybe<UserNotificationsBoolExp>;
  userNotificationsAggregate?: InputMaybe<UserNotificationsAggregateBoolExp>;
};

/** Ordering options when selecting data from "user_notification_details". */
export type UserNotificationDetailsOrderBy = {
  actionType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  primaryEntity?: InputMaybe<UserNotificationEntitiesOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userNotificationEntityId?: InputMaybe<OrderBy>;
  userNotificationsAggregate?: InputMaybe<UserNotificationsAggregateOrderBy>;
};

/** select columns of table "user_notification_details" */
export enum UserNotificationDetailsSelectColumn {
  /** column name */
  ActionType = 'actionType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserNotificationEntityId = 'userNotificationEntityId'
}

/** Streaming cursor of the table "user_notification_details" */
export type UserNotificationDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserNotificationDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserNotificationDetailsStreamCursorValueInput = {
  actionType?: InputMaybe<NotificationActionTypesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userNotificationEntityId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "user_notification_entities" */
export type UserNotificationEntities = {
  __typename?: 'UserNotificationEntities';
  /** An object relationship */
  actingUser?: Maybe<Users>;
  actingUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  actingUserProfile?: Maybe<UserProfiles>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group?: Maybe<Groups>;
  groupId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  groupThread?: Maybe<GroupThreads>;
  /** An object relationship */
  groupThreadComment?: Maybe<GroupThreadComments>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson?: Maybe<Lessons>;
  lessonId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  notificationDetails?: Maybe<UserNotificationDetails>;
  /** An object relationship */
  playSession?: Maybe<PlaySessions>;
  /** An object relationship */
  playSessionComment?: Maybe<PlaySessionComments>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  updatedAt: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "user_notification_entities". All fields are combined with a logical 'AND'. */
export type UserNotificationEntitiesBoolExp = {
  _and?: InputMaybe<Array<UserNotificationEntitiesBoolExp>>;
  _not?: InputMaybe<UserNotificationEntitiesBoolExp>;
  _or?: InputMaybe<Array<UserNotificationEntitiesBoolExp>>;
  actingUser?: InputMaybe<UsersBoolExp>;
  actingUserId?: InputMaybe<UuidComparisonExp>;
  actingUserProfile?: InputMaybe<UserProfilesBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupThread?: InputMaybe<GroupThreadsBoolExp>;
  groupThreadComment?: InputMaybe<GroupThreadCommentsBoolExp>;
  groupThreadCommentId?: InputMaybe<UuidComparisonExp>;
  groupThreadId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  notificationDetails?: InputMaybe<UserNotificationDetailsBoolExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionComment?: InputMaybe<PlaySessionCommentsBoolExp>;
  playSessionCommentId?: InputMaybe<UuidComparisonExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** Ordering options when selecting data from "user_notification_entities". */
export type UserNotificationEntitiesOrderBy = {
  actingUser?: InputMaybe<UsersOrderBy>;
  actingUserId?: InputMaybe<OrderBy>;
  actingUserProfile?: InputMaybe<UserProfilesOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupThread?: InputMaybe<GroupThreadsOrderBy>;
  groupThreadComment?: InputMaybe<GroupThreadCommentsOrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  notificationDetails?: InputMaybe<UserNotificationDetailsOrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionComment?: InputMaybe<PlaySessionCommentsOrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "user_notification_entities" */
export enum UserNotificationEntitiesSelectColumn {
  /** column name */
  ActingUserId = 'actingUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  GroupThreadId = 'groupThreadId',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  PlaySessionCommentId = 'playSessionCommentId',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** Streaming cursor of the table "user_notification_entities" */
export type UserNotificationEntitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserNotificationEntitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserNotificationEntitiesStreamCursorValueInput = {
  actingUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "user_notifications" */
export type UserNotifications = {
  __typename?: 'UserNotifications';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  notificationDetails: UserNotificationDetails;
  readAt?: Maybe<Scalars['timestamptz']>;
  status: NotificationStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  userNotificationDetailId: Scalars['uuid'];
};

/** aggregated selection of "user_notifications" */
export type UserNotificationsAggregate = {
  __typename?: 'UserNotificationsAggregate';
  aggregate?: Maybe<UserNotificationsAggregateFields>;
  nodes: Array<UserNotifications>;
};

export type UserNotificationsAggregateBoolExp = {
  count?: InputMaybe<UserNotificationsAggregateBoolExpCount>;
};

/** aggregate fields of "user_notifications" */
export type UserNotificationsAggregateFields = {
  __typename?: 'UserNotificationsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserNotificationsMaxFields>;
  min?: Maybe<UserNotificationsMinFields>;
};


/** aggregate fields of "user_notifications" */
export type UserNotificationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_notifications" */
export type UserNotificationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserNotificationsMaxOrderBy>;
  min?: InputMaybe<UserNotificationsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "user_notifications". All fields are combined with a logical 'AND'. */
export type UserNotificationsBoolExp = {
  _and?: InputMaybe<Array<UserNotificationsBoolExp>>;
  _not?: InputMaybe<UserNotificationsBoolExp>;
  _or?: InputMaybe<Array<UserNotificationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  notificationDetails?: InputMaybe<UserNotificationDetailsBoolExp>;
  readAt?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<NotificationStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userNotificationDetailId?: InputMaybe<UuidComparisonExp>;
};

/** aggregate max on columns */
export type UserNotificationsMaxFields = {
  __typename?: 'UserNotificationsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  readAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  userNotificationDetailId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_notifications" */
export type UserNotificationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  readAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userNotificationDetailId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserNotificationsMinFields = {
  __typename?: 'UserNotificationsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  readAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  userNotificationDetailId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_notifications" */
export type UserNotificationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  readAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userNotificationDetailId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_notifications" */
export type UserNotificationsMutationResponse = {
  __typename?: 'UserNotificationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserNotifications>;
};

/** Ordering options when selecting data from "user_notifications". */
export type UserNotificationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notificationDetails?: InputMaybe<UserNotificationDetailsOrderBy>;
  readAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userNotificationDetailId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_notifications */
export type UserNotificationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_notifications" */
export enum UserNotificationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  ReadAt = 'readAt',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserNotificationDetailId = 'userNotificationDetailId'
}

/** input type for updating data in table "user_notifications" */
export type UserNotificationsSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  readAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<NotificationStatusesEnum>;
};

/** Streaming cursor of the table "user_notifications" */
export type UserNotificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserNotificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserNotificationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  readAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<NotificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  userNotificationDetailId?: InputMaybe<Scalars['uuid']>;
};

export type UserNotificationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserNotificationsSetInput>;
  /** filter the rows which have to be updated */
  where: UserNotificationsBoolExp;
};

/** columns and relationships of "user_profiles" */
export type UserProfiles = {
  __typename?: 'UserProfiles';
  aboutMe?: Maybe<Scalars['String']>;
  aboutMeVideoUrl?: Maybe<Scalars['String']>;
  /** An object relationship */
  activeCity?: Maybe<Cities>;
  activeCityId?: Maybe<Scalars['uuid']>;
  cityName?: Maybe<Scalars['String']>;
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  coachLessons: Array<Lessons>;
  /** An aggregate relationship */
  coachLessonsAggregate: LessonsAggregate;
  /** An array relationship */
  coachQualifications: Array<UsersCoachQualifications>;
  /** An array relationship */
  coachServices: Array<UserCoachServices>;
  coachStatus?: Maybe<Scalars['String']>;
  /** An object relationship */
  country?: Maybe<Countries>;
  countryId?: Maybe<Scalars['String']>;
  /** An object relationship */
  countrySubdivision?: Maybe<CountrySubdivisions>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  defaultSport?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventOrganizerAccountType?: Maybe<Scalars['String']>;
  /** An array relationship */
  followers: Array<UserFollows>;
  /** An aggregate relationship */
  followersAggregate: UserFollowsAggregate;
  /** An array relationship */
  following: Array<UserFollows>;
  /** An aggregate relationship */
  followingAggregate: UserFollowsAggregate;
  fullName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  genderPreference?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  normalizedTennisRatingScale?: Maybe<TennisRatingScales>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  pickleballSkillLevel?: Maybe<SkillLevels>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  profileImageFileName?: Maybe<Scalars['String']>;
  profileImagePath?: Maybe<Scalars['String']>;
  profileImageProvider?: Maybe<Scalars['String']>;
  profileImageProviderUrl?: Maybe<Scalars['String']>;
  tennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  tennisSkillLevel?: Maybe<SkillLevels>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowersArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowingArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowingAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};

/** Boolean expression to filter rows from the table "user_profiles". All fields are combined with a logical 'AND'. */
export type UserProfilesBoolExp = {
  _and?: InputMaybe<Array<UserProfilesBoolExp>>;
  _not?: InputMaybe<UserProfilesBoolExp>;
  _or?: InputMaybe<Array<UserProfilesBoolExp>>;
  aboutMe?: InputMaybe<StringComparisonExp>;
  aboutMeVideoUrl?: InputMaybe<StringComparisonExp>;
  activeCity?: InputMaybe<CitiesBoolExp>;
  activeCityId?: InputMaybe<UuidComparisonExp>;
  cityName?: InputMaybe<StringComparisonExp>;
  coachExperienceSetAt?: InputMaybe<TimestamptzComparisonExp>;
  coachExperienceYears?: InputMaybe<NumericComparisonExp>;
  coachLessons?: InputMaybe<LessonsBoolExp>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateBoolExp>;
  coachQualifications?: InputMaybe<UsersCoachQualificationsBoolExp>;
  coachServices?: InputMaybe<UserCoachServicesBoolExp>;
  coachStatus?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<CountriesBoolExp>;
  countryId?: InputMaybe<StringComparisonExp>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsBoolExp>;
  countrySubdivisionId?: InputMaybe<UuidComparisonExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  defaultSport?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  duprId?: InputMaybe<StringComparisonExp>;
  eventOrganizerAccountType?: InputMaybe<StringComparisonExp>;
  followers?: InputMaybe<UserFollowsBoolExp>;
  followersAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  following?: InputMaybe<UserFollowsBoolExp>;
  followingAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  fullName?: InputMaybe<StringComparisonExp>;
  gender?: InputMaybe<StringComparisonExp>;
  genderPreference?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  normalizedTennisRating?: InputMaybe<NumericComparisonExp>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  normalizedTennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  pickleballSkillLevelId?: InputMaybe<StringComparisonExp>;
  preferredName?: InputMaybe<StringComparisonExp>;
  profileImageFileName?: InputMaybe<StringComparisonExp>;
  profileImagePath?: InputMaybe<StringComparisonExp>;
  profileImageProvider?: InputMaybe<StringComparisonExp>;
  profileImageProviderUrl?: InputMaybe<StringComparisonExp>;
  tennisRating?: InputMaybe<NumericComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  tennisSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  tennisSkillLevelId?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
};

/** Ordering options when selecting data from "user_profiles". */
export type UserProfilesOrderBy = {
  aboutMe?: InputMaybe<OrderBy>;
  aboutMeVideoUrl?: InputMaybe<OrderBy>;
  activeCity?: InputMaybe<CitiesOrderBy>;
  activeCityId?: InputMaybe<OrderBy>;
  cityName?: InputMaybe<OrderBy>;
  coachExperienceSetAt?: InputMaybe<OrderBy>;
  coachExperienceYears?: InputMaybe<OrderBy>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateOrderBy>;
  coachQualificationsAggregate?: InputMaybe<UsersCoachQualificationsAggregateOrderBy>;
  coachServicesAggregate?: InputMaybe<UserCoachServicesAggregateOrderBy>;
  coachStatus?: InputMaybe<OrderBy>;
  country?: InputMaybe<CountriesOrderBy>;
  countryId?: InputMaybe<OrderBy>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsOrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  defaultSport?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  duprId?: InputMaybe<OrderBy>;
  eventOrganizerAccountType?: InputMaybe<OrderBy>;
  followersAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  followingAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  fullName?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  genderPreference?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  normalizedTennisRating?: InputMaybe<OrderBy>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  normalizedTennisRatingScaleId?: InputMaybe<OrderBy>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  pickleballSkillLevelId?: InputMaybe<OrderBy>;
  preferredName?: InputMaybe<OrderBy>;
  profileImageFileName?: InputMaybe<OrderBy>;
  profileImagePath?: InputMaybe<OrderBy>;
  profileImageProvider?: InputMaybe<OrderBy>;
  profileImageProviderUrl?: InputMaybe<OrderBy>;
  tennisRating?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  tennisSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  tennisSkillLevelId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** select columns of table "user_profiles" */
export enum UserProfilesSelectColumn {
  /** column name */
  AboutMe = 'aboutMe',
  /** column name */
  AboutMeVideoUrl = 'aboutMeVideoUrl',
  /** column name */
  ActiveCityId = 'activeCityId',
  /** column name */
  CityName = 'cityName',
  /** column name */
  CoachExperienceSetAt = 'coachExperienceSetAt',
  /** column name */
  CoachExperienceYears = 'coachExperienceYears',
  /** column name */
  CoachStatus = 'coachStatus',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DefaultSport = 'defaultSport',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Gender = 'gender',
  /** column name */
  GenderPreference = 'genderPreference',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedTennisRating = 'normalizedTennisRating',
  /** column name */
  NormalizedTennisRatingScaleId = 'normalizedTennisRatingScaleId',
  /** column name */
  PickleballSkillLevelId = 'pickleballSkillLevelId',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  ProfileImageFileName = 'profileImageFileName',
  /** column name */
  ProfileImagePath = 'profileImagePath',
  /** column name */
  ProfileImageProvider = 'profileImageProvider',
  /** column name */
  ProfileImageProviderUrl = 'profileImageProviderUrl',
  /** column name */
  TennisRating = 'tennisRating',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TennisSkillLevelId = 'tennisSkillLevelId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username'
}

/** Streaming cursor of the table "user_profiles" */
export type UserProfilesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserProfilesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserProfilesStreamCursorValueInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<Scalars['String']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultSport?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  genderPreference?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "user_terms_of_service" */
export type UserTermsOfService = {
  __typename?: 'UserTermsOfService';
  acceptedAt: Scalars['timestamptz'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  ip: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userAgent: Scalars['String'];
  userId: Scalars['uuid'];
};

/** order by aggregate values of table "user_terms_of_service" */
export type UserTermsOfServiceAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserTermsOfServiceMaxOrderBy>;
  min?: InputMaybe<UserTermsOfServiceMinOrderBy>;
};

/** Boolean expression to filter rows from the table "user_terms_of_service". All fields are combined with a logical 'AND'. */
export type UserTermsOfServiceBoolExp = {
  _and?: InputMaybe<Array<UserTermsOfServiceBoolExp>>;
  _not?: InputMaybe<UserTermsOfServiceBoolExp>;
  _or?: InputMaybe<Array<UserTermsOfServiceBoolExp>>;
  acceptedAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ip?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userAgent?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_terms_of_service" */
export enum UserTermsOfServiceConstraint {
  /** unique or primary key constraint on columns "id" */
  UserTermsOfServicePkey = 'user_terms_of_service_pkey'
}

/** input type for inserting data into table "user_terms_of_service" */
export type UserTermsOfServiceInsertInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']>;
  ip?: InputMaybe<Scalars['String']>;
  userAgent?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_terms_of_service" */
export type UserTermsOfServiceMaxOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "user_terms_of_service" */
export type UserTermsOfServiceMinOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_terms_of_service" */
export type UserTermsOfServiceMutationResponse = {
  __typename?: 'UserTermsOfServiceMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserTermsOfService>;
};

/** on_conflict condition type for table "user_terms_of_service" */
export type UserTermsOfServiceOnConflict = {
  constraint: UserTermsOfServiceConstraint;
  updateColumns?: Array<UserTermsOfServiceUpdateColumn>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};

/** Ordering options when selecting data from "user_terms_of_service". */
export type UserTermsOfServiceOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "user_terms_of_service" */
export enum UserTermsOfServiceSelectColumn {
  /** column name */
  AcceptedAt = 'acceptedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserAgent = 'userAgent',
  /** column name */
  UserId = 'userId'
}

/** Streaming cursor of the table "user_terms_of_service" */
export type UserTermsOfServiceStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserTermsOfServiceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserTermsOfServiceStreamCursorValueInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userAgent?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** placeholder for update columns of table "user_terms_of_service" (current role has no relevant permissions) */
export enum UserTermsOfServiceUpdateColumn {
  /** placeholder (do not use) */
  Placeholder = '_PLACEHOLDER'
}

/** columns and relationships of "usernames_active" */
export type UsernamesActive = {
  __typename?: 'UsernamesActive';
  username?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "usernames_active". All fields are combined with a logical 'AND'. */
export type UsernamesActiveBoolExp = {
  _and?: InputMaybe<Array<UsernamesActiveBoolExp>>;
  _not?: InputMaybe<UsernamesActiveBoolExp>;
  _or?: InputMaybe<Array<UsernamesActiveBoolExp>>;
  username?: InputMaybe<StringComparisonExp>;
};

/** Ordering options when selecting data from "usernames_active". */
export type UsernamesActiveOrderBy = {
  username?: InputMaybe<OrderBy>;
};

/** select columns of table "usernames_active" */
export enum UsernamesActiveSelectColumn {
  /** column name */
  Username = 'username'
}

/** Streaming cursor of the table "usernames_active" */
export type UsernamesActiveStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsernamesActiveStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsernamesActiveStreamCursorValueInput = {
  username?: InputMaybe<Scalars['String']>;
};

/** This table prevents reserved words from being used or old usernames being claimed for where identity takeover can happen */
export type UsernamesClaimed = {
  __typename?: 'UsernamesClaimed';
  id: Scalars['uuid'];
  username: Scalars['String'];
};

/** order by aggregate values of table "usernames_claimed" */
export type UsernamesClaimedAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UsernamesClaimedMaxOrderBy>;
  min?: InputMaybe<UsernamesClaimedMinOrderBy>;
};

/** Boolean expression to filter rows from the table "usernames_claimed". All fields are combined with a logical 'AND'. */
export type UsernamesClaimedBoolExp = {
  _and?: InputMaybe<Array<UsernamesClaimedBoolExp>>;
  _not?: InputMaybe<UsernamesClaimedBoolExp>;
  _or?: InputMaybe<Array<UsernamesClaimedBoolExp>>;
  id?: InputMaybe<UuidComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
};

/** order by max() on columns of table "usernames_claimed" */
export type UsernamesClaimedMaxOrderBy = {
  id?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "usernames_claimed" */
export type UsernamesClaimedMinOrderBy = {
  id?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "usernames_claimed". */
export type UsernamesClaimedOrderBy = {
  id?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** select columns of table "usernames_claimed" */
export enum UsernamesClaimedSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Username = 'username'
}

/** Streaming cursor of the table "usernames_claimed" */
export type UsernamesClaimedStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsernamesClaimedStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsernamesClaimedStreamCursorValueInput = {
  id?: InputMaybe<Scalars['uuid']>;
  username?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'Users';
  aboutMe: Scalars['String'];
  aboutMeVideoUrl: Scalars['String'];
  /** An object relationship */
  activeCity?: Maybe<Cities>;
  activeCityId?: Maybe<Scalars['uuid']>;
  birthday?: Maybe<Scalars['date']>;
  cityName: Scalars['String'];
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears: Scalars['numeric'];
  /** An array relationship */
  coachLessons: Array<Lessons>;
  /** An aggregate relationship */
  coachLessonsAggregate: LessonsAggregate;
  /** An array relationship */
  coachQualifications: Array<UsersCoachQualifications>;
  /** An array relationship */
  coachServices: Array<UserCoachServices>;
  coachStatus?: Maybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  communicationPreferences?: Maybe<UserCommunicationPreferences>;
  /** An object relationship */
  country?: Maybe<Countries>;
  countryId?: Maybe<Scalars['String']>;
  /** An object relationship */
  countrySubdivision?: Maybe<CountrySubdivisions>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  /** An array relationship */
  creditCards: Array<UserCreditCards>;
  /** An array relationship */
  customCourts: Array<UserCustomCourts>;
  defaultCoachPaymentFulfillmentChannel?: Maybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: Maybe<Scalars['uuid']>;
  defaultSport?: Maybe<SportsEnum>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  derfaultCreditCard?: Maybe<UserCreditCards>;
  duprId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  eventOrganizerAccountType: EventOrganizerAccountTypesEnum;
  firebaseId: Scalars['String'];
  /** An array relationship */
  followers: Array<UserFollows>;
  /** An aggregate relationship */
  followersAggregate: UserFollowsAggregate;
  /** An array relationship */
  following: Array<UserFollows>;
  /** An aggregate relationship */
  followingAggregate: UserFollowsAggregate;
  fullName: Scalars['String'];
  gender?: Maybe<GenderEnum>;
  genderPreference: Scalars['String'];
  geometry?: Maybe<Scalars['geography']>;
  /** An array relationship */
  groups: Array<GroupMembers>;
  /** An aggregate relationship */
  groupsAggregate: GroupMembersAggregate;
  id: Scalars['uuid'];
  isMarketingRegistered?: Maybe<Scalars['Boolean']>;
  isOnboardComplete: Scalars['Boolean'];
  latestAuthProvider: Scalars['String'];
  latitude?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  lessonTemplates: Array<LessonTemplates>;
  longitude?: Maybe<Scalars['numeric']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  normalizedTennisRatingScale?: Maybe<TennisRatingScales>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  notifications: Array<UserNotifications>;
  /** An aggregate relationship */
  notificationsAggregate: UserNotificationsAggregate;
  originalAuthProvider: Scalars['String'];
  /** An array relationship */
  participantLessons: Array<LessonParticipants>;
  /** An aggregate relationship */
  participantLessonsAggregate: LessonParticipantsAggregate;
  phoneNumber?: Maybe<Scalars['String']>;
  /** An object relationship */
  pickleballSkillLevel?: Maybe<SkillLevels>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName: Scalars['String'];
  /** An object relationship */
  profile?: Maybe<UserProfiles>;
  profileImageFileName: Scalars['String'];
  profileImagePath: Scalars['String'];
  profileImageProvider: Scalars['String'];
  profileImageProviderId: Scalars['String'];
  profileImageProviderUrl: Scalars['String'];
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl: Scalars['String'];
  stripeCustomerId: Scalars['String'];
  stripeMerchantBusinessType?: Maybe<Scalars['String']>;
  stripeMerchantChargesEnabled: Scalars['Boolean'];
  stripeMerchantCountry?: Maybe<Scalars['String']>;
  stripeMerchantCurrency?: Maybe<Scalars['String']>;
  stripeMerchantCurrentlyDue?: Maybe<Scalars['jsonb']>;
  stripeMerchantDetailsSubmitted: Scalars['Boolean'];
  stripeMerchantEventuallyDue?: Maybe<Scalars['jsonb']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripeMerchantPastDue?: Maybe<Scalars['jsonb']>;
  stripeMerchantPayoutsEnabled: Scalars['Boolean'];
  tennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  tennisSkillLevel?: Maybe<SkillLevels>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  /** An array relationship */
  termsOfService: Array<UserTermsOfService>;
  updatedAt: Scalars['timestamptz'];
  username?: Maybe<Scalars['String']>;
  /** An array relationship */
  usernamesClaimed: Array<UsernamesClaimed>;
};


/** columns and relationships of "users" */
export type UsersCoachLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreditCardsArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCustomCourtsArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowersArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowingArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowingAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersLessonTemplatesArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersParticipantLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersParticipantLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersStripeMerchantCurrentlyDueArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersStripeMerchantEventuallyDueArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersStripeMerchantPastDueArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersTermsOfServiceArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsernamesClaimedArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type UsersBoolExp = {
  _and?: InputMaybe<Array<UsersBoolExp>>;
  _not?: InputMaybe<UsersBoolExp>;
  _or?: InputMaybe<Array<UsersBoolExp>>;
  aboutMe?: InputMaybe<StringComparisonExp>;
  aboutMeVideoUrl?: InputMaybe<StringComparisonExp>;
  activeCity?: InputMaybe<CitiesBoolExp>;
  activeCityId?: InputMaybe<UuidComparisonExp>;
  birthday?: InputMaybe<DateComparisonExp>;
  cityName?: InputMaybe<StringComparisonExp>;
  coachExperienceSetAt?: InputMaybe<TimestamptzComparisonExp>;
  coachExperienceYears?: InputMaybe<NumericComparisonExp>;
  coachLessons?: InputMaybe<LessonsBoolExp>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateBoolExp>;
  coachQualifications?: InputMaybe<UsersCoachQualificationsBoolExp>;
  coachServices?: InputMaybe<UserCoachServicesBoolExp>;
  coachStatus?: InputMaybe<CoachStatusEnumComparisonExp>;
  coachStatusUpdatedAt?: InputMaybe<TimestamptzComparisonExp>;
  communicationPreferences?: InputMaybe<UserCommunicationPreferencesBoolExp>;
  country?: InputMaybe<CountriesBoolExp>;
  countryId?: InputMaybe<StringComparisonExp>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsBoolExp>;
  countrySubdivisionId?: InputMaybe<UuidComparisonExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderId?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creditCards?: InputMaybe<UserCreditCardsBoolExp>;
  customCourts?: InputMaybe<UserCustomCourtsBoolExp>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnumComparisonExp>;
  defaultCreditCardId?: InputMaybe<UuidComparisonExp>;
  defaultSport?: InputMaybe<SportsEnumComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  derfaultCreditCard?: InputMaybe<UserCreditCardsBoolExp>;
  duprId?: InputMaybe<StringComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnumComparisonExp>;
  firebaseId?: InputMaybe<StringComparisonExp>;
  followers?: InputMaybe<UserFollowsBoolExp>;
  followersAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  following?: InputMaybe<UserFollowsBoolExp>;
  followingAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  fullName?: InputMaybe<StringComparisonExp>;
  gender?: InputMaybe<GenderEnumComparisonExp>;
  genderPreference?: InputMaybe<StringComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groups?: InputMaybe<GroupMembersBoolExp>;
  groupsAggregate?: InputMaybe<GroupMembersAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isMarketingRegistered?: InputMaybe<BooleanComparisonExp>;
  isOnboardComplete?: InputMaybe<BooleanComparisonExp>;
  latestAuthProvider?: InputMaybe<StringComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  lessonTemplates?: InputMaybe<LessonTemplatesBoolExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  normalizedTennisRating?: InputMaybe<NumericComparisonExp>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  normalizedTennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  notifications?: InputMaybe<UserNotificationsBoolExp>;
  notificationsAggregate?: InputMaybe<UserNotificationsAggregateBoolExp>;
  originalAuthProvider?: InputMaybe<StringComparisonExp>;
  participantLessons?: InputMaybe<LessonParticipantsBoolExp>;
  participantLessonsAggregate?: InputMaybe<LessonParticipantsAggregateBoolExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  pickleballSkillLevelId?: InputMaybe<StringComparisonExp>;
  preferredName?: InputMaybe<StringComparisonExp>;
  profile?: InputMaybe<UserProfilesBoolExp>;
  profileImageFileName?: InputMaybe<StringComparisonExp>;
  profileImagePath?: InputMaybe<StringComparisonExp>;
  profileImageProvider?: InputMaybe<StringComparisonExp>;
  profileImageProviderId?: InputMaybe<StringComparisonExp>;
  profileImageProviderUrl?: InputMaybe<StringComparisonExp>;
  profileImageUrl?: InputMaybe<StringComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripeMerchantBusinessType?: InputMaybe<StringComparisonExp>;
  stripeMerchantChargesEnabled?: InputMaybe<BooleanComparisonExp>;
  stripeMerchantCountry?: InputMaybe<StringComparisonExp>;
  stripeMerchantCurrency?: InputMaybe<StringComparisonExp>;
  stripeMerchantCurrentlyDue?: InputMaybe<JsonbComparisonExp>;
  stripeMerchantDetailsSubmitted?: InputMaybe<BooleanComparisonExp>;
  stripeMerchantEventuallyDue?: InputMaybe<JsonbComparisonExp>;
  stripeMerchantId?: InputMaybe<StringComparisonExp>;
  stripeMerchantPastDue?: InputMaybe<JsonbComparisonExp>;
  stripeMerchantPayoutsEnabled?: InputMaybe<BooleanComparisonExp>;
  tennisRating?: InputMaybe<NumericComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  tennisSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  tennisSkillLevelId?: InputMaybe<StringComparisonExp>;
  termsOfService?: InputMaybe<UserTermsOfServiceBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
  usernamesClaimed?: InputMaybe<UsernamesClaimedBoolExp>;
};

/** columns and relationships of "users_coach_qualifications" */
export type UsersCoachQualifications = {
  __typename?: 'UsersCoachQualifications';
  coachQualificationId: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  qualification: CoachQualifications;
  status: CoachQualificationStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** order by aggregate values of table "users_coach_qualifications" */
export type UsersCoachQualificationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UsersCoachQualificationsMaxOrderBy>;
  min?: InputMaybe<UsersCoachQualificationsMinOrderBy>;
};

/** Boolean expression to filter rows from the table "users_coach_qualifications". All fields are combined with a logical 'AND'. */
export type UsersCoachQualificationsBoolExp = {
  _and?: InputMaybe<Array<UsersCoachQualificationsBoolExp>>;
  _not?: InputMaybe<UsersCoachQualificationsBoolExp>;
  _or?: InputMaybe<Array<UsersCoachQualificationsBoolExp>>;
  coachQualificationId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  qualification?: InputMaybe<CoachQualificationsBoolExp>;
  status?: InputMaybe<CoachQualificationStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "users_coach_qualifications" */
export enum UsersCoachQualificationsConstraint {
  /** unique or primary key constraint on columns "id" */
  UsersCoachQualificationsPkey = 'users_coach_qualifications_pkey',
  /** unique or primary key constraint on columns "user_id", "coach_qualification_id" */
  UsersCoachQualificationsUserIdCoachQualificationIdKey = 'users_coach_qualifications_user_id_coach_qualification_id_key'
}

/** input type for inserting data into table "users_coach_qualifications" */
export type UsersCoachQualificationsInsertInput = {
  coachQualificationId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<CoachQualificationStatusesEnum>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** order by max() on columns of table "users_coach_qualifications" */
export type UsersCoachQualificationsMaxOrderBy = {
  coachQualificationId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "users_coach_qualifications" */
export type UsersCoachQualificationsMinOrderBy = {
  coachQualificationId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "users_coach_qualifications" */
export type UsersCoachQualificationsMutationResponse = {
  __typename?: 'UsersCoachQualificationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UsersCoachQualifications>;
};

/** on_conflict condition type for table "users_coach_qualifications" */
export type UsersCoachQualificationsOnConflict = {
  constraint: UsersCoachQualificationsConstraint;
  updateColumns?: Array<UsersCoachQualificationsUpdateColumn>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};

/** Ordering options when selecting data from "users_coach_qualifications". */
export type UsersCoachQualificationsOrderBy = {
  coachQualificationId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  qualification?: InputMaybe<CoachQualificationsOrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: users_coach_qualifications */
export type UsersCoachQualificationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "users_coach_qualifications" */
export enum UsersCoachQualificationsSelectColumn {
  /** column name */
  CoachQualificationId = 'coachQualificationId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "users_coach_qualifications" */
export type UsersCoachQualificationsSetInput = {
  status?: InputMaybe<CoachQualificationStatusesEnum>;
};

/** Streaming cursor of the table "users_coach_qualifications" */
export type UsersCoachQualificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersCoachQualificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersCoachQualificationsStreamCursorValueInput = {
  coachQualificationId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<CoachQualificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "users_coach_qualifications" */
export enum UsersCoachQualificationsUpdateColumn {
  /** column name */
  Status = 'status'
}

export type UsersCoachQualificationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersCoachQualificationsSetInput>;
  /** filter the rows which have to be updated */
  where: UsersCoachQualificationsBoolExp;
};

/** input type for incrementing numeric columns in table "users" */
export type UsersIncInput = {
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
};

/** response of any mutation on the table "users" */
export type UsersMutationResponse = {
  __typename?: 'UsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** Ordering options when selecting data from "users". */
export type UsersOrderBy = {
  aboutMe?: InputMaybe<OrderBy>;
  aboutMeVideoUrl?: InputMaybe<OrderBy>;
  activeCity?: InputMaybe<CitiesOrderBy>;
  activeCityId?: InputMaybe<OrderBy>;
  birthday?: InputMaybe<OrderBy>;
  cityName?: InputMaybe<OrderBy>;
  coachExperienceSetAt?: InputMaybe<OrderBy>;
  coachExperienceYears?: InputMaybe<OrderBy>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateOrderBy>;
  coachQualificationsAggregate?: InputMaybe<UsersCoachQualificationsAggregateOrderBy>;
  coachServicesAggregate?: InputMaybe<UserCoachServicesAggregateOrderBy>;
  coachStatus?: InputMaybe<OrderBy>;
  coachStatusUpdatedAt?: InputMaybe<OrderBy>;
  communicationPreferences?: InputMaybe<UserCommunicationPreferencesOrderBy>;
  country?: InputMaybe<CountriesOrderBy>;
  countryId?: InputMaybe<OrderBy>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsOrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creditCardsAggregate?: InputMaybe<UserCreditCardsAggregateOrderBy>;
  customCourtsAggregate?: InputMaybe<UserCustomCourtsAggregateOrderBy>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<OrderBy>;
  defaultCreditCardId?: InputMaybe<OrderBy>;
  defaultSport?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  derfaultCreditCard?: InputMaybe<UserCreditCardsOrderBy>;
  duprId?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  eventOrganizerAccountType?: InputMaybe<OrderBy>;
  firebaseId?: InputMaybe<OrderBy>;
  followersAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  followingAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  fullName?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  genderPreference?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<GroupMembersAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isMarketingRegistered?: InputMaybe<OrderBy>;
  isOnboardComplete?: InputMaybe<OrderBy>;
  latestAuthProvider?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  lessonTemplatesAggregate?: InputMaybe<LessonTemplatesAggregateOrderBy>;
  longitude?: InputMaybe<OrderBy>;
  normalizedTennisRating?: InputMaybe<OrderBy>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  normalizedTennisRatingScaleId?: InputMaybe<OrderBy>;
  notificationsAggregate?: InputMaybe<UserNotificationsAggregateOrderBy>;
  originalAuthProvider?: InputMaybe<OrderBy>;
  participantLessonsAggregate?: InputMaybe<LessonParticipantsAggregateOrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  pickleballSkillLevelId?: InputMaybe<OrderBy>;
  preferredName?: InputMaybe<OrderBy>;
  profile?: InputMaybe<UserProfilesOrderBy>;
  profileImageFileName?: InputMaybe<OrderBy>;
  profileImagePath?: InputMaybe<OrderBy>;
  profileImageProvider?: InputMaybe<OrderBy>;
  profileImageProviderId?: InputMaybe<OrderBy>;
  profileImageProviderUrl?: InputMaybe<OrderBy>;
  profileImageUrl?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantBusinessType?: InputMaybe<OrderBy>;
  stripeMerchantChargesEnabled?: InputMaybe<OrderBy>;
  stripeMerchantCountry?: InputMaybe<OrderBy>;
  stripeMerchantCurrency?: InputMaybe<OrderBy>;
  stripeMerchantCurrentlyDue?: InputMaybe<OrderBy>;
  stripeMerchantDetailsSubmitted?: InputMaybe<OrderBy>;
  stripeMerchantEventuallyDue?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripeMerchantPastDue?: InputMaybe<OrderBy>;
  stripeMerchantPayoutsEnabled?: InputMaybe<OrderBy>;
  tennisRating?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  tennisSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  tennisSkillLevelId?: InputMaybe<OrderBy>;
  termsOfServiceAggregate?: InputMaybe<UserTermsOfServiceAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
  usernamesClaimedAggregate?: InputMaybe<UsernamesClaimedAggregateOrderBy>;
};

/** primary key columns input for table: users */
export type UsersPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "users" */
export enum UsersSelectColumn {
  /** column name */
  AboutMe = 'aboutMe',
  /** column name */
  AboutMeVideoUrl = 'aboutMeVideoUrl',
  /** column name */
  ActiveCityId = 'activeCityId',
  /** column name */
  Birthday = 'birthday',
  /** column name */
  CityName = 'cityName',
  /** column name */
  CoachExperienceSetAt = 'coachExperienceSetAt',
  /** column name */
  CoachExperienceYears = 'coachExperienceYears',
  /** column name */
  CoachStatus = 'coachStatus',
  /** column name */
  CoachStatusUpdatedAt = 'coachStatusUpdatedAt',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DefaultCoachPaymentFulfillmentChannel = 'defaultCoachPaymentFulfillmentChannel',
  /** column name */
  DefaultCreditCardId = 'defaultCreditCardId',
  /** column name */
  DefaultSport = 'defaultSport',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  Email = 'email',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FirebaseId = 'firebaseId',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Gender = 'gender',
  /** column name */
  GenderPreference = 'genderPreference',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  IsMarketingRegistered = 'isMarketingRegistered',
  /** column name */
  IsOnboardComplete = 'isOnboardComplete',
  /** column name */
  LatestAuthProvider = 'latestAuthProvider',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  NormalizedTennisRating = 'normalizedTennisRating',
  /** column name */
  NormalizedTennisRatingScaleId = 'normalizedTennisRatingScaleId',
  /** column name */
  OriginalAuthProvider = 'originalAuthProvider',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PickleballSkillLevelId = 'pickleballSkillLevelId',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  ProfileImageFileName = 'profileImageFileName',
  /** column name */
  ProfileImagePath = 'profileImagePath',
  /** column name */
  ProfileImageProvider = 'profileImageProvider',
  /** column name */
  ProfileImageProviderId = 'profileImageProviderId',
  /** column name */
  ProfileImageProviderUrl = 'profileImageProviderUrl',
  /** column name */
  ProfileImageUrl = 'profileImageUrl',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantBusinessType = 'stripeMerchantBusinessType',
  /** column name */
  StripeMerchantChargesEnabled = 'stripeMerchantChargesEnabled',
  /** column name */
  StripeMerchantCountry = 'stripeMerchantCountry',
  /** column name */
  StripeMerchantCurrency = 'stripeMerchantCurrency',
  /** column name */
  StripeMerchantCurrentlyDue = 'stripeMerchantCurrentlyDue',
  /** column name */
  StripeMerchantDetailsSubmitted = 'stripeMerchantDetailsSubmitted',
  /** column name */
  StripeMerchantEventuallyDue = 'stripeMerchantEventuallyDue',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripeMerchantPastDue = 'stripeMerchantPastDue',
  /** column name */
  StripeMerchantPayoutsEnabled = 'stripeMerchantPayoutsEnabled',
  /** column name */
  TennisRating = 'tennisRating',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TennisSkillLevelId = 'tennisSkillLevelId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username'
}

/** input type for updating data in table "users" */
export type UsersSetInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  birthday?: InputMaybe<Scalars['date']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: InputMaybe<Scalars['String']>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: InputMaybe<Scalars['uuid']>;
  defaultSport?: InputMaybe<SportsEnum>;
  duprId?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderEnum>;
  genderPreference?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  isMarketingRegistered?: InputMaybe<Scalars['Boolean']>;
  isOnboardComplete?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderId?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: InputMaybe<Scalars['String']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "users" */
export type UsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersStreamCursorValueInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  birthday?: InputMaybe<Scalars['date']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: InputMaybe<Scalars['uuid']>;
  defaultSport?: InputMaybe<SportsEnum>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  firebaseId?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderEnum>;
  genderPreference?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  isMarketingRegistered?: InputMaybe<Scalars['Boolean']>;
  isOnboardComplete?: InputMaybe<Scalars['Boolean']>;
  latestAuthProvider?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  originalAuthProvider?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderId?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantBusinessType?: InputMaybe<Scalars['String']>;
  stripeMerchantChargesEnabled?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantCountry?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrency?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantDetailsSubmitted?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantPayoutsEnabled?: InputMaybe<Scalars['Boolean']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

export type UsersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UsersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersSetInput>;
  /** filter the rows which have to be updated */
  where: UsersBoolExp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidComparisonExp = {
  _eq?: InputMaybe<Scalars['uuid']>;
  _gt?: InputMaybe<Scalars['uuid']>;
  _gte?: InputMaybe<Scalars['uuid']>;
  _in?: InputMaybe<Array<Scalars['uuid']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['uuid']>;
  _lte?: InputMaybe<Scalars['uuid']>;
  _neq?: InputMaybe<Scalars['uuid']>;
  _nin?: InputMaybe<Array<Scalars['uuid']>>;
};

/** columns and relationships of "venue_access_types" */
export type VenueAccessTypes = {
  __typename?: 'VenueAccessTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "venue_access_types". All fields are combined with a logical 'AND'. */
export type VenueAccessTypesBoolExp = {
  _and?: InputMaybe<Array<VenueAccessTypesBoolExp>>;
  _not?: InputMaybe<VenueAccessTypesBoolExp>;
  _or?: InputMaybe<Array<VenueAccessTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum VenueAccessTypesEnum {
  Free = 'FREE',
  Membership = 'MEMBERSHIP',
  NeedsAudit = 'NEEDS_AUDIT',
  OneTime = 'ONE_TIME',
  Private = 'PRIVATE'
}

/** Boolean expression to compare columns of type "VenueAccessTypesEnum". All fields are combined with logical 'AND'. */
export type VenueAccessTypesEnumComparisonExp = {
  _eq?: InputMaybe<VenueAccessTypesEnum>;
  _in?: InputMaybe<Array<VenueAccessTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueAccessTypesEnum>;
  _nin?: InputMaybe<Array<VenueAccessTypesEnum>>;
};

/** Ordering options when selecting data from "venue_access_types". */
export type VenueAccessTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_access_types" */
export enum VenueAccessTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "venue_access_types" */
export type VenueAccessTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueAccessTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueAccessTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "venue_amenities" */
export type VenueAmenities = {
  __typename?: 'VenueAmenities';
  amenity: AmenitiesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** order by aggregate values of table "venue_amenities" */
export type VenueAmenitiesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenueAmenitiesMaxOrderBy>;
  min?: InputMaybe<VenueAmenitiesMinOrderBy>;
};

/** Boolean expression to filter rows from the table "venue_amenities". All fields are combined with a logical 'AND'. */
export type VenueAmenitiesBoolExp = {
  _and?: InputMaybe<Array<VenueAmenitiesBoolExp>>;
  _not?: InputMaybe<VenueAmenitiesBoolExp>;
  _or?: InputMaybe<Array<VenueAmenitiesBoolExp>>;
  amenity?: InputMaybe<AmenitiesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** order by max() on columns of table "venue_amenities" */
export type VenueAmenitiesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "venue_amenities" */
export type VenueAmenitiesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "venue_amenities". */
export type VenueAmenitiesOrderBy = {
  amenity?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_amenities" */
export enum VenueAmenitiesSelectColumn {
  /** column name */
  Amenity = 'amenity',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

/** Streaming cursor of the table "venue_amenities" */
export type VenueAmenitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueAmenitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueAmenitiesStreamCursorValueInput = {
  amenity?: InputMaybe<AmenitiesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "venue_court_surfaces" */
export type VenueCourtSurfaces = {
  __typename?: 'VenueCourtSurfaces';
  courtSurface: CourtSurfacesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** order by aggregate values of table "venue_court_surfaces" */
export type VenueCourtSurfacesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenueCourtSurfacesMaxOrderBy>;
  min?: InputMaybe<VenueCourtSurfacesMinOrderBy>;
};

/** Boolean expression to filter rows from the table "venue_court_surfaces". All fields are combined with a logical 'AND'. */
export type VenueCourtSurfacesBoolExp = {
  _and?: InputMaybe<Array<VenueCourtSurfacesBoolExp>>;
  _not?: InputMaybe<VenueCourtSurfacesBoolExp>;
  _or?: InputMaybe<Array<VenueCourtSurfacesBoolExp>>;
  courtSurface?: InputMaybe<CourtSurfacesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** order by max() on columns of table "venue_court_surfaces" */
export type VenueCourtSurfacesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "venue_court_surfaces" */
export type VenueCourtSurfacesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "venue_court_surfaces". */
export type VenueCourtSurfacesOrderBy = {
  courtSurface?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_court_surfaces" */
export enum VenueCourtSurfacesSelectColumn {
  /** column name */
  CourtSurface = 'courtSurface',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

/** Streaming cursor of the table "venue_court_surfaces" */
export type VenueCourtSurfacesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueCourtSurfacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueCourtSurfacesStreamCursorValueInput = {
  courtSurface?: InputMaybe<CourtSurfacesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "venue_facility_types" */
export type VenueFacilityTypes = {
  __typename?: 'VenueFacilityTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "venue_facility_types". All fields are combined with a logical 'AND'. */
export type VenueFacilityTypesBoolExp = {
  _and?: InputMaybe<Array<VenueFacilityTypesBoolExp>>;
  _not?: InputMaybe<VenueFacilityTypesBoolExp>;
  _or?: InputMaybe<Array<VenueFacilityTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum VenueFacilityTypesEnum {
  Club = 'CLUB',
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  School = 'SCHOOL'
}

/** Boolean expression to compare columns of type "VenueFacilityTypesEnum". All fields are combined with logical 'AND'. */
export type VenueFacilityTypesEnumComparisonExp = {
  _eq?: InputMaybe<VenueFacilityTypesEnum>;
  _in?: InputMaybe<Array<VenueFacilityTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueFacilityTypesEnum>;
  _nin?: InputMaybe<Array<VenueFacilityTypesEnum>>;
};

/** Ordering options when selecting data from "venue_facility_types". */
export type VenueFacilityTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_facility_types" */
export enum VenueFacilityTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "venue_facility_types" */
export type VenueFacilityTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueFacilityTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueFacilityTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "venue_follows" */
export type VenueFollows = {
  __typename?: 'VenueFollows';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  status: FollowStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "venue_follows" */
export type VenueFollowsAggregate = {
  __typename?: 'VenueFollowsAggregate';
  aggregate?: Maybe<VenueFollowsAggregateFields>;
  nodes: Array<VenueFollows>;
};

/** aggregate fields of "venue_follows" */
export type VenueFollowsAggregateFields = {
  __typename?: 'VenueFollowsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueFollowsMaxFields>;
  min?: Maybe<VenueFollowsMinFields>;
};


/** aggregate fields of "venue_follows" */
export type VenueFollowsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue_follows". All fields are combined with a logical 'AND'. */
export type VenueFollowsBoolExp = {
  _and?: InputMaybe<Array<VenueFollowsBoolExp>>;
  _not?: InputMaybe<VenueFollowsBoolExp>;
  _or?: InputMaybe<Array<VenueFollowsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<FollowStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "venue_follows" */
export enum VenueFollowsConstraint {
  /** unique or primary key constraint on columns "id" */
  VenueFollowsPkey = 'venue_follows_pkey',
  /** unique or primary key constraint on columns "venue_id", "user_id" */
  VenueFollowsVenueIdUserIdKey = 'venue_follows_venue_id_user_id_key'
}

/** input type for inserting data into table "venue_follows" */
export type VenueFollowsInsertInput = {
  status?: InputMaybe<FollowStatusesEnum>;
  userId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type VenueFollowsMaxFields = {
  __typename?: 'VenueFollowsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type VenueFollowsMinFields = {
  __typename?: 'VenueFollowsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "venue_follows" */
export type VenueFollowsMutationResponse = {
  __typename?: 'VenueFollowsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueFollows>;
};

/** on_conflict condition type for table "venue_follows" */
export type VenueFollowsOnConflict = {
  constraint: VenueFollowsConstraint;
  updateColumns?: Array<VenueFollowsUpdateColumn>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};

/** Ordering options when selecting data from "venue_follows". */
export type VenueFollowsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_follows */
export type VenueFollowsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "venue_follows" */
export enum VenueFollowsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VenueId = 'venueId'
}

/** input type for updating data in table "venue_follows" */
export type VenueFollowsSetInput = {
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<FollowStatusesEnum>;
};

/** Streaming cursor of the table "venue_follows" */
export type VenueFollowsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueFollowsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueFollowsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "venue_follows" */
export enum VenueFollowsUpdateColumn {
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Status = 'status'
}

export type VenueFollowsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueFollowsSetInput>;
  /** filter the rows which have to be updated */
  where: VenueFollowsBoolExp;
};

/** columns and relationships of "venue_images" */
export type VenueImages = {
  __typename?: 'VenueImages';
  attributionHtml: Scalars['String'];
  attributionName: Scalars['String'];
  attributionUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName: Scalars['String'];
  id: Scalars['uuid'];
  isVisible: Scalars['Boolean'];
  path: Scalars['String'];
  provider: Scalars['String'];
  providerId: Scalars['String'];
  providerUrl: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  url: Scalars['String'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** order by aggregate values of table "venue_images" */
export type VenueImagesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenueImagesMaxOrderBy>;
  min?: InputMaybe<VenueImagesMinOrderBy>;
};

/** Boolean expression to filter rows from the table "venue_images". All fields are combined with a logical 'AND'. */
export type VenueImagesBoolExp = {
  _and?: InputMaybe<Array<VenueImagesBoolExp>>;
  _not?: InputMaybe<VenueImagesBoolExp>;
  _or?: InputMaybe<Array<VenueImagesBoolExp>>;
  attributionHtml?: InputMaybe<StringComparisonExp>;
  attributionName?: InputMaybe<StringComparisonExp>;
  attributionUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fileName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isVisible?: InputMaybe<BooleanComparisonExp>;
  path?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerId?: InputMaybe<StringComparisonExp>;
  providerUrl?: InputMaybe<StringComparisonExp>;
  source?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** order by max() on columns of table "venue_images" */
export type VenueImagesMaxOrderBy = {
  attributionHtml?: InputMaybe<OrderBy>;
  attributionName?: InputMaybe<OrderBy>;
  attributionUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "venue_images" */
export type VenueImagesMinOrderBy = {
  attributionHtml?: InputMaybe<OrderBy>;
  attributionName?: InputMaybe<OrderBy>;
  attributionUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "venue_images". */
export type VenueImagesOrderBy = {
  attributionHtml?: InputMaybe<OrderBy>;
  attributionName?: InputMaybe<OrderBy>;
  attributionUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isVisible?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_images" */
export enum VenueImagesSelectColumn {
  /** column name */
  AttributionHtml = 'attributionHtml',
  /** column name */
  AttributionName = 'attributionName',
  /** column name */
  AttributionUrl = 'attributionUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  Id = 'id',
  /** column name */
  IsVisible = 'isVisible',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  Source = 'source',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  VenueId = 'venueId'
}

/** Streaming cursor of the table "venue_images" */
export type VenueImagesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueImagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueImagesStreamCursorValueInput = {
  attributionHtml?: InputMaybe<Scalars['String']>;
  attributionName?: InputMaybe<Scalars['String']>;
  attributionUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "venue_lines" */
export type VenueLines = {
  __typename?: 'VenueLines';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "venue_lines". All fields are combined with a logical 'AND'. */
export type VenueLinesBoolExp = {
  _and?: InputMaybe<Array<VenueLinesBoolExp>>;
  _not?: InputMaybe<VenueLinesBoolExp>;
  _or?: InputMaybe<Array<VenueLinesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum VenueLinesEnum {
  Chalk = 'CHALK',
  Permanent = 'PERMANENT',
  Tape = 'TAPE',
  Temporary = 'TEMPORARY'
}

/** Boolean expression to compare columns of type "VenueLinesEnum". All fields are combined with logical 'AND'. */
export type VenueLinesEnumComparisonExp = {
  _eq?: InputMaybe<VenueLinesEnum>;
  _in?: InputMaybe<Array<VenueLinesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueLinesEnum>;
  _nin?: InputMaybe<Array<VenueLinesEnum>>;
};

/** Ordering options when selecting data from "venue_lines". */
export type VenueLinesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_lines" */
export enum VenueLinesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "venue_lines" */
export type VenueLinesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueLinesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueLinesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "venue_nets" */
export type VenueNets = {
  __typename?: 'VenueNets';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "venue_nets". All fields are combined with a logical 'AND'. */
export type VenueNetsBoolExp = {
  _and?: InputMaybe<Array<VenueNetsBoolExp>>;
  _not?: InputMaybe<VenueNetsBoolExp>;
  _or?: InputMaybe<Array<VenueNetsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum VenueNetsEnum {
  BringYourOwn = 'BRING_YOUR_OWN',
  Permanent = 'PERMANENT',
  Portable = 'PORTABLE',
  Tennis = 'TENNIS'
}

/** Boolean expression to compare columns of type "VenueNetsEnum". All fields are combined with logical 'AND'. */
export type VenueNetsEnumComparisonExp = {
  _eq?: InputMaybe<VenueNetsEnum>;
  _in?: InputMaybe<Array<VenueNetsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueNetsEnum>;
  _nin?: InputMaybe<Array<VenueNetsEnum>>;
};

/** Ordering options when selecting data from "venue_nets". */
export type VenueNetsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "venue_nets" */
export enum VenueNetsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "venue_nets" */
export type VenueNetsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueNetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueNetsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "venues" */
export type Venues = {
  __typename?: 'Venues';
  accessDetails: Scalars['String'];
  accessType?: Maybe<VenueAccessTypesEnum>;
  addressString: Scalars['String'];
  /** An array relationship */
  amenities: Array<VenueAmenities>;
  /** An object relationship */
  city?: Maybe<Cities>;
  cityId?: Maybe<Scalars['uuid']>;
  coordinatesWkb: Scalars['String'];
  /** An array relationship */
  courtSurfaces: Array<VenueCourtSurfaces>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  facilityType?: Maybe<VenueFacilityTypesEnum>;
  featuredPriority?: Maybe<Scalars['Int']>;
  geometry?: Maybe<Scalars['geography']>;
  /** An array relationship */
  groups: Array<GroupVenues>;
  /** An aggregate relationship */
  groupsAggregate: GroupVenuesAggregate;
  hasPickleball: Scalars['Boolean'];
  hasReservations?: Maybe<Scalars['Boolean']>;
  id: Scalars['uuid'];
  /** An array relationship */
  images: Array<VenueImages>;
  indoorCourtCount: Scalars['Int'];
  isActive: Scalars['Boolean'];
  latitude: Scalars['numeric'];
  longitude: Scalars['numeric'];
  outdoorCourtCount: Scalars['Int'];
  pickleballLines?: Maybe<VenueLinesEnum>;
  pickleballNets?: Maybe<VenueNetsEnum>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  scheduleDetails: Scalars['String'];
  shouldHideDefaultDescription: Scalars['Boolean'];
  slug: Scalars['String'];
  timezone: Scalars['String'];
  title: Scalars['String'];
  totalCourtCount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  venueSlug: Scalars['String'];
  websiteUrl: Scalars['String'];
};


/** columns and relationships of "venues" */
export type VenuesAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesImagesArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};

/** order by aggregate values of table "venues" */
export type VenuesAggregateOrderBy = {
  avg?: InputMaybe<VenuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenuesMaxOrderBy>;
  min?: InputMaybe<VenuesMinOrderBy>;
  stddev?: InputMaybe<VenuesStddevOrderBy>;
  stddevPop?: InputMaybe<VenuesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<VenuesStddevSampOrderBy>;
  sum?: InputMaybe<VenuesSumOrderBy>;
  varPop?: InputMaybe<VenuesVarPopOrderBy>;
  varSamp?: InputMaybe<VenuesVarSampOrderBy>;
  variance?: InputMaybe<VenuesVarianceOrderBy>;
};

/** order by avg() on columns of table "venues" */
export type VenuesAvgOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "venues". All fields are combined with a logical 'AND'. */
export type VenuesBoolExp = {
  _and?: InputMaybe<Array<VenuesBoolExp>>;
  _not?: InputMaybe<VenuesBoolExp>;
  _or?: InputMaybe<Array<VenuesBoolExp>>;
  accessDetails?: InputMaybe<StringComparisonExp>;
  accessType?: InputMaybe<VenueAccessTypesEnumComparisonExp>;
  addressString?: InputMaybe<StringComparisonExp>;
  amenities?: InputMaybe<VenueAmenitiesBoolExp>;
  city?: InputMaybe<CitiesBoolExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  coordinatesWkb?: InputMaybe<StringComparisonExp>;
  courtSurfaces?: InputMaybe<VenueCourtSurfacesBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  facilityType?: InputMaybe<VenueFacilityTypesEnumComparisonExp>;
  featuredPriority?: InputMaybe<IntComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groups?: InputMaybe<GroupVenuesBoolExp>;
  groupsAggregate?: InputMaybe<GroupVenuesAggregateBoolExp>;
  hasPickleball?: InputMaybe<BooleanComparisonExp>;
  hasReservations?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  images?: InputMaybe<VenueImagesBoolExp>;
  indoorCourtCount?: InputMaybe<IntComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  outdoorCourtCount?: InputMaybe<IntComparisonExp>;
  pickleballLines?: InputMaybe<VenueLinesEnumComparisonExp>;
  pickleballNets?: InputMaybe<VenueNetsEnumComparisonExp>;
  playSessions?: InputMaybe<PlaySessionsBoolExp>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateBoolExp>;
  scheduleDetails?: InputMaybe<StringComparisonExp>;
  shouldHideDefaultDescription?: InputMaybe<BooleanComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  totalCourtCount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venueSlug?: InputMaybe<StringComparisonExp>;
  websiteUrl?: InputMaybe<StringComparisonExp>;
};

/** order by max() on columns of table "venues" */
export type VenuesMaxOrderBy = {
  accessDetails?: InputMaybe<OrderBy>;
  addressString?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  coordinatesWkb?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  featuredPriority?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  scheduleDetails?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueSlug?: InputMaybe<OrderBy>;
  websiteUrl?: InputMaybe<OrderBy>;
};

/** order by min() on columns of table "venues" */
export type VenuesMinOrderBy = {
  accessDetails?: InputMaybe<OrderBy>;
  addressString?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  coordinatesWkb?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  featuredPriority?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  scheduleDetails?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueSlug?: InputMaybe<OrderBy>;
  websiteUrl?: InputMaybe<OrderBy>;
};

/** Ordering options when selecting data from "venues". */
export type VenuesOrderBy = {
  accessDetails?: InputMaybe<OrderBy>;
  accessType?: InputMaybe<OrderBy>;
  addressString?: InputMaybe<OrderBy>;
  amenitiesAggregate?: InputMaybe<VenueAmenitiesAggregateOrderBy>;
  city?: InputMaybe<CitiesOrderBy>;
  cityId?: InputMaybe<OrderBy>;
  coordinatesWkb?: InputMaybe<OrderBy>;
  courtSurfacesAggregate?: InputMaybe<VenueCourtSurfacesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  facilityType?: InputMaybe<OrderBy>;
  featuredPriority?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<GroupVenuesAggregateOrderBy>;
  hasPickleball?: InputMaybe<OrderBy>;
  hasReservations?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imagesAggregate?: InputMaybe<VenueImagesAggregateOrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  pickleballLines?: InputMaybe<OrderBy>;
  pickleballNets?: InputMaybe<OrderBy>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateOrderBy>;
  scheduleDetails?: InputMaybe<OrderBy>;
  shouldHideDefaultDescription?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueSlug?: InputMaybe<OrderBy>;
  websiteUrl?: InputMaybe<OrderBy>;
};

/** select columns of table "venues" */
export enum VenuesSelectColumn {
  /** column name */
  AccessDetails = 'accessDetails',
  /** column name */
  AccessType = 'accessType',
  /** column name */
  AddressString = 'addressString',
  /** column name */
  CityId = 'cityId',
  /** column name */
  CoordinatesWkb = 'coordinatesWkb',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  FacilityType = 'facilityType',
  /** column name */
  FeaturedPriority = 'featuredPriority',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  HasPickleball = 'hasPickleball',
  /** column name */
  HasReservations = 'hasReservations',
  /** column name */
  Id = 'id',
  /** column name */
  IndoorCourtCount = 'indoorCourtCount',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  OutdoorCourtCount = 'outdoorCourtCount',
  /** column name */
  PickleballLines = 'pickleballLines',
  /** column name */
  PickleballNets = 'pickleballNets',
  /** column name */
  ScheduleDetails = 'scheduleDetails',
  /** column name */
  ShouldHideDefaultDescription = 'shouldHideDefaultDescription',
  /** column name */
  Slug = 'slug',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Title = 'title',
  /** column name */
  TotalCourtCount = 'totalCourtCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueSlug = 'venueSlug',
  /** column name */
  WebsiteUrl = 'websiteUrl'
}

/** order by stddev() on columns of table "venues" */
export type VenuesStddevOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** order by stddevPop() on columns of table "venues" */
export type VenuesStddevPopOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** order by stddevSamp() on columns of table "venues" */
export type VenuesStddevSampOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "venues" */
export type VenuesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenuesStreamCursorValueInput = {
  accessDetails?: InputMaybe<Scalars['String']>;
  accessType?: InputMaybe<VenueAccessTypesEnum>;
  addressString?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  coordinatesWkb?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  facilityType?: InputMaybe<VenueFacilityTypesEnum>;
  featuredPriority?: InputMaybe<Scalars['Int']>;
  geometry?: InputMaybe<Scalars['geography']>;
  hasPickleball?: InputMaybe<Scalars['Boolean']>;
  hasReservations?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  indoorCourtCount?: InputMaybe<Scalars['Int']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  outdoorCourtCount?: InputMaybe<Scalars['Int']>;
  pickleballLines?: InputMaybe<VenueLinesEnum>;
  pickleballNets?: InputMaybe<VenueNetsEnum>;
  scheduleDetails?: InputMaybe<Scalars['String']>;
  shouldHideDefaultDescription?: InputMaybe<Scalars['Boolean']>;
  slug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  totalCourtCount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueSlug?: InputMaybe<Scalars['String']>;
  websiteUrl?: InputMaybe<Scalars['String']>;
};

/** order by sum() on columns of table "venues" */
export type VenuesSumOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** order by varPop() on columns of table "venues" */
export type VenuesVarPopOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** order by varSamp() on columns of table "venues" */
export type VenuesVarSampOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** order by variance() on columns of table "venues" */
export type VenuesVarianceOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "win_reasons" */
export type WinReasons = {
  __typename?: 'WinReasons';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** Boolean expression to filter rows from the table "win_reasons". All fields are combined with a logical 'AND'. */
export type WinReasonsBoolExp = {
  _and?: InputMaybe<Array<WinReasonsBoolExp>>;
  _not?: InputMaybe<WinReasonsBoolExp>;
  _or?: InputMaybe<Array<WinReasonsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

export enum WinReasonsEnum {
  Forfeit = 'FORFEIT',
  OrganizerSelected = 'ORGANIZER_SELECTED',
  Score = 'SCORE'
}

/** Boolean expression to compare columns of type "WinReasonsEnum". All fields are combined with logical 'AND'. */
export type WinReasonsEnumComparisonExp = {
  _eq?: InputMaybe<WinReasonsEnum>;
  _in?: InputMaybe<Array<WinReasonsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<WinReasonsEnum>;
  _nin?: InputMaybe<Array<WinReasonsEnum>>;
};

/** Ordering options when selecting data from "win_reasons". */
export type WinReasonsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** select columns of table "win_reasons" */
export enum WinReasonsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** Streaming cursor of the table "win_reasons" */
export type WinReasonsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: WinReasonsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type WinReasonsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type GroupCommentVotesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupCommentVotesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupMembersAggregateBoolExpBool_And = {
  arguments: GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupMembersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupMembersAggregateBoolExpBool_Or = {
  arguments: GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupMembersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupMembersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupMembersBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupThreadCommentsAggregateBoolExpBool_And = {
  arguments: GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupThreadCommentsAggregateBoolExpBool_Or = {
  arguments: GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupThreadCommentsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentsBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupVenuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupVenuesBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonParticipantsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonParticipantsBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonWaitlistsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonWaitlistsBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonsBoolExp>;
  predicate: IntComparisonExp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "lesson_equipment" */
  deleteLessonEquipment?: Maybe<LessonEquipmentMutationResponse>;
  /** delete single row from the table: "lesson_equipment" */
  deleteLessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** delete data from the table: "lesson_times" */
  deleteLessonTimes?: Maybe<LessonTimesMutationResponse>;
  /** delete single row from the table: "lesson_times" */
  deleteLessonTimesByPk?: Maybe<LessonTimes>;
  /** insert data into the table: "app_pings" */
  insertAppPings?: Maybe<AppPingsMutationResponse>;
  /** insert a single row into the table: "app_pings" */
  insertAppPingsOne?: Maybe<AppPings>;
  /** insert data into the table: "event_faqs" */
  insertEventFaqs?: Maybe<EventFaqsMutationResponse>;
  /** insert a single row into the table: "event_faqs" */
  insertEventFaqsOne?: Maybe<EventFaqs>;
  /** insert data into the table: "event_game_scores" */
  insertEventGameScores?: Maybe<EventGameScoresMutationResponse>;
  /** insert a single row into the table: "event_game_scores" */
  insertEventGameScoresOne?: Maybe<EventGameScores>;
  /** insert data into the table: "event_invitations" */
  insertEventInvitations?: Maybe<EventInvitationsMutationResponse>;
  /** insert a single row into the table: "event_invitations" */
  insertEventInvitationsOne?: Maybe<EventInvitations>;
  /** insert data into the table: "event_match_games" */
  insertEventMatchGames?: Maybe<EventMatchGamesMutationResponse>;
  /** insert a single row into the table: "event_match_games" */
  insertEventMatchGamesOne?: Maybe<EventMatchGames>;
  /** insert data into the table: "event_registration_details" */
  insertEventRegistrationDetails?: Maybe<EventRegistrationDetailsMutationResponse>;
  /** insert a single row into the table: "event_registration_details" */
  insertEventRegistrationDetailsOne?: Maybe<EventRegistrationDetails>;
  /** insert data into the table: "event_sponsors" */
  insertEventSponsors?: Maybe<EventSponsorsMutationResponse>;
  /** insert a single row into the table: "event_sponsors" */
  insertEventSponsorsOne?: Maybe<EventSponsors>;
  /** insert data into the table: "group_comment_votes" */
  insertGroupCommentVotes?: Maybe<GroupCommentVotesMutationResponse>;
  /** insert a single row into the table: "group_comment_votes" */
  insertGroupCommentVotesOne?: Maybe<GroupCommentVotes>;
  /** insert data into the table: "group_members" */
  insertGroupMembers?: Maybe<GroupMembersMutationResponse>;
  /** insert a single row into the table: "group_members" */
  insertGroupMembersOne?: Maybe<GroupMembers>;
  /** insert data into the table: "group_thread_comment_files" */
  insertGroupThreadCommentFiles?: Maybe<GroupThreadCommentFilesMutationResponse>;
  /** insert a single row into the table: "group_thread_comment_files" */
  insertGroupThreadCommentFilesOne?: Maybe<GroupThreadCommentFiles>;
  /** insert data into the table: "group_thread_comments" */
  insertGroupThreadComments?: Maybe<GroupThreadCommentsMutationResponse>;
  /** insert a single row into the table: "group_thread_comments" */
  insertGroupThreadCommentsOne?: Maybe<GroupThreadComments>;
  /** insert data into the table: "group_threads" */
  insertGroupThreads?: Maybe<GroupThreadsMutationResponse>;
  /** insert a single row into the table: "group_threads" */
  insertGroupThreadsOne?: Maybe<GroupThreads>;
  /** insert data into the table: "groups_play_sessions" */
  insertGroupsPlaySessions?: Maybe<GroupsPlaySessionsMutationResponse>;
  /** insert a single row into the table: "groups_play_sessions" */
  insertGroupsPlaySessionsOne?: Maybe<GroupsPlaySessions>;
  /** insert data into the table: "lesson_equipment" */
  insertLessonEquipment?: Maybe<LessonEquipmentMutationResponse>;
  /** insert a single row into the table: "lesson_equipment" */
  insertLessonEquipmentOne?: Maybe<LessonEquipment>;
  /** insert data into the table: "lesson_templates" */
  insertLessonTemplates?: Maybe<LessonTemplatesMutationResponse>;
  /** insert a single row into the table: "lesson_templates" */
  insertLessonTemplatesOne?: Maybe<LessonTemplates>;
  /** insert data into the table: "lesson_times" */
  insertLessonTimes?: Maybe<LessonTimesMutationResponse>;
  /** insert a single row into the table: "lesson_times" */
  insertLessonTimesOne?: Maybe<LessonTimes>;
  /** insert data into the table: "lesson_waitlists" */
  insertLessonWaitlists?: Maybe<LessonWaitlistsMutationResponse>;
  /** insert a single row into the table: "lesson_waitlists" */
  insertLessonWaitlistsOne?: Maybe<LessonWaitlists>;
  /** insert data into the table: "lessons" */
  insertLessons?: Maybe<LessonsMutationResponse>;
  /** insert a single row into the table: "lessons" */
  insertLessonsOne?: Maybe<Lessons>;
  /** insert data into the table: "play_session_comments" */
  insertPlaySessionComments?: Maybe<PlaySessionCommentsMutationResponse>;
  /** insert a single row into the table: "play_session_comments" */
  insertPlaySessionCommentsOne?: Maybe<PlaySessionComments>;
  /** insert data into the table: "play_session_participants" */
  insertPlaySessionParticipants?: Maybe<PlaySessionParticipantsMutationResponse>;
  /** insert a single row into the table: "play_session_participants" */
  insertPlaySessionParticipantsOne?: Maybe<PlaySessionParticipants>;
  /** insert data into the table: "play_sessions" */
  insertPlaySessions?: Maybe<PlaySessionsMutationResponse>;
  /** insert a single row into the table: "play_sessions" */
  insertPlaySessionsOne?: Maybe<PlaySessions>;
  /** insert data into the table: "signup_requests" */
  insertSignupRequests?: Maybe<SignupRequestsMutationResponse>;
  /** insert a single row into the table: "signup_requests" */
  insertSignupRequestsOne?: Maybe<SignupRequests>;
  /** insert data into the table: "user_coach_services" */
  insertUserCoachServices?: Maybe<UserCoachServicesMutationResponse>;
  /** insert a single row into the table: "user_coach_services" */
  insertUserCoachServicesOne?: Maybe<UserCoachServices>;
  /** insert data into the table: "user_custom_courts" */
  insertUserCustomCourts?: Maybe<UserCustomCourtsMutationResponse>;
  /** insert a single row into the table: "user_custom_courts" */
  insertUserCustomCourtsOne?: Maybe<UserCustomCourts>;
  /** insert data into the table: "user_follows" */
  insertUserFollows?: Maybe<UserFollowsMutationResponse>;
  /** insert a single row into the table: "user_follows" */
  insertUserFollowsOne?: Maybe<UserFollows>;
  /** insert data into the table: "user_image_log" */
  insertUserImageLog?: Maybe<UserImageLogMutationResponse>;
  /** insert a single row into the table: "user_image_log" */
  insertUserImageLogOne?: Maybe<UserImageLog>;
  /** insert data into the table: "user_terms_of_service" */
  insertUserTermsOfService?: Maybe<UserTermsOfServiceMutationResponse>;
  /** insert a single row into the table: "user_terms_of_service" */
  insertUserTermsOfServiceOne?: Maybe<UserTermsOfService>;
  /** insert data into the table: "users_coach_qualifications" */
  insertUsersCoachQualifications?: Maybe<UsersCoachQualificationsMutationResponse>;
  /** insert a single row into the table: "users_coach_qualifications" */
  insertUsersCoachQualificationsOne?: Maybe<UsersCoachQualifications>;
  /** insert data into the table: "venue_follows" */
  insertVenueFollows?: Maybe<VenueFollowsMutationResponse>;
  /** insert a single row into the table: "venue_follows" */
  insertVenueFollowsOne?: Maybe<VenueFollows>;
  /** update data of the table: "event_contact_details" */
  updateEventContactDetails?: Maybe<EventContactDetailsMutationResponse>;
  /** update single row of the table: "event_contact_details" */
  updateEventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** update multiples rows of table: "event_contact_details" */
  updateEventContactDetailsMany?: Maybe<Array<Maybe<EventContactDetailsMutationResponse>>>;
  /** update data of the table: "event_courts" */
  updateEventCourts?: Maybe<EventCourtsMutationResponse>;
  /** update single row of the table: "event_courts" */
  updateEventCourtsByPk?: Maybe<EventCourts>;
  /** update multiples rows of table: "event_courts" */
  updateEventCourtsMany?: Maybe<Array<Maybe<EventCourtsMutationResponse>>>;
  /** update data of the table: "event_faqs" */
  updateEventFaqs?: Maybe<EventFaqsMutationResponse>;
  /** update single row of the table: "event_faqs" */
  updateEventFaqsByPk?: Maybe<EventFaqs>;
  /** update multiples rows of table: "event_faqs" */
  updateEventFaqsMany?: Maybe<Array<Maybe<EventFaqsMutationResponse>>>;
  /** update data of the table: "event_game_scores" */
  updateEventGameScores?: Maybe<EventGameScoresMutationResponse>;
  /** update single row of the table: "event_game_scores" */
  updateEventGameScoresByPk?: Maybe<EventGameScores>;
  /** update multiples rows of table: "event_game_scores" */
  updateEventGameScoresMany?: Maybe<Array<Maybe<EventGameScoresMutationResponse>>>;
  /** update data of the table: "event_group_sequences" */
  updateEventGroupSequences?: Maybe<EventGroupSequencesMutationResponse>;
  /** update single row of the table: "event_group_sequences" */
  updateEventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** update multiples rows of table: "event_group_sequences" */
  updateEventGroupSequencesMany?: Maybe<Array<Maybe<EventGroupSequencesMutationResponse>>>;
  /** update data of the table: "event_groups" */
  updateEventGroups?: Maybe<EventGroupsMutationResponse>;
  /** update single row of the table: "event_groups" */
  updateEventGroupsByPk?: Maybe<EventGroups>;
  /** update multiples rows of table: "event_groups" */
  updateEventGroupsMany?: Maybe<Array<Maybe<EventGroupsMutationResponse>>>;
  /** update data of the table: "event_match_games" */
  updateEventMatchGames?: Maybe<EventMatchGamesMutationResponse>;
  /** update single row of the table: "event_match_games" */
  updateEventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** update multiples rows of table: "event_match_games" */
  updateEventMatchGamesMany?: Maybe<Array<Maybe<EventMatchGamesMutationResponse>>>;
  /** update data of the table: "event_matches" */
  updateEventMatches?: Maybe<EventMatchesMutationResponse>;
  /** update single row of the table: "event_matches" */
  updateEventMatchesByPk?: Maybe<EventMatches>;
  /** update multiples rows of table: "event_matches" */
  updateEventMatchesMany?: Maybe<Array<Maybe<EventMatchesMutationResponse>>>;
  /** update data of the table: "event_sponsors" */
  updateEventSponsors?: Maybe<EventSponsorsMutationResponse>;
  /** update single row of the table: "event_sponsors" */
  updateEventSponsorsByPk?: Maybe<EventSponsors>;
  /** update multiples rows of table: "event_sponsors" */
  updateEventSponsorsMany?: Maybe<Array<Maybe<EventSponsorsMutationResponse>>>;
  /** update data of the table: "events" */
  updateEvents?: Maybe<EventsMutationResponse>;
  /** update single row of the table: "events" */
  updateEventsByPk?: Maybe<Events>;
  /** update multiples rows of table: "events" */
  updateEventsMany?: Maybe<Array<Maybe<EventsMutationResponse>>>;
  /** update data of the table: "group_comment_votes" */
  updateGroupCommentVotes?: Maybe<GroupCommentVotesMutationResponse>;
  /** update single row of the table: "group_comment_votes" */
  updateGroupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** update multiples rows of table: "group_comment_votes" */
  updateGroupCommentVotesMany?: Maybe<Array<Maybe<GroupCommentVotesMutationResponse>>>;
  /** update data of the table: "group_members" */
  updateGroupMembers?: Maybe<GroupMembersMutationResponse>;
  /** update single row of the table: "group_members" */
  updateGroupMembersByPk?: Maybe<GroupMembers>;
  /** update multiples rows of table: "group_members" */
  updateGroupMembersMany?: Maybe<Array<Maybe<GroupMembersMutationResponse>>>;
  /** update data of the table: "group_thread_comment_files" */
  updateGroupThreadCommentFiles?: Maybe<GroupThreadCommentFilesMutationResponse>;
  /** update single row of the table: "group_thread_comment_files" */
  updateGroupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** update multiples rows of table: "group_thread_comment_files" */
  updateGroupThreadCommentFilesMany?: Maybe<Array<Maybe<GroupThreadCommentFilesMutationResponse>>>;
  /** update data of the table: "group_thread_comments" */
  updateGroupThreadComments?: Maybe<GroupThreadCommentsMutationResponse>;
  /** update single row of the table: "group_thread_comments" */
  updateGroupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** update multiples rows of table: "group_thread_comments" */
  updateGroupThreadCommentsMany?: Maybe<Array<Maybe<GroupThreadCommentsMutationResponse>>>;
  /** update data of the table: "groups_play_sessions" */
  updateGroupsPlaySessions?: Maybe<GroupsPlaySessionsMutationResponse>;
  /** update single row of the table: "groups_play_sessions" */
  updateGroupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** update multiples rows of table: "groups_play_sessions" */
  updateGroupsPlaySessionsMany?: Maybe<Array<Maybe<GroupsPlaySessionsMutationResponse>>>;
  /** update data of the table: "lesson_equipment" */
  updateLessonEquipment?: Maybe<LessonEquipmentMutationResponse>;
  /** update single row of the table: "lesson_equipment" */
  updateLessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** update multiples rows of table: "lesson_equipment" */
  updateLessonEquipmentMany?: Maybe<Array<Maybe<LessonEquipmentMutationResponse>>>;
  /** update data of the table: "lesson_templates" */
  updateLessonTemplates?: Maybe<LessonTemplatesMutationResponse>;
  /** update single row of the table: "lesson_templates" */
  updateLessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** update multiples rows of table: "lesson_templates" */
  updateLessonTemplatesMany?: Maybe<Array<Maybe<LessonTemplatesMutationResponse>>>;
  /** update data of the table: "lesson_waitlists" */
  updateLessonWaitlists?: Maybe<LessonWaitlistsMutationResponse>;
  /** update single row of the table: "lesson_waitlists" */
  updateLessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** update multiples rows of table: "lesson_waitlists" */
  updateLessonWaitlistsMany?: Maybe<Array<Maybe<LessonWaitlistsMutationResponse>>>;
  /** update data of the table: "lessons" */
  updateLessons?: Maybe<LessonsMutationResponse>;
  /** update single row of the table: "lessons" */
  updateLessonsByPk?: Maybe<Lessons>;
  /** update multiples rows of table: "lessons" */
  updateLessonsMany?: Maybe<Array<Maybe<LessonsMutationResponse>>>;
  /** update data of the table: "play_session_comments" */
  updatePlaySessionComments?: Maybe<PlaySessionCommentsMutationResponse>;
  /** update single row of the table: "play_session_comments" */
  updatePlaySessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** update multiples rows of table: "play_session_comments" */
  updatePlaySessionCommentsMany?: Maybe<Array<Maybe<PlaySessionCommentsMutationResponse>>>;
  /** update data of the table: "play_sessions" */
  updatePlaySessions?: Maybe<PlaySessionsMutationResponse>;
  /** update single row of the table: "play_sessions" */
  updatePlaySessionsByPk?: Maybe<PlaySessions>;
  /** update multiples rows of table: "play_sessions" */
  updatePlaySessionsMany?: Maybe<Array<Maybe<PlaySessionsMutationResponse>>>;
  /** update data of the table: "user_coach_services" */
  updateUserCoachServices?: Maybe<UserCoachServicesMutationResponse>;
  /** update single row of the table: "user_coach_services" */
  updateUserCoachServicesByPk?: Maybe<UserCoachServices>;
  /** update multiples rows of table: "user_coach_services" */
  updateUserCoachServicesMany?: Maybe<Array<Maybe<UserCoachServicesMutationResponse>>>;
  /** update data of the table: "user_communication_preferences" */
  updateUserCommunicationPreferences?: Maybe<UserCommunicationPreferencesMutationResponse>;
  /** update single row of the table: "user_communication_preferences" */
  updateUserCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** update multiples rows of table: "user_communication_preferences" */
  updateUserCommunicationPreferencesMany?: Maybe<Array<Maybe<UserCommunicationPreferencesMutationResponse>>>;
  /** update data of the table: "user_custom_courts" */
  updateUserCustomCourts?: Maybe<UserCustomCourtsMutationResponse>;
  /** update single row of the table: "user_custom_courts" */
  updateUserCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** update multiples rows of table: "user_custom_courts" */
  updateUserCustomCourtsMany?: Maybe<Array<Maybe<UserCustomCourtsMutationResponse>>>;
  /** update data of the table: "user_follows" */
  updateUserFollows?: Maybe<UserFollowsMutationResponse>;
  /** update single row of the table: "user_follows" */
  updateUserFollowsByPk?: Maybe<UserFollows>;
  /** update multiples rows of table: "user_follows" */
  updateUserFollowsMany?: Maybe<Array<Maybe<UserFollowsMutationResponse>>>;
  /** update data of the table: "user_notifications" */
  updateUserNotifications?: Maybe<UserNotificationsMutationResponse>;
  /** update single row of the table: "user_notifications" */
  updateUserNotificationsByPk?: Maybe<UserNotifications>;
  /** update multiples rows of table: "user_notifications" */
  updateUserNotificationsMany?: Maybe<Array<Maybe<UserNotificationsMutationResponse>>>;
  /** update data of the table: "users" */
  updateUsers?: Maybe<UsersMutationResponse>;
  /** update single row of the table: "users" */
  updateUsersByPk?: Maybe<Users>;
  /** update data of the table: "users_coach_qualifications" */
  updateUsersCoachQualifications?: Maybe<UsersCoachQualificationsMutationResponse>;
  /** update single row of the table: "users_coach_qualifications" */
  updateUsersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** update multiples rows of table: "users_coach_qualifications" */
  updateUsersCoachQualificationsMany?: Maybe<Array<Maybe<UsersCoachQualificationsMutationResponse>>>;
  /** update multiples rows of table: "users" */
  updateUsersMany?: Maybe<Array<Maybe<UsersMutationResponse>>>;
  /** update data of the table: "venue_follows" */
  updateVenueFollows?: Maybe<VenueFollowsMutationResponse>;
  /** update single row of the table: "venue_follows" */
  updateVenueFollowsByPk?: Maybe<VenueFollows>;
  /** update multiples rows of table: "venue_follows" */
  updateVenueFollowsMany?: Maybe<Array<Maybe<VenueFollowsMutationResponse>>>;
};


/** mutation root */
export type Mutation_RootDeleteLessonEquipmentArgs = {
  where: LessonEquipmentBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonEquipmentByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonTimesArgs = {
  where: LessonTimesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonTimesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInsertAppPingsArgs = {
  objects: Array<AppPingsInsertInput>;
  onConflict?: InputMaybe<AppPingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppPingsOneArgs = {
  object: AppPingsInsertInput;
  onConflict?: InputMaybe<AppPingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventFaqsArgs = {
  objects: Array<EventFaqsInsertInput>;
  onConflict?: InputMaybe<EventFaqsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventFaqsOneArgs = {
  object: EventFaqsInsertInput;
  onConflict?: InputMaybe<EventFaqsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGameScoresArgs = {
  objects: Array<EventGameScoresInsertInput>;
  onConflict?: InputMaybe<EventGameScoresOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGameScoresOneArgs = {
  object: EventGameScoresInsertInput;
  onConflict?: InputMaybe<EventGameScoresOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventInvitationsArgs = {
  objects: Array<EventInvitationsInsertInput>;
  onConflict?: InputMaybe<EventInvitationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventInvitationsOneArgs = {
  object: EventInvitationsInsertInput;
  onConflict?: InputMaybe<EventInvitationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchGamesArgs = {
  objects: Array<EventMatchGamesInsertInput>;
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchGamesOneArgs = {
  object: EventMatchGamesInsertInput;
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventRegistrationDetailsArgs = {
  objects: Array<EventRegistrationDetailsInsertInput>;
  onConflict?: InputMaybe<EventRegistrationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventRegistrationDetailsOneArgs = {
  object: EventRegistrationDetailsInsertInput;
  onConflict?: InputMaybe<EventRegistrationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventSponsorsArgs = {
  objects: Array<EventSponsorsInsertInput>;
  onConflict?: InputMaybe<EventSponsorsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventSponsorsOneArgs = {
  object: EventSponsorsInsertInput;
  onConflict?: InputMaybe<EventSponsorsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupCommentVotesArgs = {
  objects: Array<GroupCommentVotesInsertInput>;
  onConflict?: InputMaybe<GroupCommentVotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupCommentVotesOneArgs = {
  object: GroupCommentVotesInsertInput;
  onConflict?: InputMaybe<GroupCommentVotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupMembersArgs = {
  objects: Array<GroupMembersInsertInput>;
  onConflict?: InputMaybe<GroupMembersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupMembersOneArgs = {
  object: GroupMembersInsertInput;
  onConflict?: InputMaybe<GroupMembersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentFilesArgs = {
  objects: Array<GroupThreadCommentFilesInsertInput>;
  onConflict?: InputMaybe<GroupThreadCommentFilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentFilesOneArgs = {
  object: GroupThreadCommentFilesInsertInput;
  onConflict?: InputMaybe<GroupThreadCommentFilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentsArgs = {
  objects: Array<GroupThreadCommentsInsertInput>;
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentsOneArgs = {
  object: GroupThreadCommentsInsertInput;
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadsArgs = {
  objects: Array<GroupThreadsInsertInput>;
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadsOneArgs = {
  object: GroupThreadsInsertInput;
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupsPlaySessionsArgs = {
  objects: Array<GroupsPlaySessionsInsertInput>;
  onConflict?: InputMaybe<GroupsPlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupsPlaySessionsOneArgs = {
  object: GroupsPlaySessionsInsertInput;
  onConflict?: InputMaybe<GroupsPlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonEquipmentArgs = {
  objects: Array<LessonEquipmentInsertInput>;
  onConflict?: InputMaybe<LessonEquipmentOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonEquipmentOneArgs = {
  object: LessonEquipmentInsertInput;
  onConflict?: InputMaybe<LessonEquipmentOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTemplatesArgs = {
  objects: Array<LessonTemplatesInsertInput>;
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTemplatesOneArgs = {
  object: LessonTemplatesInsertInput;
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTimesArgs = {
  objects: Array<LessonTimesInsertInput>;
  onConflict?: InputMaybe<LessonTimesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTimesOneArgs = {
  object: LessonTimesInsertInput;
  onConflict?: InputMaybe<LessonTimesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonWaitlistsArgs = {
  objects: Array<LessonWaitlistsInsertInput>;
  onConflict?: InputMaybe<LessonWaitlistsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonWaitlistsOneArgs = {
  object: LessonWaitlistsInsertInput;
  onConflict?: InputMaybe<LessonWaitlistsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonsArgs = {
  objects: Array<LessonsInsertInput>;
  onConflict?: InputMaybe<LessonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonsOneArgs = {
  object: LessonsInsertInput;
  onConflict?: InputMaybe<LessonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionCommentsArgs = {
  objects: Array<PlaySessionCommentsInsertInput>;
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionCommentsOneArgs = {
  object: PlaySessionCommentsInsertInput;
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionParticipantsArgs = {
  objects: Array<PlaySessionParticipantsInsertInput>;
  onConflict?: InputMaybe<PlaySessionParticipantsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionParticipantsOneArgs = {
  object: PlaySessionParticipantsInsertInput;
  onConflict?: InputMaybe<PlaySessionParticipantsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionsArgs = {
  objects: Array<PlaySessionsInsertInput>;
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionsOneArgs = {
  object: PlaySessionsInsertInput;
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSignupRequestsArgs = {
  objects: Array<SignupRequestsInsertInput>;
  onConflict?: InputMaybe<SignupRequestsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSignupRequestsOneArgs = {
  object: SignupRequestsInsertInput;
  onConflict?: InputMaybe<SignupRequestsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCoachServicesArgs = {
  objects: Array<UserCoachServicesInsertInput>;
  onConflict?: InputMaybe<UserCoachServicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCoachServicesOneArgs = {
  object: UserCoachServicesInsertInput;
  onConflict?: InputMaybe<UserCoachServicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCustomCourtsArgs = {
  objects: Array<UserCustomCourtsInsertInput>;
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCustomCourtsOneArgs = {
  object: UserCustomCourtsInsertInput;
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserFollowsArgs = {
  objects: Array<UserFollowsInsertInput>;
  onConflict?: InputMaybe<UserFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserFollowsOneArgs = {
  object: UserFollowsInsertInput;
  onConflict?: InputMaybe<UserFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserImageLogArgs = {
  objects: Array<UserImageLogInsertInput>;
  onConflict?: InputMaybe<UserImageLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserImageLogOneArgs = {
  object: UserImageLogInsertInput;
  onConflict?: InputMaybe<UserImageLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserTermsOfServiceArgs = {
  objects: Array<UserTermsOfServiceInsertInput>;
  onConflict?: InputMaybe<UserTermsOfServiceOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserTermsOfServiceOneArgs = {
  object: UserTermsOfServiceInsertInput;
  onConflict?: InputMaybe<UserTermsOfServiceOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersCoachQualificationsArgs = {
  objects: Array<UsersCoachQualificationsInsertInput>;
  onConflict?: InputMaybe<UsersCoachQualificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersCoachQualificationsOneArgs = {
  object: UsersCoachQualificationsInsertInput;
  onConflict?: InputMaybe<UsersCoachQualificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueFollowsArgs = {
  objects: Array<VenueFollowsInsertInput>;
  onConflict?: InputMaybe<VenueFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueFollowsOneArgs = {
  object: VenueFollowsInsertInput;
  onConflict?: InputMaybe<VenueFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootUpdateEventContactDetailsArgs = {
  _set?: InputMaybe<EventContactDetailsSetInput>;
  where: EventContactDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventContactDetailsByPkArgs = {
  _set?: InputMaybe<EventContactDetailsSetInput>;
  pkColumns: EventContactDetailsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventContactDetailsManyArgs = {
  updates: Array<EventContactDetailsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtsArgs = {
  _set?: InputMaybe<EventCourtsSetInput>;
  where: EventCourtsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtsByPkArgs = {
  _set?: InputMaybe<EventCourtsSetInput>;
  pkColumns: EventCourtsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtsManyArgs = {
  updates: Array<EventCourtsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventFaqsArgs = {
  _set?: InputMaybe<EventFaqsSetInput>;
  where: EventFaqsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventFaqsByPkArgs = {
  _set?: InputMaybe<EventFaqsSetInput>;
  pkColumns: EventFaqsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventFaqsManyArgs = {
  updates: Array<EventFaqsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGameScoresArgs = {
  _inc?: InputMaybe<EventGameScoresIncInput>;
  _set?: InputMaybe<EventGameScoresSetInput>;
  where: EventGameScoresBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGameScoresByPkArgs = {
  _inc?: InputMaybe<EventGameScoresIncInput>;
  _set?: InputMaybe<EventGameScoresSetInput>;
  pkColumns: EventGameScoresPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGameScoresManyArgs = {
  updates: Array<EventGameScoresUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequencesArgs = {
  _set?: InputMaybe<EventGroupSequencesSetInput>;
  where: EventGroupSequencesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequencesByPkArgs = {
  _set?: InputMaybe<EventGroupSequencesSetInput>;
  pkColumns: EventGroupSequencesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequencesManyArgs = {
  updates: Array<EventGroupSequencesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupsArgs = {
  _inc?: InputMaybe<EventGroupsIncInput>;
  _set?: InputMaybe<EventGroupsSetInput>;
  where: EventGroupsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupsByPkArgs = {
  _inc?: InputMaybe<EventGroupsIncInput>;
  _set?: InputMaybe<EventGroupsSetInput>;
  pkColumns: EventGroupsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupsManyArgs = {
  updates: Array<EventGroupsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchGamesArgs = {
  _inc?: InputMaybe<EventMatchGamesIncInput>;
  _set?: InputMaybe<EventMatchGamesSetInput>;
  where: EventMatchGamesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchGamesByPkArgs = {
  _inc?: InputMaybe<EventMatchGamesIncInput>;
  _set?: InputMaybe<EventMatchGamesSetInput>;
  pkColumns: EventMatchGamesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchGamesManyArgs = {
  updates: Array<EventMatchGamesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesArgs = {
  _inc?: InputMaybe<EventMatchesIncInput>;
  _set?: InputMaybe<EventMatchesSetInput>;
  where: EventMatchesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesByPkArgs = {
  _inc?: InputMaybe<EventMatchesIncInput>;
  _set?: InputMaybe<EventMatchesSetInput>;
  pkColumns: EventMatchesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesManyArgs = {
  updates: Array<EventMatchesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventSponsorsArgs = {
  _set?: InputMaybe<EventSponsorsSetInput>;
  where: EventSponsorsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventSponsorsByPkArgs = {
  _set?: InputMaybe<EventSponsorsSetInput>;
  pkColumns: EventSponsorsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventSponsorsManyArgs = {
  updates: Array<EventSponsorsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventsArgs = {
  _inc?: InputMaybe<EventsIncInput>;
  _set?: InputMaybe<EventsSetInput>;
  where: EventsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventsByPkArgs = {
  _inc?: InputMaybe<EventsIncInput>;
  _set?: InputMaybe<EventsSetInput>;
  pkColumns: EventsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventsManyArgs = {
  updates: Array<EventsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupCommentVotesArgs = {
  _set?: InputMaybe<GroupCommentVotesSetInput>;
  where: GroupCommentVotesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupCommentVotesByPkArgs = {
  _set?: InputMaybe<GroupCommentVotesSetInput>;
  pkColumns: GroupCommentVotesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupCommentVotesManyArgs = {
  updates: Array<GroupCommentVotesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupMembersArgs = {
  _set?: InputMaybe<GroupMembersSetInput>;
  where: GroupMembersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupMembersByPkArgs = {
  _set?: InputMaybe<GroupMembersSetInput>;
  pkColumns: GroupMembersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupMembersManyArgs = {
  updates: Array<GroupMembersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentFilesArgs = {
  _set?: InputMaybe<GroupThreadCommentFilesSetInput>;
  where: GroupThreadCommentFilesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentFilesByPkArgs = {
  _set?: InputMaybe<GroupThreadCommentFilesSetInput>;
  pkColumns: GroupThreadCommentFilesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentFilesManyArgs = {
  updates: Array<GroupThreadCommentFilesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentsArgs = {
  _set?: InputMaybe<GroupThreadCommentsSetInput>;
  where: GroupThreadCommentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentsByPkArgs = {
  _set?: InputMaybe<GroupThreadCommentsSetInput>;
  pkColumns: GroupThreadCommentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentsManyArgs = {
  updates: Array<GroupThreadCommentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupsPlaySessionsArgs = {
  _set?: InputMaybe<GroupsPlaySessionsSetInput>;
  where: GroupsPlaySessionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupsPlaySessionsByPkArgs = {
  _set?: InputMaybe<GroupsPlaySessionsSetInput>;
  pkColumns: GroupsPlaySessionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupsPlaySessionsManyArgs = {
  updates: Array<GroupsPlaySessionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentArgs = {
  _set?: InputMaybe<LessonEquipmentSetInput>;
  where: LessonEquipmentBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentByPkArgs = {
  _set?: InputMaybe<LessonEquipmentSetInput>;
  pkColumns: LessonEquipmentPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentManyArgs = {
  updates: Array<LessonEquipmentUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonTemplatesArgs = {
  _inc?: InputMaybe<LessonTemplatesIncInput>;
  _set?: InputMaybe<LessonTemplatesSetInput>;
  where: LessonTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonTemplatesByPkArgs = {
  _inc?: InputMaybe<LessonTemplatesIncInput>;
  _set?: InputMaybe<LessonTemplatesSetInput>;
  pkColumns: LessonTemplatesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonTemplatesManyArgs = {
  updates: Array<LessonTemplatesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistsArgs = {
  _set?: InputMaybe<LessonWaitlistsSetInput>;
  where: LessonWaitlistsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistsByPkArgs = {
  _set?: InputMaybe<LessonWaitlistsSetInput>;
  pkColumns: LessonWaitlistsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistsManyArgs = {
  updates: Array<LessonWaitlistsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonsArgs = {
  _inc?: InputMaybe<LessonsIncInput>;
  _set?: InputMaybe<LessonsSetInput>;
  where: LessonsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonsByPkArgs = {
  _inc?: InputMaybe<LessonsIncInput>;
  _set?: InputMaybe<LessonsSetInput>;
  pkColumns: LessonsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonsManyArgs = {
  updates: Array<LessonsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCommentsArgs = {
  _set?: InputMaybe<PlaySessionCommentsSetInput>;
  where: PlaySessionCommentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCommentsByPkArgs = {
  _set?: InputMaybe<PlaySessionCommentsSetInput>;
  pkColumns: PlaySessionCommentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCommentsManyArgs = {
  updates: Array<PlaySessionCommentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionsArgs = {
  _inc?: InputMaybe<PlaySessionsIncInput>;
  _set?: InputMaybe<PlaySessionsSetInput>;
  where: PlaySessionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionsByPkArgs = {
  _inc?: InputMaybe<PlaySessionsIncInput>;
  _set?: InputMaybe<PlaySessionsSetInput>;
  pkColumns: PlaySessionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionsManyArgs = {
  updates: Array<PlaySessionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCoachServicesArgs = {
  _inc?: InputMaybe<UserCoachServicesIncInput>;
  _set?: InputMaybe<UserCoachServicesSetInput>;
  where: UserCoachServicesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCoachServicesByPkArgs = {
  _inc?: InputMaybe<UserCoachServicesIncInput>;
  _set?: InputMaybe<UserCoachServicesSetInput>;
  pkColumns: UserCoachServicesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCoachServicesManyArgs = {
  updates: Array<UserCoachServicesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCommunicationPreferencesArgs = {
  _set?: InputMaybe<UserCommunicationPreferencesSetInput>;
  where: UserCommunicationPreferencesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCommunicationPreferencesByPkArgs = {
  _set?: InputMaybe<UserCommunicationPreferencesSetInput>;
  pkColumns: UserCommunicationPreferencesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCommunicationPreferencesManyArgs = {
  updates: Array<UserCommunicationPreferencesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCustomCourtsArgs = {
  _set?: InputMaybe<UserCustomCourtsSetInput>;
  where: UserCustomCourtsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCustomCourtsByPkArgs = {
  _set?: InputMaybe<UserCustomCourtsSetInput>;
  pkColumns: UserCustomCourtsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCustomCourtsManyArgs = {
  updates: Array<UserCustomCourtsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserFollowsArgs = {
  _set?: InputMaybe<UserFollowsSetInput>;
  where: UserFollowsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserFollowsByPkArgs = {
  _set?: InputMaybe<UserFollowsSetInput>;
  pkColumns: UserFollowsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserFollowsManyArgs = {
  updates: Array<UserFollowsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationsArgs = {
  _set?: InputMaybe<UserNotificationsSetInput>;
  where: UserNotificationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationsByPkArgs = {
  _set?: InputMaybe<UserNotificationsSetInput>;
  pkColumns: UserNotificationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationsManyArgs = {
  updates: Array<UserNotificationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersArgs = {
  _inc?: InputMaybe<UsersIncInput>;
  _set?: InputMaybe<UsersSetInput>;
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersByPkArgs = {
  _inc?: InputMaybe<UsersIncInput>;
  _set?: InputMaybe<UsersSetInput>;
  pkColumns: UsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsersCoachQualificationsArgs = {
  _set?: InputMaybe<UsersCoachQualificationsSetInput>;
  where: UsersCoachQualificationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersCoachQualificationsByPkArgs = {
  _set?: InputMaybe<UsersCoachQualificationsSetInput>;
  pkColumns: UsersCoachQualificationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsersCoachQualificationsManyArgs = {
  updates: Array<UsersCoachQualificationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersManyArgs = {
  updates: Array<UsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueFollowsArgs = {
  _set?: InputMaybe<VenueFollowsSetInput>;
  where: VenueFollowsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueFollowsByPkArgs = {
  _set?: InputMaybe<VenueFollowsSetInput>;
  pkColumns: VenueFollowsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueFollowsManyArgs = {
  updates: Array<VenueFollowsUpdates>;
};

export type PlaySessionCommentsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionCommentsBoolExp>;
  predicate: IntComparisonExp;
};

export type PlaySessionParticipantsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionParticipantsBoolExp>;
  predicate: IntComparisonExp;
};

export type PlaySessionsAggregateBoolExpBool_And = {
  arguments: PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PlaySessionsAggregateBoolExpBool_Or = {
  arguments: PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PlaySessionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionsBoolExp>;
  predicate: IntComparisonExp;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "amenities" */
  amenities: Array<Amenities>;
  /** fetch data from the table: "amenities" using primary key columns */
  amenitiesByPk?: Maybe<Amenities>;
  /** fetch data from the table: "app_personas" */
  appPersonas: Array<AppPersonas>;
  /** fetch data from the table: "app_personas" using primary key columns */
  appPersonasByPk?: Maybe<AppPersonas>;
  /** fetch data from the table: "app_pings" */
  appPings: Array<AppPings>;
  /** fetch data from the table: "app_pings" using primary key columns */
  appPingsByPk?: Maybe<AppPings>;
  /** fetch data from the table: "ball_types" */
  ballTypes: Array<BallTypes>;
  /** fetch data from the table: "ball_types" using primary key columns */
  ballTypesByPk?: Maybe<BallTypes>;
  /** An array relationship */
  cities: Array<Cities>;
  /** fetch data from the table: "cities" using primary key columns */
  citiesByPk?: Maybe<Cities>;
  /** fetch data from the table: "coach_qualification_groups" */
  coachQualificationGroups: Array<CoachQualificationGroups>;
  /** fetch data from the table: "coach_qualification_groups" using primary key columns */
  coachQualificationGroupsByPk?: Maybe<CoachQualificationGroups>;
  /** fetch data from the table: "coach_qualifications" */
  coachQualifications: Array<CoachQualifications>;
  /** fetch data from the table: "coach_qualifications" using primary key columns */
  coachQualificationsByPk?: Maybe<CoachQualifications>;
  /** fetch data from the table: "coach_status" */
  coachStatus: Array<CoachStatus>;
  /** fetch data from the table: "coach_status" using primary key columns */
  coachStatusByPk?: Maybe<CoachStatus>;
  /** fetch data from the table: "comment_vote" */
  commentVote: Array<CommentVote>;
  /** fetch data from the table: "comment_vote" using primary key columns */
  commentVoteByPk?: Maybe<CommentVote>;
  /** fetch data from the table: "communication_preference_statuses" */
  communicationPreferenceStatuses: Array<CommunicationPreferenceStatuses>;
  /** fetch data from the table: "communication_preference_statuses" using primary key columns */
  communicationPreferenceStatusesByPk?: Maybe<CommunicationPreferenceStatuses>;
  /** fetch data from the table: "competition_formats" */
  competitionFormats: Array<CompetitionFormats>;
  /** fetch data from the table: "competition_formats" using primary key columns */
  competitionFormatsByPk?: Maybe<CompetitionFormats>;
  /** fetch data from the table: "competition_gender" */
  competitionGender: Array<CompetitionGender>;
  /** fetch data from the table: "competition_gender" using primary key columns */
  competitionGenderByPk?: Maybe<CompetitionGender>;
  /** fetch data from the table: "countries" */
  countries: Array<Countries>;
  /** fetch data from the table: "countries" using primary key columns */
  countriesByPk?: Maybe<Countries>;
  /** fetch data from the table: "country_subdivisions" */
  countrySubdivisions: Array<CountrySubdivisions>;
  /** fetch data from the table: "country_subdivisions" using primary key columns */
  countrySubdivisionsByPk?: Maybe<CountrySubdivisions>;
  /** fetch data from the table: "court_surfaces" */
  courtSurfaces: Array<CourtSurfaces>;
  /** fetch data from the table: "court_surfaces" using primary key columns */
  courtSurfacesByPk?: Maybe<CourtSurfaces>;
  /** fetch data from the table: "event_contact_details" */
  eventContactDetails: Array<EventContactDetails>;
  /** fetch data from the table: "event_contact_details" using primary key columns */
  eventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** fetch data from the table: "event_court_statuses" */
  eventCourtStatuses: Array<EventCourtStatuses>;
  /** fetch data from the table: "event_court_statuses" using primary key columns */
  eventCourtStatusesByPk?: Maybe<EventCourtStatuses>;
  /** fetch data from the table: "event_courts" */
  eventCourts: Array<EventCourts>;
  /** fetch data from the table: "event_courts" using primary key columns */
  eventCourtsByPk?: Maybe<EventCourts>;
  /** fetch data from the table: "event_faqs" */
  eventFaqs: Array<EventFaqs>;
  /** fetch data from the table: "event_faqs" using primary key columns */
  eventFaqsByPk?: Maybe<EventFaqs>;
  /** fetch data from the table: "event_game_scores" */
  eventGameScores: Array<EventGameScores>;
  /** fetch data from the table: "event_game_scores" using primary key columns */
  eventGameScoresByPk?: Maybe<EventGameScores>;
  /** fetch data from the table: "event_group_formats" */
  eventGroupFormats: Array<EventGroupFormats>;
  /** fetch data from the table: "event_group_formats" using primary key columns */
  eventGroupFormatsByPk?: Maybe<EventGroupFormats>;
  /** fetch data from the table: "event_group_pools" */
  eventGroupPools: Array<EventGroupPools>;
  /** fetch data from the table: "event_group_pools" using primary key columns */
  eventGroupPoolsByPk?: Maybe<EventGroupPools>;
  /** fetch data from the table: "event_group_registration_statuses" */
  eventGroupRegistrationStatuses: Array<EventGroupRegistrationStatuses>;
  /** fetch data from the table: "event_group_registration_statuses" using primary key columns */
  eventGroupRegistrationStatusesByPk?: Maybe<EventGroupRegistrationStatuses>;
  /** fetch data from the table: "event_group_registrations" */
  eventGroupRegistrations: Array<EventGroupRegistrations>;
  /** fetch data from the table: "event_group_registrations" using primary key columns */
  eventGroupRegistrationsByPk?: Maybe<EventGroupRegistrations>;
  /** fetch data from the table: "event_group_sequence_seeding" */
  eventGroupSequenceSeeding: Array<EventGroupSequenceSeeding>;
  /** fetch data from the table: "event_group_sequence_seeding" using primary key columns */
  eventGroupSequenceSeedingByPk?: Maybe<EventGroupSequenceSeeding>;
  /** fetch data from the table: "event_group_sequences" */
  eventGroupSequences: Array<EventGroupSequences>;
  /** fetch data from the table: "event_group_sequences" using primary key columns */
  eventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** fetch data from the table: "event_groups" */
  eventGroups: Array<EventGroups>;
  /** fetch data from the table: "event_groups" using primary key columns */
  eventGroupsByPk?: Maybe<EventGroups>;
  /** fetch data from the table: "event_invitation_statuses" */
  eventInvitationStatuses: Array<EventInvitationStatuses>;
  /** fetch data from the table: "event_invitation_statuses" using primary key columns */
  eventInvitationStatusesByPk?: Maybe<EventInvitationStatuses>;
  /** fetch data from the table: "event_invitations" */
  eventInvitations: Array<EventInvitations>;
  /** fetch data from the table: "event_invitations" using primary key columns */
  eventInvitationsByPk?: Maybe<EventInvitations>;
  /** fetch data from the table: "event_listing_fees" */
  eventListingFees: Array<EventListingFees>;
  /** fetch data from the table: "event_listing_fees" using primary key columns */
  eventListingFeesByPk?: Maybe<EventListingFees>;
  /** fetch data from the table: "event_match_games" */
  eventMatchGames: Array<EventMatchGames>;
  /** fetch data from the table: "event_match_games" using primary key columns */
  eventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** fetch data from the table: "event_matches" */
  eventMatches: Array<EventMatches>;
  /** fetch data from the table: "event_matches" using primary key columns */
  eventMatchesByPk?: Maybe<EventMatches>;
  /** fetch data from the table: "event_matches_teams" */
  eventMatchesTeams: Array<EventMatchesTeams>;
  /** fetch data from the table: "event_matches_teams" using primary key columns */
  eventMatchesTeamsByPk?: Maybe<EventMatchesTeams>;
  /** fetch data from the table: "event_organizer_account_types" */
  eventOrganizerAccountTypes: Array<EventOrganizerAccountTypes>;
  /** fetch data from the table: "event_organizer_account_types" using primary key columns */
  eventOrganizerAccountTypesByPk?: Maybe<EventOrganizerAccountTypes>;
  /** fetch data from the table: "event_pool_rounds" */
  eventPoolRounds: Array<EventPoolRounds>;
  /** fetch data from the table: "event_pool_rounds" using primary key columns */
  eventPoolRoundsByPk?: Maybe<EventPoolRounds>;
  /** fetch data from the table: "event_pools_teams" */
  eventPoolsTeams: Array<EventPoolsTeams>;
  /** fetch data from the table: "event_pools_teams" using primary key columns */
  eventPoolsTeamsByPk?: Maybe<EventPoolsTeams>;
  /** fetch data from the table: "event_privacy" */
  eventPrivacy: Array<EventPrivacy>;
  /** fetch data from the table: "event_privacy" using primary key columns */
  eventPrivacyByPk?: Maybe<EventPrivacy>;
  /** fetch data from the table: "event_registration_details" */
  eventRegistrationDetails: Array<EventRegistrationDetails>;
  /** fetch data from the table: "event_registration_details" using primary key columns */
  eventRegistrationDetailsByPk?: Maybe<EventRegistrationDetails>;
  /** fetch data from the table: "event_registrations" */
  eventRegistrations: Array<EventRegistrations>;
  /** fetch data from the table: "event_registrations" using primary key columns */
  eventRegistrationsByPk?: Maybe<EventRegistrations>;
  /** fetch data from the table: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasons: Array<EventSequenceCompleteReasons>;
  /** fetch data from the table: "event_sequence_complete_reasons" using primary key columns */
  eventSequenceCompleteReasonsByPk?: Maybe<EventSequenceCompleteReasons>;
  /** fetch data from the table: "event_sponsors" */
  eventSponsors: Array<EventSponsors>;
  /** fetch data from the table: "event_sponsors" using primary key columns */
  eventSponsorsByPk?: Maybe<EventSponsors>;
  /** fetch data from the table: "event_statuses" */
  eventStatuses: Array<EventStatuses>;
  /** fetch data from the table: "event_statuses" using primary key columns */
  eventStatusesByPk?: Maybe<EventStatuses>;
  /** fetch data from the table: "event_team_member_statuses" */
  eventTeamMemberStatuses: Array<EventTeamMemberStatuses>;
  /** fetch data from the table: "event_team_member_statuses" using primary key columns */
  eventTeamMemberStatusesByPk?: Maybe<EventTeamMemberStatuses>;
  /** fetch data from the table: "event_team_members" */
  eventTeamMembers: Array<EventTeamMembers>;
  /** fetch data from the table: "event_team_members" using primary key columns */
  eventTeamMembersByPk?: Maybe<EventTeamMembers>;
  /** fetch data from the table: "event_teams" */
  eventTeams: Array<EventTeams>;
  /** fetch data from the table: "event_teams" using primary key columns */
  eventTeamsByPk?: Maybe<EventTeams>;
  /** fetch data from the table: "event_transaction_item_types" */
  eventTransactionItemTypes: Array<EventTransactionItemTypes>;
  /** fetch data from the table: "event_transaction_item_types" using primary key columns */
  eventTransactionItemTypesByPk?: Maybe<EventTransactionItemTypes>;
  /** fetch data from the table: "event_transaction_items" */
  eventTransactionItems: Array<EventTransactionItems>;
  /** fetch data from the table: "event_transaction_items" using primary key columns */
  eventTransactionItemsByPk?: Maybe<EventTransactionItems>;
  /** fetch data from the table: "event_transactions" */
  eventTransactions: Array<EventTransactions>;
  /** fetch data from the table: "event_transactions" using primary key columns */
  eventTransactionsByPk?: Maybe<EventTransactions>;
  /** fetch data from the table: "event_types" */
  eventTypes: Array<EventTypes>;
  /** fetch data from the table: "event_types" using primary key columns */
  eventTypesByPk?: Maybe<EventTypes>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch data from the table: "events" using primary key columns */
  eventsByPk?: Maybe<Events>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch data from the table: "gender" using primary key columns */
  genderByPk?: Maybe<Gender>;
  /** fetch data from the table: "group_comment_votes" */
  groupCommentVotes: Array<GroupCommentVotes>;
  /** fetch aggregated fields from the table: "group_comment_votes" */
  groupCommentVotesAggregate: GroupCommentVotesAggregate;
  /** fetch data from the table: "group_comment_votes" using primary key columns */
  groupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** fetch data from the table: "group_members" */
  groupMembers: Array<GroupMembers>;
  /** fetch aggregated fields from the table: "group_members" */
  groupMembersAggregate: GroupMembersAggregate;
  /** fetch data from the table: "group_members" using primary key columns */
  groupMembersByPk?: Maybe<GroupMembers>;
  /** fetch data from the table: "group_thread_comment_files" */
  groupThreadCommentFiles: Array<GroupThreadCommentFiles>;
  /** fetch data from the table: "group_thread_comment_files" using primary key columns */
  groupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** fetch data from the table: "group_thread_comments" */
  groupThreadComments: Array<GroupThreadComments>;
  /** fetch aggregated fields from the table: "group_thread_comments" */
  groupThreadCommentsAggregate: GroupThreadCommentsAggregate;
  /** fetch data from the table: "group_thread_comments" using primary key columns */
  groupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** fetch data from the table: "group_threads" */
  groupThreads: Array<GroupThreads>;
  /** fetch data from the table: "group_threads" using primary key columns */
  groupThreadsByPk?: Maybe<GroupThreads>;
  /** fetch data from the table: "group_venues" */
  groupVenues: Array<GroupVenues>;
  /** fetch aggregated fields from the table: "group_venues" */
  groupVenuesAggregate: GroupVenuesAggregate;
  /** fetch data from the table: "group_venues" using primary key columns */
  groupVenuesByPk?: Maybe<GroupVenues>;
  /** An array relationship */
  groups: Array<Groups>;
  /** fetch data from the table: "groups" using primary key columns */
  groupsByPk?: Maybe<Groups>;
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  /** fetch data from the table: "groups_play_sessions" using primary key columns */
  groupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** fetch data from the table: "lesson_equipment" */
  lessonEquipment: Array<LessonEquipment>;
  /** fetch data from the table: "lesson_equipment" using primary key columns */
  lessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** fetch data from the table: "lesson_equipment_options" */
  lessonEquipmentOptions: Array<LessonEquipmentOptions>;
  /** fetch data from the table: "lesson_equipment_options" using primary key columns */
  lessonEquipmentOptionsByPk?: Maybe<LessonEquipmentOptions>;
  /** fetch data from the table: "lesson_order_items" */
  lessonOrderItems: Array<LessonOrderItems>;
  /** fetch data from the table: "lesson_order_items" using primary key columns */
  lessonOrderItemsByPk?: Maybe<LessonOrderItems>;
  /** fetch data from the table: "lesson_orders" */
  lessonOrders: Array<LessonOrders>;
  /** fetch aggregated fields from the table: "lesson_orders" */
  lessonOrdersAggregate: LessonOrdersAggregate;
  /** fetch data from the table: "lesson_orders" using primary key columns */
  lessonOrdersByPk?: Maybe<LessonOrders>;
  /** fetch data from the table: "lesson_participant_statuses" */
  lessonParticipantStatuses: Array<LessonParticipantStatuses>;
  /** fetch data from the table: "lesson_participant_statuses" using primary key columns */
  lessonParticipantStatusesByPk?: Maybe<LessonParticipantStatuses>;
  /** fetch data from the table: "lesson_participants" */
  lessonParticipants: Array<LessonParticipants>;
  /** fetch aggregated fields from the table: "lesson_participants" */
  lessonParticipantsAggregate: LessonParticipantsAggregate;
  /** fetch data from the table: "lesson_participants" using primary key columns */
  lessonParticipantsByPk?: Maybe<LessonParticipants>;
  /** fetch data from the table: "lesson_privacy" */
  lessonPrivacy: Array<LessonPrivacy>;
  /** fetch data from the table: "lesson_privacy" using primary key columns */
  lessonPrivacyByPk?: Maybe<LessonPrivacy>;
  /** fetch data from the table: "lesson_statuses" */
  lessonStatuses: Array<LessonStatuses>;
  /** fetch data from the table: "lesson_statuses" using primary key columns */
  lessonStatusesByPk?: Maybe<LessonStatuses>;
  /** An array relationship */
  lessonTemplates: Array<LessonTemplates>;
  /** fetch data from the table: "lesson_templates" using primary key columns */
  lessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** fetch data from the table: "lesson_times" */
  lessonTimes: Array<LessonTimes>;
  /** fetch data from the table: "lesson_times" using primary key columns */
  lessonTimesByPk?: Maybe<LessonTimes>;
  /** fetch data from the table: "lesson_types" */
  lessonTypes: Array<LessonTypes>;
  /** fetch data from the table: "lesson_types" using primary key columns */
  lessonTypesByPk?: Maybe<LessonTypes>;
  /** fetch data from the table: "lesson_waitlist_statuses" */
  lessonWaitlistStatuses: Array<LessonWaitlistStatuses>;
  /** fetch data from the table: "lesson_waitlist_statuses" using primary key columns */
  lessonWaitlistStatusesByPk?: Maybe<LessonWaitlistStatuses>;
  /** fetch data from the table: "lesson_waitlists" */
  lessonWaitlists: Array<LessonWaitlists>;
  /** fetch aggregated fields from the table: "lesson_waitlists" */
  lessonWaitlistsAggregate: LessonWaitlistsAggregate;
  /** fetch data from the table: "lesson_waitlists" using primary key columns */
  lessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** An array relationship */
  lessons: Array<Lessons>;
  /** An aggregate relationship */
  lessonsAggregate: LessonsAggregate;
  /** fetch data from the table: "lessons" using primary key columns */
  lessonsByPk?: Maybe<Lessons>;
  /** fetch data from the table: "match_selection_criteria" */
  matchSelectionCriteria: Array<MatchSelectionCriteria>;
  /** fetch data from the table: "match_selection_criteria" using primary key columns */
  matchSelectionCriteriaByPk?: Maybe<MatchSelectionCriteria>;
  /** fetch data from the table: "payment_fulfillment_channels" */
  paymentFulfillmentChannels: Array<PaymentFulfillmentChannels>;
  /** fetch data from the table: "payment_fulfillment_channels" using primary key columns */
  paymentFulfillmentChannelsByPk?: Maybe<PaymentFulfillmentChannels>;
  /** fetch data from the table: "pickleball_rating_scales" */
  pickleballRatingScales: Array<PickleballRatingScales>;
  /** fetch data from the table: "pickleball_rating_scales" using primary key columns */
  pickleballRatingScalesByPk?: Maybe<PickleballRatingScales>;
  /** fetch data from the table: "play_session_comments" */
  playSessionComments: Array<PlaySessionComments>;
  /** fetch aggregated fields from the table: "play_session_comments" */
  playSessionCommentsAggregate: PlaySessionCommentsAggregate;
  /** fetch data from the table: "play_session_comments" using primary key columns */
  playSessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** fetch data from the table: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatuses: Array<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table: "play_session_court_booking_statuses" using primary key columns */
  playSessionCourtBookingStatusesByPk?: Maybe<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table: "play_session_formats" */
  playSessionFormats: Array<PlaySessionFormats>;
  /** fetch data from the table: "play_session_formats" using primary key columns */
  playSessionFormatsByPk?: Maybe<PlaySessionFormats>;
  /** fetch data from the table: "play_session_match_competitiveness" */
  playSessionMatchCompetitiveness: Array<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table: "play_session_match_competitiveness" using primary key columns */
  playSessionMatchCompetitivenessByPk?: Maybe<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table: "play_session_participant_statuses" */
  playSessionParticipantStatuses: Array<PlaySessionParticipantStatuses>;
  /** fetch data from the table: "play_session_participant_statuses" using primary key columns */
  playSessionParticipantStatusesByPk?: Maybe<PlaySessionParticipantStatuses>;
  /** fetch data from the table: "play_session_participants" */
  playSessionParticipants: Array<PlaySessionParticipants>;
  /** fetch aggregated fields from the table: "play_session_participants" */
  playSessionParticipantsAggregate: PlaySessionParticipantsAggregate;
  /** fetch data from the table: "play_session_participants" using primary key columns */
  playSessionParticipantsByPk?: Maybe<PlaySessionParticipants>;
  /** fetch data from the table: "play_session_privacy" */
  playSessionPrivacy: Array<PlaySessionPrivacy>;
  /** fetch data from the table: "play_session_privacy" using primary key columns */
  playSessionPrivacyByPk?: Maybe<PlaySessionPrivacy>;
  /** fetch data from the table: "play_session_statuses" */
  playSessionStatuses: Array<PlaySessionStatuses>;
  /** fetch data from the table: "play_session_statuses" using primary key columns */
  playSessionStatusesByPk?: Maybe<PlaySessionStatuses>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  /** fetch data from the table: "play_sessions" using primary key columns */
  playSessionsByPk?: Maybe<PlaySessions>;
  /** fetch data from the table: "scoring_format" */
  scoringFormat: Array<ScoringFormat>;
  /** fetch data from the table: "scoring_format" using primary key columns */
  scoringFormatByPk?: Maybe<ScoringFormat>;
  /** fetch data from the table: "signup_requests" */
  signupRequests: Array<SignupRequests>;
  /** fetch data from the table: "signup_requests" using primary key columns */
  signupRequestsByPk?: Maybe<SignupRequests>;
  /** fetch data from the table: "skill_levels" */
  skillLevels: Array<SkillLevels>;
  /** fetch data from the table: "skill_levels" using primary key columns */
  skillLevelsByPk?: Maybe<SkillLevels>;
  /** fetch data from the table: "sports" */
  sports: Array<Sports>;
  /** fetch data from the table: "sports" using primary key columns */
  sportsByPk?: Maybe<Sports>;
  /** fetch data from the table: "team_types" */
  teamTypes: Array<TeamTypes>;
  /** fetch data from the table: "team_types" using primary key columns */
  teamTypesByPk?: Maybe<TeamTypes>;
  /** fetch data from the table: "tennis_rating_scales" */
  tennisRatingScales: Array<TennisRatingScales>;
  /** fetch data from the table: "tennis_rating_scales" using primary key columns */
  tennisRatingScalesByPk?: Maybe<TennisRatingScales>;
  /** fetch data from the table: "user_coach_services" */
  userCoachServices: Array<UserCoachServices>;
  /** fetch data from the table: "user_coach_services" using primary key columns */
  userCoachServicesByPk?: Maybe<UserCoachServices>;
  /** fetch data from the table: "user_communication_preferences" */
  userCommunicationPreferences: Array<UserCommunicationPreferences>;
  /** fetch data from the table: "user_communication_preferences" using primary key columns */
  userCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** fetch data from the table: "user_credit_cards" */
  userCreditCards: Array<UserCreditCards>;
  /** fetch data from the table: "user_credit_cards" using primary key columns */
  userCreditCardsByPk?: Maybe<UserCreditCards>;
  /** fetch data from the table: "user_custom_courts" */
  userCustomCourts: Array<UserCustomCourts>;
  /** fetch data from the table: "user_custom_courts" using primary key columns */
  userCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** fetch data from the table: "user_follows" */
  userFollows: Array<UserFollows>;
  /** fetch aggregated fields from the table: "user_follows" */
  userFollowsAggregate: UserFollowsAggregate;
  /** fetch data from the table: "user_follows" using primary key columns */
  userFollowsByPk?: Maybe<UserFollows>;
  /** fetch data from the table: "user_image_log" */
  userImageLog: Array<UserImageLog>;
  /** fetch data from the table: "user_image_log" using primary key columns */
  userImageLogByPk?: Maybe<UserImageLog>;
  /** fetch data from the table: "user_notification_details" */
  userNotificationDetails: Array<UserNotificationDetails>;
  /** fetch data from the table: "user_notification_details" using primary key columns */
  userNotificationDetailsByPk?: Maybe<UserNotificationDetails>;
  /** fetch data from the table: "user_notification_entities" */
  userNotificationEntities: Array<UserNotificationEntities>;
  /** fetch data from the table: "user_notification_entities" using primary key columns */
  userNotificationEntitiesByPk?: Maybe<UserNotificationEntities>;
  /** An array relationship */
  userNotifications: Array<UserNotifications>;
  /** An aggregate relationship */
  userNotificationsAggregate: UserNotificationsAggregate;
  /** fetch data from the table: "user_notifications" using primary key columns */
  userNotificationsByPk?: Maybe<UserNotifications>;
  /** fetch data from the table: "user_profiles" */
  userProfiles: Array<UserProfiles>;
  /** fetch data from the table: "user_terms_of_service" */
  userTermsOfService: Array<UserTermsOfService>;
  /** fetch data from the table: "user_terms_of_service" using primary key columns */
  userTermsOfServiceByPk?: Maybe<UserTermsOfService>;
  /** fetch data from the table: "usernames_active" */
  usernamesActive: Array<UsernamesActive>;
  /** An array relationship */
  usernamesClaimed: Array<UsernamesClaimed>;
  /** fetch data from the table: "usernames_claimed" using primary key columns */
  usernamesClaimedByPk?: Maybe<UsernamesClaimed>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table: "users_coach_qualifications" */
  usersCoachQualifications: Array<UsersCoachQualifications>;
  /** fetch data from the table: "users_coach_qualifications" using primary key columns */
  usersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** fetch data from the table: "venue_access_types" */
  venueAccessTypes: Array<VenueAccessTypes>;
  /** fetch data from the table: "venue_access_types" using primary key columns */
  venueAccessTypesByPk?: Maybe<VenueAccessTypes>;
  /** fetch data from the table: "venue_amenities" */
  venueAmenities: Array<VenueAmenities>;
  /** fetch data from the table: "venue_amenities" using primary key columns */
  venueAmenitiesByPk?: Maybe<VenueAmenities>;
  /** fetch data from the table: "venue_court_surfaces" */
  venueCourtSurfaces: Array<VenueCourtSurfaces>;
  /** fetch data from the table: "venue_court_surfaces" using primary key columns */
  venueCourtSurfacesByPk?: Maybe<VenueCourtSurfaces>;
  /** fetch data from the table: "venue_facility_types" */
  venueFacilityTypes: Array<VenueFacilityTypes>;
  /** fetch data from the table: "venue_facility_types" using primary key columns */
  venueFacilityTypesByPk?: Maybe<VenueFacilityTypes>;
  /** fetch data from the table: "venue_follows" */
  venueFollows: Array<VenueFollows>;
  /** fetch aggregated fields from the table: "venue_follows" */
  venueFollowsAggregate: VenueFollowsAggregate;
  /** fetch data from the table: "venue_follows" using primary key columns */
  venueFollowsByPk?: Maybe<VenueFollows>;
  /** fetch data from the table: "venue_images" */
  venueImages: Array<VenueImages>;
  /** fetch data from the table: "venue_images" using primary key columns */
  venueImagesByPk?: Maybe<VenueImages>;
  /** fetch data from the table: "venue_lines" */
  venueLines: Array<VenueLines>;
  /** fetch data from the table: "venue_lines" using primary key columns */
  venueLinesByPk?: Maybe<VenueLines>;
  /** fetch data from the table: "venue_nets" */
  venueNets: Array<VenueNets>;
  /** fetch data from the table: "venue_nets" using primary key columns */
  venueNetsByPk?: Maybe<VenueNets>;
  /** An array relationship */
  venues: Array<Venues>;
  /** fetch data from the table: "venues" using primary key columns */
  venuesByPk?: Maybe<Venues>;
  /** fetch data from the table: "win_reasons" */
  winReasons: Array<WinReasons>;
  /** fetch data from the table: "win_reasons" using primary key columns */
  winReasonsByPk?: Maybe<WinReasons>;
};


export type Query_RootAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<AmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AmenitiesOrderBy>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Query_RootAmenitiesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootAppPersonasArgs = {
  distinctOn?: InputMaybe<Array<AppPersonasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPersonasOrderBy>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Query_RootAppPersonasByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootAppPingsArgs = {
  distinctOn?: InputMaybe<Array<AppPingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPingsOrderBy>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Query_RootAppPingsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBallTypesArgs = {
  distinctOn?: InputMaybe<Array<BallTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BallTypesOrderBy>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Query_RootBallTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCitiesArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Query_RootCitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCoachQualificationGroupsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationGroupsOrderBy>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Query_RootCoachQualificationGroupsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationsOrderBy>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Query_RootCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCoachStatusArgs = {
  distinctOn?: InputMaybe<Array<CoachStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachStatusOrderBy>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Query_RootCoachStatusByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCommentVoteArgs = {
  distinctOn?: InputMaybe<Array<CommentVoteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentVoteOrderBy>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Query_RootCommentVoteByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCommunicationPreferenceStatusesArgs = {
  distinctOn?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommunicationPreferenceStatusesOrderBy>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Query_RootCommunicationPreferenceStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCompetitionFormatsArgs = {
  distinctOn?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionFormatsOrderBy>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Query_RootCompetitionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCompetitionGenderArgs = {
  distinctOn?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionGenderOrderBy>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Query_RootCompetitionGenderByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCountriesArgs = {
  distinctOn?: InputMaybe<Array<CountriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Query_RootCountriesByPkArgs = {
  id: Scalars['String'];
};


export type Query_RootCountrySubdivisionsArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Query_RootCountrySubdivisionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CourtSurfacesOrderBy>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Query_RootCourtSurfacesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventContactDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventContactDetailsOrderBy>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Query_RootEventContactDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventCourtStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtStatusesOrderBy>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Query_RootEventCourtStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Query_RootEventCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventFaqsArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Query_RootEventFaqsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGameScoresArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Query_RootEventGameScoresByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupFormatsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupFormatsOrderBy>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Query_RootEventGroupFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventGroupPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Query_RootEventGroupPoolsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupRegistrationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationStatusesOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Query_RootEventGroupRegistrationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventGroupRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Query_RootEventGroupRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupSequenceSeedingArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Query_RootEventGroupSequenceSeedingByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupSequencesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Query_RootEventGroupSequencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Query_RootEventGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventInvitationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationStatusesOrderBy>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Query_RootEventInvitationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Query_RootEventInvitationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventListingFeesArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Query_RootEventListingFeesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventMatchGamesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Query_RootEventMatchGamesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Query_RootEventMatchesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventMatchesTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Query_RootEventMatchesTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventOrganizerAccountTypesArgs = {
  distinctOn?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventOrganizerAccountTypesOrderBy>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Query_RootEventOrganizerAccountTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventPoolRoundsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Query_RootEventPoolRoundsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventPoolsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Query_RootEventPoolsTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventPrivacyArgs = {
  distinctOn?: InputMaybe<Array<EventPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPrivacyOrderBy>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Query_RootEventPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventRegistrationDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationDetailsOrderBy>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Query_RootEventRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Query_RootEventRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventSequenceCompleteReasonsArgs = {
  distinctOn?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSequenceCompleteReasonsOrderBy>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Query_RootEventSequenceCompleteReasonsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventSponsorsArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Query_RootEventSponsorsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventStatusesOrderBy>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Query_RootEventStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventTeamMemberStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMemberStatusesOrderBy>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Query_RootEventTeamMemberStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventTeamMembersArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Query_RootEventTeamMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Query_RootEventTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTransactionItemTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemTypesOrderBy>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Query_RootEventTransactionItemTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Query_RootEventTransactionItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTransactionsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Query_RootEventTransactionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTypesOrderBy>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Query_RootEventTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventsArgs = {
  distinctOn?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Query_RootEventsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGenderArgs = {
  distinctOn?: InputMaybe<Array<GenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GenderOrderBy>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Query_RootGenderByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootGroupCommentVotesArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Query_RootGroupCommentVotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Query_RootGroupCommentVotesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupMembersArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Query_RootGroupMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Query_RootGroupMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupThreadCommentFilesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Query_RootGroupThreadCommentFilesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupThreadCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Query_RootGroupThreadCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Query_RootGroupThreadCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupThreadsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Query_RootGroupThreadsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupVenuesArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Query_RootGroupVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Query_RootGroupVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Query_RootGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Query_RootGroupsPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonEquipmentArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Query_RootLessonEquipmentByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonEquipmentOptionsArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOptionsOrderBy>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Query_RootLessonEquipmentOptionsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonOrderItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Query_RootLessonOrderItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonOrdersArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Query_RootLessonOrdersAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Query_RootLessonOrdersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantStatusesOrderBy>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Query_RootLessonParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonParticipantsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Query_RootLessonParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Query_RootLessonParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonPrivacyArgs = {
  distinctOn?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonPrivacyOrderBy>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Query_RootLessonPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonStatusesOrderBy>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Query_RootLessonStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonTemplatesArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Query_RootLessonTemplatesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonTimesArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Query_RootLessonTimesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonTypesArgs = {
  distinctOn?: InputMaybe<Array<LessonTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTypesOrderBy>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Query_RootLessonTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonWaitlistStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistStatusesOrderBy>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Query_RootLessonWaitlistStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonWaitlistsArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Query_RootLessonWaitlistsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Query_RootLessonWaitlistsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Query_RootLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Query_RootLessonsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootMatchSelectionCriteriaArgs = {
  distinctOn?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MatchSelectionCriteriaOrderBy>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Query_RootMatchSelectionCriteriaByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPaymentFulfillmentChannelsArgs = {
  distinctOn?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentFulfillmentChannelsOrderBy>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Query_RootPaymentFulfillmentChannelsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPickleballRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PickleballRatingScalesOrderBy>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Query_RootPickleballRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlaySessionCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Query_RootPlaySessionCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Query_RootPlaySessionCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlaySessionCourtBookingStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCourtBookingStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Query_RootPlaySessionCourtBookingStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionFormatsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionFormatsOrderBy>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Query_RootPlaySessionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionMatchCompetitivenessArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionMatchCompetitivenessOrderBy>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Query_RootPlaySessionMatchCompetitivenessByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Query_RootPlaySessionParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionParticipantsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Query_RootPlaySessionParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Query_RootPlaySessionParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlaySessionPrivacyArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionPrivacyOrderBy>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Query_RootPlaySessionPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Query_RootPlaySessionStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Query_RootPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Query_RootPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootScoringFormatArgs = {
  distinctOn?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ScoringFormatOrderBy>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Query_RootScoringFormatByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootSignupRequestsArgs = {
  distinctOn?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SignupRequestsOrderBy>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Query_RootSignupRequestsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSkillLevelsArgs = {
  distinctOn?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkillLevelsOrderBy>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Query_RootSkillLevelsByPkArgs = {
  id: Scalars['String'];
};


export type Query_RootSportsArgs = {
  distinctOn?: InputMaybe<Array<SportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SportsOrderBy>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Query_RootSportsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootTeamTypesArgs = {
  distinctOn?: InputMaybe<Array<TeamTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TeamTypesOrderBy>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Query_RootTeamTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootTennisRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TennisRatingScalesOrderBy>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Query_RootTennisRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Query_RootUserCoachServicesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCommunicationPreferencesArgs = {
  distinctOn?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCommunicationPreferencesOrderBy>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Query_RootUserCommunicationPreferencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCreditCardsArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Query_RootUserCreditCardsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCustomCourtsArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Query_RootUserCustomCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserFollowsArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Query_RootUserFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Query_RootUserFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserImageLogArgs = {
  distinctOn?: InputMaybe<Array<UserImageLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserImageLogOrderBy>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Query_RootUserImageLogByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserNotificationDetailsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationDetailsOrderBy>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Query_RootUserNotificationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserNotificationEntitiesArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationEntitiesOrderBy>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Query_RootUserNotificationEntitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Query_RootUserNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Query_RootUserNotificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserProfilesArgs = {
  distinctOn?: InputMaybe<Array<UserProfilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserProfilesOrderBy>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Query_RootUserTermsOfServiceArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Query_RootUserTermsOfServiceByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsernamesActiveArgs = {
  distinctOn?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesActiveOrderBy>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Query_RootUsernamesClaimedArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Query_RootUsernamesClaimedByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsersCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Query_RootUsersCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueAccessTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAccessTypesOrderBy>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Query_RootVenueAccessTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenueAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Query_RootVenueAmenitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Query_RootVenueCourtSurfacesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueFacilityTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFacilityTypesOrderBy>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Query_RootVenueFacilityTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenueFollowsArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Query_RootVenueFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Query_RootVenueFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueImagesArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Query_RootVenueImagesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueLinesArgs = {
  distinctOn?: InputMaybe<Array<VenueLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueLinesOrderBy>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Query_RootVenueLinesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenueNetsArgs = {
  distinctOn?: InputMaybe<Array<VenueNetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueNetsOrderBy>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Query_RootVenueNetsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenuesArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Query_RootVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWinReasonsArgs = {
  distinctOn?: InputMaybe<Array<WinReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WinReasonsOrderBy>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};


export type Query_RootWinReasonsByPkArgs = {
  value: Scalars['String'];
};

export type St_D_Within_Geography_Input = {
  distance: Scalars['Float'];
  from: Scalars['geography'];
  use_spheroid?: InputMaybe<Scalars['Boolean']>;
};

export type St_D_Within_Input = {
  distance: Scalars['Float'];
  from: Scalars['geometry'];
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "amenities" */
  amenities: Array<Amenities>;
  /** fetch data from the table: "amenities" using primary key columns */
  amenitiesByPk?: Maybe<Amenities>;
  /** fetch data from the table in a streaming manner: "amenities" */
  amenitiesStream: Array<Amenities>;
  /** fetch data from the table: "app_personas" */
  appPersonas: Array<AppPersonas>;
  /** fetch data from the table: "app_personas" using primary key columns */
  appPersonasByPk?: Maybe<AppPersonas>;
  /** fetch data from the table in a streaming manner: "app_personas" */
  appPersonasStream: Array<AppPersonas>;
  /** fetch data from the table: "app_pings" */
  appPings: Array<AppPings>;
  /** fetch data from the table: "app_pings" using primary key columns */
  appPingsByPk?: Maybe<AppPings>;
  /** fetch data from the table in a streaming manner: "app_pings" */
  appPingsStream: Array<AppPings>;
  /** fetch data from the table: "ball_types" */
  ballTypes: Array<BallTypes>;
  /** fetch data from the table: "ball_types" using primary key columns */
  ballTypesByPk?: Maybe<BallTypes>;
  /** fetch data from the table in a streaming manner: "ball_types" */
  ballTypesStream: Array<BallTypes>;
  /** An array relationship */
  cities: Array<Cities>;
  /** fetch data from the table: "cities" using primary key columns */
  citiesByPk?: Maybe<Cities>;
  /** fetch data from the table in a streaming manner: "cities" */
  citiesStream: Array<Cities>;
  /** fetch data from the table: "coach_qualification_groups" */
  coachQualificationGroups: Array<CoachQualificationGroups>;
  /** fetch data from the table: "coach_qualification_groups" using primary key columns */
  coachQualificationGroupsByPk?: Maybe<CoachQualificationGroups>;
  /** fetch data from the table in a streaming manner: "coach_qualification_groups" */
  coachQualificationGroupsStream: Array<CoachQualificationGroups>;
  /** fetch data from the table: "coach_qualifications" */
  coachQualifications: Array<CoachQualifications>;
  /** fetch data from the table: "coach_qualifications" using primary key columns */
  coachQualificationsByPk?: Maybe<CoachQualifications>;
  /** fetch data from the table in a streaming manner: "coach_qualifications" */
  coachQualificationsStream: Array<CoachQualifications>;
  /** fetch data from the table: "coach_status" */
  coachStatus: Array<CoachStatus>;
  /** fetch data from the table: "coach_status" using primary key columns */
  coachStatusByPk?: Maybe<CoachStatus>;
  /** fetch data from the table in a streaming manner: "coach_status" */
  coachStatusStream: Array<CoachStatus>;
  /** fetch data from the table: "comment_vote" */
  commentVote: Array<CommentVote>;
  /** fetch data from the table: "comment_vote" using primary key columns */
  commentVoteByPk?: Maybe<CommentVote>;
  /** fetch data from the table in a streaming manner: "comment_vote" */
  commentVoteStream: Array<CommentVote>;
  /** fetch data from the table: "communication_preference_statuses" */
  communicationPreferenceStatuses: Array<CommunicationPreferenceStatuses>;
  /** fetch data from the table: "communication_preference_statuses" using primary key columns */
  communicationPreferenceStatusesByPk?: Maybe<CommunicationPreferenceStatuses>;
  /** fetch data from the table in a streaming manner: "communication_preference_statuses" */
  communicationPreferenceStatusesStream: Array<CommunicationPreferenceStatuses>;
  /** fetch data from the table: "competition_formats" */
  competitionFormats: Array<CompetitionFormats>;
  /** fetch data from the table: "competition_formats" using primary key columns */
  competitionFormatsByPk?: Maybe<CompetitionFormats>;
  /** fetch data from the table in a streaming manner: "competition_formats" */
  competitionFormatsStream: Array<CompetitionFormats>;
  /** fetch data from the table: "competition_gender" */
  competitionGender: Array<CompetitionGender>;
  /** fetch data from the table: "competition_gender" using primary key columns */
  competitionGenderByPk?: Maybe<CompetitionGender>;
  /** fetch data from the table in a streaming manner: "competition_gender" */
  competitionGenderStream: Array<CompetitionGender>;
  /** fetch data from the table: "countries" */
  countries: Array<Countries>;
  /** fetch data from the table: "countries" using primary key columns */
  countriesByPk?: Maybe<Countries>;
  /** fetch data from the table in a streaming manner: "countries" */
  countriesStream: Array<Countries>;
  /** fetch data from the table: "country_subdivisions" */
  countrySubdivisions: Array<CountrySubdivisions>;
  /** fetch data from the table: "country_subdivisions" using primary key columns */
  countrySubdivisionsByPk?: Maybe<CountrySubdivisions>;
  /** fetch data from the table in a streaming manner: "country_subdivisions" */
  countrySubdivisionsStream: Array<CountrySubdivisions>;
  /** fetch data from the table: "court_surfaces" */
  courtSurfaces: Array<CourtSurfaces>;
  /** fetch data from the table: "court_surfaces" using primary key columns */
  courtSurfacesByPk?: Maybe<CourtSurfaces>;
  /** fetch data from the table in a streaming manner: "court_surfaces" */
  courtSurfacesStream: Array<CourtSurfaces>;
  /** fetch data from the table: "event_contact_details" */
  eventContactDetails: Array<EventContactDetails>;
  /** fetch data from the table: "event_contact_details" using primary key columns */
  eventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** fetch data from the table in a streaming manner: "event_contact_details" */
  eventContactDetailsStream: Array<EventContactDetails>;
  /** fetch data from the table: "event_court_statuses" */
  eventCourtStatuses: Array<EventCourtStatuses>;
  /** fetch data from the table: "event_court_statuses" using primary key columns */
  eventCourtStatusesByPk?: Maybe<EventCourtStatuses>;
  /** fetch data from the table in a streaming manner: "event_court_statuses" */
  eventCourtStatusesStream: Array<EventCourtStatuses>;
  /** fetch data from the table: "event_courts" */
  eventCourts: Array<EventCourts>;
  /** fetch data from the table: "event_courts" using primary key columns */
  eventCourtsByPk?: Maybe<EventCourts>;
  /** fetch data from the table in a streaming manner: "event_courts" */
  eventCourtsStream: Array<EventCourts>;
  /** fetch data from the table: "event_faqs" */
  eventFaqs: Array<EventFaqs>;
  /** fetch data from the table: "event_faqs" using primary key columns */
  eventFaqsByPk?: Maybe<EventFaqs>;
  /** fetch data from the table in a streaming manner: "event_faqs" */
  eventFaqsStream: Array<EventFaqs>;
  /** fetch data from the table: "event_game_scores" */
  eventGameScores: Array<EventGameScores>;
  /** fetch data from the table: "event_game_scores" using primary key columns */
  eventGameScoresByPk?: Maybe<EventGameScores>;
  /** fetch data from the table in a streaming manner: "event_game_scores" */
  eventGameScoresStream: Array<EventGameScores>;
  /** fetch data from the table: "event_group_formats" */
  eventGroupFormats: Array<EventGroupFormats>;
  /** fetch data from the table: "event_group_formats" using primary key columns */
  eventGroupFormatsByPk?: Maybe<EventGroupFormats>;
  /** fetch data from the table in a streaming manner: "event_group_formats" */
  eventGroupFormatsStream: Array<EventGroupFormats>;
  /** fetch data from the table: "event_group_pools" */
  eventGroupPools: Array<EventGroupPools>;
  /** fetch data from the table: "event_group_pools" using primary key columns */
  eventGroupPoolsByPk?: Maybe<EventGroupPools>;
  /** fetch data from the table in a streaming manner: "event_group_pools" */
  eventGroupPoolsStream: Array<EventGroupPools>;
  /** fetch data from the table: "event_group_registration_statuses" */
  eventGroupRegistrationStatuses: Array<EventGroupRegistrationStatuses>;
  /** fetch data from the table: "event_group_registration_statuses" using primary key columns */
  eventGroupRegistrationStatusesByPk?: Maybe<EventGroupRegistrationStatuses>;
  /** fetch data from the table in a streaming manner: "event_group_registration_statuses" */
  eventGroupRegistrationStatusesStream: Array<EventGroupRegistrationStatuses>;
  /** fetch data from the table: "event_group_registrations" */
  eventGroupRegistrations: Array<EventGroupRegistrations>;
  /** fetch data from the table: "event_group_registrations" using primary key columns */
  eventGroupRegistrationsByPk?: Maybe<EventGroupRegistrations>;
  /** fetch data from the table in a streaming manner: "event_group_registrations" */
  eventGroupRegistrationsStream: Array<EventGroupRegistrations>;
  /** fetch data from the table: "event_group_sequence_seeding" */
  eventGroupSequenceSeeding: Array<EventGroupSequenceSeeding>;
  /** fetch data from the table: "event_group_sequence_seeding" using primary key columns */
  eventGroupSequenceSeedingByPk?: Maybe<EventGroupSequenceSeeding>;
  /** fetch data from the table in a streaming manner: "event_group_sequence_seeding" */
  eventGroupSequenceSeedingStream: Array<EventGroupSequenceSeeding>;
  /** fetch data from the table: "event_group_sequences" */
  eventGroupSequences: Array<EventGroupSequences>;
  /** fetch data from the table: "event_group_sequences" using primary key columns */
  eventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** fetch data from the table in a streaming manner: "event_group_sequences" */
  eventGroupSequencesStream: Array<EventGroupSequences>;
  /** fetch data from the table: "event_groups" */
  eventGroups: Array<EventGroups>;
  /** fetch data from the table: "event_groups" using primary key columns */
  eventGroupsByPk?: Maybe<EventGroups>;
  /** fetch data from the table in a streaming manner: "event_groups" */
  eventGroupsStream: Array<EventGroups>;
  /** fetch data from the table: "event_invitation_statuses" */
  eventInvitationStatuses: Array<EventInvitationStatuses>;
  /** fetch data from the table: "event_invitation_statuses" using primary key columns */
  eventInvitationStatusesByPk?: Maybe<EventInvitationStatuses>;
  /** fetch data from the table in a streaming manner: "event_invitation_statuses" */
  eventInvitationStatusesStream: Array<EventInvitationStatuses>;
  /** fetch data from the table: "event_invitations" */
  eventInvitations: Array<EventInvitations>;
  /** fetch data from the table: "event_invitations" using primary key columns */
  eventInvitationsByPk?: Maybe<EventInvitations>;
  /** fetch data from the table in a streaming manner: "event_invitations" */
  eventInvitationsStream: Array<EventInvitations>;
  /** fetch data from the table: "event_listing_fees" */
  eventListingFees: Array<EventListingFees>;
  /** fetch data from the table: "event_listing_fees" using primary key columns */
  eventListingFeesByPk?: Maybe<EventListingFees>;
  /** fetch data from the table in a streaming manner: "event_listing_fees" */
  eventListingFeesStream: Array<EventListingFees>;
  /** fetch data from the table: "event_match_games" */
  eventMatchGames: Array<EventMatchGames>;
  /** fetch data from the table: "event_match_games" using primary key columns */
  eventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** fetch data from the table in a streaming manner: "event_match_games" */
  eventMatchGamesStream: Array<EventMatchGames>;
  /** fetch data from the table: "event_matches" */
  eventMatches: Array<EventMatches>;
  /** fetch data from the table: "event_matches" using primary key columns */
  eventMatchesByPk?: Maybe<EventMatches>;
  /** fetch data from the table in a streaming manner: "event_matches" */
  eventMatchesStream: Array<EventMatches>;
  /** fetch data from the table: "event_matches_teams" */
  eventMatchesTeams: Array<EventMatchesTeams>;
  /** fetch data from the table: "event_matches_teams" using primary key columns */
  eventMatchesTeamsByPk?: Maybe<EventMatchesTeams>;
  /** fetch data from the table in a streaming manner: "event_matches_teams" */
  eventMatchesTeamsStream: Array<EventMatchesTeams>;
  /** fetch data from the table: "event_organizer_account_types" */
  eventOrganizerAccountTypes: Array<EventOrganizerAccountTypes>;
  /** fetch data from the table: "event_organizer_account_types" using primary key columns */
  eventOrganizerAccountTypesByPk?: Maybe<EventOrganizerAccountTypes>;
  /** fetch data from the table in a streaming manner: "event_organizer_account_types" */
  eventOrganizerAccountTypesStream: Array<EventOrganizerAccountTypes>;
  /** fetch data from the table: "event_pool_rounds" */
  eventPoolRounds: Array<EventPoolRounds>;
  /** fetch data from the table: "event_pool_rounds" using primary key columns */
  eventPoolRoundsByPk?: Maybe<EventPoolRounds>;
  /** fetch data from the table in a streaming manner: "event_pool_rounds" */
  eventPoolRoundsStream: Array<EventPoolRounds>;
  /** fetch data from the table: "event_pools_teams" */
  eventPoolsTeams: Array<EventPoolsTeams>;
  /** fetch data from the table: "event_pools_teams" using primary key columns */
  eventPoolsTeamsByPk?: Maybe<EventPoolsTeams>;
  /** fetch data from the table in a streaming manner: "event_pools_teams" */
  eventPoolsTeamsStream: Array<EventPoolsTeams>;
  /** fetch data from the table: "event_privacy" */
  eventPrivacy: Array<EventPrivacy>;
  /** fetch data from the table: "event_privacy" using primary key columns */
  eventPrivacyByPk?: Maybe<EventPrivacy>;
  /** fetch data from the table in a streaming manner: "event_privacy" */
  eventPrivacyStream: Array<EventPrivacy>;
  /** fetch data from the table: "event_registration_details" */
  eventRegistrationDetails: Array<EventRegistrationDetails>;
  /** fetch data from the table: "event_registration_details" using primary key columns */
  eventRegistrationDetailsByPk?: Maybe<EventRegistrationDetails>;
  /** fetch data from the table in a streaming manner: "event_registration_details" */
  eventRegistrationDetailsStream: Array<EventRegistrationDetails>;
  /** fetch data from the table: "event_registrations" */
  eventRegistrations: Array<EventRegistrations>;
  /** fetch data from the table: "event_registrations" using primary key columns */
  eventRegistrationsByPk?: Maybe<EventRegistrations>;
  /** fetch data from the table in a streaming manner: "event_registrations" */
  eventRegistrationsStream: Array<EventRegistrations>;
  /** fetch data from the table: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasons: Array<EventSequenceCompleteReasons>;
  /** fetch data from the table: "event_sequence_complete_reasons" using primary key columns */
  eventSequenceCompleteReasonsByPk?: Maybe<EventSequenceCompleteReasons>;
  /** fetch data from the table in a streaming manner: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasonsStream: Array<EventSequenceCompleteReasons>;
  /** fetch data from the table: "event_sponsors" */
  eventSponsors: Array<EventSponsors>;
  /** fetch data from the table: "event_sponsors" using primary key columns */
  eventSponsorsByPk?: Maybe<EventSponsors>;
  /** fetch data from the table in a streaming manner: "event_sponsors" */
  eventSponsorsStream: Array<EventSponsors>;
  /** fetch data from the table: "event_statuses" */
  eventStatuses: Array<EventStatuses>;
  /** fetch data from the table: "event_statuses" using primary key columns */
  eventStatusesByPk?: Maybe<EventStatuses>;
  /** fetch data from the table in a streaming manner: "event_statuses" */
  eventStatusesStream: Array<EventStatuses>;
  /** fetch data from the table: "event_team_member_statuses" */
  eventTeamMemberStatuses: Array<EventTeamMemberStatuses>;
  /** fetch data from the table: "event_team_member_statuses" using primary key columns */
  eventTeamMemberStatusesByPk?: Maybe<EventTeamMemberStatuses>;
  /** fetch data from the table in a streaming manner: "event_team_member_statuses" */
  eventTeamMemberStatusesStream: Array<EventTeamMemberStatuses>;
  /** fetch data from the table: "event_team_members" */
  eventTeamMembers: Array<EventTeamMembers>;
  /** fetch data from the table: "event_team_members" using primary key columns */
  eventTeamMembersByPk?: Maybe<EventTeamMembers>;
  /** fetch data from the table in a streaming manner: "event_team_members" */
  eventTeamMembersStream: Array<EventTeamMembers>;
  /** fetch data from the table: "event_teams" */
  eventTeams: Array<EventTeams>;
  /** fetch data from the table: "event_teams" using primary key columns */
  eventTeamsByPk?: Maybe<EventTeams>;
  /** fetch data from the table in a streaming manner: "event_teams" */
  eventTeamsStream: Array<EventTeams>;
  /** fetch data from the table: "event_transaction_item_types" */
  eventTransactionItemTypes: Array<EventTransactionItemTypes>;
  /** fetch data from the table: "event_transaction_item_types" using primary key columns */
  eventTransactionItemTypesByPk?: Maybe<EventTransactionItemTypes>;
  /** fetch data from the table in a streaming manner: "event_transaction_item_types" */
  eventTransactionItemTypesStream: Array<EventTransactionItemTypes>;
  /** fetch data from the table: "event_transaction_items" */
  eventTransactionItems: Array<EventTransactionItems>;
  /** fetch data from the table: "event_transaction_items" using primary key columns */
  eventTransactionItemsByPk?: Maybe<EventTransactionItems>;
  /** fetch data from the table in a streaming manner: "event_transaction_items" */
  eventTransactionItemsStream: Array<EventTransactionItems>;
  /** fetch data from the table: "event_transactions" */
  eventTransactions: Array<EventTransactions>;
  /** fetch data from the table: "event_transactions" using primary key columns */
  eventTransactionsByPk?: Maybe<EventTransactions>;
  /** fetch data from the table in a streaming manner: "event_transactions" */
  eventTransactionsStream: Array<EventTransactions>;
  /** fetch data from the table: "event_types" */
  eventTypes: Array<EventTypes>;
  /** fetch data from the table: "event_types" using primary key columns */
  eventTypesByPk?: Maybe<EventTypes>;
  /** fetch data from the table in a streaming manner: "event_types" */
  eventTypesStream: Array<EventTypes>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch data from the table: "events" using primary key columns */
  eventsByPk?: Maybe<Events>;
  /** fetch data from the table in a streaming manner: "events" */
  eventsStream: Array<Events>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch data from the table: "gender" using primary key columns */
  genderByPk?: Maybe<Gender>;
  /** fetch data from the table in a streaming manner: "gender" */
  genderStream: Array<Gender>;
  /** fetch data from the table: "group_comment_votes" */
  groupCommentVotes: Array<GroupCommentVotes>;
  /** fetch aggregated fields from the table: "group_comment_votes" */
  groupCommentVotesAggregate: GroupCommentVotesAggregate;
  /** fetch data from the table: "group_comment_votes" using primary key columns */
  groupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** fetch data from the table in a streaming manner: "group_comment_votes" */
  groupCommentVotesStream: Array<GroupCommentVotes>;
  /** fetch data from the table: "group_members" */
  groupMembers: Array<GroupMembers>;
  /** fetch aggregated fields from the table: "group_members" */
  groupMembersAggregate: GroupMembersAggregate;
  /** fetch data from the table: "group_members" using primary key columns */
  groupMembersByPk?: Maybe<GroupMembers>;
  /** fetch data from the table in a streaming manner: "group_members" */
  groupMembersStream: Array<GroupMembers>;
  /** fetch data from the table: "group_thread_comment_files" */
  groupThreadCommentFiles: Array<GroupThreadCommentFiles>;
  /** fetch data from the table: "group_thread_comment_files" using primary key columns */
  groupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** fetch data from the table in a streaming manner: "group_thread_comment_files" */
  groupThreadCommentFilesStream: Array<GroupThreadCommentFiles>;
  /** fetch data from the table: "group_thread_comments" */
  groupThreadComments: Array<GroupThreadComments>;
  /** fetch aggregated fields from the table: "group_thread_comments" */
  groupThreadCommentsAggregate: GroupThreadCommentsAggregate;
  /** fetch data from the table: "group_thread_comments" using primary key columns */
  groupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** fetch data from the table in a streaming manner: "group_thread_comments" */
  groupThreadCommentsStream: Array<GroupThreadComments>;
  /** fetch data from the table: "group_threads" */
  groupThreads: Array<GroupThreads>;
  /** fetch data from the table: "group_threads" using primary key columns */
  groupThreadsByPk?: Maybe<GroupThreads>;
  /** fetch data from the table in a streaming manner: "group_threads" */
  groupThreadsStream: Array<GroupThreads>;
  /** fetch data from the table: "group_venues" */
  groupVenues: Array<GroupVenues>;
  /** fetch aggregated fields from the table: "group_venues" */
  groupVenuesAggregate: GroupVenuesAggregate;
  /** fetch data from the table: "group_venues" using primary key columns */
  groupVenuesByPk?: Maybe<GroupVenues>;
  /** fetch data from the table in a streaming manner: "group_venues" */
  groupVenuesStream: Array<GroupVenues>;
  /** An array relationship */
  groups: Array<Groups>;
  /** fetch data from the table: "groups" using primary key columns */
  groupsByPk?: Maybe<Groups>;
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  /** fetch data from the table: "groups_play_sessions" using primary key columns */
  groupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** fetch data from the table in a streaming manner: "groups_play_sessions" */
  groupsPlaySessionsStream: Array<GroupsPlaySessions>;
  /** fetch data from the table in a streaming manner: "groups" */
  groupsStream: Array<Groups>;
  /** fetch data from the table: "lesson_equipment" */
  lessonEquipment: Array<LessonEquipment>;
  /** fetch data from the table: "lesson_equipment" using primary key columns */
  lessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** fetch data from the table: "lesson_equipment_options" */
  lessonEquipmentOptions: Array<LessonEquipmentOptions>;
  /** fetch data from the table: "lesson_equipment_options" using primary key columns */
  lessonEquipmentOptionsByPk?: Maybe<LessonEquipmentOptions>;
  /** fetch data from the table in a streaming manner: "lesson_equipment_options" */
  lessonEquipmentOptionsStream: Array<LessonEquipmentOptions>;
  /** fetch data from the table in a streaming manner: "lesson_equipment" */
  lessonEquipmentStream: Array<LessonEquipment>;
  /** fetch data from the table: "lesson_order_items" */
  lessonOrderItems: Array<LessonOrderItems>;
  /** fetch data from the table: "lesson_order_items" using primary key columns */
  lessonOrderItemsByPk?: Maybe<LessonOrderItems>;
  /** fetch data from the table in a streaming manner: "lesson_order_items" */
  lessonOrderItemsStream: Array<LessonOrderItems>;
  /** fetch data from the table: "lesson_orders" */
  lessonOrders: Array<LessonOrders>;
  /** fetch aggregated fields from the table: "lesson_orders" */
  lessonOrdersAggregate: LessonOrdersAggregate;
  /** fetch data from the table: "lesson_orders" using primary key columns */
  lessonOrdersByPk?: Maybe<LessonOrders>;
  /** fetch data from the table in a streaming manner: "lesson_orders" */
  lessonOrdersStream: Array<LessonOrders>;
  /** fetch data from the table: "lesson_participant_statuses" */
  lessonParticipantStatuses: Array<LessonParticipantStatuses>;
  /** fetch data from the table: "lesson_participant_statuses" using primary key columns */
  lessonParticipantStatusesByPk?: Maybe<LessonParticipantStatuses>;
  /** fetch data from the table in a streaming manner: "lesson_participant_statuses" */
  lessonParticipantStatusesStream: Array<LessonParticipantStatuses>;
  /** fetch data from the table: "lesson_participants" */
  lessonParticipants: Array<LessonParticipants>;
  /** fetch aggregated fields from the table: "lesson_participants" */
  lessonParticipantsAggregate: LessonParticipantsAggregate;
  /** fetch data from the table: "lesson_participants" using primary key columns */
  lessonParticipantsByPk?: Maybe<LessonParticipants>;
  /** fetch data from the table in a streaming manner: "lesson_participants" */
  lessonParticipantsStream: Array<LessonParticipants>;
  /** fetch data from the table: "lesson_privacy" */
  lessonPrivacy: Array<LessonPrivacy>;
  /** fetch data from the table: "lesson_privacy" using primary key columns */
  lessonPrivacyByPk?: Maybe<LessonPrivacy>;
  /** fetch data from the table in a streaming manner: "lesson_privacy" */
  lessonPrivacyStream: Array<LessonPrivacy>;
  /** fetch data from the table: "lesson_statuses" */
  lessonStatuses: Array<LessonStatuses>;
  /** fetch data from the table: "lesson_statuses" using primary key columns */
  lessonStatusesByPk?: Maybe<LessonStatuses>;
  /** fetch data from the table in a streaming manner: "lesson_statuses" */
  lessonStatusesStream: Array<LessonStatuses>;
  /** An array relationship */
  lessonTemplates: Array<LessonTemplates>;
  /** fetch data from the table: "lesson_templates" using primary key columns */
  lessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** fetch data from the table in a streaming manner: "lesson_templates" */
  lessonTemplatesStream: Array<LessonTemplates>;
  /** fetch data from the table: "lesson_times" */
  lessonTimes: Array<LessonTimes>;
  /** fetch data from the table: "lesson_times" using primary key columns */
  lessonTimesByPk?: Maybe<LessonTimes>;
  /** fetch data from the table in a streaming manner: "lesson_times" */
  lessonTimesStream: Array<LessonTimes>;
  /** fetch data from the table: "lesson_types" */
  lessonTypes: Array<LessonTypes>;
  /** fetch data from the table: "lesson_types" using primary key columns */
  lessonTypesByPk?: Maybe<LessonTypes>;
  /** fetch data from the table in a streaming manner: "lesson_types" */
  lessonTypesStream: Array<LessonTypes>;
  /** fetch data from the table: "lesson_waitlist_statuses" */
  lessonWaitlistStatuses: Array<LessonWaitlistStatuses>;
  /** fetch data from the table: "lesson_waitlist_statuses" using primary key columns */
  lessonWaitlistStatusesByPk?: Maybe<LessonWaitlistStatuses>;
  /** fetch data from the table in a streaming manner: "lesson_waitlist_statuses" */
  lessonWaitlistStatusesStream: Array<LessonWaitlistStatuses>;
  /** fetch data from the table: "lesson_waitlists" */
  lessonWaitlists: Array<LessonWaitlists>;
  /** fetch aggregated fields from the table: "lesson_waitlists" */
  lessonWaitlistsAggregate: LessonWaitlistsAggregate;
  /** fetch data from the table: "lesson_waitlists" using primary key columns */
  lessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** fetch data from the table in a streaming manner: "lesson_waitlists" */
  lessonWaitlistsStream: Array<LessonWaitlists>;
  /** An array relationship */
  lessons: Array<Lessons>;
  /** An aggregate relationship */
  lessonsAggregate: LessonsAggregate;
  /** fetch data from the table: "lessons" using primary key columns */
  lessonsByPk?: Maybe<Lessons>;
  /** fetch data from the table in a streaming manner: "lessons" */
  lessonsStream: Array<Lessons>;
  /** fetch data from the table: "match_selection_criteria" */
  matchSelectionCriteria: Array<MatchSelectionCriteria>;
  /** fetch data from the table: "match_selection_criteria" using primary key columns */
  matchSelectionCriteriaByPk?: Maybe<MatchSelectionCriteria>;
  /** fetch data from the table in a streaming manner: "match_selection_criteria" */
  matchSelectionCriteriaStream: Array<MatchSelectionCriteria>;
  /** fetch data from the table: "payment_fulfillment_channels" */
  paymentFulfillmentChannels: Array<PaymentFulfillmentChannels>;
  /** fetch data from the table: "payment_fulfillment_channels" using primary key columns */
  paymentFulfillmentChannelsByPk?: Maybe<PaymentFulfillmentChannels>;
  /** fetch data from the table in a streaming manner: "payment_fulfillment_channels" */
  paymentFulfillmentChannelsStream: Array<PaymentFulfillmentChannels>;
  /** fetch data from the table: "pickleball_rating_scales" */
  pickleballRatingScales: Array<PickleballRatingScales>;
  /** fetch data from the table: "pickleball_rating_scales" using primary key columns */
  pickleballRatingScalesByPk?: Maybe<PickleballRatingScales>;
  /** fetch data from the table in a streaming manner: "pickleball_rating_scales" */
  pickleballRatingScalesStream: Array<PickleballRatingScales>;
  /** fetch data from the table: "play_session_comments" */
  playSessionComments: Array<PlaySessionComments>;
  /** fetch aggregated fields from the table: "play_session_comments" */
  playSessionCommentsAggregate: PlaySessionCommentsAggregate;
  /** fetch data from the table: "play_session_comments" using primary key columns */
  playSessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** fetch data from the table in a streaming manner: "play_session_comments" */
  playSessionCommentsStream: Array<PlaySessionComments>;
  /** fetch data from the table: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatuses: Array<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table: "play_session_court_booking_statuses" using primary key columns */
  playSessionCourtBookingStatusesByPk?: Maybe<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table in a streaming manner: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatusesStream: Array<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table: "play_session_formats" */
  playSessionFormats: Array<PlaySessionFormats>;
  /** fetch data from the table: "play_session_formats" using primary key columns */
  playSessionFormatsByPk?: Maybe<PlaySessionFormats>;
  /** fetch data from the table in a streaming manner: "play_session_formats" */
  playSessionFormatsStream: Array<PlaySessionFormats>;
  /** fetch data from the table: "play_session_match_competitiveness" */
  playSessionMatchCompetitiveness: Array<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table: "play_session_match_competitiveness" using primary key columns */
  playSessionMatchCompetitivenessByPk?: Maybe<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table in a streaming manner: "play_session_match_competitiveness" */
  playSessionMatchCompetitivenessStream: Array<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table: "play_session_participant_statuses" */
  playSessionParticipantStatuses: Array<PlaySessionParticipantStatuses>;
  /** fetch data from the table: "play_session_participant_statuses" using primary key columns */
  playSessionParticipantStatusesByPk?: Maybe<PlaySessionParticipantStatuses>;
  /** fetch data from the table in a streaming manner: "play_session_participant_statuses" */
  playSessionParticipantStatusesStream: Array<PlaySessionParticipantStatuses>;
  /** fetch data from the table: "play_session_participants" */
  playSessionParticipants: Array<PlaySessionParticipants>;
  /** fetch aggregated fields from the table: "play_session_participants" */
  playSessionParticipantsAggregate: PlaySessionParticipantsAggregate;
  /** fetch data from the table: "play_session_participants" using primary key columns */
  playSessionParticipantsByPk?: Maybe<PlaySessionParticipants>;
  /** fetch data from the table in a streaming manner: "play_session_participants" */
  playSessionParticipantsStream: Array<PlaySessionParticipants>;
  /** fetch data from the table: "play_session_privacy" */
  playSessionPrivacy: Array<PlaySessionPrivacy>;
  /** fetch data from the table: "play_session_privacy" using primary key columns */
  playSessionPrivacyByPk?: Maybe<PlaySessionPrivacy>;
  /** fetch data from the table in a streaming manner: "play_session_privacy" */
  playSessionPrivacyStream: Array<PlaySessionPrivacy>;
  /** fetch data from the table: "play_session_statuses" */
  playSessionStatuses: Array<PlaySessionStatuses>;
  /** fetch data from the table: "play_session_statuses" using primary key columns */
  playSessionStatusesByPk?: Maybe<PlaySessionStatuses>;
  /** fetch data from the table in a streaming manner: "play_session_statuses" */
  playSessionStatusesStream: Array<PlaySessionStatuses>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  /** fetch data from the table: "play_sessions" using primary key columns */
  playSessionsByPk?: Maybe<PlaySessions>;
  /** fetch data from the table in a streaming manner: "play_sessions" */
  playSessionsStream: Array<PlaySessions>;
  /** fetch data from the table: "scoring_format" */
  scoringFormat: Array<ScoringFormat>;
  /** fetch data from the table: "scoring_format" using primary key columns */
  scoringFormatByPk?: Maybe<ScoringFormat>;
  /** fetch data from the table in a streaming manner: "scoring_format" */
  scoringFormatStream: Array<ScoringFormat>;
  /** fetch data from the table: "signup_requests" */
  signupRequests: Array<SignupRequests>;
  /** fetch data from the table: "signup_requests" using primary key columns */
  signupRequestsByPk?: Maybe<SignupRequests>;
  /** fetch data from the table in a streaming manner: "signup_requests" */
  signupRequestsStream: Array<SignupRequests>;
  /** fetch data from the table: "skill_levels" */
  skillLevels: Array<SkillLevels>;
  /** fetch data from the table: "skill_levels" using primary key columns */
  skillLevelsByPk?: Maybe<SkillLevels>;
  /** fetch data from the table in a streaming manner: "skill_levels" */
  skillLevelsStream: Array<SkillLevels>;
  /** fetch data from the table: "sports" */
  sports: Array<Sports>;
  /** fetch data from the table: "sports" using primary key columns */
  sportsByPk?: Maybe<Sports>;
  /** fetch data from the table in a streaming manner: "sports" */
  sportsStream: Array<Sports>;
  /** fetch data from the table: "team_types" */
  teamTypes: Array<TeamTypes>;
  /** fetch data from the table: "team_types" using primary key columns */
  teamTypesByPk?: Maybe<TeamTypes>;
  /** fetch data from the table in a streaming manner: "team_types" */
  teamTypesStream: Array<TeamTypes>;
  /** fetch data from the table: "tennis_rating_scales" */
  tennisRatingScales: Array<TennisRatingScales>;
  /** fetch data from the table: "tennis_rating_scales" using primary key columns */
  tennisRatingScalesByPk?: Maybe<TennisRatingScales>;
  /** fetch data from the table in a streaming manner: "tennis_rating_scales" */
  tennisRatingScalesStream: Array<TennisRatingScales>;
  /** fetch data from the table: "user_coach_services" */
  userCoachServices: Array<UserCoachServices>;
  /** fetch data from the table: "user_coach_services" using primary key columns */
  userCoachServicesByPk?: Maybe<UserCoachServices>;
  /** fetch data from the table in a streaming manner: "user_coach_services" */
  userCoachServicesStream: Array<UserCoachServices>;
  /** fetch data from the table: "user_communication_preferences" */
  userCommunicationPreferences: Array<UserCommunicationPreferences>;
  /** fetch data from the table: "user_communication_preferences" using primary key columns */
  userCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** fetch data from the table in a streaming manner: "user_communication_preferences" */
  userCommunicationPreferencesStream: Array<UserCommunicationPreferences>;
  /** fetch data from the table: "user_credit_cards" */
  userCreditCards: Array<UserCreditCards>;
  /** fetch data from the table: "user_credit_cards" using primary key columns */
  userCreditCardsByPk?: Maybe<UserCreditCards>;
  /** fetch data from the table in a streaming manner: "user_credit_cards" */
  userCreditCardsStream: Array<UserCreditCards>;
  /** fetch data from the table: "user_custom_courts" */
  userCustomCourts: Array<UserCustomCourts>;
  /** fetch data from the table: "user_custom_courts" using primary key columns */
  userCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** fetch data from the table in a streaming manner: "user_custom_courts" */
  userCustomCourtsStream: Array<UserCustomCourts>;
  /** fetch data from the table: "user_follows" */
  userFollows: Array<UserFollows>;
  /** fetch aggregated fields from the table: "user_follows" */
  userFollowsAggregate: UserFollowsAggregate;
  /** fetch data from the table: "user_follows" using primary key columns */
  userFollowsByPk?: Maybe<UserFollows>;
  /** fetch data from the table in a streaming manner: "user_follows" */
  userFollowsStream: Array<UserFollows>;
  /** fetch data from the table: "user_image_log" */
  userImageLog: Array<UserImageLog>;
  /** fetch data from the table: "user_image_log" using primary key columns */
  userImageLogByPk?: Maybe<UserImageLog>;
  /** fetch data from the table in a streaming manner: "user_image_log" */
  userImageLogStream: Array<UserImageLog>;
  /** fetch data from the table: "user_notification_details" */
  userNotificationDetails: Array<UserNotificationDetails>;
  /** fetch data from the table: "user_notification_details" using primary key columns */
  userNotificationDetailsByPk?: Maybe<UserNotificationDetails>;
  /** fetch data from the table in a streaming manner: "user_notification_details" */
  userNotificationDetailsStream: Array<UserNotificationDetails>;
  /** fetch data from the table: "user_notification_entities" */
  userNotificationEntities: Array<UserNotificationEntities>;
  /** fetch data from the table: "user_notification_entities" using primary key columns */
  userNotificationEntitiesByPk?: Maybe<UserNotificationEntities>;
  /** fetch data from the table in a streaming manner: "user_notification_entities" */
  userNotificationEntitiesStream: Array<UserNotificationEntities>;
  /** An array relationship */
  userNotifications: Array<UserNotifications>;
  /** An aggregate relationship */
  userNotificationsAggregate: UserNotificationsAggregate;
  /** fetch data from the table: "user_notifications" using primary key columns */
  userNotificationsByPk?: Maybe<UserNotifications>;
  /** fetch data from the table in a streaming manner: "user_notifications" */
  userNotificationsStream: Array<UserNotifications>;
  /** fetch data from the table: "user_profiles" */
  userProfiles: Array<UserProfiles>;
  /** fetch data from the table in a streaming manner: "user_profiles" */
  userProfilesStream: Array<UserProfiles>;
  /** fetch data from the table: "user_terms_of_service" */
  userTermsOfService: Array<UserTermsOfService>;
  /** fetch data from the table: "user_terms_of_service" using primary key columns */
  userTermsOfServiceByPk?: Maybe<UserTermsOfService>;
  /** fetch data from the table in a streaming manner: "user_terms_of_service" */
  userTermsOfServiceStream: Array<UserTermsOfService>;
  /** fetch data from the table: "usernames_active" */
  usernamesActive: Array<UsernamesActive>;
  /** fetch data from the table in a streaming manner: "usernames_active" */
  usernamesActiveStream: Array<UsernamesActive>;
  /** An array relationship */
  usernamesClaimed: Array<UsernamesClaimed>;
  /** fetch data from the table: "usernames_claimed" using primary key columns */
  usernamesClaimedByPk?: Maybe<UsernamesClaimed>;
  /** fetch data from the table in a streaming manner: "usernames_claimed" */
  usernamesClaimedStream: Array<UsernamesClaimed>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table: "users_coach_qualifications" */
  usersCoachQualifications: Array<UsersCoachQualifications>;
  /** fetch data from the table: "users_coach_qualifications" using primary key columns */
  usersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** fetch data from the table in a streaming manner: "users_coach_qualifications" */
  usersCoachQualificationsStream: Array<UsersCoachQualifications>;
  /** fetch data from the table in a streaming manner: "users" */
  usersStream: Array<Users>;
  /** fetch data from the table: "venue_access_types" */
  venueAccessTypes: Array<VenueAccessTypes>;
  /** fetch data from the table: "venue_access_types" using primary key columns */
  venueAccessTypesByPk?: Maybe<VenueAccessTypes>;
  /** fetch data from the table in a streaming manner: "venue_access_types" */
  venueAccessTypesStream: Array<VenueAccessTypes>;
  /** fetch data from the table: "venue_amenities" */
  venueAmenities: Array<VenueAmenities>;
  /** fetch data from the table: "venue_amenities" using primary key columns */
  venueAmenitiesByPk?: Maybe<VenueAmenities>;
  /** fetch data from the table in a streaming manner: "venue_amenities" */
  venueAmenitiesStream: Array<VenueAmenities>;
  /** fetch data from the table: "venue_court_surfaces" */
  venueCourtSurfaces: Array<VenueCourtSurfaces>;
  /** fetch data from the table: "venue_court_surfaces" using primary key columns */
  venueCourtSurfacesByPk?: Maybe<VenueCourtSurfaces>;
  /** fetch data from the table in a streaming manner: "venue_court_surfaces" */
  venueCourtSurfacesStream: Array<VenueCourtSurfaces>;
  /** fetch data from the table: "venue_facility_types" */
  venueFacilityTypes: Array<VenueFacilityTypes>;
  /** fetch data from the table: "venue_facility_types" using primary key columns */
  venueFacilityTypesByPk?: Maybe<VenueFacilityTypes>;
  /** fetch data from the table in a streaming manner: "venue_facility_types" */
  venueFacilityTypesStream: Array<VenueFacilityTypes>;
  /** fetch data from the table: "venue_follows" */
  venueFollows: Array<VenueFollows>;
  /** fetch aggregated fields from the table: "venue_follows" */
  venueFollowsAggregate: VenueFollowsAggregate;
  /** fetch data from the table: "venue_follows" using primary key columns */
  venueFollowsByPk?: Maybe<VenueFollows>;
  /** fetch data from the table in a streaming manner: "venue_follows" */
  venueFollowsStream: Array<VenueFollows>;
  /** fetch data from the table: "venue_images" */
  venueImages: Array<VenueImages>;
  /** fetch data from the table: "venue_images" using primary key columns */
  venueImagesByPk?: Maybe<VenueImages>;
  /** fetch data from the table in a streaming manner: "venue_images" */
  venueImagesStream: Array<VenueImages>;
  /** fetch data from the table: "venue_lines" */
  venueLines: Array<VenueLines>;
  /** fetch data from the table: "venue_lines" using primary key columns */
  venueLinesByPk?: Maybe<VenueLines>;
  /** fetch data from the table in a streaming manner: "venue_lines" */
  venueLinesStream: Array<VenueLines>;
  /** fetch data from the table: "venue_nets" */
  venueNets: Array<VenueNets>;
  /** fetch data from the table: "venue_nets" using primary key columns */
  venueNetsByPk?: Maybe<VenueNets>;
  /** fetch data from the table in a streaming manner: "venue_nets" */
  venueNetsStream: Array<VenueNets>;
  /** An array relationship */
  venues: Array<Venues>;
  /** fetch data from the table: "venues" using primary key columns */
  venuesByPk?: Maybe<Venues>;
  /** fetch data from the table in a streaming manner: "venues" */
  venuesStream: Array<Venues>;
  /** fetch data from the table: "win_reasons" */
  winReasons: Array<WinReasons>;
  /** fetch data from the table: "win_reasons" using primary key columns */
  winReasonsByPk?: Maybe<WinReasons>;
  /** fetch data from the table in a streaming manner: "win_reasons" */
  winReasonsStream: Array<WinReasons>;
};


export type Subscription_RootAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<AmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AmenitiesOrderBy>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Subscription_RootAmenitiesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootAmenitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<AmenitiesStreamCursorInput>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Subscription_RootAppPersonasArgs = {
  distinctOn?: InputMaybe<Array<AppPersonasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPersonasOrderBy>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Subscription_RootAppPersonasByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootAppPersonasStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<AppPersonasStreamCursorInput>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Subscription_RootAppPingsArgs = {
  distinctOn?: InputMaybe<Array<AppPingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPingsOrderBy>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Subscription_RootAppPingsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAppPingsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<AppPingsStreamCursorInput>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Subscription_RootBallTypesArgs = {
  distinctOn?: InputMaybe<Array<BallTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BallTypesOrderBy>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Subscription_RootBallTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootBallTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<BallTypesStreamCursorInput>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Subscription_RootCitiesArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Subscription_RootCitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CitiesStreamCursorInput>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Subscription_RootCoachQualificationGroupsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationGroupsOrderBy>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Subscription_RootCoachQualificationGroupsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCoachQualificationGroupsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachQualificationGroupsStreamCursorInput>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Subscription_RootCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationsOrderBy>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Subscription_RootCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCoachQualificationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachQualificationsStreamCursorInput>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Subscription_RootCoachStatusArgs = {
  distinctOn?: InputMaybe<Array<CoachStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachStatusOrderBy>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Subscription_RootCoachStatusByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCoachStatusStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachStatusStreamCursorInput>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Subscription_RootCommentVoteArgs = {
  distinctOn?: InputMaybe<Array<CommentVoteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentVoteOrderBy>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Subscription_RootCommentVoteByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCommentVoteStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CommentVoteStreamCursorInput>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Subscription_RootCommunicationPreferenceStatusesArgs = {
  distinctOn?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommunicationPreferenceStatusesOrderBy>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Subscription_RootCommunicationPreferenceStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCommunicationPreferenceStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CommunicationPreferenceStatusesStreamCursorInput>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Subscription_RootCompetitionFormatsArgs = {
  distinctOn?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionFormatsOrderBy>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Subscription_RootCompetitionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCompetitionFormatsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CompetitionFormatsStreamCursorInput>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Subscription_RootCompetitionGenderArgs = {
  distinctOn?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionGenderOrderBy>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Subscription_RootCompetitionGenderByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCompetitionGenderStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CompetitionGenderStreamCursorInput>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Subscription_RootCountriesArgs = {
  distinctOn?: InputMaybe<Array<CountriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Subscription_RootCountriesByPkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootCountriesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CountriesStreamCursorInput>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Subscription_RootCountrySubdivisionsArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Subscription_RootCountrySubdivisionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCountrySubdivisionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CountrySubdivisionsStreamCursorInput>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Subscription_RootCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CourtSurfacesOrderBy>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Subscription_RootCourtSurfacesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCourtSurfacesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CourtSurfacesStreamCursorInput>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Subscription_RootEventContactDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventContactDetailsOrderBy>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Subscription_RootEventContactDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventContactDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventContactDetailsStreamCursorInput>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Subscription_RootEventCourtStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtStatusesOrderBy>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Subscription_RootEventCourtStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventCourtStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventCourtStatusesStreamCursorInput>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Subscription_RootEventCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Subscription_RootEventCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventCourtsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventCourtsStreamCursorInput>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Subscription_RootEventFaqsArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Subscription_RootEventFaqsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventFaqsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventFaqsStreamCursorInput>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Subscription_RootEventGameScoresArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Subscription_RootEventGameScoresByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGameScoresStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGameScoresStreamCursorInput>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Subscription_RootEventGroupFormatsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupFormatsOrderBy>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Subscription_RootEventGroupFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventGroupFormatsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupFormatsStreamCursorInput>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Subscription_RootEventGroupPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Subscription_RootEventGroupPoolsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupPoolsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupPoolsStreamCursorInput>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Subscription_RootEventGroupRegistrationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationStatusesOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Subscription_RootEventGroupRegistrationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventGroupRegistrationStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupRegistrationStatusesStreamCursorInput>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Subscription_RootEventGroupRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Subscription_RootEventGroupRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupRegistrationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupRegistrationsStreamCursorInput>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Subscription_RootEventGroupSequenceSeedingArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Subscription_RootEventGroupSequenceSeedingByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupSequenceSeedingStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupSequenceSeedingStreamCursorInput>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Subscription_RootEventGroupSequencesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Subscription_RootEventGroupSequencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupSequencesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupSequencesStreamCursorInput>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Subscription_RootEventGroupsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Subscription_RootEventGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupsStreamCursorInput>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Subscription_RootEventInvitationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationStatusesOrderBy>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Subscription_RootEventInvitationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventInvitationStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventInvitationStatusesStreamCursorInput>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Subscription_RootEventInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Subscription_RootEventInvitationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventInvitationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventInvitationsStreamCursorInput>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Subscription_RootEventListingFeesArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Subscription_RootEventListingFeesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventListingFeesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventListingFeesStreamCursorInput>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Subscription_RootEventMatchGamesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Subscription_RootEventMatchGamesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventMatchGamesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventMatchGamesStreamCursorInput>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Subscription_RootEventMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Subscription_RootEventMatchesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventMatchesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventMatchesStreamCursorInput>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Subscription_RootEventMatchesTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Subscription_RootEventMatchesTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventMatchesTeamsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventMatchesTeamsStreamCursorInput>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Subscription_RootEventOrganizerAccountTypesArgs = {
  distinctOn?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventOrganizerAccountTypesOrderBy>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Subscription_RootEventOrganizerAccountTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventOrganizerAccountTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventOrganizerAccountTypesStreamCursorInput>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Subscription_RootEventPoolRoundsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Subscription_RootEventPoolRoundsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventPoolRoundsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventPoolRoundsStreamCursorInput>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Subscription_RootEventPoolsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Subscription_RootEventPoolsTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventPoolsTeamsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventPoolsTeamsStreamCursorInput>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Subscription_RootEventPrivacyArgs = {
  distinctOn?: InputMaybe<Array<EventPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPrivacyOrderBy>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Subscription_RootEventPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventPrivacyStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventPrivacyStreamCursorInput>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Subscription_RootEventRegistrationDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationDetailsOrderBy>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Subscription_RootEventRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventRegistrationDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventRegistrationDetailsStreamCursorInput>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Subscription_RootEventRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Subscription_RootEventRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventRegistrationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventRegistrationsStreamCursorInput>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Subscription_RootEventSequenceCompleteReasonsArgs = {
  distinctOn?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSequenceCompleteReasonsOrderBy>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Subscription_RootEventSequenceCompleteReasonsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventSequenceCompleteReasonsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventSequenceCompleteReasonsStreamCursorInput>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Subscription_RootEventSponsorsArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Subscription_RootEventSponsorsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventSponsorsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventSponsorsStreamCursorInput>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Subscription_RootEventStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventStatusesOrderBy>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Subscription_RootEventStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventStatusesStreamCursorInput>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Subscription_RootEventTeamMemberStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMemberStatusesOrderBy>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Subscription_RootEventTeamMemberStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventTeamMemberStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTeamMemberStatusesStreamCursorInput>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Subscription_RootEventTeamMembersArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Subscription_RootEventTeamMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTeamMembersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTeamMembersStreamCursorInput>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Subscription_RootEventTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Subscription_RootEventTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTeamsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTeamsStreamCursorInput>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Subscription_RootEventTransactionItemTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemTypesOrderBy>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Subscription_RootEventTransactionItemTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventTransactionItemTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTransactionItemTypesStreamCursorInput>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Subscription_RootEventTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Subscription_RootEventTransactionItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTransactionItemsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTransactionItemsStreamCursorInput>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Subscription_RootEventTransactionsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Subscription_RootEventTransactionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTransactionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTransactionsStreamCursorInput>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Subscription_RootEventTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTypesOrderBy>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Subscription_RootEventTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTypesStreamCursorInput>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Subscription_RootEventsArgs = {
  distinctOn?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Subscription_RootEventsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventsStreamCursorInput>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Subscription_RootGenderArgs = {
  distinctOn?: InputMaybe<Array<GenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GenderOrderBy>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Subscription_RootGenderByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootGenderStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GenderStreamCursorInput>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Subscription_RootGroupCommentVotesArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Subscription_RootGroupCommentVotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Subscription_RootGroupCommentVotesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupCommentVotesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupCommentVotesStreamCursorInput>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Subscription_RootGroupMembersArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Subscription_RootGroupMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Subscription_RootGroupMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupMembersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupMembersStreamCursorInput>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Subscription_RootGroupThreadCommentFilesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Subscription_RootGroupThreadCommentFilesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupThreadCommentFilesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupThreadCommentFilesStreamCursorInput>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Subscription_RootGroupThreadCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Subscription_RootGroupThreadCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Subscription_RootGroupThreadCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupThreadCommentsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupThreadCommentsStreamCursorInput>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Subscription_RootGroupThreadsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Subscription_RootGroupThreadsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupThreadsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupThreadsStreamCursorInput>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Subscription_RootGroupVenuesArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Subscription_RootGroupVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Subscription_RootGroupVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupVenuesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupVenuesStreamCursorInput>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Subscription_RootGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Subscription_RootGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Subscription_RootGroupsPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupsPlaySessionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupsPlaySessionsStreamCursorInput>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Subscription_RootGroupsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupsStreamCursorInput>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Subscription_RootLessonEquipmentArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Subscription_RootLessonEquipmentByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonEquipmentOptionsArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOptionsOrderBy>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Subscription_RootLessonEquipmentOptionsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonEquipmentOptionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonEquipmentOptionsStreamCursorInput>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Subscription_RootLessonEquipmentStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonEquipmentStreamCursorInput>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Subscription_RootLessonOrderItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Subscription_RootLessonOrderItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonOrderItemsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonOrderItemsStreamCursorInput>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Subscription_RootLessonOrdersArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Subscription_RootLessonOrdersAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Subscription_RootLessonOrdersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonOrdersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonOrdersStreamCursorInput>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Subscription_RootLessonParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantStatusesOrderBy>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Subscription_RootLessonParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonParticipantStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonParticipantStatusesStreamCursorInput>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Subscription_RootLessonParticipantsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Subscription_RootLessonParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Subscription_RootLessonParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonParticipantsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonParticipantsStreamCursorInput>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Subscription_RootLessonPrivacyArgs = {
  distinctOn?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonPrivacyOrderBy>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Subscription_RootLessonPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonPrivacyStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonPrivacyStreamCursorInput>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Subscription_RootLessonStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonStatusesOrderBy>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Subscription_RootLessonStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonStatusesStreamCursorInput>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Subscription_RootLessonTemplatesArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Subscription_RootLessonTemplatesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonTemplatesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonTemplatesStreamCursorInput>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Subscription_RootLessonTimesArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Subscription_RootLessonTimesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonTimesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonTimesStreamCursorInput>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Subscription_RootLessonTypesArgs = {
  distinctOn?: InputMaybe<Array<LessonTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTypesOrderBy>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Subscription_RootLessonTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonTypesStreamCursorInput>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Subscription_RootLessonWaitlistStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistStatusesOrderBy>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Subscription_RootLessonWaitlistStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonWaitlistStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonWaitlistStatusesStreamCursorInput>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Subscription_RootLessonWaitlistsArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Subscription_RootLessonWaitlistsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Subscription_RootLessonWaitlistsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonWaitlistsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonWaitlistsStreamCursorInput>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Subscription_RootLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Subscription_RootLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Subscription_RootLessonsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonsStreamCursorInput>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Subscription_RootMatchSelectionCriteriaArgs = {
  distinctOn?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MatchSelectionCriteriaOrderBy>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Subscription_RootMatchSelectionCriteriaByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootMatchSelectionCriteriaStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<MatchSelectionCriteriaStreamCursorInput>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Subscription_RootPaymentFulfillmentChannelsArgs = {
  distinctOn?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentFulfillmentChannelsOrderBy>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Subscription_RootPaymentFulfillmentChannelsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPaymentFulfillmentChannelsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PaymentFulfillmentChannelsStreamCursorInput>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Subscription_RootPickleballRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PickleballRatingScalesOrderBy>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Subscription_RootPickleballRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPickleballRatingScalesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PickleballRatingScalesStreamCursorInput>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Subscription_RootPlaySessionCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Subscription_RootPlaySessionCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Subscription_RootPlaySessionCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlaySessionCommentsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionCommentsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Subscription_RootPlaySessionCourtBookingStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCourtBookingStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Subscription_RootPlaySessionCourtBookingStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionCourtBookingStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionCourtBookingStatusesStreamCursorInput>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Subscription_RootPlaySessionFormatsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionFormatsOrderBy>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Subscription_RootPlaySessionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionFormatsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionFormatsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Subscription_RootPlaySessionMatchCompetitivenessArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionMatchCompetitivenessOrderBy>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Subscription_RootPlaySessionMatchCompetitivenessByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionMatchCompetitivenessStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionMatchCompetitivenessStreamCursorInput>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Subscription_RootPlaySessionParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Subscription_RootPlaySessionParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionParticipantStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionParticipantStatusesStreamCursorInput>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Subscription_RootPlaySessionParticipantsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Subscription_RootPlaySessionParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Subscription_RootPlaySessionParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlaySessionParticipantsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionParticipantsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Subscription_RootPlaySessionPrivacyArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionPrivacyOrderBy>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Subscription_RootPlaySessionPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionPrivacyStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionPrivacyStreamCursorInput>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Subscription_RootPlaySessionStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Subscription_RootPlaySessionStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionStatusesStreamCursorInput>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Subscription_RootPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Subscription_RootPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Subscription_RootPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlaySessionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Subscription_RootScoringFormatArgs = {
  distinctOn?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ScoringFormatOrderBy>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Subscription_RootScoringFormatByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootScoringFormatStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<ScoringFormatStreamCursorInput>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Subscription_RootSignupRequestsArgs = {
  distinctOn?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SignupRequestsOrderBy>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Subscription_RootSignupRequestsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSignupRequestsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<SignupRequestsStreamCursorInput>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Subscription_RootSkillLevelsArgs = {
  distinctOn?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkillLevelsOrderBy>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Subscription_RootSkillLevelsByPkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootSkillLevelsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<SkillLevelsStreamCursorInput>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Subscription_RootSportsArgs = {
  distinctOn?: InputMaybe<Array<SportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SportsOrderBy>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Subscription_RootSportsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootSportsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<SportsStreamCursorInput>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Subscription_RootTeamTypesArgs = {
  distinctOn?: InputMaybe<Array<TeamTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TeamTypesOrderBy>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Subscription_RootTeamTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootTeamTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<TeamTypesStreamCursorInput>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Subscription_RootTennisRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TennisRatingScalesOrderBy>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Subscription_RootTennisRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootTennisRatingScalesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<TennisRatingScalesStreamCursorInput>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Subscription_RootUserCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Subscription_RootUserCoachServicesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCoachServicesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCoachServicesStreamCursorInput>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Subscription_RootUserCommunicationPreferencesArgs = {
  distinctOn?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCommunicationPreferencesOrderBy>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Subscription_RootUserCommunicationPreferencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCommunicationPreferencesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCommunicationPreferencesStreamCursorInput>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Subscription_RootUserCreditCardsArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Subscription_RootUserCreditCardsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCreditCardsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCreditCardsStreamCursorInput>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Subscription_RootUserCustomCourtsArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Subscription_RootUserCustomCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCustomCourtsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCustomCourtsStreamCursorInput>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Subscription_RootUserFollowsArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Subscription_RootUserFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Subscription_RootUserFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserFollowsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserFollowsStreamCursorInput>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Subscription_RootUserImageLogArgs = {
  distinctOn?: InputMaybe<Array<UserImageLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserImageLogOrderBy>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Subscription_RootUserImageLogByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserImageLogStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserImageLogStreamCursorInput>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Subscription_RootUserNotificationDetailsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationDetailsOrderBy>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Subscription_RootUserNotificationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserNotificationDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserNotificationDetailsStreamCursorInput>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Subscription_RootUserNotificationEntitiesArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationEntitiesOrderBy>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Subscription_RootUserNotificationEntitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserNotificationEntitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserNotificationEntitiesStreamCursorInput>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Subscription_RootUserNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Subscription_RootUserNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Subscription_RootUserNotificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserNotificationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserNotificationsStreamCursorInput>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Subscription_RootUserProfilesArgs = {
  distinctOn?: InputMaybe<Array<UserProfilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserProfilesOrderBy>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Subscription_RootUserProfilesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserProfilesStreamCursorInput>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Subscription_RootUserTermsOfServiceArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Subscription_RootUserTermsOfServiceByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserTermsOfServiceStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserTermsOfServiceStreamCursorInput>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Subscription_RootUsernamesActiveArgs = {
  distinctOn?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesActiveOrderBy>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Subscription_RootUsernamesActiveStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsernamesActiveStreamCursorInput>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Subscription_RootUsernamesClaimedArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Subscription_RootUsernamesClaimedByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsernamesClaimedStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsernamesClaimedStreamCursorInput>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Subscription_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsersCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Subscription_RootUsersCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsersCoachQualificationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsersCoachQualificationsStreamCursorInput>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Subscription_RootUsersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsersStreamCursorInput>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootVenueAccessTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAccessTypesOrderBy>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Subscription_RootVenueAccessTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueAccessTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueAccessTypesStreamCursorInput>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Subscription_RootVenueAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Subscription_RootVenueAmenitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueAmenitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueAmenitiesStreamCursorInput>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Subscription_RootVenueCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Subscription_RootVenueCourtSurfacesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueCourtSurfacesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueCourtSurfacesStreamCursorInput>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Subscription_RootVenueFacilityTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFacilityTypesOrderBy>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Subscription_RootVenueFacilityTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueFacilityTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueFacilityTypesStreamCursorInput>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Subscription_RootVenueFollowsArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Subscription_RootVenueFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Subscription_RootVenueFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueFollowsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueFollowsStreamCursorInput>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Subscription_RootVenueImagesArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Subscription_RootVenueImagesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueImagesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueImagesStreamCursorInput>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Subscription_RootVenueLinesArgs = {
  distinctOn?: InputMaybe<Array<VenueLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueLinesOrderBy>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Subscription_RootVenueLinesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueLinesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueLinesStreamCursorInput>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Subscription_RootVenueNetsArgs = {
  distinctOn?: InputMaybe<Array<VenueNetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueNetsOrderBy>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Subscription_RootVenueNetsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueNetsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueNetsStreamCursorInput>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Subscription_RootVenuesArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Subscription_RootVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenuesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenuesStreamCursorInput>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Subscription_RootWinReasonsArgs = {
  distinctOn?: InputMaybe<Array<WinReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WinReasonsOrderBy>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};


export type Subscription_RootWinReasonsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootWinReasonsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<WinReasonsStreamCursorInput>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};

export type UserFollowsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserFollowsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserFollowsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserNotificationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserNotificationsBoolExp>;
  predicate: IntComparisonExp;
};

export type GetUserUnreadNotificationCountQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetUserUnreadNotificationCountQuery = { __typename?: 'query_root', userNotificationsAggregate: { __typename?: 'UserNotificationsAggregate', aggregate?: { __typename?: 'UserNotificationsAggregateFields', count: number } | null } };

export type InsertUserGroupMembershipMutationVariables = Exact<{
  groupId: Scalars['uuid'];
  userId: Scalars['uuid'];
}>;


export type InsertUserGroupMembershipMutation = { __typename?: 'mutation_root', insertGroupMembersOne?: { __typename?: 'GroupMembers', id: any } | null };

export type GetClosestCitiesQueryVariables = Exact<{
  distance: Scalars['Float'];
  from: Scalars['geography'];
}>;


export type GetClosestCitiesQuery = { __typename?: 'query_root', cities: Array<{ __typename?: 'Cities', id: any, name: string, geometry?: any | null, latitude: any, longitude: any }> };

export type InsertUsagePingMutationVariables = Exact<{
  pathname?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
  firebaseId?: InputMaybe<Scalars['String']>;
  queryString?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
  ipResponse?: InputMaybe<Scalars['jsonb']>;
}>;


export type InsertUsagePingMutation = { __typename?: 'mutation_root', insertAppPingsOne?: { __typename?: 'AppPings', id: any } | null };

export type LessonFieldsFragment = { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> };

export type PlaySessionFieldsFragment = { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null };

export type UserProfileFieldsFragment = { __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, preferredName?: string | null, fullName?: string | null, coachStatus?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, aboutMe?: string | null, aboutMeVideoUrl?: string | null, cityName?: string | null, gender?: string | null, coachExperienceYears?: any | null, coachExperienceSetAt?: any | null, normalizedTennisRating?: any | null, tennisRating?: any | null, country?: { __typename?: 'Countries', id: string, iso2: string, iso3: string, name: string } | null, countrySubdivision?: { __typename?: 'CountrySubdivisions', code: string, id: any, name: string, type: string } | null, coachLessonsAggregate: { __typename?: 'LessonsAggregate', aggregate?: { __typename?: 'LessonsAggregateFields', count: number } | null }, followersAggregate: { __typename?: 'UserFollowsAggregate', aggregate?: { __typename?: 'UserFollowsAggregateFields', count: number } | null }, followers: Array<{ __typename?: 'UserFollows', followerUserId: any, followedUserId: any, followerProfile?: { __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, preferredName?: string | null } | null }>, coachServices: Array<{ __typename?: 'UserCoachServices', currency: string, description: string, id: any, title: string, priceUnitAmount: number, type?: LessonTypesEnum | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string }>, coachQualifications: Array<{ __typename?: 'UsersCoachQualifications', id: any, status: CoachQualificationStatusesEnum, qualification: { __typename?: 'CoachQualifications', id: any, name: string, order: number, groupId?: CoachQualificationGroupsEnum | null, displayKey: string } }>, normalizedTennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null, pickleballSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null };

export type InsertPlaySessionCommentMutationVariables = Exact<{
  content: Scalars['String'];
  playSessionId: Scalars['uuid'];
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionRootCommentId?: InputMaybe<Scalars['uuid']>;
  userId: Scalars['uuid'];
}>;


export type InsertPlaySessionCommentMutation = { __typename?: 'mutation_root', insertPlaySessionCommentsOne?: { __typename?: 'PlaySessionComments', content: string, id: any, createdAt: any, deletedAt?: any | null, playSessionCommentId?: any | null, playSessionId: any, playSessionRootCommentId?: any | null, updatedAt: any, userId: any } | null };

export type UpdateFollowerInactiveMutationVariables = Exact<{
  followedUserId: Scalars['uuid'];
  followerUserId: Scalars['uuid'];
}>;


export type UpdateFollowerInactiveMutation = { __typename?: 'mutation_root', updateUserFollows?: { __typename?: 'UserFollowsMutationResponse', returning: Array<{ __typename?: 'UserFollows', followerUserId: any, followedUserId: any, status: FollowStatusesEnum }> } | null };

export type UpdateUserCoverImageMutationVariables = Exact<{
  id: Scalars['uuid'];
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
}>;


export type UpdateUserCoverImageMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, coverImageFileName: string, coverImagePath: string, coverImageProvider: string, coverImageProviderId: string, coverImageProviderUrl: string, profile?: { __typename?: 'UserProfiles', id?: any | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProvider?: string | null, coverImageProviderUrl?: string | null } | null } | null, insertUserImageLogOne?: { __typename?: 'UserImageLog', id: any } | null };

export type UpdateUserDefaultSportMutationVariables = Exact<{
  id: Scalars['uuid'];
  defaultSport: SportsEnum;
}>;


export type UpdateUserDefaultSportMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', defaultSport?: SportsEnum | null, id: any } | null };

export type UpdateUserProfileImageMutationVariables = Exact<{
  id: Scalars['uuid'];
  profileImageFileName: Scalars['String'];
  profileImagePath: Scalars['String'];
  profileImageProvider: Scalars['String'];
  profileImageProviderId: Scalars['String'];
  profileImageProviderUrl: Scalars['String'];
}>;


export type UpdateUserProfileImageMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, profileImageFileName: string, profileImagePath: string, profileImageProvider: string, profileImageProviderId: string, profileImageProviderUrl: string, profile?: { __typename?: 'UserProfiles', id?: any | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProvider?: string | null, profileImageProviderUrl?: string | null } | null } | null, insertUserImageLogOne?: { __typename?: 'UserImageLog', id: any } | null };

export type UpsertFollowerConnectionMutationVariables = Exact<{
  followedUserId: Scalars['uuid'];
  followerUserId: Scalars['uuid'];
  status: FollowStatusesEnum;
}>;


export type UpsertFollowerConnectionMutation = { __typename?: 'mutation_root', insertUserFollowsOne?: { __typename?: 'UserFollows', followerUserId: any, followedUserId: any, status: FollowStatusesEnum } | null };

export type UpsertGroupThreadVoteMutationVariables = Exact<{
  groupThreadCommentId: Scalars['uuid'];
  userId: Scalars['uuid'];
  vote: CommentVoteEnum;
}>;


export type UpsertGroupThreadVoteMutation = { __typename?: 'mutation_root', insertGroupCommentVotesOne?: { __typename?: 'GroupCommentVotes', id: any, userId: any, groupThreadCommentId: any, vote: CommentVoteEnum } | null };

export type GetActiveCoachProfilesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetActiveCoachProfilesQuery = { __typename?: 'query_root', userProfiles: Array<{ __typename?: 'UserProfiles', coachStatus?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, fullName?: string | null, gender?: string | null, genderPreference?: string | null, id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, username?: string | null }> };

export type GetActiveOwnerLessonsByIdQueryVariables = Exact<{
  ownerUserId: Scalars['uuid'];
}>;


export type GetActiveOwnerLessonsByIdQuery = { __typename?: 'query_root', lessons: Array<{ __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> }> };

export type GetAllActiveLessonsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllActiveLessonsQuery = { __typename?: 'query_root', lessons: Array<{ __typename?: 'Lessons', id: any, title: string, startDateTime?: any | null, endDateTime?: any | null, description: string, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, currency: string, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, status: LessonStatusesEnum, type: LessonTypesEnum, typeCustom: string, userCustomCourt?: { __typename?: 'UserCustomCourts', id: any, title: string, fullAddress: string } | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, coachStatus?: string | null, gender?: string | null, genderPreference?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, username?: string | null } | null }> };

export type GetCurrentUserQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetCurrentUserQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', id: any, coachStatus?: CoachStatusEnum | null, email: string, firebaseId: string, fullName: string, preferredName: string, birthday?: any | null, duprId?: string | null, gender?: GenderEnum | null, genderPreference: string, stripeCustomerId: string, stripeMerchantChargesEnabled: boolean, stripeMerchantDetailsSubmitted: boolean, stripeMerchantId?: string | null, stripeMerchantPayoutsEnabled: boolean, username?: string | null, profileImageFileName: string, profileImagePath: string, profileImageProviderUrl: string, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, defaultCreditCardId?: any | null, tennisRatingScaleId?: any | null, tennisRating?: any | null, defaultSport?: SportsEnum | null, defaultCoachPaymentFulfillmentChannel?: PaymentFulfillmentChannelsEnum | null, tennisSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null, pickleballSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null, groups: Array<{ __typename?: 'GroupMembers', id: any, isActive: boolean, groupId: any, group: { __typename?: 'Groups', id: any, primarySport?: SportsEnum | null } }>, followingCoachesAggregate: { __typename?: 'UserFollowsAggregate', aggregate?: { __typename?: 'UserFollowsAggregateFields', count: number } | null } } | null };

export type GetGroupByAccessCodeQueryVariables = Exact<{
  accessCode: Scalars['String'];
}>;


export type GetGroupByAccessCodeQuery = { __typename?: 'query_root', groups: Array<{ __typename?: 'Groups', id: any, accessCode?: string | null, headline: string, title: string, city: { __typename?: 'Cities', id: any, name: string }, ownerUserProfile?: { __typename?: 'UserProfiles', fullName?: string | null, id?: any | null } | null }> };

export type GetGroupVenuesQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type GetGroupVenuesQuery = { __typename?: 'query_root', groupVenues: Array<{ __typename?: 'GroupVenues', id: any, venue: { __typename?: 'Venues', id: any, createdAt: any, title: string, slug: string, outdoorCourtCount: number, indoorCourtCount: number, isActive: boolean, accessType?: VenueAccessTypesEnum | null, addressString: string, totalCourtCount: number, facilityType?: VenueFacilityTypesEnum | null, pickleballNets?: VenueNetsEnum | null, images: Array<{ __typename?: 'VenueImages', providerUrl: string, id: any, url: string }>, courtSurfaces: Array<{ __typename?: 'VenueCourtSurfaces', id: any, courtSurface: CourtSurfacesEnum }> } }> };

export type GetLessonByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetLessonByIdQuery = { __typename?: 'query_root', lessonsByPk?: { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> } | null };

export type GetPlaySessionByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetPlaySessionByIdQuery = { __typename?: 'query_root', playSessionsByPk?: { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null } | null };

export type GetPlaySessionCommentsQueryVariables = Exact<{
  playSessionId: Scalars['uuid'];
}>;


export type GetPlaySessionCommentsQuery = { __typename?: 'query_root', playSessionComments: Array<{ __typename?: 'PlaySessionComments', id: any, createdAt: any, content: string, playSessionCommentId?: any | null, playSessionId: any, playSessionRootCommentId?: any | null, userId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, profileImagePath?: string | null, username?: string | null } | null }> };

export type GetPlayerLessonsQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetPlayerLessonsQuery = { __typename?: 'query_root', lessonParticipants: Array<{ __typename?: 'LessonParticipants', id: any, status: LessonParticipantStatusesEnum, lesson: { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> } }> };

export type GetPlayerPlaySessionsQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetPlayerPlaySessionsQuery = { __typename?: 'query_root', playSessionParticipants: Array<{ __typename?: 'PlaySessionParticipants', id: any, status: PlaySessionParticipantStatusesEnum, playSession: { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null } }>, playSessions: Array<{ __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null }> };

export type GetSportsRatingScalesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSportsRatingScalesQuery = { __typename?: 'query_root', pickleballRatingScales: Array<{ __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string }>, tennisRatingScales: Array<{ __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string }> };

export type GetUserFollowerProfilesQueryVariables = Exact<{
  followedUserId: Scalars['uuid'];
}>;


export type GetUserFollowerProfilesQuery = { __typename?: 'query_root', userFollows: Array<{ __typename?: 'UserFollows', status: FollowStatusesEnum, followerUserId: any, followedUserId: any, followerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null }> };

export type GetUserFollowingIdsQueryVariables = Exact<{
  followerUserId: Scalars['uuid'];
}>;


export type GetUserFollowingIdsQuery = { __typename?: 'query_root', userFollows: Array<{ __typename?: 'UserFollows', status: FollowStatusesEnum, followerUserId: any, followedUserId: any }> };

export type GetUserProfileByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetUserProfileByIdQuery = { __typename?: 'query_root', userProfiles: Array<{ __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, preferredName?: string | null, fullName?: string | null, coachStatus?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, aboutMe?: string | null, aboutMeVideoUrl?: string | null, cityName?: string | null, gender?: string | null, coachExperienceYears?: any | null, coachExperienceSetAt?: any | null, normalizedTennisRating?: any | null, tennisRating?: any | null, country?: { __typename?: 'Countries', id: string, iso2: string, iso3: string, name: string } | null, countrySubdivision?: { __typename?: 'CountrySubdivisions', code: string, id: any, name: string, type: string } | null, coachLessonsAggregate: { __typename?: 'LessonsAggregate', aggregate?: { __typename?: 'LessonsAggregateFields', count: number } | null }, followersAggregate: { __typename?: 'UserFollowsAggregate', aggregate?: { __typename?: 'UserFollowsAggregateFields', count: number } | null }, followers: Array<{ __typename?: 'UserFollows', followerUserId: any, followedUserId: any, followerProfile?: { __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, preferredName?: string | null } | null }>, coachServices: Array<{ __typename?: 'UserCoachServices', currency: string, description: string, id: any, title: string, priceUnitAmount: number, type?: LessonTypesEnum | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string }>, coachQualifications: Array<{ __typename?: 'UsersCoachQualifications', id: any, status: CoachQualificationStatusesEnum, qualification: { __typename?: 'CoachQualifications', id: any, name: string, order: number, groupId?: CoachQualificationGroupsEnum | null, displayKey: string } }>, normalizedTennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null, pickleballSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null }> };

export type GetUserProfileByUsernameQueryVariables = Exact<{
  username: Scalars['String'];
  viewerId: Scalars['uuid'];
}>;


export type GetUserProfileByUsernameQuery = { __typename?: 'query_root', userProfiles: Array<{ __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, preferredName?: string | null, fullName?: string | null, coachStatus?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, aboutMe?: string | null, aboutMeVideoUrl?: string | null, cityName?: string | null, gender?: string | null, coachExperienceYears?: any | null, coachExperienceSetAt?: any | null, normalizedTennisRating?: any | null, tennisRating?: any | null, country?: { __typename?: 'Countries', id: string, iso2: string, iso3: string, name: string } | null, countrySubdivision?: { __typename?: 'CountrySubdivisions', code: string, id: any, name: string, type: string } | null, coachLessonsAggregate: { __typename?: 'LessonsAggregate', aggregate?: { __typename?: 'LessonsAggregateFields', count: number } | null }, followersAggregate: { __typename?: 'UserFollowsAggregate', aggregate?: { __typename?: 'UserFollowsAggregateFields', count: number } | null }, followers: Array<{ __typename?: 'UserFollows', followerUserId: any, followedUserId: any, followerProfile?: { __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, preferredName?: string | null } | null }>, coachServices: Array<{ __typename?: 'UserCoachServices', currency: string, description: string, id: any, title: string, priceUnitAmount: number, type?: LessonTypesEnum | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string }>, coachQualifications: Array<{ __typename?: 'UsersCoachQualifications', id: any, status: CoachQualificationStatusesEnum, qualification: { __typename?: 'CoachQualifications', id: any, name: string, order: number, groupId?: CoachQualificationGroupsEnum | null, displayKey: string } }>, normalizedTennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null, pickleballSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null }>, userFollows: Array<{ __typename?: 'UserFollows', status: FollowStatusesEnum, followedUserId: any, followerUserId: any }> };

export type GetUserPublicProfileByUsernameQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type GetUserPublicProfileByUsernameQuery = { __typename?: 'query_root', userProfiles: Array<{ __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, preferredName?: string | null, fullName?: string | null, coachStatus?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, aboutMe?: string | null, aboutMeVideoUrl?: string | null, cityName?: string | null, gender?: string | null, coachExperienceYears?: any | null, coachExperienceSetAt?: any | null, normalizedTennisRating?: any | null, tennisRating?: any | null, country?: { __typename?: 'Countries', id: string, iso2: string, iso3: string, name: string } | null, countrySubdivision?: { __typename?: 'CountrySubdivisions', code: string, id: any, name: string, type: string } | null, coachLessonsAggregate: { __typename?: 'LessonsAggregate', aggregate?: { __typename?: 'LessonsAggregateFields', count: number } | null }, followersAggregate: { __typename?: 'UserFollowsAggregate', aggregate?: { __typename?: 'UserFollowsAggregateFields', count: number } | null }, followers: Array<{ __typename?: 'UserFollows', followerUserId: any, followedUserId: any, followerProfile?: { __typename?: 'UserProfiles', id?: any | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, preferredName?: string | null } | null }>, coachServices: Array<{ __typename?: 'UserCoachServices', currency: string, description: string, id: any, title: string, priceUnitAmount: number, type?: LessonTypesEnum | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string }>, coachQualifications: Array<{ __typename?: 'UsersCoachQualifications', id: any, status: CoachQualificationStatusesEnum, qualification: { __typename?: 'CoachQualifications', id: any, name: string, order: number, groupId?: CoachQualificationGroupsEnum | null, displayKey: string } }>, normalizedTennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, name: string, shortName: string } | null, tennisSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null, pickleballSkillLevel?: { __typename?: 'SkillLevels', id: string, isDisplayed: boolean, rank: number, displayName: string } | null }> };

export type GetExistingUserQueryVariables = Exact<{
  firebaseId: Scalars['String'];
}>;


export type GetExistingUserQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'Users', id: any, email: string, username?: string | null, fullName: string, coachStatus?: CoachStatusEnum | null }> };

export type InsertSignupRequestMutationVariables = Exact<{
  accountType: Scalars['String'];
  email: Scalars['String'];
  fullName: Scalars['String'];
  preferredName: Scalars['String'];
  username: Scalars['String'];
  ip?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
}>;


export type InsertSignupRequestMutation = { __typename?: 'mutation_root', insertSignupRequestsOne?: { __typename?: 'SignupRequests', id: any } | null };

export type CheckUsernameAvailabilityQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type CheckUsernameAvailabilityQuery = { __typename?: 'query_root', usernamesActive: Array<{ __typename?: 'UsernamesActive', username?: string | null }>, usernamesClaimed: Array<{ __typename?: 'UsernamesClaimed', id: any, username: string }> };

export type GetGroupThreadByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
  userId: Scalars['uuid'];
}>;


export type GetGroupThreadByIdQuery = { __typename?: 'query_root', groupThreadsByPk?: { __typename?: 'GroupThreads', comments: Array<{ __typename?: 'GroupThreadComments', content: string, createdAt: any, groupCommentId?: any | null, groupRootCommentId?: any | null, id: any, isOriginalThreadComment: boolean, updatedAt: any, userId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, profileImagePath?: string | null, username?: string | null } | null, votesAggregate: { __typename?: 'GroupCommentVotesAggregate', aggregate?: { __typename?: 'GroupCommentVotesAggregateFields', count: number } | null }, votes: Array<{ __typename?: 'GroupCommentVotes', id: any, userId: any, groupThreadCommentId: any, vote: CommentVoteEnum }>, files: Array<{ __typename?: 'GroupThreadCommentFiles', id: any, url: string, path: string }> }> } | null };

export type InsertGroupThreadCommentMutationVariables = Exact<{
  userId: Scalars['uuid'];
  groupThreadId: Scalars['uuid'];
  content: Scalars['String'];
  groupCommentId?: InputMaybe<Scalars['uuid']>;
  groupRootCommentId?: InputMaybe<Scalars['uuid']>;
}>;


export type InsertGroupThreadCommentMutation = { __typename?: 'mutation_root', insertGroupThreadCommentsOne?: { __typename?: 'GroupThreadComments', id: any, groupThreadId: any, content: string } | null };

export type GetVenuesByGeoQueryVariables = Exact<{
  distance: Scalars['Float'];
  from: Scalars['geography'];
}>;


export type GetVenuesByGeoQuery = { __typename?: 'query_root', venues: Array<{ __typename?: 'Venues', id: any, title: string, geometry?: any | null, slug: string, pickleballLines?: VenueLinesEnum | null, addressString: string, accessType?: VenueAccessTypesEnum | null, indoorCourtCount: number, outdoorCourtCount: number, pickleballNets?: VenueNetsEnum | null, images: Array<{ __typename?: 'VenueImages', id: any, fileName: string, url: string }>, city?: { __typename?: 'Cities', id: any, name: string, countrySubdivision: { __typename?: 'CountrySubdivisions', id: any, name: string } } | null, courtSurfaces: Array<{ __typename?: 'VenueCourtSurfaces', id: any, courtSurface: CourtSurfacesEnum }> }> };

export type GetPlaySessionsByVenueIdAsUserQueryVariables = Exact<{
  venueId: Scalars['uuid'];
  startDateTime: Scalars['timestamptz'];
  userId: Scalars['uuid'];
}>;


export type GetPlaySessionsByVenueIdAsUserQuery = { __typename?: 'query_root', playSessions: Array<{ __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, commentsAggregate: { __typename?: 'PlaySessionCommentsAggregate', aggregate?: { __typename?: 'PlaySessionCommentsAggregateFields', count: number } | null }, currentUserAsParticipant: Array<{ __typename?: 'PlaySessionParticipants', id: any, status: PlaySessionParticipantStatusesEnum }>, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null }> };

export type GetPlaySessionsByVenueIdAsAnonymousQueryVariables = Exact<{
  venueId: Scalars['uuid'];
  startDateTime: Scalars['timestamptz'];
}>;


export type GetPlaySessionsByVenueIdAsAnonymousQuery = { __typename?: 'query_root', playSessions: Array<{ __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, commentsAggregate: { __typename?: 'PlaySessionCommentsAggregate', aggregate?: { __typename?: 'PlaySessionCommentsAggregateFields', count: number } | null }, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null }> };

export type UpsertVenueFollowMutationVariables = Exact<{
  userId: Scalars['uuid'];
  venueId: Scalars['uuid'];
  status: FollowStatusesEnum;
}>;


export type UpsertVenueFollowMutation = { __typename?: 'mutation_root', insertVenueFollowsOne?: { __typename?: 'VenueFollows', status: FollowStatusesEnum, id: any, userId: any, venueId: any } | null };

export type GetUserVenueFollowQueryVariables = Exact<{
  userId: Scalars['uuid'];
  venueId: Scalars['uuid'];
}>;


export type GetUserVenueFollowQuery = { __typename?: 'query_root', venueFollows: Array<{ __typename?: 'VenueFollows', id: any, userId: any, venueId: any, status: FollowStatusesEnum }> };

export type GetGamedayByEventIdQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetGamedayByEventIdQuery = { __typename?: 'query_root', eventsByPk?: { __typename?: 'Events', id: any, title: string, hostUserId?: any | null, groups: Array<{ __typename?: 'EventGroups', id: any, title: string, winBy?: number | null, totalPoints: number, teamLimit: number, teamType: TeamTypesEnum, startsAt?: any | null, endsAt?: any | null, scoringFormat: ScoringFormatEnum, gamesPerMatch: number, format: EventGroupFormatsEnum, minimumNumberOfGames: number, numberOfEliminationTeams?: number | null, numberOfEstimatedCourts?: number | null, sequences: Array<{ __typename?: 'EventGroupSequences', id: any, nextSequenceId?: any | null, order: number, groupId: any, competitionFormat: CompetitionFormatsEnum, completeReason: EventSequenceCompleteReasonsEnum, isSequenceComplete: boolean, pools: Array<{ __typename?: 'EventGroupPools', id: any, title: string, startsAt?: any | null, endsAt?: any | null, rounds: Array<{ __typename?: 'EventPoolRounds', id: any, roundOrder: number, title: string, matches: Array<{ __typename?: 'EventMatches', courtNumber?: number | null, id: any, matchOrder: number, isBye: boolean, winningTeamId?: any | null, losingTeamId?: any | null, team1Id?: any | null, team2Id?: any | null, previousMatch1Id?: any | null, previousMatch2Id?: any | null, selectionCriteriaPreviousMatch1?: MatchSelectionCriteriaEnum | null, selectionCriteriaPreviousMatch2?: MatchSelectionCriteriaEnum | null, team1?: { __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', id: any, status: EventTeamMemberStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } | null, team2?: { __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', id: any, status: EventTeamMemberStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } | null, games: Array<{ __typename?: 'EventMatchGames', id: any, losingTeamId: any, team1Id: any, team1Score: any, team2Id: any, team2Score: any, winReason: WinReasonsEnum, winningTeamId: any, scores: Array<{ __typename?: 'EventGameScores', id: any, score: number, teamId: any }> }> }> }> }>, seeding: Array<{ __typename?: 'EventGroupSequenceSeeding', id: any, eventTeamId: any, seed: number }> }>, courts: Array<{ __typename?: 'EventCourts', id: any, updatedAt: any, courtNumber: number, courtStatus: EventCourtStatusesEnum, activeMatchId?: any | null, activeMatch?: { __typename?: 'EventMatches', id: any, teams: Array<{ __typename?: 'EventMatchesTeams', id: any, team: { __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } }> } | null }> }>, courts: Array<{ __typename?: 'EventCourts', id: any, updatedAt: any, activeMatchId?: any | null, courtStatus: EventCourtStatusesEnum, courtNumber: number, activeEventGroupId?: any | null, activeEventGroupPoolId?: any | null }> } | null };

export type AssignCourtToMatchMutationVariables = Exact<{
  matchId: Scalars['uuid'];
  courtId: Scalars['uuid'];
  courtNumber: Scalars['Int'];
}>;


export type AssignCourtToMatchMutation = { __typename?: 'mutation_root', updateEventMatchesByPk?: { __typename?: 'EventMatches', id: any, eventCourtId?: any | null, courtNumber?: number | null } | null, updateEventCourtsByPk?: { __typename?: 'EventCourts', id: any, updatedAt: any, courtNumber: number, courtStatus: EventCourtStatusesEnum, activeMatchId?: any | null, activeMatch?: { __typename?: 'EventMatches', id: any, team1?: { __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', id: any, status: EventTeamMemberStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } | null, team2?: { __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', id: any, status: EventTeamMemberStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } | null, teams: Array<{ __typename?: 'EventMatchesTeams', id: any, team: { __typename?: 'EventTeams', members: Array<{ __typename?: 'EventTeamMembers', userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } }> } | null } | null };

export type SetMatchScoresFreeCourtMutationVariables = Exact<{
  losingTeamId: Scalars['uuid'];
  matchId: Scalars['uuid'];
  team1Id: Scalars['uuid'];
  team1Score: Scalars['numeric'];
  team2Id: Scalars['uuid'];
  team2Score: Scalars['numeric'];
  winReason: WinReasonsEnum;
  winningTeamId: Scalars['uuid'];
  data?: InputMaybe<Array<EventGameScoresInsertInput> | EventGameScoresInsertInput>;
  courtId: Scalars['uuid'];
}>;


export type SetMatchScoresFreeCourtMutation = { __typename?: 'mutation_root', insertEventMatchGamesOne?: { __typename?: 'EventMatchGames', id: any, matchId: any, team1Score: any, team2Score: any, team1Id: any, team2Id: any, winReason: WinReasonsEnum, winningTeamId: any, losingTeamId: any } | null, updateEventMatchesByPk?: { __typename?: 'EventMatches', id: any, losingTeamId?: any | null, winReason?: WinReasonsEnum | null, winningTeamId?: any | null, courtNumber?: number | null } | null, updateEventCourtsByPk?: { __typename?: 'EventCourts', id: any, activeMatchId?: any | null } | null };

export type SetMatchScoresUpdateNextMatchCourtMutationVariables = Exact<{
  losingTeamId: Scalars['uuid'];
  matchId: Scalars['uuid'];
  team1Id: Scalars['uuid'];
  team1Score: Scalars['numeric'];
  team2Id: Scalars['uuid'];
  team2Score: Scalars['numeric'];
  winReason: WinReasonsEnum;
  winningTeamId: Scalars['uuid'];
  data?: InputMaybe<Array<EventGameScoresInsertInput> | EventGameScoresInsertInput>;
  courtId: Scalars['uuid'];
  courtNumber: Scalars['Int'];
  nextMatchId: Scalars['uuid'];
}>;


export type SetMatchScoresUpdateNextMatchCourtMutation = { __typename?: 'mutation_root', insertEventMatchGamesOne?: { __typename?: 'EventMatchGames', id: any, matchId: any, team1Score: any, team2Score: any, winReason: WinReasonsEnum, winningTeamId: any, losingTeamId: any } | null, updatePreviousMatch?: { __typename?: 'EventMatches', id: any, losingTeamId?: any | null, winReason?: WinReasonsEnum | null, winningTeamId?: any | null, courtNumber?: number | null, eventCourtId?: any | null } | null, updateNextMatch?: { __typename?: 'EventMatches', id: any, losingTeamId?: any | null, winReason?: WinReasonsEnum | null, winningTeamId?: any | null, courtNumber?: number | null, eventCourtId?: any | null } | null, updateEventCourtsByPk?: { __typename?: 'EventCourts', id: any, activeMatchId?: any | null } | null };

export type SetMatchScoresMutationVariables = Exact<{
  losingTeamId: Scalars['uuid'];
  matchId: Scalars['uuid'];
  team1Id: Scalars['uuid'];
  team1Score: Scalars['numeric'];
  team2Id: Scalars['uuid'];
  team2Score: Scalars['numeric'];
  winReason: WinReasonsEnum;
  winningTeamId: Scalars['uuid'];
  data?: InputMaybe<Array<EventGameScoresInsertInput> | EventGameScoresInsertInput>;
}>;


export type SetMatchScoresMutation = { __typename?: 'mutation_root', insertEventMatchGamesOne?: { __typename?: 'EventMatchGames', id: any, matchId: any, team1Score: any, team2Score: any, winReason: WinReasonsEnum, winningTeamId: any, losingTeamId: any } | null, updatePreviousMatch?: { __typename?: 'EventMatches', id: any, losingTeamId?: any | null, winReason?: WinReasonsEnum | null, winningTeamId?: any | null, courtNumber?: number | null, eventCourtId?: any | null } | null };

export type UpdateGameScoreMutationVariables = Exact<{
  gameId: Scalars['uuid'];
  team1Score: Scalars['numeric'];
  team2Score: Scalars['numeric'];
  losingTeamId: Scalars['uuid'];
  winningTeamId: Scalars['uuid'];
  matchId: Scalars['uuid'];
  matchWinningTeamId: Scalars['uuid'];
  matchLosingTeamId: Scalars['uuid'];
  updates?: InputMaybe<Array<EventGameScoresUpdates> | EventGameScoresUpdates>;
}>;


export type UpdateGameScoreMutation = { __typename?: 'mutation_root', updateEventMatchGamesByPk?: { __typename?: 'EventMatchGames', id: any, team2Id: any, team2Score: any, team1Id: any, team1Score: any, losingTeamId: any } | null, updateEventMatchesByPk?: { __typename?: 'EventMatches', id: any, losingTeamId?: any | null, winningTeamId?: any | null } | null, updateEventGameScoresMany?: Array<{ __typename?: 'EventGameScoresMutationResponse', returning: Array<{ __typename?: 'EventGameScores', id: any, score: number }> } | null> | null };

export type UpdateSingleEliminationMatchProgressionMutationVariables = Exact<{
  updates?: InputMaybe<Array<EventMatchesUpdates> | EventMatchesUpdates>;
}>;


export type UpdateSingleEliminationMatchProgressionMutation = { __typename?: 'mutation_root', updateEventMatchesMany?: Array<{ __typename?: 'EventMatchesMutationResponse', returning: Array<{ __typename?: 'EventMatches', team1Id?: any | null, team2Id?: any | null }> } | null> | null };

export type UpdatedUnassignCourtMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type UpdatedUnassignCourtMutation = { __typename?: 'mutation_root', updateEventCourtsByPk?: { __typename?: 'EventCourts', id: any, courtNumber: number, courtStatus: EventCourtStatusesEnum, activeMatchId?: any | null, activeEventGroupId?: any | null, activeEventGroupPoolId?: any | null } | null };

export type UpdateCourtsStartGroupMutationVariables = Exact<{
  courtUpdates?: InputMaybe<Array<EventCourtsUpdates> | EventCourtsUpdates>;
  matchUpdates?: InputMaybe<Array<EventMatchesUpdates> | EventMatchesUpdates>;
}>;


export type UpdateCourtsStartGroupMutation = { __typename?: 'mutation_root', updateEventCourtsMany?: Array<{ __typename?: 'EventCourtsMutationResponse', returning: Array<{ __typename?: 'EventCourts', id: any, updatedAt: any, courtNumber: number, courtStatus: EventCourtStatusesEnum, activeMatchId?: any | null, activeMatch?: { __typename?: 'EventMatches', id: any, teams: Array<{ __typename?: 'EventMatchesTeams', id: any, team: { __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null } | null }> } }> } | null }> } | null> | null, updateEventMatchesMany?: Array<{ __typename?: 'EventMatchesMutationResponse', returning: Array<{ __typename?: 'EventMatches', id: any, isBye: boolean, matchOrder: number, courtNumber?: number | null, eventCourtId?: any | null }> } | null> | null };

export type UpdateRemoveCourtFromMatchMutationVariables = Exact<{
  matchId: Scalars['uuid'];
  courtId: Scalars['uuid'];
}>;


export type UpdateRemoveCourtFromMatchMutation = { __typename?: 'mutation_root', updateEventMatchesByPk?: { __typename?: 'EventMatches', id: any, eventCourtId?: any | null, courtNumber?: number | null } | null, updateEventCourtsByPk?: { __typename?: 'EventCourts', activeMatchId?: any | null, id: any } | null };

export type UpdateReleaseCourtsFromGroupMutationVariables = Exact<{
  activeEventGroupId: Scalars['uuid'];
}>;


export type UpdateReleaseCourtsFromGroupMutation = { __typename?: 'mutation_root', updateEventCourts?: { __typename?: 'EventCourtsMutationResponse', returning: Array<{ __typename?: 'EventCourts', id: any, activeEventGroupId?: any | null, activeEventGroupPoolId?: any | null, activeMatchId?: any | null }> } | null };

export type UpdateCompleteSequenceMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type UpdateCompleteSequenceMutation = { __typename?: 'mutation_root', updateEventGroupSequencesByPk?: { __typename?: 'EventGroupSequences', id: any, isSequenceComplete: boolean, completeReason: EventSequenceCompleteReasonsEnum } | null };

export type GetUserGroupsQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetUserGroupsQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', id: any, groups: Array<{ __typename?: 'GroupMembers', id: any, isActive: boolean, groupId: any }> } | null };

export type GetGroupByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
  userId: Scalars['uuid'];
}>;


export type GetGroupByIdQuery = { __typename?: 'query_root', groupsByPk?: { __typename?: 'Groups', contactEmail?: string | null, contactMessage?: string | null, contactPhoneNumber?: string | null, contactUrl?: string | null, coverPhotoUrl: string, createdAt: any, description: string, displayOwnerContactInfo: boolean, headline: string, id: any, isPrivate: boolean, ownerUserId?: any | null, profilePhotoUrl: string, skillLevelMaximum?: any | null, skillLevelMinimum?: any | null, slug: string, title: string, allowMemberInvites: boolean, allowMemberSessionInvites: boolean, accessCode?: string | null, city: { __typename?: 'Cities', id: any, name: string }, threads: Array<{ __typename?: 'GroupThreads', createdAt: any, id: any, comments: Array<{ __typename?: 'GroupThreadComments', createdAt: any, content: string, groupCommentId?: any | null, groupRootCommentId?: any | null, groupThreadId: any, id: any, isOriginalThreadComment: boolean, votesAggregate: { __typename?: 'GroupCommentVotesAggregate', aggregate?: { __typename?: 'GroupCommentVotesAggregateFields', count: number } | null }, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, profileImagePath?: string | null, username?: string | null, defaultSport?: string | null } | null, votes: Array<{ __typename?: 'GroupCommentVotes', id: any, userId: any, groupThreadCommentId: any, vote: CommentVoteEnum }>, files: Array<{ __typename?: 'GroupThreadCommentFiles', id: any, url: string, path: string }> }>, commentsAggregate: { __typename?: 'GroupThreadCommentsAggregate', aggregate?: { __typename?: 'GroupThreadCommentsAggregateFields', count: number } | null } }>, membersAggregate: { __typename?: 'GroupMembersAggregate', aggregate?: { __typename?: 'GroupMembersAggregateFields', count: number } | null }, ownerUserProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, profileImagePath?: string | null } | null, venuesAggregate: { __typename?: 'GroupVenuesAggregate', aggregate?: { __typename?: 'GroupVenuesAggregateFields', count: number } | null } } | null };

export type InsertThreadWithCommentMutationVariables = Exact<{
  groupId: Scalars['uuid'];
  userId: Scalars['uuid'];
  content?: InputMaybe<Scalars['String']>;
  files?: InputMaybe<Array<GroupThreadCommentFilesInsertInput> | GroupThreadCommentFilesInsertInput>;
}>;


export type InsertThreadWithCommentMutation = { __typename?: 'mutation_root', insertGroupThreadsOne?: { __typename?: 'GroupThreads', id: any } | null };

export type UpdateCommentFileAsDeletedMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type UpdateCommentFileAsDeletedMutation = { __typename?: 'mutation_root', updateGroupThreadCommentFilesByPk?: { __typename?: 'GroupThreadCommentFiles', id: any, deletedAt?: any | null } | null };

export type GetGroupMembersQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetGroupMembersQuery = { __typename?: 'query_root', groupsByPk?: { __typename?: 'Groups', id: any, members: Array<{ __typename?: 'GroupMembers', userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, profileImagePath?: string | null, username?: string | null } | null }> } | null };

export type GetUserAvailableLessonContentQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetUserAvailableLessonContentQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', id: any, customCourts: Array<{ __typename?: 'UserCustomCourts', createdAt: any, deletedAt?: any | null, fullAddress: string, id: any, title: string }>, lessonTemplates: Array<{ __typename?: 'LessonTemplates', coverImageUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, id: any, originalLessonId?: any | null, participantLimit: number, priceUnitAmount: number, privacy?: LessonPrivacyEnum | null, templateName: string, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, userId?: any | null, userCustomCourtId?: any | null, sport?: SportsEnum | null }> } | null };

export type InsertNewLessonWithNewCourtMutationVariables = Exact<{
  title: Scalars['String'];
  type: LessonTypesEnum;
  typeCustom?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<LessonStatusesEnum>;
  description: Scalars['String'];
  startDateTime: Scalars['timestamptz'];
  endDateTime: Scalars['timestamptz'];
  ownerUserId: Scalars['uuid'];
  participantLimit: Scalars['Int'];
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  priceUnitAmount: Scalars['Int'];
  privacy?: InputMaybe<LessonPrivacyEnum>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  lessonTimeData: Array<LessonTimesInsertInput> | LessonTimesInsertInput;
  customCourtData: UserCustomCourtsInsertInput;
  lessonEquipment?: InputMaybe<Array<LessonEquipmentInsertInput> | LessonEquipmentInsertInput>;
  locale: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneAbbreviation: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  sport: SportsEnum;
}>;


export type InsertNewLessonWithNewCourtMutation = { __typename?: 'mutation_root', insertLessonsOne?: { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> } | null };

export type InsertNewLessonWithExistingCourtMutationVariables = Exact<{
  title: Scalars['String'];
  sport: SportsEnum;
  type: LessonTypesEnum;
  typeCustom?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<LessonStatusesEnum>;
  description: Scalars['String'];
  startDateTime: Scalars['timestamptz'];
  endDateTime: Scalars['timestamptz'];
  ownerUserId: Scalars['uuid'];
  participantLimit: Scalars['Int'];
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  priceUnitAmount: Scalars['Int'];
  privacy?: InputMaybe<LessonPrivacyEnum>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  lessonTimeData: Array<LessonTimesInsertInput> | LessonTimesInsertInput;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  lessonEquipment?: InputMaybe<Array<LessonEquipmentInsertInput> | LessonEquipmentInsertInput>;
  locale: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneAbbreviation: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
}>;


export type InsertNewLessonWithExistingCourtMutation = { __typename?: 'mutation_root', insertLessonsOne?: { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> } | null };

export type InsertUserCustomCourtMutationVariables = Exact<{
  customCourtData: UserCustomCourtsInsertInput;
}>;


export type InsertUserCustomCourtMutation = { __typename?: 'mutation_root', insertUserCustomCourtsOne?: { __typename?: 'UserCustomCourts', id: any } | null };

export type UpdateLessonTimesMutationVariables = Exact<{
  lessonId: Scalars['uuid'];
  lessonTimeData: Array<LessonTimesInsertInput> | LessonTimesInsertInput;
}>;


export type UpdateLessonTimesMutation = { __typename?: 'mutation_root', deleteLessonTimes?: { __typename?: 'LessonTimesMutationResponse', affectedRows: number } | null, insertLessonTimes?: { __typename?: 'LessonTimesMutationResponse', affectedRows: number } | null };

export type UpdateLessonEquipmentMutationVariables = Exact<{
  lessonId: Scalars['uuid'];
  lessonEquipmentData?: InputMaybe<Array<LessonEquipmentInsertInput> | LessonEquipmentInsertInput>;
}>;


export type UpdateLessonEquipmentMutation = { __typename?: 'mutation_root', deleteLessonEquipment?: { __typename?: 'LessonEquipmentMutationResponse', affectedRows: number } | null, insertLessonEquipment?: { __typename?: 'LessonEquipmentMutationResponse', affectedRows: number } | null };

export type UpdateNewLessonByIdMutationVariables = Exact<{
  lessonId: Scalars['uuid'];
  title: Scalars['String'];
  sport: SportsEnum;
  type: LessonTypesEnum;
  typeCustom?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<LessonStatusesEnum>;
  description: Scalars['String'];
  startDateTime: Scalars['timestamptz'];
  endDateTime: Scalars['timestamptz'];
  participantLimit: Scalars['Int'];
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  priceUnitAmount: Scalars['Int'];
  privacy?: InputMaybe<LessonPrivacyEnum>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourtId: Scalars['uuid'];
}>;


export type UpdateNewLessonByIdMutation = { __typename?: 'mutation_root', updateLessonsByPk?: { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> } | null };

export type UpdateExistingLessonByIdMutationVariables = Exact<{
  lessonId: Scalars['uuid'];
  title: Scalars['String'];
  description: Scalars['String'];
  sport?: InputMaybe<SportsEnum>;
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  participantLimit: Scalars['Int'];
}>;


export type UpdateExistingLessonByIdMutation = { __typename?: 'mutation_root', updateLessonsByPk?: { __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> } | null };

export type UpdateUserDefaultCoachPaymentFulfillmentChannelMutationVariables = Exact<{
  id: Scalars['uuid'];
  defaultCoachPaymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
}>;


export type UpdateUserDefaultCoachPaymentFulfillmentChannelMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', defaultCoachPaymentFulfillmentChannel?: PaymentFulfillmentChannelsEnum | null, id: any } | null };

export type GetUserCreditCardsQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetUserCreditCardsQuery = { __typename?: 'query_root', userCreditCards: Array<{ __typename?: 'UserCreditCards', id: any, last4: string, provider: string, providerCardId: string, expireYear: number, expireMonth: number, brand: string, billingName?: string | null, billingPostalCode?: string | null }> };

export type SetLessonAsActiveMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SetLessonAsActiveMutation = { __typename?: 'mutation_root', updateLessonsByPk?: { __typename?: 'Lessons', id: any, status: LessonStatusesEnum, publishedAt?: any | null } | null };

export type InsertLessonTemplateMutationVariables = Exact<{
  coverImageUrl?: InputMaybe<Scalars['String']>;
  currency: Scalars['String'];
  description: Scalars['String'];
  originalLessonId: Scalars['uuid'];
  participantLimit: Scalars['Int'];
  priceUnitAmount: Scalars['Int'];
  privacy: LessonPrivacyEnum;
  templateName: Scalars['String'];
  title: Scalars['String'];
  type: LessonTypesEnum;
  typeCustom: Scalars['String'];
  userId: Scalars['uuid'];
  userCustomCourtId: Scalars['uuid'];
  sport: SportsEnum;
}>;


export type InsertLessonTemplateMutation = { __typename?: 'mutation_root', insertLessonTemplatesOne?: { __typename?: 'LessonTemplates', id: any, type: LessonTypesEnum, title: string, templateName: string, coverImageUrl: string, currency: string, description: string, originalLessonId?: any | null, participantLimit: number, priceUnitAmount: number, privacy?: LessonPrivacyEnum | null, typeCustom: string, userId?: any | null, userCustomCourtId?: any | null, sport?: SportsEnum | null } | null };

export type GetLessonParticipantOrderDetailsQueryVariables = Exact<{
  userId: Scalars['uuid'];
  lessonId: Scalars['uuid'];
}>;


export type GetLessonParticipantOrderDetailsQuery = { __typename?: 'query_root', lessonParticipants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, status: LessonParticipantStatusesEnum, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, orderItems: Array<{ __typename?: 'LessonOrderItems', id: any, status: OrderStatusesEnum, totalUnitAmount: number, priceUnitAmount: number, order: { __typename?: 'LessonOrders', paidUnitAmount: number, refundUnitAmount: number, status: OrderStatusesEnum, orderTotalUnitAmount: number, orderSubtotalUnitAmount: number } }> }> };

export type GetLessonWaitlistQueryVariables = Exact<{
  lessonId: Scalars['uuid'];
}>;


export type GetLessonWaitlistQuery = { __typename?: 'query_root', lessonWaitlists: Array<{ __typename?: 'LessonWaitlists', id: any, status: LessonWaitlistStatusesEnum, userId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, username?: string | null } | null }> };

export type UpsertLessonWaitlistMutationVariables = Exact<{
  userId: Scalars['uuid'];
  lessonId: Scalars['uuid'];
  status: LessonWaitlistStatusesEnum;
}>;


export type UpsertLessonWaitlistMutation = { __typename?: 'mutation_root', insertLessonWaitlistsOne?: { __typename?: 'LessonWaitlists', lessonId: any, status: LessonWaitlistStatusesEnum, userId: any, id: any } | null };

export type GetUserCommunicationPreferencesQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetUserCommunicationPreferencesQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', id: any, coachStatus?: CoachStatusEnum | null, communicationPreferences?: { __typename?: 'UserCommunicationPreferences', id: any, lessonBookedEmail: CommunicationPreferenceStatusesEnum, lessonBookedPush: CommunicationPreferenceStatusesEnum, lessonCanceledEmail: CommunicationPreferenceStatusesEnum, lessonCanceledPushed: CommunicationPreferenceStatusesEnum, lessonReminderEmail: CommunicationPreferenceStatusesEnum, lessonReminderPush: CommunicationPreferenceStatusesEnum, marketingEmail: CommunicationPreferenceStatusesEnum, marketingPush: CommunicationPreferenceStatusesEnum, newFollowerEmail: CommunicationPreferenceStatusesEnum, newFollowerPush: CommunicationPreferenceStatusesEnum, newLessonPublishedEmail: CommunicationPreferenceStatusesEnum, newLessonPublishedPush: CommunicationPreferenceStatusesEnum, participantLeftLessonEmail: CommunicationPreferenceStatusesEnum, participantLeftLessonPush: CommunicationPreferenceStatusesEnum, payoutEmail: CommunicationPreferenceStatusesEnum, payoutPush: CommunicationPreferenceStatusesEnum, playSessionCanceledEmail: CommunicationPreferenceStatusesEnum, playSessionCanceledPush: CommunicationPreferenceStatusesEnum, playSessionParticipantJoinedEmail: CommunicationPreferenceStatusesEnum, playSessionParticipantJoinedPush: CommunicationPreferenceStatusesEnum, playSessionParticipantLeftEmail: CommunicationPreferenceStatusesEnum, playSessionParticipantLeftPush: CommunicationPreferenceStatusesEnum, playSessionReminderEmail: CommunicationPreferenceStatusesEnum, playSessionReminderPush: CommunicationPreferenceStatusesEnum } | null } | null };

export type UpdateUserCommunicationPreferencesMutationVariables = Exact<{
  id: Scalars['uuid'];
  _set: UserCommunicationPreferencesSetInput;
}>;


export type UpdateUserCommunicationPreferencesMutation = { __typename?: 'mutation_root', updateUserCommunicationPreferencesByPk?: { __typename?: 'UserCommunicationPreferences', id: any, lessonBookedEmail: CommunicationPreferenceStatusesEnum, lessonBookedPush: CommunicationPreferenceStatusesEnum, lessonCanceledEmail: CommunicationPreferenceStatusesEnum, lessonCanceledPushed: CommunicationPreferenceStatusesEnum, lessonReminderEmail: CommunicationPreferenceStatusesEnum, lessonReminderPush: CommunicationPreferenceStatusesEnum, marketingEmail: CommunicationPreferenceStatusesEnum, marketingPush: CommunicationPreferenceStatusesEnum, newFollowerEmail: CommunicationPreferenceStatusesEnum, newFollowerPush: CommunicationPreferenceStatusesEnum, newLessonPublishedEmail: CommunicationPreferenceStatusesEnum, newLessonPublishedPush: CommunicationPreferenceStatusesEnum, participantLeftLessonEmail: CommunicationPreferenceStatusesEnum, participantLeftLessonPush: CommunicationPreferenceStatusesEnum, payoutEmail: CommunicationPreferenceStatusesEnum, payoutPush: CommunicationPreferenceStatusesEnum, playSessionCanceledEmail: CommunicationPreferenceStatusesEnum, playSessionCanceledPush: CommunicationPreferenceStatusesEnum, playSessionParticipantJoinedEmail: CommunicationPreferenceStatusesEnum, playSessionParticipantJoinedPush: CommunicationPreferenceStatusesEnum, playSessionParticipantLeftEmail: CommunicationPreferenceStatusesEnum, playSessionParticipantLeftPush: CommunicationPreferenceStatusesEnum, playSessionReminderEmail: CommunicationPreferenceStatusesEnum, playSessionReminderPush: CommunicationPreferenceStatusesEnum } | null };

export type GetUserNotificationsQueryVariables = Exact<{
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  userId: Scalars['uuid'];
}>;


export type GetUserNotificationsQuery = { __typename?: 'query_root', userNotifications: Array<{ __typename?: 'UserNotifications', id: any, status: NotificationStatusesEnum, notificationDetails: { __typename?: 'UserNotificationDetails', actionType: NotificationActionTypesEnum, id: any, primaryEntity: { __typename?: 'UserNotificationEntities', actingUserProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, coachStatus?: string | null } | null, lesson?: { __typename?: 'Lessons', id: any, ownerUserId?: any | null, startDateTime?: any | null, endDateTime?: any | null, title: string, status: LessonStatusesEnum, ownerProfile?: { __typename?: 'UserProfiles', username?: string | null, preferredName?: string | null, fullName?: string | null, coachStatus?: string | null, id?: any | null } | null } | null, playSession?: { __typename?: 'PlaySessions', id: any, startDateTime?: any | null, endDateTime?: any | null, title: string, status: PlaySessionStatusesEnum, organizerUserId?: any | null, format: PlaySessionFormatsEnum, sport: SportsEnum, targetSkillLevel?: string | null, organizerProfile?: { __typename?: 'UserProfiles', username?: string | null, preferredName?: string | null, fullName?: string | null, coachStatus?: string | null, id?: any | null } | null } | null, group?: { __typename?: 'Groups', id: any, title: string, slug: string } | null, groupThread?: { __typename?: 'GroupThreads', groupId: any, id: any, comments: Array<{ __typename?: 'GroupThreadComments', id: any, content: string }> } | null } } }> };

export type GetUserNotificationsCountQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetUserNotificationsCountQuery = { __typename?: 'query_root', userNotificationsAggregate: { __typename?: 'UserNotificationsAggregate', aggregate?: { __typename?: 'UserNotificationsAggregateFields', count: number } | null } };

export type UpdateNotificationsAsReadMutationVariables = Exact<{
  updates: Array<UserNotificationsUpdates> | UserNotificationsUpdates;
}>;


export type UpdateNotificationsAsReadMutation = { __typename?: 'mutation_root', updateUserNotificationsMany?: Array<{ __typename?: 'UserNotificationsMutationResponse', returning: Array<{ __typename?: 'UserNotifications', id: any, status: NotificationStatusesEnum }> } | null> | null };

export type UpdateUserGenderMutationVariables = Exact<{
  id: Scalars['uuid'];
  gender: GenderEnum;
  genderPreference: Scalars['String'];
}>;


export type UpdateUserGenderMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, gender?: GenderEnum | null, genderPreference: string } | null };

export type InsertRepeatLessonsMutationVariables = Exact<{
  objects?: InputMaybe<Array<LessonsInsertInput> | LessonsInsertInput>;
}>;


export type InsertRepeatLessonsMutation = { __typename?: 'mutation_root', insertLessons?: { __typename?: 'LessonsMutationResponse', returning: Array<{ __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> }> } | null };

export type UpdateUserOnboardBioMutationVariables = Exact<{
  id: Scalars['uuid'];
  birthday: Scalars['date'];
  gender: GenderEnum;
  genderPreference?: InputMaybe<Scalars['String']>;
}>;


export type UpdateUserOnboardBioMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, gender?: GenderEnum | null, genderPreference: string, fullName: string, email: string, birthday?: any | null, normalizedTennisRating?: any | null, normalizedTennisRatingScaleId?: any | null, tennisRating?: any | null, tennisRatingScaleId?: any | null } | null };

export type SetOnboardCompleteMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SetOnboardCompleteMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, isOnboardComplete: boolean } | null };

export type UpdateMarketingCommunicationPreferencesMutationVariables = Exact<{
  id: Scalars['uuid'];
  marketingPreference?: InputMaybe<CommunicationPreferenceStatusesEnum>;
}>;


export type UpdateMarketingCommunicationPreferencesMutation = { __typename?: 'mutation_root', updateUserCommunicationPreferencesByPk?: { __typename?: 'UserCommunicationPreferences', id: any, marketingEmail: CommunicationPreferenceStatusesEnum, marketingPush: CommunicationPreferenceStatusesEnum } | null };

export type InsertAcceptTermsOfServiceMutationVariables = Exact<{
  ip?: InputMaybe<Scalars['String']>;
  userAgent?: InputMaybe<Scalars['String']>;
  userId: Scalars['uuid'];
}>;


export type InsertAcceptTermsOfServiceMutation = { __typename?: 'mutation_root', insertUserTermsOfServiceOne?: { __typename?: 'UserTermsOfService', id: any, ip: string, acceptedAt: any, userAgent: string, userId: any } | null };

export type SetUserLocationMutationVariables = Exact<{
  id: Scalars['uuid'];
  countryId: Scalars['String'];
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  cityName: Scalars['String'];
}>;


export type SetUserLocationMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, countrySubdivisionId?: any | null, countryId?: string | null } | null };

export type SetUserCoachQualificationsMutationVariables = Exact<{
  userId: Scalars['uuid'];
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  objects?: InputMaybe<Array<UsersCoachQualificationsInsertInput> | UsersCoachQualificationsInsertInput>;
}>;


export type SetUserCoachQualificationsMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, coachExperienceSetAt?: any | null, coachExperienceYears: any } | null, insertUsersCoachQualifications?: { __typename?: 'UsersCoachQualificationsMutationResponse', returning: Array<{ __typename?: 'UsersCoachQualifications', id: any, status: CoachQualificationStatusesEnum, coachQualificationId: any, userId: any }> } | null };

export type GetSkillLevelsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSkillLevelsQuery = { __typename?: 'query_root', skillLevels: Array<{ __typename?: 'SkillLevels', displayName: string, id: string, isDisplayed: boolean, rank: number }> };

export type UpdateUserTennisSkillLevelMutationVariables = Exact<{
  id: Scalars['uuid'];
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
}>;


export type UpdateUserTennisSkillLevelMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, tennisSkillLevelId?: string | null } | null };

export type UpdateUserPickleballSkillLevelMutationVariables = Exact<{
  id: Scalars['uuid'];
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
}>;


export type UpdateUserPickleballSkillLevelMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, pickleballSkillLevelId?: string | null } | null };

export type GetPublishedEventsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPublishedEventsQuery = { __typename?: 'query_root', events: Array<{ __typename?: 'Events', id: any, title: string, cityString: string, startDateTime: any, addressString?: string | null, displayLocation: string, endDate: any, coverImageUrl?: string | null, endDateTime: any, latitude?: any | null, longitude?: any | null, status: EventStatusesEnum, startDate: any, publishedAt?: any | null, city?: { __typename?: 'Cities', id: any, name: string, countrySubdivision: { __typename?: 'CountrySubdivisions', id: any, name: string, code: string } } | null }> };

export type UpdateEventContentsMutationVariables = Exact<{
  id: Scalars['uuid'];
  input: EventsSetInput;
}>;


export type UpdateEventContentsMutation = { __typename?: 'mutation_root', updateEventsByPk?: { __typename?: 'Events', id: any, title: string, hasPrizes: boolean, isSanctioned: boolean, privacy: EventPrivacyEnum, registrationDeadlineDate: any, registrationPriceUnitAmount: number, coverImageUrl?: string | null } | null };

export type UpdateFaqByIdMutationVariables = Exact<{
  id: Scalars['uuid'];
  input: EventFaqsSetInput;
}>;


export type UpdateFaqByIdMutation = { __typename?: 'mutation_root', updateEventFaqsByPk?: { __typename?: 'EventFaqs', id: any, answer: string, question: string } | null };

export type UpdateEventSponsorsByPkMutationVariables = Exact<{
  id: Scalars['uuid'];
  input: EventSponsorsSetInput;
}>;


export type UpdateEventSponsorsByPkMutation = { __typename?: 'mutation_root', updateEventSponsorsByPk?: { __typename?: 'EventSponsors', id: any, name: string, isTitleSponsor: boolean, categoryName: string, imageUrl: string } | null };

export type UpdateEventGroupsByPkMutationVariables = Exact<{
  id: Scalars['uuid'];
  input: EventGroupsSetInput;
}>;


export type UpdateEventGroupsByPkMutation = { __typename?: 'mutation_root', updateEventGroupsByPk?: { __typename?: 'EventGroups', id: any, title: string, format: EventGroupFormatsEnum, formatCustomName: string, gamesPerMatch: number, gender: CompetitionGenderEnum, maximumAge?: number | null, minimumAge?: number | null, maximumRating?: any | null, minimumRating?: any | null, minimumNumberOfGames: number, priceUnitAmount: number, teamLimit: number, scoringFormat: ScoringFormatEnum, startsAt?: any | null, endsAt?: any | null } | null };

export type GetPlaySessionFeedQueryVariables = Exact<{
  startDateTime: Scalars['timestamptz'];
  groupId: Scalars['uuid'];
  userId: Scalars['uuid'];
}>;


export type GetPlaySessionFeedQuery = { __typename?: 'query_root', playSessions: Array<{ __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, commentsAggregate: { __typename?: 'PlaySessionCommentsAggregate', aggregate?: { __typename?: 'PlaySessionCommentsAggregateFields', count: number } | null }, currentUserAsParticipant: Array<{ __typename?: 'PlaySessionParticipants', id: any, status: PlaySessionParticipantStatusesEnum }>, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null }> };

export type GetActiveJoinedPlaySessionsQueryVariables = Exact<{
  userId: Scalars['uuid'];
  startDateTime: Scalars['timestamptz'];
}>;


export type GetActiveJoinedPlaySessionsQuery = { __typename?: 'query_root', playSessionParticipants: Array<{ __typename?: 'PlaySessionParticipants', playSession: { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, commentsAggregate: { __typename?: 'PlaySessionCommentsAggregate', aggregate?: { __typename?: 'PlaySessionCommentsAggregateFields', count: number } | null }, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null } }> };

export type GetUserCustomCourtsQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetUserCustomCourtsQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', id: any, customCourts: Array<{ __typename?: 'UserCustomCourts', createdAt: any, deletedAt?: any | null, fullAddress: string, id: any, title: string }> } | null };

export type InsertNewPlaySessionMutationVariables = Exact<{
  competitiveness: PlaySessionMatchCompetitivenessEnum;
  courtBookingStatus: PlaySessionCourtBookingStatusesEnum;
  description?: InputMaybe<Scalars['String']>;
  endDateTime: Scalars['timestamptz'];
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format: PlaySessionFormatsEnum;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale: Scalars['String'];
  organizerUserId: Scalars['uuid'];
  participantLimit?: InputMaybe<Scalars['Int']>;
  sport: SportsEnum;
  startDateTime: Scalars['timestamptz'];
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title?: InputMaybe<Scalars['String']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
  commentData?: InputMaybe<Array<PlaySessionCommentsInsertInput> | PlaySessionCommentsInsertInput>;
  data?: InputMaybe<Array<GroupsPlaySessionsInsertInput> | GroupsPlaySessionsInsertInput>;
}>;


export type InsertNewPlaySessionMutation = { __typename?: 'mutation_root', insertPlaySessionsOne?: { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null } | null };

export type UpdateNewPlaySessionByIdMutationVariables = Exact<{
  playSessionId: Scalars['uuid'];
  competitiveness: PlaySessionMatchCompetitivenessEnum;
  courtBookingStatus: PlaySessionCourtBookingStatusesEnum;
  description?: InputMaybe<Scalars['String']>;
  endDateTime: Scalars['timestamptz'];
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format: PlaySessionFormatsEnum;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  sport: SportsEnum;
  startDateTime: Scalars['timestamptz'];
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  venueId?: InputMaybe<Scalars['uuid']>;
  commentObjects?: InputMaybe<Array<PlaySessionCommentsInsertInput> | PlaySessionCommentsInsertInput>;
}>;


export type UpdateNewPlaySessionByIdMutation = { __typename?: 'mutation_root', updatePlaySessionComments?: { __typename?: 'PlaySessionCommentsMutationResponse', affectedRows: number } | null, updatePlaySessionsByPk?: { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null } | null, insertPlaySessionComments?: { __typename?: 'PlaySessionCommentsMutationResponse', affectedRows: number } | null };

export type UpdateExistingPlaySessionByIdMutationVariables = Exact<{
  playSessionId: Scalars['uuid'];
  title: Scalars['String'];
  description: Scalars['String'];
  sport: SportsEnum;
  format: PlaySessionFormatsEnum;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  courtBookingStatus: PlaySessionCourtBookingStatusesEnum;
  competitiveness: PlaySessionMatchCompetitivenessEnum;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  startDateTime: Scalars['timestamptz'];
  endDateTime: Scalars['timestamptz'];
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
}>;


export type UpdateExistingPlaySessionByIdMutation = { __typename?: 'mutation_root', updatePlaySessionsByPk?: { __typename?: 'PlaySessions', cancelReason: string, canceledAt?: any | null, deletedAt?: any | null, competitiveness?: PlaySessionMatchCompetitivenessEnum | null, courtBookingStatus: PlaySessionCourtBookingStatusesEnum, createdAt: any, currency: string, description: string, endDateTime?: any | null, extraRacketCount?: number | null, format: PlaySessionFormatsEnum, groupId?: any | null, id: any, isBringingNet: boolean, participantLimit?: number | null, sport: SportsEnum, startDateTime?: any | null, status: PlaySessionStatusesEnum, targetSkillLevel?: string | null, title: string, userCustomCourtId?: any | null, locale: string, timezoneOffsetMinutes: number, timezoneName: string, timezoneAbbreviation: string, publishedAt?: any | null, priceUnitAmount: number, updatedAt: any, organizerUserId?: any | null, privacy: PlaySessionPrivacyEnum, skillRatingMaximum?: any | null, skillRatingMinimum?: any | null, organizerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'PlaySessionParticipantsAggregate', aggregate?: { __typename?: 'PlaySessionParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'PlaySessionParticipants', id: any, playSessionId: any, userId: any, status: PlaySessionParticipantStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, tennisRatingScale?: { __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string } | null, venue?: { __typename?: 'Venues', id: any, title: string, addressString: string, latitude: any, longitude: any, images: Array<{ __typename?: 'VenueImages', id: any, providerUrl: string, path: string, url: string }> } | null } | null };

export type SetPlaySessionAsActiveMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SetPlaySessionAsActiveMutation = { __typename?: 'mutation_root', updatePlaySessionsByPk?: { __typename?: 'PlaySessions', id: any, status: PlaySessionStatusesEnum, publishedAt?: any | null } | null };

export type UpdateCoachProfileMutationVariables = Exact<{
  id: Scalars['uuid'];
  fullName?: InputMaybe<Scalars['String']>;
  aboutMe?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  existingCoachServices?: InputMaybe<Array<UserCoachServicesUpdates> | UserCoachServicesUpdates>;
  newCoachServices?: InputMaybe<Array<UserCoachServicesInsertInput> | UserCoachServicesInsertInput>;
  qualificationObjects?: InputMaybe<Array<UsersCoachQualificationsInsertInput> | UsersCoachQualificationsInsertInput>;
}>;


export type UpdateCoachProfileMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, fullName: string, preferredName: string, username?: string | null, aboutMe: string, countryId?: string | null, countrySubdivisionId?: any | null, cityName: string, profile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, aboutMe?: string | null, username?: string | null, countryId?: string | null, countrySubdivisionId?: any | null, cityName?: string | null } | null } | null, updateUserCoachServicesMany?: Array<{ __typename?: 'UserCoachServicesMutationResponse', returning: Array<{ __typename?: 'UserCoachServices', coverImageUrl: string, currency: string, description: string, id: any, priceUnitAmount: number, title: string, type?: LessonTypesEnum | null, userId: any }> } | null> | null, insertUserCoachServices?: { __typename?: 'UserCoachServicesMutationResponse', returning: Array<{ __typename?: 'UserCoachServices', coverImageUrl: string, currency: string, description: string, id: any, priceUnitAmount: number, title: string, type?: LessonTypesEnum | null, userId: any }> } | null, insertUsersCoachQualifications?: { __typename?: 'UsersCoachQualificationsMutationResponse', returning: Array<{ __typename?: 'UsersCoachQualifications', id: any, status: CoachQualificationStatusesEnum, coachQualificationId: any, userId: any }> } | null };

export type UpdatePlayerProfileMutationVariables = Exact<{
  id: Scalars['uuid'];
  fullName?: InputMaybe<Scalars['String']>;
  aboutMe?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
}>;


export type UpdatePlayerProfileMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, fullName: string, preferredName: string, username?: string | null, aboutMe: string, countryId?: string | null, countrySubdivisionId?: any | null, cityName: string, normalizedTennisRating?: any | null, normalizedTennisRatingScaleId?: any | null, tennisRating?: any | null, tennisRatingScaleId?: any | null, profile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, aboutMe?: string | null, username?: string | null, countryId?: string | null, countrySubdivisionId?: any | null, cityName?: string | null, normalizedTennisRating?: any | null, normalizedTennisRatingScaleId?: any | null, tennisRating?: any | null, tennisRatingScaleId?: any | null } | null } | null };

export type GetCountriesAndActiveSubdivisionsQueryVariables = Exact<{
  countryId: Scalars['String'];
}>;


export type GetCountriesAndActiveSubdivisionsQuery = { __typename?: 'query_root', countries: Array<{ __typename?: 'Countries', id: string, name: string, slug: string }>, countrySubdivisions: Array<{ __typename?: 'CountrySubdivisions', id: any, name: string, type: string }> };

export type GetAvailableCoachQualificationsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAvailableCoachQualificationsQuery = { __typename?: 'query_root', coachQualifications: Array<{ __typename?: 'CoachQualifications', id: any, name: string, order: number, groupId?: CoachQualificationGroupsEnum | null, displayKey: string }> };

export type GetTennisRatingScalesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTennisRatingScalesQuery = { __typename?: 'query_root', tennisRatingScales: Array<{ __typename?: 'TennisRatingScales', id: any, maximum: any, minimum: any, name: string, order: number, shortName: string }> };

export type GetCoachEarningsUnitAmountQueryVariables = Exact<{
  sellerUserId: Scalars['uuid'];
}>;


export type GetCoachEarningsUnitAmountQuery = { __typename?: 'query_root', lessonOrdersAggregate: { __typename?: 'LessonOrdersAggregate', aggregate?: { __typename?: 'LessonOrdersAggregateFields', sum?: { __typename?: 'LessonOrdersSumFields', transferUnitAmount?: number | null } | null } | null } };

export type GetEventDetailsQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetEventDetailsQuery = { __typename?: 'query_root', eventsByPk?: { __typename?: 'Events', addressString?: string | null, cityId?: any | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageUrl?: string | null, currency: string, longitude?: any | null, latitude?: any | null, createdAt: any, description: string, displayLocation: string, endDate: any, endDateTime: any, externalUrl?: string | null, geometry?: any | null, hasPrizes: boolean, id: any, isExternal: boolean, organizerImageUrl?: string | null, organizerImagePath?: string | null, locale: string, isSanctioned: boolean, privacy: EventPrivacyEnum, prizeDescription: string, publishedAt?: any | null, registrationClosedAt?: any | null, registrationDeadlineDate: any, registrationDeadlineDateTime?: any | null, registrationPriceUnitAmount: number, registrationOpenDate?: any | null, registrationOpenDateTime?: any | null, isRatingRequired: boolean, slug: string, scoringFormat: ScoringFormatEnum, sport: SportsEnum, startDate: any, startDateTime: any, status: EventStatusesEnum, title: string, type: EventTypesEnum, timezoneName: string, timezoneOffsetMinutes: number, timezoneAbbreviation: string, sourceRegistrationCount: number, sourceOrganizerTitle?: string | null, groupFormat?: EventGroupFormatsEnum | null, ballCustomName: string, ballType: BallTypesEnum, city?: { __typename?: 'Cities', id: any, name: string, slug: string, countrySubdivision: { __typename?: 'CountrySubdivisions', id: any, name: string, slug: string, code: string, country: { __typename?: 'Countries', id: string, name: string, slug: string } } } | null, venue?: { __typename?: 'Venues', id: any, title: string, slug: string, pickleballLines?: VenueLinesEnum | null, pickleballNets?: VenueNetsEnum | null, longitude: any, latitude: any, geometry?: any | null, addressString: string, outdoorCourtCount: number, indoorCourtCount: number, timezone: string, images: Array<{ __typename?: 'VenueImages', id: any, path: string, url: string }>, courtSurfaces: Array<{ __typename?: 'VenueCourtSurfaces', id: any, courtSurface: CourtSurfacesEnum }> } | null, pickleballRatingScale?: { __typename?: 'PickleballRatingScales', id: any, maximum: any, minimum: any, name: string, shortName: string } | null, hostUserProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, preferredName?: string | null, profileImageFileName?: string | null, profileImageProvider?: string | null } | null, faqs: Array<{ __typename?: 'EventFaqs', id: any, question: string, answer: string }>, registrations: Array<{ __typename?: 'EventRegistrations', id: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, username?: string | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProvider?: string | null, profileImageProviderUrl?: string | null } | null }>, groups: Array<{ __typename?: 'EventGroups', id: any, gender: CompetitionGenderEnum, gamesPerMatch: number, formatCustomName: string, format: EventGroupFormatsEnum, endsAt?: any | null, maximumAge?: number | null, maximumRating?: any | null, minimumNumberOfGames: number, minimumAge?: number | null, minimumRating?: any | null, priceUnitAmount: number, scoringFormat: ScoringFormatEnum, startsAt?: any | null, teamLimit: number, teamType: TeamTypesEnum, title: string, totalPoints: number, winBy?: number | null, teams: Array<{ __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', id: any, userId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProvider?: string | null, profileImageProviderUrl?: string | null } | null }> }>, registrations: Array<{ __typename?: 'EventGroupRegistrations', id: any, userId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProvider?: string | null, profileImageProviderUrl?: string | null } | null }> }> } | null };

export type GetUserEventRegistrationQueryVariables = Exact<{
  eventId: Scalars['uuid'];
  userId: Scalars['uuid'];
}>;


export type GetUserEventRegistrationQuery = { __typename?: 'query_root', eventRegistrations: Array<{ __typename?: 'EventRegistrations', id: any }>, eventGroupRegistrations: Array<{ __typename?: 'EventGroupRegistrations', id: any, status: EventGroupRegistrationStatusesEnum, group: { __typename?: 'EventGroups', id: any, title: string, format: EventGroupFormatsEnum, formatCustomName: string, maximumAge?: number | null, maximumRating?: any | null, minimumAge?: number | null, minimumNumberOfGames: number, minimumRating?: any | null, teamType: TeamTypesEnum, teams: Array<{ __typename?: 'EventTeams', id: any, members: Array<{ __typename?: 'EventTeamMembers', userId: any, id: any, status: EventTeamMemberStatusesEnum, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProvider?: string | null, profileImageProviderUrl?: string | null } | null }> }> }, invitations: Array<{ __typename?: 'EventInvitations', id: any, invitationEmail: string, status: EventInvitationStatusesEnum }> }> };

export type GetEventTeamInvitationByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetEventTeamInvitationByIdQuery = { __typename?: 'query_root', eventTeamsByPk?: { __typename?: 'EventTeams', id: any, groupId: any, group: { __typename?: 'EventGroups', id: any }, members: Array<{ __typename?: 'EventTeamMembers', id: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, fullName?: string | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProvider?: string | null, profileImageProviderUrl?: string | null } | null }> } | null };

export type GetActiveLessonsFromFollowedCoachesQueryVariables = Exact<{
  followerUserId: Scalars['uuid'];
}>;


export type GetActiveLessonsFromFollowedCoachesQuery = { __typename?: 'query_root', userFollows: Array<{ __typename?: 'UserFollows', id: any, followedUserId: any, followerUserId: any, followedProfile?: { __typename?: 'UserProfiles', coachStatus?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null, fullName?: string | null, id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, username?: string | null, coachLessons: Array<{ __typename?: 'Lessons', cancelReason: string, canceledAt?: any | null, coverImageFileName: string, coverImagePath: string, coverImageProviderUrl: string, createdAt: any, currency: string, deletedAt?: any | null, description: string, endDateTime?: any | null, id: any, ownerUserId?: any | null, paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum, participantLimit?: number | null, priceUnitAmount: number, privacy: LessonPrivacyEnum, reminderEventId?: any | null, sport: SportsEnum, startDateTime?: any | null, status: LessonStatusesEnum, locale: string, timezoneName: string, timezoneAbbreviation: string, timezoneOffsetMinutes: number, title: string, type: LessonTypesEnum, typeCustom: string, updatedAt: any, publishedAt?: any | null, userCustomCourtId?: any | null, usedTemplateId?: any | null, ownerProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, fullName?: string | null, username?: string | null } | null, userCustomCourt?: { __typename?: 'UserCustomCourts', createdAt: any, fullAddress: string, id: any, title: string, updatedAt: any } | null, participantsAggregate: { __typename?: 'LessonParticipantsAggregate', aggregate?: { __typename?: 'LessonParticipantsAggregateFields', count: number } | null }, participants: Array<{ __typename?: 'LessonParticipants', id: any, userId: any, lessonId: any, userProfile?: { __typename?: 'UserProfiles', id?: any | null, preferredName?: string | null, fullName?: string | null, username?: string | null, profileImageFileName?: string | null, profileImagePath?: string | null, profileImageProviderUrl?: string | null, coverImageFileName?: string | null, coverImagePath?: string | null, coverImageProviderUrl?: string | null } | null }>, equipment: Array<{ __typename?: 'LessonEquipment', id: any, lessonId: any, equipmentOptionId: LessonEquipmentOptionsEnum }> }> } | null }> };

export const LessonFieldsFragmentDoc = gql`
    fragment lessonFields on Lessons {
  cancelReason
  canceledAt
  coverImageFileName
  coverImagePath
  coverImageProviderUrl
  createdAt
  currency
  deletedAt
  description
  endDateTime
  id
  ownerUserId
  paymentFulfillmentChannel
  participantLimit
  priceUnitAmount
  privacy
  reminderEventId
  sport
  startDateTime
  status
  locale
  timezoneName
  timezoneAbbreviation
  timezoneOffsetMinutes
  title
  type
  typeCustom
  updatedAt
  publishedAt
  userCustomCourtId
  usedTemplateId
  ownerProfile {
    id
    preferredName
    profileImageFileName
    profileImagePath
    profileImageProviderUrl
    fullName
    username
  }
  userCustomCourt {
    createdAt
    fullAddress
    id
    title
    updatedAt
  }
  participantsAggregate(where: {status: {_eq: ACTIVE}}) {
    aggregate {
      count
    }
  }
  participants(where: {status: {_eq: ACTIVE}}) {
    id
    userId
    lessonId
    userProfile {
      id
      preferredName
      fullName
      username
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      coverImageFileName
      coverImagePath
      coverImageProviderUrl
    }
  }
  equipment {
    id
    lessonId
    equipmentOptionId
  }
}
    `;
export const PlaySessionFieldsFragmentDoc = gql`
    fragment playSessionFields on PlaySessions {
  cancelReason
  canceledAt
  deletedAt
  competitiveness
  courtBookingStatus
  createdAt
  currency
  description
  endDateTime
  extraRacketCount
  format
  groupId
  id
  isBringingNet
  participantLimit
  sport
  startDateTime
  status
  targetSkillLevel
  title
  userCustomCourtId
  locale
  timezoneOffsetMinutes
  timezoneName
  timezoneAbbreviation
  publishedAt
  priceUnitAmount
  updatedAt
  organizerUserId
  privacy
  skillRatingMaximum
  skillRatingMinimum
  organizerProfile {
    id
    preferredName
    profileImageFileName
    profileImagePath
    profileImageProviderUrl
    fullName
    username
  }
  userCustomCourt {
    createdAt
    fullAddress
    id
    title
    updatedAt
  }
  participantsAggregate(where: {status: {_eq: ACTIVE}}) {
    aggregate {
      count
    }
  }
  participants {
    id
    playSessionId
    userId
    status
    userProfile {
      id
      preferredName
      fullName
      username
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      coverImageFileName
      coverImagePath
      coverImageProviderUrl
    }
  }
  tennisRatingScale {
    id
    maximum
    minimum
    name
    order
    shortName
  }
  pickleballRatingScale {
    id
    maximum
    minimum
    name
    order
    shortName
  }
  venue {
    id
    title
    addressString
    latitude
    longitude
    images(where: {isVisible: {_eq: true}}) {
      id
      providerUrl
      path
      url
    }
  }
}
    `;
export const UserProfileFieldsFragmentDoc = gql`
    fragment userProfileFields on UserProfiles {
  id
  username
  profileImageFileName
  profileImagePath
  profileImageProviderUrl
  preferredName
  fullName
  coachStatus
  coverImageFileName
  coverImagePath
  coverImageProviderUrl
  aboutMe
  aboutMeVideoUrl
  cityName
  gender
  country {
    id
    iso2
    iso3
    name
  }
  countrySubdivision {
    code
    id
    name
    type
  }
  coachExperienceYears
  coachExperienceSetAt
  coachLessonsAggregate(where: {status: {_eq: ACTIVE}}) {
    aggregate {
      count
    }
  }
  followersAggregate(where: {status: {_eq: ACTIVE}}) {
    aggregate {
      count
    }
  }
  followers(limit: 5, where: {status: {_eq: ACTIVE}}) {
    followerProfile {
      id
      username
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      fullName
      preferredName
    }
    followerUserId
    followedUserId
  }
  coachServices {
    currency
    description
    id
    title
    priceUnitAmount
    type
    coverImageFileName
    coverImagePath
    coverImageProviderUrl
  }
  coachQualifications(where: {status: {_eq: ACTIVE}}) {
    id
    status
    qualification {
      id
      name
      order
      groupId
      displayKey
    }
  }
  normalizedTennisRating
  normalizedTennisRatingScale {
    id
    name
    shortName
  }
  tennisRating
  tennisRatingScale {
    id
    name
    shortName
  }
  tennisSkillLevel {
    id
    isDisplayed
    rank
    displayName
  }
  pickleballSkillLevel {
    id
    isDisplayed
    rank
    displayName
  }
}
    `;
export const GetUserUnreadNotificationCountDocument = gql`
    query getUserUnreadNotificationCount($userId: uuid!) {
  userNotificationsAggregate(
    where: {userId: {_eq: $userId}, status: {_eq: UNREAD}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetUserUnreadNotificationCountQuery__
 *
 * To run a query within a React component, call `useGetUserUnreadNotificationCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserUnreadNotificationCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserUnreadNotificationCountQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserUnreadNotificationCountQuery(baseOptions: Apollo.QueryHookOptions<GetUserUnreadNotificationCountQuery, GetUserUnreadNotificationCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserUnreadNotificationCountQuery, GetUserUnreadNotificationCountQueryVariables>(GetUserUnreadNotificationCountDocument, options);
      }
export function useGetUserUnreadNotificationCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserUnreadNotificationCountQuery, GetUserUnreadNotificationCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserUnreadNotificationCountQuery, GetUserUnreadNotificationCountQueryVariables>(GetUserUnreadNotificationCountDocument, options);
        }
export type GetUserUnreadNotificationCountQueryHookResult = ReturnType<typeof useGetUserUnreadNotificationCountQuery>;
export type GetUserUnreadNotificationCountLazyQueryHookResult = ReturnType<typeof useGetUserUnreadNotificationCountLazyQuery>;
export type GetUserUnreadNotificationCountQueryResult = Apollo.QueryResult<GetUserUnreadNotificationCountQuery, GetUserUnreadNotificationCountQueryVariables>;
export const InsertUserGroupMembershipDocument = gql`
    mutation insertUserGroupMembership($groupId: uuid!, $userId: uuid!) {
  insertGroupMembersOne(
    object: {groupId: $groupId, userId: $userId, isActive: true}
  ) {
    id
  }
}
    `;
export type InsertUserGroupMembershipMutationFn = Apollo.MutationFunction<InsertUserGroupMembershipMutation, InsertUserGroupMembershipMutationVariables>;

/**
 * __useInsertUserGroupMembershipMutation__
 *
 * To run a mutation, you first call `useInsertUserGroupMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertUserGroupMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertUserGroupMembershipMutation, { data, loading, error }] = useInsertUserGroupMembershipMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertUserGroupMembershipMutation(baseOptions?: Apollo.MutationHookOptions<InsertUserGroupMembershipMutation, InsertUserGroupMembershipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertUserGroupMembershipMutation, InsertUserGroupMembershipMutationVariables>(InsertUserGroupMembershipDocument, options);
      }
export type InsertUserGroupMembershipMutationHookResult = ReturnType<typeof useInsertUserGroupMembershipMutation>;
export type InsertUserGroupMembershipMutationResult = Apollo.MutationResult<InsertUserGroupMembershipMutation>;
export type InsertUserGroupMembershipMutationOptions = Apollo.BaseMutationOptions<InsertUserGroupMembershipMutation, InsertUserGroupMembershipMutationVariables>;
export const GetClosestCitiesDocument = gql`
    query getClosestCities($distance: Float!, $from: geography!) {
  cities(where: {geometry: {_stDWithin: {distance: $distance, from: $from}}}) {
    id
    name
    geometry
    latitude
    longitude
  }
}
    `;

/**
 * __useGetClosestCitiesQuery__
 *
 * To run a query within a React component, call `useGetClosestCitiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetClosestCitiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetClosestCitiesQuery({
 *   variables: {
 *      distance: // value for 'distance'
 *      from: // value for 'from'
 *   },
 * });
 */
export function useGetClosestCitiesQuery(baseOptions: Apollo.QueryHookOptions<GetClosestCitiesQuery, GetClosestCitiesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetClosestCitiesQuery, GetClosestCitiesQueryVariables>(GetClosestCitiesDocument, options);
      }
export function useGetClosestCitiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetClosestCitiesQuery, GetClosestCitiesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetClosestCitiesQuery, GetClosestCitiesQueryVariables>(GetClosestCitiesDocument, options);
        }
export type GetClosestCitiesQueryHookResult = ReturnType<typeof useGetClosestCitiesQuery>;
export type GetClosestCitiesLazyQueryHookResult = ReturnType<typeof useGetClosestCitiesLazyQuery>;
export type GetClosestCitiesQueryResult = Apollo.QueryResult<GetClosestCitiesQuery, GetClosestCitiesQueryVariables>;
export const InsertUsagePingDocument = gql`
    mutation insertUsagePing($pathname: String = "", $userId: uuid, $firebaseId: String, $queryString: String = "", $platform: String = "", $ip: String = "", $timezone: String = "", $country: String = "", $region: String = "", $city: String = "", $zip: String = "", $ipResponse: jsonb) {
  insertAppPingsOne(
    object: {pathname: $pathname, userId: $userId, firebaseId: $firebaseId, queryString: $queryString, platform: $platform, ip: $ip, timezone: $timezone, country: $country, region: $region, city: $city, zip: $zip, ipResponse: $ipResponse}
  ) {
    id
  }
}
    `;
export type InsertUsagePingMutationFn = Apollo.MutationFunction<InsertUsagePingMutation, InsertUsagePingMutationVariables>;

/**
 * __useInsertUsagePingMutation__
 *
 * To run a mutation, you first call `useInsertUsagePingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertUsagePingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertUsagePingMutation, { data, loading, error }] = useInsertUsagePingMutation({
 *   variables: {
 *      pathname: // value for 'pathname'
 *      userId: // value for 'userId'
 *      firebaseId: // value for 'firebaseId'
 *      queryString: // value for 'queryString'
 *      platform: // value for 'platform'
 *      ip: // value for 'ip'
 *      timezone: // value for 'timezone'
 *      country: // value for 'country'
 *      region: // value for 'region'
 *      city: // value for 'city'
 *      zip: // value for 'zip'
 *      ipResponse: // value for 'ipResponse'
 *   },
 * });
 */
export function useInsertUsagePingMutation(baseOptions?: Apollo.MutationHookOptions<InsertUsagePingMutation, InsertUsagePingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertUsagePingMutation, InsertUsagePingMutationVariables>(InsertUsagePingDocument, options);
      }
export type InsertUsagePingMutationHookResult = ReturnType<typeof useInsertUsagePingMutation>;
export type InsertUsagePingMutationResult = Apollo.MutationResult<InsertUsagePingMutation>;
export type InsertUsagePingMutationOptions = Apollo.BaseMutationOptions<InsertUsagePingMutation, InsertUsagePingMutationVariables>;
export const InsertPlaySessionCommentDocument = gql`
    mutation insertPlaySessionComment($content: String!, $playSessionId: uuid!, $playSessionCommentId: uuid = null, $playSessionRootCommentId: uuid = null, $userId: uuid!) {
  insertPlaySessionCommentsOne(
    object: {content: $content, playSessionId: $playSessionId, playSessionCommentId: $playSessionCommentId, playSessionRootCommentId: $playSessionRootCommentId, userId: $userId}
  ) {
    content
    id
    createdAt
    deletedAt
    playSessionCommentId
    playSessionId
    playSessionRootCommentId
    updatedAt
    userId
  }
}
    `;
export type InsertPlaySessionCommentMutationFn = Apollo.MutationFunction<InsertPlaySessionCommentMutation, InsertPlaySessionCommentMutationVariables>;

/**
 * __useInsertPlaySessionCommentMutation__
 *
 * To run a mutation, you first call `useInsertPlaySessionCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertPlaySessionCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertPlaySessionCommentMutation, { data, loading, error }] = useInsertPlaySessionCommentMutation({
 *   variables: {
 *      content: // value for 'content'
 *      playSessionId: // value for 'playSessionId'
 *      playSessionCommentId: // value for 'playSessionCommentId'
 *      playSessionRootCommentId: // value for 'playSessionRootCommentId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertPlaySessionCommentMutation(baseOptions?: Apollo.MutationHookOptions<InsertPlaySessionCommentMutation, InsertPlaySessionCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertPlaySessionCommentMutation, InsertPlaySessionCommentMutationVariables>(InsertPlaySessionCommentDocument, options);
      }
export type InsertPlaySessionCommentMutationHookResult = ReturnType<typeof useInsertPlaySessionCommentMutation>;
export type InsertPlaySessionCommentMutationResult = Apollo.MutationResult<InsertPlaySessionCommentMutation>;
export type InsertPlaySessionCommentMutationOptions = Apollo.BaseMutationOptions<InsertPlaySessionCommentMutation, InsertPlaySessionCommentMutationVariables>;
export const UpdateFollowerInactiveDocument = gql`
    mutation updateFollowerInactive($followedUserId: uuid!, $followerUserId: uuid!) {
  updateUserFollows(
    where: {followedUserId: {_eq: $followedUserId}, followerUserId: {_eq: $followerUserId}}
    _set: {status: INACTIVE}
  ) {
    returning {
      followerUserId
      followedUserId
      status
    }
  }
}
    `;
export type UpdateFollowerInactiveMutationFn = Apollo.MutationFunction<UpdateFollowerInactiveMutation, UpdateFollowerInactiveMutationVariables>;

/**
 * __useUpdateFollowerInactiveMutation__
 *
 * To run a mutation, you first call `useUpdateFollowerInactiveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFollowerInactiveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFollowerInactiveMutation, { data, loading, error }] = useUpdateFollowerInactiveMutation({
 *   variables: {
 *      followedUserId: // value for 'followedUserId'
 *      followerUserId: // value for 'followerUserId'
 *   },
 * });
 */
export function useUpdateFollowerInactiveMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFollowerInactiveMutation, UpdateFollowerInactiveMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFollowerInactiveMutation, UpdateFollowerInactiveMutationVariables>(UpdateFollowerInactiveDocument, options);
      }
export type UpdateFollowerInactiveMutationHookResult = ReturnType<typeof useUpdateFollowerInactiveMutation>;
export type UpdateFollowerInactiveMutationResult = Apollo.MutationResult<UpdateFollowerInactiveMutation>;
export type UpdateFollowerInactiveMutationOptions = Apollo.BaseMutationOptions<UpdateFollowerInactiveMutation, UpdateFollowerInactiveMutationVariables>;
export const UpdateUserCoverImageDocument = gql`
    mutation updateUserCoverImage($id: uuid!, $coverImageFileName: String!, $coverImagePath: String!, $coverImageProvider: String!, $coverImageProviderId: String!, $coverImageProviderUrl: String!) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {coverImageFileName: $coverImageFileName, coverImagePath: $coverImagePath, coverImageProvider: $coverImageProvider, coverImageProviderId: $coverImageProviderId, coverImageProviderUrl: $coverImageProviderUrl}
  ) {
    id
    coverImageFileName
    coverImagePath
    coverImageProvider
    coverImageProviderId
    coverImageProviderUrl
    profile {
      id
      coverImageFileName
      coverImagePath
      coverImageProvider
      coverImageProviderUrl
    }
  }
  insertUserImageLogOne(
    object: {fileName: $coverImageFileName, provider: $coverImageProvider, providerId: $coverImageProviderId, providerUrl: $coverImageProviderUrl, userId: $id, path: $coverImagePath}
  ) {
    id
  }
}
    `;
export type UpdateUserCoverImageMutationFn = Apollo.MutationFunction<UpdateUserCoverImageMutation, UpdateUserCoverImageMutationVariables>;

/**
 * __useUpdateUserCoverImageMutation__
 *
 * To run a mutation, you first call `useUpdateUserCoverImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserCoverImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserCoverImageMutation, { data, loading, error }] = useUpdateUserCoverImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      coverImageFileName: // value for 'coverImageFileName'
 *      coverImagePath: // value for 'coverImagePath'
 *      coverImageProvider: // value for 'coverImageProvider'
 *      coverImageProviderId: // value for 'coverImageProviderId'
 *      coverImageProviderUrl: // value for 'coverImageProviderUrl'
 *   },
 * });
 */
export function useUpdateUserCoverImageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserCoverImageMutation, UpdateUserCoverImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserCoverImageMutation, UpdateUserCoverImageMutationVariables>(UpdateUserCoverImageDocument, options);
      }
export type UpdateUserCoverImageMutationHookResult = ReturnType<typeof useUpdateUserCoverImageMutation>;
export type UpdateUserCoverImageMutationResult = Apollo.MutationResult<UpdateUserCoverImageMutation>;
export type UpdateUserCoverImageMutationOptions = Apollo.BaseMutationOptions<UpdateUserCoverImageMutation, UpdateUserCoverImageMutationVariables>;
export const UpdateUserDefaultSportDocument = gql`
    mutation updateUserDefaultSport($id: uuid!, $defaultSport: SportsEnum!) {
  updateUsersByPk(pkColumns: {id: $id}, _set: {defaultSport: $defaultSport}) {
    defaultSport
    id
  }
}
    `;
export type UpdateUserDefaultSportMutationFn = Apollo.MutationFunction<UpdateUserDefaultSportMutation, UpdateUserDefaultSportMutationVariables>;

/**
 * __useUpdateUserDefaultSportMutation__
 *
 * To run a mutation, you first call `useUpdateUserDefaultSportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserDefaultSportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserDefaultSportMutation, { data, loading, error }] = useUpdateUserDefaultSportMutation({
 *   variables: {
 *      id: // value for 'id'
 *      defaultSport: // value for 'defaultSport'
 *   },
 * });
 */
export function useUpdateUserDefaultSportMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserDefaultSportMutation, UpdateUserDefaultSportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserDefaultSportMutation, UpdateUserDefaultSportMutationVariables>(UpdateUserDefaultSportDocument, options);
      }
export type UpdateUserDefaultSportMutationHookResult = ReturnType<typeof useUpdateUserDefaultSportMutation>;
export type UpdateUserDefaultSportMutationResult = Apollo.MutationResult<UpdateUserDefaultSportMutation>;
export type UpdateUserDefaultSportMutationOptions = Apollo.BaseMutationOptions<UpdateUserDefaultSportMutation, UpdateUserDefaultSportMutationVariables>;
export const UpdateUserProfileImageDocument = gql`
    mutation updateUserProfileImage($id: uuid!, $profileImageFileName: String!, $profileImagePath: String!, $profileImageProvider: String!, $profileImageProviderId: String!, $profileImageProviderUrl: String!) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {profileImageFileName: $profileImageFileName, profileImagePath: $profileImagePath, profileImageProvider: $profileImageProvider, profileImageProviderId: $profileImageProviderId, profileImageProviderUrl: $profileImageProviderUrl}
  ) {
    id
    profileImageFileName
    profileImagePath
    profileImageProvider
    profileImageProviderId
    profileImageProviderUrl
    profile {
      id
      profileImageFileName
      profileImagePath
      profileImageProvider
      profileImageProviderUrl
    }
  }
  insertUserImageLogOne(
    object: {fileName: $profileImageFileName, provider: $profileImageProvider, providerId: $profileImageProviderId, providerUrl: $profileImageProviderUrl, userId: $id, path: $profileImagePath}
  ) {
    id
  }
}
    `;
export type UpdateUserProfileImageMutationFn = Apollo.MutationFunction<UpdateUserProfileImageMutation, UpdateUserProfileImageMutationVariables>;

/**
 * __useUpdateUserProfileImageMutation__
 *
 * To run a mutation, you first call `useUpdateUserProfileImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserProfileImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserProfileImageMutation, { data, loading, error }] = useUpdateUserProfileImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      profileImageFileName: // value for 'profileImageFileName'
 *      profileImagePath: // value for 'profileImagePath'
 *      profileImageProvider: // value for 'profileImageProvider'
 *      profileImageProviderId: // value for 'profileImageProviderId'
 *      profileImageProviderUrl: // value for 'profileImageProviderUrl'
 *   },
 * });
 */
export function useUpdateUserProfileImageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserProfileImageMutation, UpdateUserProfileImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserProfileImageMutation, UpdateUserProfileImageMutationVariables>(UpdateUserProfileImageDocument, options);
      }
export type UpdateUserProfileImageMutationHookResult = ReturnType<typeof useUpdateUserProfileImageMutation>;
export type UpdateUserProfileImageMutationResult = Apollo.MutationResult<UpdateUserProfileImageMutation>;
export type UpdateUserProfileImageMutationOptions = Apollo.BaseMutationOptions<UpdateUserProfileImageMutation, UpdateUserProfileImageMutationVariables>;
export const UpsertFollowerConnectionDocument = gql`
    mutation upsertFollowerConnection($followedUserId: uuid!, $followerUserId: uuid!, $status: FollowStatusesEnum!) {
  insertUserFollowsOne(
    object: {followedUserId: $followedUserId, followerUserId: $followerUserId, status: $status}
    onConflict: {constraint: user_follows_followed_user_id_follower_user_id_key, updateColumns: status}
  ) {
    followerUserId
    followedUserId
    status
  }
}
    `;
export type UpsertFollowerConnectionMutationFn = Apollo.MutationFunction<UpsertFollowerConnectionMutation, UpsertFollowerConnectionMutationVariables>;

/**
 * __useUpsertFollowerConnectionMutation__
 *
 * To run a mutation, you first call `useUpsertFollowerConnectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertFollowerConnectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertFollowerConnectionMutation, { data, loading, error }] = useUpsertFollowerConnectionMutation({
 *   variables: {
 *      followedUserId: // value for 'followedUserId'
 *      followerUserId: // value for 'followerUserId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useUpsertFollowerConnectionMutation(baseOptions?: Apollo.MutationHookOptions<UpsertFollowerConnectionMutation, UpsertFollowerConnectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertFollowerConnectionMutation, UpsertFollowerConnectionMutationVariables>(UpsertFollowerConnectionDocument, options);
      }
export type UpsertFollowerConnectionMutationHookResult = ReturnType<typeof useUpsertFollowerConnectionMutation>;
export type UpsertFollowerConnectionMutationResult = Apollo.MutationResult<UpsertFollowerConnectionMutation>;
export type UpsertFollowerConnectionMutationOptions = Apollo.BaseMutationOptions<UpsertFollowerConnectionMutation, UpsertFollowerConnectionMutationVariables>;
export const UpsertGroupThreadVoteDocument = gql`
    mutation upsertGroupThreadVote($groupThreadCommentId: uuid!, $userId: uuid!, $vote: CommentVoteEnum!) {
  insertGroupCommentVotesOne(
    object: {groupThreadCommentId: $groupThreadCommentId, userId: $userId, vote: $vote}
    onConflict: {constraint: group_comment_votes_group_thread_comment_id_user_id_key, updateColumns: vote}
  ) {
    id
    userId
    groupThreadCommentId
    vote
  }
}
    `;
export type UpsertGroupThreadVoteMutationFn = Apollo.MutationFunction<UpsertGroupThreadVoteMutation, UpsertGroupThreadVoteMutationVariables>;

/**
 * __useUpsertGroupThreadVoteMutation__
 *
 * To run a mutation, you first call `useUpsertGroupThreadVoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertGroupThreadVoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertGroupThreadVoteMutation, { data, loading, error }] = useUpsertGroupThreadVoteMutation({
 *   variables: {
 *      groupThreadCommentId: // value for 'groupThreadCommentId'
 *      userId: // value for 'userId'
 *      vote: // value for 'vote'
 *   },
 * });
 */
export function useUpsertGroupThreadVoteMutation(baseOptions?: Apollo.MutationHookOptions<UpsertGroupThreadVoteMutation, UpsertGroupThreadVoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertGroupThreadVoteMutation, UpsertGroupThreadVoteMutationVariables>(UpsertGroupThreadVoteDocument, options);
      }
export type UpsertGroupThreadVoteMutationHookResult = ReturnType<typeof useUpsertGroupThreadVoteMutation>;
export type UpsertGroupThreadVoteMutationResult = Apollo.MutationResult<UpsertGroupThreadVoteMutation>;
export type UpsertGroupThreadVoteMutationOptions = Apollo.BaseMutationOptions<UpsertGroupThreadVoteMutation, UpsertGroupThreadVoteMutationVariables>;
export const GetActiveCoachProfilesDocument = gql`
    query getActiveCoachProfiles {
  userProfiles(where: {coachStatus: {_eq: "ACTIVE"}}, orderBy: {updatedAt: DESC}) {
    coachStatus
    coverImageFileName
    coverImagePath
    coverImageProviderUrl
    fullName
    gender
    genderPreference
    id
    preferredName
    profileImageFileName
    profileImagePath
    profileImageProviderUrl
    username
  }
}
    `;

/**
 * __useGetActiveCoachProfilesQuery__
 *
 * To run a query within a React component, call `useGetActiveCoachProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActiveCoachProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActiveCoachProfilesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetActiveCoachProfilesQuery(baseOptions?: Apollo.QueryHookOptions<GetActiveCoachProfilesQuery, GetActiveCoachProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActiveCoachProfilesQuery, GetActiveCoachProfilesQueryVariables>(GetActiveCoachProfilesDocument, options);
      }
export function useGetActiveCoachProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActiveCoachProfilesQuery, GetActiveCoachProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActiveCoachProfilesQuery, GetActiveCoachProfilesQueryVariables>(GetActiveCoachProfilesDocument, options);
        }
export type GetActiveCoachProfilesQueryHookResult = ReturnType<typeof useGetActiveCoachProfilesQuery>;
export type GetActiveCoachProfilesLazyQueryHookResult = ReturnType<typeof useGetActiveCoachProfilesLazyQuery>;
export type GetActiveCoachProfilesQueryResult = Apollo.QueryResult<GetActiveCoachProfilesQuery, GetActiveCoachProfilesQueryVariables>;
export const GetActiveOwnerLessonsByIdDocument = gql`
    query getActiveOwnerLessonsById($ownerUserId: uuid!) {
  lessons(where: {ownerUserId: {_eq: $ownerUserId}, status: {_eq: ACTIVE}}) {
    ...lessonFields
  }
}
    ${LessonFieldsFragmentDoc}`;

/**
 * __useGetActiveOwnerLessonsByIdQuery__
 *
 * To run a query within a React component, call `useGetActiveOwnerLessonsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActiveOwnerLessonsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActiveOwnerLessonsByIdQuery({
 *   variables: {
 *      ownerUserId: // value for 'ownerUserId'
 *   },
 * });
 */
export function useGetActiveOwnerLessonsByIdQuery(baseOptions: Apollo.QueryHookOptions<GetActiveOwnerLessonsByIdQuery, GetActiveOwnerLessonsByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActiveOwnerLessonsByIdQuery, GetActiveOwnerLessonsByIdQueryVariables>(GetActiveOwnerLessonsByIdDocument, options);
      }
export function useGetActiveOwnerLessonsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActiveOwnerLessonsByIdQuery, GetActiveOwnerLessonsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActiveOwnerLessonsByIdQuery, GetActiveOwnerLessonsByIdQueryVariables>(GetActiveOwnerLessonsByIdDocument, options);
        }
export type GetActiveOwnerLessonsByIdQueryHookResult = ReturnType<typeof useGetActiveOwnerLessonsByIdQuery>;
export type GetActiveOwnerLessonsByIdLazyQueryHookResult = ReturnType<typeof useGetActiveOwnerLessonsByIdLazyQuery>;
export type GetActiveOwnerLessonsByIdQueryResult = Apollo.QueryResult<GetActiveOwnerLessonsByIdQuery, GetActiveOwnerLessonsByIdQueryVariables>;
export const GetAllActiveLessonsDocument = gql`
    query getAllActiveLessons {
  lessons(where: {status: {_eq: ACTIVE}}) {
    id
    title
    startDateTime
    endDateTime
    description
    coverImageFileName
    coverImagePath
    coverImageProviderUrl
    currency
    participantLimit
    priceUnitAmount
    privacy
    status
    type
    typeCustom
    userCustomCourt {
      id
      title
      fullAddress
    }
    ownerProfile {
      id
      fullName
      preferredName
      coverImageFileName
      coverImagePath
      coverImageProviderUrl
      coachStatus
      gender
      genderPreference
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      username
    }
  }
}
    `;

/**
 * __useGetAllActiveLessonsQuery__
 *
 * To run a query within a React component, call `useGetAllActiveLessonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllActiveLessonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllActiveLessonsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllActiveLessonsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllActiveLessonsQuery, GetAllActiveLessonsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllActiveLessonsQuery, GetAllActiveLessonsQueryVariables>(GetAllActiveLessonsDocument, options);
      }
export function useGetAllActiveLessonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllActiveLessonsQuery, GetAllActiveLessonsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllActiveLessonsQuery, GetAllActiveLessonsQueryVariables>(GetAllActiveLessonsDocument, options);
        }
export type GetAllActiveLessonsQueryHookResult = ReturnType<typeof useGetAllActiveLessonsQuery>;
export type GetAllActiveLessonsLazyQueryHookResult = ReturnType<typeof useGetAllActiveLessonsLazyQuery>;
export type GetAllActiveLessonsQueryResult = Apollo.QueryResult<GetAllActiveLessonsQuery, GetAllActiveLessonsQueryVariables>;
export const GetCurrentUserDocument = gql`
    query getCurrentUser($id: uuid!) {
  usersByPk(id: $id) {
    id
    coachStatus
    email
    firebaseId
    fullName
    preferredName
    birthday
    duprId
    gender
    genderPreference
    stripeCustomerId
    stripeMerchantChargesEnabled
    stripeMerchantDetailsSubmitted
    stripeMerchantId
    stripeMerchantPayoutsEnabled
    username
    profileImageFileName
    profileImagePath
    profileImageProviderUrl
    coverImageFileName
    coverImagePath
    coverImageProviderUrl
    defaultCreditCardId
    tennisRatingScaleId
    tennisRating
    defaultSport
    defaultCoachPaymentFulfillmentChannel
    tennisSkillLevel {
      id
      isDisplayed
      rank
      displayName
    }
    pickleballSkillLevel {
      id
      isDisplayed
      rank
      displayName
    }
    groups(where: {isActive: {_eq: true}}) {
      id
      isActive
      groupId
      group {
        id
        primarySport
      }
    }
    followingCoachesAggregate: followingAggregate(
      where: {followedProfile: {coachStatus: {_eq: "ACTIVE"}}}
    ) {
      aggregate {
        count
      }
    }
  }
}
    `;

/**
 * __useGetCurrentUserQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetCurrentUserQuery(baseOptions: Apollo.QueryHookOptions<GetCurrentUserQuery, GetCurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>(GetCurrentUserDocument, options);
      }
export function useGetCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserQuery, GetCurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>(GetCurrentUserDocument, options);
        }
export type GetCurrentUserQueryHookResult = ReturnType<typeof useGetCurrentUserQuery>;
export type GetCurrentUserLazyQueryHookResult = ReturnType<typeof useGetCurrentUserLazyQuery>;
export type GetCurrentUserQueryResult = Apollo.QueryResult<GetCurrentUserQuery, GetCurrentUserQueryVariables>;
export const GetGroupByAccessCodeDocument = gql`
    query getGroupByAccessCode($accessCode: String!) {
  groups(where: {accessCode: {_eq: $accessCode}}) {
    id
    accessCode
    headline
    title
    city {
      id
      name
    }
    ownerUserProfile {
      fullName
      id
    }
  }
}
    `;

/**
 * __useGetGroupByAccessCodeQuery__
 *
 * To run a query within a React component, call `useGetGroupByAccessCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGroupByAccessCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGroupByAccessCodeQuery({
 *   variables: {
 *      accessCode: // value for 'accessCode'
 *   },
 * });
 */
export function useGetGroupByAccessCodeQuery(baseOptions: Apollo.QueryHookOptions<GetGroupByAccessCodeQuery, GetGroupByAccessCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGroupByAccessCodeQuery, GetGroupByAccessCodeQueryVariables>(GetGroupByAccessCodeDocument, options);
      }
export function useGetGroupByAccessCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGroupByAccessCodeQuery, GetGroupByAccessCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGroupByAccessCodeQuery, GetGroupByAccessCodeQueryVariables>(GetGroupByAccessCodeDocument, options);
        }
export type GetGroupByAccessCodeQueryHookResult = ReturnType<typeof useGetGroupByAccessCodeQuery>;
export type GetGroupByAccessCodeLazyQueryHookResult = ReturnType<typeof useGetGroupByAccessCodeLazyQuery>;
export type GetGroupByAccessCodeQueryResult = Apollo.QueryResult<GetGroupByAccessCodeQuery, GetGroupByAccessCodeQueryVariables>;
export const GetGroupVenuesDocument = gql`
    query getGroupVenues($groupId: uuid!) {
  groupVenues(where: {groupId: {_eq: $groupId}}) {
    id
    venue {
      id
      createdAt
      title
      slug
      outdoorCourtCount
      indoorCourtCount
      isActive
      accessType
      addressString
      totalCourtCount
      facilityType
      pickleballNets
      images {
        providerUrl
        id
        url
      }
      courtSurfaces {
        id
        courtSurface
      }
    }
  }
}
    `;

/**
 * __useGetGroupVenuesQuery__
 *
 * To run a query within a React component, call `useGetGroupVenuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGroupVenuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGroupVenuesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetGroupVenuesQuery(baseOptions: Apollo.QueryHookOptions<GetGroupVenuesQuery, GetGroupVenuesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGroupVenuesQuery, GetGroupVenuesQueryVariables>(GetGroupVenuesDocument, options);
      }
export function useGetGroupVenuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGroupVenuesQuery, GetGroupVenuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGroupVenuesQuery, GetGroupVenuesQueryVariables>(GetGroupVenuesDocument, options);
        }
export type GetGroupVenuesQueryHookResult = ReturnType<typeof useGetGroupVenuesQuery>;
export type GetGroupVenuesLazyQueryHookResult = ReturnType<typeof useGetGroupVenuesLazyQuery>;
export type GetGroupVenuesQueryResult = Apollo.QueryResult<GetGroupVenuesQuery, GetGroupVenuesQueryVariables>;
export const GetLessonByIdDocument = gql`
    query getLessonById($id: uuid!) {
  lessonsByPk(id: $id) {
    ...lessonFields
  }
}
    ${LessonFieldsFragmentDoc}`;

/**
 * __useGetLessonByIdQuery__
 *
 * To run a query within a React component, call `useGetLessonByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLessonByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLessonByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetLessonByIdQuery(baseOptions: Apollo.QueryHookOptions<GetLessonByIdQuery, GetLessonByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLessonByIdQuery, GetLessonByIdQueryVariables>(GetLessonByIdDocument, options);
      }
export function useGetLessonByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLessonByIdQuery, GetLessonByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLessonByIdQuery, GetLessonByIdQueryVariables>(GetLessonByIdDocument, options);
        }
export type GetLessonByIdQueryHookResult = ReturnType<typeof useGetLessonByIdQuery>;
export type GetLessonByIdLazyQueryHookResult = ReturnType<typeof useGetLessonByIdLazyQuery>;
export type GetLessonByIdQueryResult = Apollo.QueryResult<GetLessonByIdQuery, GetLessonByIdQueryVariables>;
export const GetPlaySessionByIdDocument = gql`
    query getPlaySessionById($id: uuid!) {
  playSessionsByPk(id: $id) {
    ...playSessionFields
  }
}
    ${PlaySessionFieldsFragmentDoc}`;

/**
 * __useGetPlaySessionByIdQuery__
 *
 * To run a query within a React component, call `useGetPlaySessionByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlaySessionByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlaySessionByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPlaySessionByIdQuery(baseOptions: Apollo.QueryHookOptions<GetPlaySessionByIdQuery, GetPlaySessionByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlaySessionByIdQuery, GetPlaySessionByIdQueryVariables>(GetPlaySessionByIdDocument, options);
      }
export function useGetPlaySessionByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlaySessionByIdQuery, GetPlaySessionByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlaySessionByIdQuery, GetPlaySessionByIdQueryVariables>(GetPlaySessionByIdDocument, options);
        }
export type GetPlaySessionByIdQueryHookResult = ReturnType<typeof useGetPlaySessionByIdQuery>;
export type GetPlaySessionByIdLazyQueryHookResult = ReturnType<typeof useGetPlaySessionByIdLazyQuery>;
export type GetPlaySessionByIdQueryResult = Apollo.QueryResult<GetPlaySessionByIdQuery, GetPlaySessionByIdQueryVariables>;
export const GetPlaySessionCommentsDocument = gql`
    query getPlaySessionComments($playSessionId: uuid!) {
  playSessionComments(
    orderBy: {createdAt: ASC}
    where: {playSessionId: {_eq: $playSessionId}}
  ) {
    id
    createdAt
    content
    playSessionCommentId
    playSessionId
    playSessionRootCommentId
    userId
    userProfile {
      id
      fullName
      preferredName
      profileImagePath
      username
    }
  }
}
    `;

/**
 * __useGetPlaySessionCommentsQuery__
 *
 * To run a query within a React component, call `useGetPlaySessionCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlaySessionCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlaySessionCommentsQuery({
 *   variables: {
 *      playSessionId: // value for 'playSessionId'
 *   },
 * });
 */
export function useGetPlaySessionCommentsQuery(baseOptions: Apollo.QueryHookOptions<GetPlaySessionCommentsQuery, GetPlaySessionCommentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlaySessionCommentsQuery, GetPlaySessionCommentsQueryVariables>(GetPlaySessionCommentsDocument, options);
      }
export function useGetPlaySessionCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlaySessionCommentsQuery, GetPlaySessionCommentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlaySessionCommentsQuery, GetPlaySessionCommentsQueryVariables>(GetPlaySessionCommentsDocument, options);
        }
export type GetPlaySessionCommentsQueryHookResult = ReturnType<typeof useGetPlaySessionCommentsQuery>;
export type GetPlaySessionCommentsLazyQueryHookResult = ReturnType<typeof useGetPlaySessionCommentsLazyQuery>;
export type GetPlaySessionCommentsQueryResult = Apollo.QueryResult<GetPlaySessionCommentsQuery, GetPlaySessionCommentsQueryVariables>;
export const GetPlayerLessonsDocument = gql`
    query getPlayerLessons($userId: uuid!) {
  lessonParticipants(
    where: {userId: {_eq: $userId}, status: {_eq: ACTIVE}, lesson: {status: {_eq: ACTIVE}}}
  ) {
    id
    status
    lesson {
      ...lessonFields
    }
  }
}
    ${LessonFieldsFragmentDoc}`;

/**
 * __useGetPlayerLessonsQuery__
 *
 * To run a query within a React component, call `useGetPlayerLessonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayerLessonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayerLessonsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPlayerLessonsQuery(baseOptions: Apollo.QueryHookOptions<GetPlayerLessonsQuery, GetPlayerLessonsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlayerLessonsQuery, GetPlayerLessonsQueryVariables>(GetPlayerLessonsDocument, options);
      }
export function useGetPlayerLessonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayerLessonsQuery, GetPlayerLessonsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlayerLessonsQuery, GetPlayerLessonsQueryVariables>(GetPlayerLessonsDocument, options);
        }
export type GetPlayerLessonsQueryHookResult = ReturnType<typeof useGetPlayerLessonsQuery>;
export type GetPlayerLessonsLazyQueryHookResult = ReturnType<typeof useGetPlayerLessonsLazyQuery>;
export type GetPlayerLessonsQueryResult = Apollo.QueryResult<GetPlayerLessonsQuery, GetPlayerLessonsQueryVariables>;
export const GetPlayerPlaySessionsDocument = gql`
    query getPlayerPlaySessions($userId: uuid!) {
  playSessionParticipants(
    where: {userId: {_eq: $userId}, status: {_eq: ACTIVE}, playSession: {status: {_eq: ACTIVE}}}
  ) {
    id
    status
    playSession {
      ...playSessionFields
    }
  }
  playSessions(where: {status: {_eq: ACTIVE}, organizerUserId: {_eq: $userId}}) {
    ...playSessionFields
  }
}
    ${PlaySessionFieldsFragmentDoc}`;

/**
 * __useGetPlayerPlaySessionsQuery__
 *
 * To run a query within a React component, call `useGetPlayerPlaySessionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayerPlaySessionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayerPlaySessionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPlayerPlaySessionsQuery(baseOptions: Apollo.QueryHookOptions<GetPlayerPlaySessionsQuery, GetPlayerPlaySessionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlayerPlaySessionsQuery, GetPlayerPlaySessionsQueryVariables>(GetPlayerPlaySessionsDocument, options);
      }
export function useGetPlayerPlaySessionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayerPlaySessionsQuery, GetPlayerPlaySessionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlayerPlaySessionsQuery, GetPlayerPlaySessionsQueryVariables>(GetPlayerPlaySessionsDocument, options);
        }
export type GetPlayerPlaySessionsQueryHookResult = ReturnType<typeof useGetPlayerPlaySessionsQuery>;
export type GetPlayerPlaySessionsLazyQueryHookResult = ReturnType<typeof useGetPlayerPlaySessionsLazyQuery>;
export type GetPlayerPlaySessionsQueryResult = Apollo.QueryResult<GetPlayerPlaySessionsQuery, GetPlayerPlaySessionsQueryVariables>;
export const GetSportsRatingScalesDocument = gql`
    query getSportsRatingScales {
  pickleballRatingScales {
    id
    maximum
    minimum
    name
    order
    shortName
  }
  tennisRatingScales {
    id
    maximum
    minimum
    name
    order
    shortName
  }
}
    `;

/**
 * __useGetSportsRatingScalesQuery__
 *
 * To run a query within a React component, call `useGetSportsRatingScalesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSportsRatingScalesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSportsRatingScalesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSportsRatingScalesQuery(baseOptions?: Apollo.QueryHookOptions<GetSportsRatingScalesQuery, GetSportsRatingScalesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSportsRatingScalesQuery, GetSportsRatingScalesQueryVariables>(GetSportsRatingScalesDocument, options);
      }
export function useGetSportsRatingScalesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSportsRatingScalesQuery, GetSportsRatingScalesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSportsRatingScalesQuery, GetSportsRatingScalesQueryVariables>(GetSportsRatingScalesDocument, options);
        }
export type GetSportsRatingScalesQueryHookResult = ReturnType<typeof useGetSportsRatingScalesQuery>;
export type GetSportsRatingScalesLazyQueryHookResult = ReturnType<typeof useGetSportsRatingScalesLazyQuery>;
export type GetSportsRatingScalesQueryResult = Apollo.QueryResult<GetSportsRatingScalesQuery, GetSportsRatingScalesQueryVariables>;
export const GetUserFollowerProfilesDocument = gql`
    query getUserFollowerProfiles($followedUserId: uuid!) {
  userFollows(
    where: {followedUserId: {_eq: $followedUserId}, status: {_eq: ACTIVE}}
  ) {
    status
    followerUserId
    followedUserId
    followerProfile {
      id
      preferredName
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      fullName
      username
    }
  }
}
    `;

/**
 * __useGetUserFollowerProfilesQuery__
 *
 * To run a query within a React component, call `useGetUserFollowerProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserFollowerProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserFollowerProfilesQuery({
 *   variables: {
 *      followedUserId: // value for 'followedUserId'
 *   },
 * });
 */
export function useGetUserFollowerProfilesQuery(baseOptions: Apollo.QueryHookOptions<GetUserFollowerProfilesQuery, GetUserFollowerProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserFollowerProfilesQuery, GetUserFollowerProfilesQueryVariables>(GetUserFollowerProfilesDocument, options);
      }
export function useGetUserFollowerProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserFollowerProfilesQuery, GetUserFollowerProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserFollowerProfilesQuery, GetUserFollowerProfilesQueryVariables>(GetUserFollowerProfilesDocument, options);
        }
export type GetUserFollowerProfilesQueryHookResult = ReturnType<typeof useGetUserFollowerProfilesQuery>;
export type GetUserFollowerProfilesLazyQueryHookResult = ReturnType<typeof useGetUserFollowerProfilesLazyQuery>;
export type GetUserFollowerProfilesQueryResult = Apollo.QueryResult<GetUserFollowerProfilesQuery, GetUserFollowerProfilesQueryVariables>;
export const GetUserFollowingIdsDocument = gql`
    query getUserFollowingIds($followerUserId: uuid!) {
  userFollows(
    where: {followerUserId: {_eq: $followerUserId}, status: {_eq: ACTIVE}}
  ) {
    status
    followerUserId
    followedUserId
  }
}
    `;

/**
 * __useGetUserFollowingIdsQuery__
 *
 * To run a query within a React component, call `useGetUserFollowingIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserFollowingIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserFollowingIdsQuery({
 *   variables: {
 *      followerUserId: // value for 'followerUserId'
 *   },
 * });
 */
export function useGetUserFollowingIdsQuery(baseOptions: Apollo.QueryHookOptions<GetUserFollowingIdsQuery, GetUserFollowingIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserFollowingIdsQuery, GetUserFollowingIdsQueryVariables>(GetUserFollowingIdsDocument, options);
      }
export function useGetUserFollowingIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserFollowingIdsQuery, GetUserFollowingIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserFollowingIdsQuery, GetUserFollowingIdsQueryVariables>(GetUserFollowingIdsDocument, options);
        }
export type GetUserFollowingIdsQueryHookResult = ReturnType<typeof useGetUserFollowingIdsQuery>;
export type GetUserFollowingIdsLazyQueryHookResult = ReturnType<typeof useGetUserFollowingIdsLazyQuery>;
export type GetUserFollowingIdsQueryResult = Apollo.QueryResult<GetUserFollowingIdsQuery, GetUserFollowingIdsQueryVariables>;
export const GetUserProfileByIdDocument = gql`
    query getUserProfileById($id: uuid!) {
  userProfiles(where: {id: {_eq: $id}}) {
    ...userProfileFields
  }
}
    ${UserProfileFieldsFragmentDoc}`;

/**
 * __useGetUserProfileByIdQuery__
 *
 * To run a query within a React component, call `useGetUserProfileByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserProfileByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserProfileByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserProfileByIdQuery(baseOptions: Apollo.QueryHookOptions<GetUserProfileByIdQuery, GetUserProfileByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserProfileByIdQuery, GetUserProfileByIdQueryVariables>(GetUserProfileByIdDocument, options);
      }
export function useGetUserProfileByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserProfileByIdQuery, GetUserProfileByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserProfileByIdQuery, GetUserProfileByIdQueryVariables>(GetUserProfileByIdDocument, options);
        }
export type GetUserProfileByIdQueryHookResult = ReturnType<typeof useGetUserProfileByIdQuery>;
export type GetUserProfileByIdLazyQueryHookResult = ReturnType<typeof useGetUserProfileByIdLazyQuery>;
export type GetUserProfileByIdQueryResult = Apollo.QueryResult<GetUserProfileByIdQuery, GetUserProfileByIdQueryVariables>;
export const GetUserProfileByUsernameDocument = gql`
    query getUserProfileByUsername($username: String!, $viewerId: uuid!) {
  userProfiles(where: {username: {_eq: $username}}) {
    ...userProfileFields
  }
  userFollows(
    where: {followedProfile: {username: {_eq: $username}}, followerUserId: {_eq: $viewerId}}
  ) {
    status
    followedUserId
    followerUserId
  }
}
    ${UserProfileFieldsFragmentDoc}`;

/**
 * __useGetUserProfileByUsernameQuery__
 *
 * To run a query within a React component, call `useGetUserProfileByUsernameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserProfileByUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserProfileByUsernameQuery({
 *   variables: {
 *      username: // value for 'username'
 *      viewerId: // value for 'viewerId'
 *   },
 * });
 */
export function useGetUserProfileByUsernameQuery(baseOptions: Apollo.QueryHookOptions<GetUserProfileByUsernameQuery, GetUserProfileByUsernameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserProfileByUsernameQuery, GetUserProfileByUsernameQueryVariables>(GetUserProfileByUsernameDocument, options);
      }
export function useGetUserProfileByUsernameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserProfileByUsernameQuery, GetUserProfileByUsernameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserProfileByUsernameQuery, GetUserProfileByUsernameQueryVariables>(GetUserProfileByUsernameDocument, options);
        }
export type GetUserProfileByUsernameQueryHookResult = ReturnType<typeof useGetUserProfileByUsernameQuery>;
export type GetUserProfileByUsernameLazyQueryHookResult = ReturnType<typeof useGetUserProfileByUsernameLazyQuery>;
export type GetUserProfileByUsernameQueryResult = Apollo.QueryResult<GetUserProfileByUsernameQuery, GetUserProfileByUsernameQueryVariables>;
export const GetUserPublicProfileByUsernameDocument = gql`
    query getUserPublicProfileByUsername($username: String!) {
  userProfiles(where: {username: {_eq: $username}}) {
    ...userProfileFields
  }
}
    ${UserProfileFieldsFragmentDoc}`;

/**
 * __useGetUserPublicProfileByUsernameQuery__
 *
 * To run a query within a React component, call `useGetUserPublicProfileByUsernameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserPublicProfileByUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserPublicProfileByUsernameQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useGetUserPublicProfileByUsernameQuery(baseOptions: Apollo.QueryHookOptions<GetUserPublicProfileByUsernameQuery, GetUserPublicProfileByUsernameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserPublicProfileByUsernameQuery, GetUserPublicProfileByUsernameQueryVariables>(GetUserPublicProfileByUsernameDocument, options);
      }
export function useGetUserPublicProfileByUsernameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserPublicProfileByUsernameQuery, GetUserPublicProfileByUsernameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserPublicProfileByUsernameQuery, GetUserPublicProfileByUsernameQueryVariables>(GetUserPublicProfileByUsernameDocument, options);
        }
export type GetUserPublicProfileByUsernameQueryHookResult = ReturnType<typeof useGetUserPublicProfileByUsernameQuery>;
export type GetUserPublicProfileByUsernameLazyQueryHookResult = ReturnType<typeof useGetUserPublicProfileByUsernameLazyQuery>;
export type GetUserPublicProfileByUsernameQueryResult = Apollo.QueryResult<GetUserPublicProfileByUsernameQuery, GetUserPublicProfileByUsernameQueryVariables>;
export const GetExistingUserDocument = gql`
    query getExistingUser($firebaseId: String!) {
  users(where: {firebaseId: {_eq: $firebaseId}}) {
    id
    email
    username
    fullName
    coachStatus
  }
}
    `;

/**
 * __useGetExistingUserQuery__
 *
 * To run a query within a React component, call `useGetExistingUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExistingUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExistingUserQuery({
 *   variables: {
 *      firebaseId: // value for 'firebaseId'
 *   },
 * });
 */
export function useGetExistingUserQuery(baseOptions: Apollo.QueryHookOptions<GetExistingUserQuery, GetExistingUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetExistingUserQuery, GetExistingUserQueryVariables>(GetExistingUserDocument, options);
      }
export function useGetExistingUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExistingUserQuery, GetExistingUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetExistingUserQuery, GetExistingUserQueryVariables>(GetExistingUserDocument, options);
        }
export type GetExistingUserQueryHookResult = ReturnType<typeof useGetExistingUserQuery>;
export type GetExistingUserLazyQueryHookResult = ReturnType<typeof useGetExistingUserLazyQuery>;
export type GetExistingUserQueryResult = Apollo.QueryResult<GetExistingUserQuery, GetExistingUserQueryVariables>;
export const InsertSignupRequestDocument = gql`
    mutation insertSignupRequest($accountType: String!, $email: String!, $fullName: String!, $preferredName: String!, $username: String!, $ip: String = "", $timezone: String = "", $country: String = "", $region: String = "", $city: String = "", $zip: String = "", $platform: String = "", $fullDetails: jsonb, $latitude: numeric, $longitude: numeric, $cityId: uuid, $phoneNumber: String, $eventOrganizerAccountType: EventOrganizerAccountTypesEnum) {
  insertSignupRequestsOne(
    object: {accountType: $accountType, email: $email, fullName: $fullName, preferredName: $preferredName, username: $username, ip: $ip, timezone: $timezone, country: $country, region: $region, city: $city, zip: $zip, fullDetails: $fullDetails, platform: $platform, latitude: $latitude, longitude: $longitude, cityId: $cityId, phoneNumber: $phoneNumber, eventOrganizerAccountType: $eventOrganizerAccountType}
  ) {
    id
  }
}
    `;
export type InsertSignupRequestMutationFn = Apollo.MutationFunction<InsertSignupRequestMutation, InsertSignupRequestMutationVariables>;

/**
 * __useInsertSignupRequestMutation__
 *
 * To run a mutation, you first call `useInsertSignupRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertSignupRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertSignupRequestMutation, { data, loading, error }] = useInsertSignupRequestMutation({
 *   variables: {
 *      accountType: // value for 'accountType'
 *      email: // value for 'email'
 *      fullName: // value for 'fullName'
 *      preferredName: // value for 'preferredName'
 *      username: // value for 'username'
 *      ip: // value for 'ip'
 *      timezone: // value for 'timezone'
 *      country: // value for 'country'
 *      region: // value for 'region'
 *      city: // value for 'city'
 *      zip: // value for 'zip'
 *      platform: // value for 'platform'
 *      fullDetails: // value for 'fullDetails'
 *      latitude: // value for 'latitude'
 *      longitude: // value for 'longitude'
 *      cityId: // value for 'cityId'
 *      phoneNumber: // value for 'phoneNumber'
 *      eventOrganizerAccountType: // value for 'eventOrganizerAccountType'
 *   },
 * });
 */
export function useInsertSignupRequestMutation(baseOptions?: Apollo.MutationHookOptions<InsertSignupRequestMutation, InsertSignupRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertSignupRequestMutation, InsertSignupRequestMutationVariables>(InsertSignupRequestDocument, options);
      }
export type InsertSignupRequestMutationHookResult = ReturnType<typeof useInsertSignupRequestMutation>;
export type InsertSignupRequestMutationResult = Apollo.MutationResult<InsertSignupRequestMutation>;
export type InsertSignupRequestMutationOptions = Apollo.BaseMutationOptions<InsertSignupRequestMutation, InsertSignupRequestMutationVariables>;
export const CheckUsernameAvailabilityDocument = gql`
    query checkUsernameAvailability($username: String!) {
  usernamesActive(where: {username: {_eq: $username}}) {
    username
  }
  usernamesClaimed(where: {username: {_eq: $username}}) {
    id
    username
  }
}
    `;

/**
 * __useCheckUsernameAvailabilityQuery__
 *
 * To run a query within a React component, call `useCheckUsernameAvailabilityQuery` and pass it any options that fit your needs.
 * When your component renders, `useCheckUsernameAvailabilityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCheckUsernameAvailabilityQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useCheckUsernameAvailabilityQuery(baseOptions: Apollo.QueryHookOptions<CheckUsernameAvailabilityQuery, CheckUsernameAvailabilityQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CheckUsernameAvailabilityQuery, CheckUsernameAvailabilityQueryVariables>(CheckUsernameAvailabilityDocument, options);
      }
export function useCheckUsernameAvailabilityLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CheckUsernameAvailabilityQuery, CheckUsernameAvailabilityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CheckUsernameAvailabilityQuery, CheckUsernameAvailabilityQueryVariables>(CheckUsernameAvailabilityDocument, options);
        }
export type CheckUsernameAvailabilityQueryHookResult = ReturnType<typeof useCheckUsernameAvailabilityQuery>;
export type CheckUsernameAvailabilityLazyQueryHookResult = ReturnType<typeof useCheckUsernameAvailabilityLazyQuery>;
export type CheckUsernameAvailabilityQueryResult = Apollo.QueryResult<CheckUsernameAvailabilityQuery, CheckUsernameAvailabilityQueryVariables>;
export const GetGroupThreadByIdDocument = gql`
    query getGroupThreadById($id: uuid!, $userId: uuid!) {
  groupThreadsByPk(id: $id) {
    comments(orderBy: {createdAt: ASC}) {
      content
      createdAt
      groupCommentId
      groupRootCommentId
      id
      isOriginalThreadComment
      updatedAt
      userId
      userProfile {
        id
        fullName
        preferredName
        profileImagePath
        username
      }
      votesAggregate(where: {vote: {_eq: POSITIVE}}) {
        aggregate {
          count
        }
      }
      votes(where: {userId: {_eq: $userId}}) {
        id
        userId
        groupThreadCommentId
        vote
      }
      files {
        id
        url
        path
      }
    }
  }
}
    `;

/**
 * __useGetGroupThreadByIdQuery__
 *
 * To run a query within a React component, call `useGetGroupThreadByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGroupThreadByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGroupThreadByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetGroupThreadByIdQuery(baseOptions: Apollo.QueryHookOptions<GetGroupThreadByIdQuery, GetGroupThreadByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGroupThreadByIdQuery, GetGroupThreadByIdQueryVariables>(GetGroupThreadByIdDocument, options);
      }
export function useGetGroupThreadByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGroupThreadByIdQuery, GetGroupThreadByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGroupThreadByIdQuery, GetGroupThreadByIdQueryVariables>(GetGroupThreadByIdDocument, options);
        }
export type GetGroupThreadByIdQueryHookResult = ReturnType<typeof useGetGroupThreadByIdQuery>;
export type GetGroupThreadByIdLazyQueryHookResult = ReturnType<typeof useGetGroupThreadByIdLazyQuery>;
export type GetGroupThreadByIdQueryResult = Apollo.QueryResult<GetGroupThreadByIdQuery, GetGroupThreadByIdQueryVariables>;
export const InsertGroupThreadCommentDocument = gql`
    mutation insertGroupThreadComment($userId: uuid!, $groupThreadId: uuid!, $content: String!, $groupCommentId: uuid, $groupRootCommentId: uuid) {
  insertGroupThreadCommentsOne(
    object: {userId: $userId, groupThreadId: $groupThreadId, content: $content, groupCommentId: $groupCommentId, groupRootCommentId: $groupRootCommentId, isOriginalThreadComment: false, votes: {data: {userId: $userId, vote: POSITIVE}}}
  ) {
    id
    groupThreadId
    content
  }
}
    `;
export type InsertGroupThreadCommentMutationFn = Apollo.MutationFunction<InsertGroupThreadCommentMutation, InsertGroupThreadCommentMutationVariables>;

/**
 * __useInsertGroupThreadCommentMutation__
 *
 * To run a mutation, you first call `useInsertGroupThreadCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertGroupThreadCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertGroupThreadCommentMutation, { data, loading, error }] = useInsertGroupThreadCommentMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      groupThreadId: // value for 'groupThreadId'
 *      content: // value for 'content'
 *      groupCommentId: // value for 'groupCommentId'
 *      groupRootCommentId: // value for 'groupRootCommentId'
 *   },
 * });
 */
export function useInsertGroupThreadCommentMutation(baseOptions?: Apollo.MutationHookOptions<InsertGroupThreadCommentMutation, InsertGroupThreadCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertGroupThreadCommentMutation, InsertGroupThreadCommentMutationVariables>(InsertGroupThreadCommentDocument, options);
      }
export type InsertGroupThreadCommentMutationHookResult = ReturnType<typeof useInsertGroupThreadCommentMutation>;
export type InsertGroupThreadCommentMutationResult = Apollo.MutationResult<InsertGroupThreadCommentMutation>;
export type InsertGroupThreadCommentMutationOptions = Apollo.BaseMutationOptions<InsertGroupThreadCommentMutation, InsertGroupThreadCommentMutationVariables>;
export const GetVenuesByGeoDocument = gql`
    query getVenuesByGeo($distance: Float!, $from: geography!) {
  venues(
    where: {geometry: {_stDWithin: {distance: $distance, from: $from}}}
    limit: 1000
    orderBy: {geometry: ASC}
  ) {
    id
    title
    geometry
    slug
    pickleballLines
    addressString
    accessType
    indoorCourtCount
    outdoorCourtCount
    pickleballNets
    images {
      id
      fileName
      url
    }
    city {
      id
      name
      countrySubdivision {
        id
        name
      }
    }
    courtSurfaces {
      id
      courtSurface
    }
  }
}
    `;

/**
 * __useGetVenuesByGeoQuery__
 *
 * To run a query within a React component, call `useGetVenuesByGeoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVenuesByGeoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVenuesByGeoQuery({
 *   variables: {
 *      distance: // value for 'distance'
 *      from: // value for 'from'
 *   },
 * });
 */
export function useGetVenuesByGeoQuery(baseOptions: Apollo.QueryHookOptions<GetVenuesByGeoQuery, GetVenuesByGeoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVenuesByGeoQuery, GetVenuesByGeoQueryVariables>(GetVenuesByGeoDocument, options);
      }
export function useGetVenuesByGeoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVenuesByGeoQuery, GetVenuesByGeoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVenuesByGeoQuery, GetVenuesByGeoQueryVariables>(GetVenuesByGeoDocument, options);
        }
export type GetVenuesByGeoQueryHookResult = ReturnType<typeof useGetVenuesByGeoQuery>;
export type GetVenuesByGeoLazyQueryHookResult = ReturnType<typeof useGetVenuesByGeoLazyQuery>;
export type GetVenuesByGeoQueryResult = Apollo.QueryResult<GetVenuesByGeoQuery, GetVenuesByGeoQueryVariables>;
export const GetPlaySessionsByVenueIdAsUserDocument = gql`
    query getPlaySessionsByVenueIdAsUser($venueId: uuid!, $startDateTime: timestamptz!, $userId: uuid!) {
  playSessions(
    where: {venueId: {_eq: $venueId}, startDateTime: {_gte: $startDateTime}}
  ) {
    ...playSessionFields
    commentsAggregate {
      aggregate {
        count
      }
    }
    currentUserAsParticipant: participants(
      where: {userId: {_eq: $userId}, status: {_eq: ACTIVE}}
    ) {
      id
      status
    }
  }
}
    ${PlaySessionFieldsFragmentDoc}`;

/**
 * __useGetPlaySessionsByVenueIdAsUserQuery__
 *
 * To run a query within a React component, call `useGetPlaySessionsByVenueIdAsUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlaySessionsByVenueIdAsUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlaySessionsByVenueIdAsUserQuery({
 *   variables: {
 *      venueId: // value for 'venueId'
 *      startDateTime: // value for 'startDateTime'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPlaySessionsByVenueIdAsUserQuery(baseOptions: Apollo.QueryHookOptions<GetPlaySessionsByVenueIdAsUserQuery, GetPlaySessionsByVenueIdAsUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlaySessionsByVenueIdAsUserQuery, GetPlaySessionsByVenueIdAsUserQueryVariables>(GetPlaySessionsByVenueIdAsUserDocument, options);
      }
export function useGetPlaySessionsByVenueIdAsUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlaySessionsByVenueIdAsUserQuery, GetPlaySessionsByVenueIdAsUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlaySessionsByVenueIdAsUserQuery, GetPlaySessionsByVenueIdAsUserQueryVariables>(GetPlaySessionsByVenueIdAsUserDocument, options);
        }
export type GetPlaySessionsByVenueIdAsUserQueryHookResult = ReturnType<typeof useGetPlaySessionsByVenueIdAsUserQuery>;
export type GetPlaySessionsByVenueIdAsUserLazyQueryHookResult = ReturnType<typeof useGetPlaySessionsByVenueIdAsUserLazyQuery>;
export type GetPlaySessionsByVenueIdAsUserQueryResult = Apollo.QueryResult<GetPlaySessionsByVenueIdAsUserQuery, GetPlaySessionsByVenueIdAsUserQueryVariables>;
export const GetPlaySessionsByVenueIdAsAnonymousDocument = gql`
    query getPlaySessionsByVenueIdAsAnonymous($venueId: uuid!, $startDateTime: timestamptz!) {
  playSessions(
    where: {venueId: {_eq: $venueId}, startDateTime: {_gte: $startDateTime}}
  ) {
    ...playSessionFields
    commentsAggregate {
      aggregate {
        count
      }
    }
  }
}
    ${PlaySessionFieldsFragmentDoc}`;

/**
 * __useGetPlaySessionsByVenueIdAsAnonymousQuery__
 *
 * To run a query within a React component, call `useGetPlaySessionsByVenueIdAsAnonymousQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlaySessionsByVenueIdAsAnonymousQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlaySessionsByVenueIdAsAnonymousQuery({
 *   variables: {
 *      venueId: // value for 'venueId'
 *      startDateTime: // value for 'startDateTime'
 *   },
 * });
 */
export function useGetPlaySessionsByVenueIdAsAnonymousQuery(baseOptions: Apollo.QueryHookOptions<GetPlaySessionsByVenueIdAsAnonymousQuery, GetPlaySessionsByVenueIdAsAnonymousQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlaySessionsByVenueIdAsAnonymousQuery, GetPlaySessionsByVenueIdAsAnonymousQueryVariables>(GetPlaySessionsByVenueIdAsAnonymousDocument, options);
      }
export function useGetPlaySessionsByVenueIdAsAnonymousLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlaySessionsByVenueIdAsAnonymousQuery, GetPlaySessionsByVenueIdAsAnonymousQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlaySessionsByVenueIdAsAnonymousQuery, GetPlaySessionsByVenueIdAsAnonymousQueryVariables>(GetPlaySessionsByVenueIdAsAnonymousDocument, options);
        }
export type GetPlaySessionsByVenueIdAsAnonymousQueryHookResult = ReturnType<typeof useGetPlaySessionsByVenueIdAsAnonymousQuery>;
export type GetPlaySessionsByVenueIdAsAnonymousLazyQueryHookResult = ReturnType<typeof useGetPlaySessionsByVenueIdAsAnonymousLazyQuery>;
export type GetPlaySessionsByVenueIdAsAnonymousQueryResult = Apollo.QueryResult<GetPlaySessionsByVenueIdAsAnonymousQuery, GetPlaySessionsByVenueIdAsAnonymousQueryVariables>;
export const UpsertVenueFollowDocument = gql`
    mutation upsertVenueFollow($userId: uuid!, $venueId: uuid!, $status: FollowStatusesEnum!) {
  insertVenueFollowsOne(
    object: {userId: $userId, venueId: $venueId, status: $status}
    onConflict: {constraint: venue_follows_venue_id_user_id_key, updateColumns: status}
  ) {
    status
    id
    userId
    venueId
  }
}
    `;
export type UpsertVenueFollowMutationFn = Apollo.MutationFunction<UpsertVenueFollowMutation, UpsertVenueFollowMutationVariables>;

/**
 * __useUpsertVenueFollowMutation__
 *
 * To run a mutation, you first call `useUpsertVenueFollowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertVenueFollowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertVenueFollowMutation, { data, loading, error }] = useUpsertVenueFollowMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      venueId: // value for 'venueId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useUpsertVenueFollowMutation(baseOptions?: Apollo.MutationHookOptions<UpsertVenueFollowMutation, UpsertVenueFollowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertVenueFollowMutation, UpsertVenueFollowMutationVariables>(UpsertVenueFollowDocument, options);
      }
export type UpsertVenueFollowMutationHookResult = ReturnType<typeof useUpsertVenueFollowMutation>;
export type UpsertVenueFollowMutationResult = Apollo.MutationResult<UpsertVenueFollowMutation>;
export type UpsertVenueFollowMutationOptions = Apollo.BaseMutationOptions<UpsertVenueFollowMutation, UpsertVenueFollowMutationVariables>;
export const GetUserVenueFollowDocument = gql`
    query getUserVenueFollow($userId: uuid!, $venueId: uuid!) {
  venueFollows(where: {userId: {_eq: $userId}, venueId: {_eq: $venueId}}) {
    id
    userId
    venueId
    status
  }
}
    `;

/**
 * __useGetUserVenueFollowQuery__
 *
 * To run a query within a React component, call `useGetUserVenueFollowQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserVenueFollowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserVenueFollowQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      venueId: // value for 'venueId'
 *   },
 * });
 */
export function useGetUserVenueFollowQuery(baseOptions: Apollo.QueryHookOptions<GetUserVenueFollowQuery, GetUserVenueFollowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserVenueFollowQuery, GetUserVenueFollowQueryVariables>(GetUserVenueFollowDocument, options);
      }
export function useGetUserVenueFollowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserVenueFollowQuery, GetUserVenueFollowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserVenueFollowQuery, GetUserVenueFollowQueryVariables>(GetUserVenueFollowDocument, options);
        }
export type GetUserVenueFollowQueryHookResult = ReturnType<typeof useGetUserVenueFollowQuery>;
export type GetUserVenueFollowLazyQueryHookResult = ReturnType<typeof useGetUserVenueFollowLazyQuery>;
export type GetUserVenueFollowQueryResult = Apollo.QueryResult<GetUserVenueFollowQuery, GetUserVenueFollowQueryVariables>;
export const GetGamedayByEventIdDocument = gql`
    query getGamedayByEventId($id: uuid!) {
  eventsByPk(id: $id) {
    id
    title
    hostUserId
    groups {
      id
      title
      winBy
      totalPoints
      teamLimit
      teamType
      startsAt
      endsAt
      scoringFormat
      gamesPerMatch
      format
      minimumNumberOfGames
      numberOfEliminationTeams
      numberOfEstimatedCourts
      sequences(orderBy: {order: ASC}) {
        id
        nextSequenceId
        order
        groupId
        competitionFormat
        completeReason
        isSequenceComplete
        pools {
          id
          title
          startsAt
          endsAt
          rounds(orderBy: {roundOrder: ASC}) {
            id
            roundOrder
            title
            matches(orderBy: {matchOrder: ASC}) {
              courtNumber
              id
              matchOrder
              isBye
              winningTeamId
              losingTeamId
              team1Id
              team2Id
              previousMatch1Id
              previousMatch2Id
              selectionCriteriaPreviousMatch1
              selectionCriteriaPreviousMatch2
              losingTeamId
              team1 {
                id
                members(orderBy: {createdAt: ASC}) {
                  id
                  status
                  userProfile {
                    id
                    preferredName
                    fullName
                  }
                }
              }
              team2 {
                id
                members(orderBy: {createdAt: ASC}) {
                  id
                  status
                  userProfile {
                    id
                    preferredName
                    fullName
                  }
                }
              }
              games {
                id
                scores {
                  id
                  score
                  teamId
                }
                losingTeamId
                team1Id
                team1Score
                team2Id
                team2Score
                winReason
                winningTeamId
              }
            }
          }
        }
        seeding {
          id
          eventTeamId
          seed
        }
      }
      courts {
        id
        updatedAt
        courtNumber
        courtStatus
        activeMatchId
        activeMatch {
          id
          teams {
            id
            team {
              id
              members {
                userProfile {
                  id
                  preferredName
                  fullName
                }
              }
            }
          }
        }
      }
    }
    courts {
      id
      updatedAt
      activeMatchId
      courtStatus
      courtNumber
      activeEventGroupId
      activeEventGroupPoolId
    }
  }
}
    `;

/**
 * __useGetGamedayByEventIdQuery__
 *
 * To run a query within a React component, call `useGetGamedayByEventIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGamedayByEventIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGamedayByEventIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGamedayByEventIdQuery(baseOptions: Apollo.QueryHookOptions<GetGamedayByEventIdQuery, GetGamedayByEventIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGamedayByEventIdQuery, GetGamedayByEventIdQueryVariables>(GetGamedayByEventIdDocument, options);
      }
export function useGetGamedayByEventIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGamedayByEventIdQuery, GetGamedayByEventIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGamedayByEventIdQuery, GetGamedayByEventIdQueryVariables>(GetGamedayByEventIdDocument, options);
        }
export type GetGamedayByEventIdQueryHookResult = ReturnType<typeof useGetGamedayByEventIdQuery>;
export type GetGamedayByEventIdLazyQueryHookResult = ReturnType<typeof useGetGamedayByEventIdLazyQuery>;
export type GetGamedayByEventIdQueryResult = Apollo.QueryResult<GetGamedayByEventIdQuery, GetGamedayByEventIdQueryVariables>;
export const AssignCourtToMatchDocument = gql`
    mutation assignCourtToMatch($matchId: uuid!, $courtId: uuid!, $courtNumber: Int!) {
  updateEventMatchesByPk(
    pkColumns: {id: $matchId}
    _set: {eventCourtId: $courtId, courtNumber: $courtNumber}
  ) {
    id
    eventCourtId
    courtNumber
  }
  updateEventCourtsByPk(
    pkColumns: {id: $courtId}
    _set: {activeMatchId: $matchId}
  ) {
    id
    updatedAt
    courtNumber
    courtStatus
    activeMatchId
    activeMatch {
      id
      team1 {
        id
        members(orderBy: {createdAt: ASC}) {
          id
          status
          userProfile {
            id
            preferredName
            fullName
          }
        }
      }
      team2 {
        id
        members(orderBy: {createdAt: ASC}) {
          id
          status
          userProfile {
            id
            preferredName
            fullName
          }
        }
      }
      teams {
        id
        team {
          members {
            userProfile {
              id
              preferredName
              fullName
            }
          }
        }
      }
    }
  }
}
    `;
export type AssignCourtToMatchMutationFn = Apollo.MutationFunction<AssignCourtToMatchMutation, AssignCourtToMatchMutationVariables>;

/**
 * __useAssignCourtToMatchMutation__
 *
 * To run a mutation, you first call `useAssignCourtToMatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignCourtToMatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignCourtToMatchMutation, { data, loading, error }] = useAssignCourtToMatchMutation({
 *   variables: {
 *      matchId: // value for 'matchId'
 *      courtId: // value for 'courtId'
 *      courtNumber: // value for 'courtNumber'
 *   },
 * });
 */
export function useAssignCourtToMatchMutation(baseOptions?: Apollo.MutationHookOptions<AssignCourtToMatchMutation, AssignCourtToMatchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignCourtToMatchMutation, AssignCourtToMatchMutationVariables>(AssignCourtToMatchDocument, options);
      }
export type AssignCourtToMatchMutationHookResult = ReturnType<typeof useAssignCourtToMatchMutation>;
export type AssignCourtToMatchMutationResult = Apollo.MutationResult<AssignCourtToMatchMutation>;
export type AssignCourtToMatchMutationOptions = Apollo.BaseMutationOptions<AssignCourtToMatchMutation, AssignCourtToMatchMutationVariables>;
export const SetMatchScoresFreeCourtDocument = gql`
    mutation setMatchScoresFreeCourt($losingTeamId: uuid!, $matchId: uuid!, $team1Id: uuid!, $team1Score: numeric!, $team2Id: uuid!, $team2Score: numeric!, $winReason: WinReasonsEnum!, $winningTeamId: uuid!, $data: [EventGameScoresInsertInput!] = [], $courtId: uuid!) {
  insertEventMatchGamesOne(
    object: {losingTeamId: $losingTeamId, matchId: $matchId, team1Id: $team1Id, team1Score: $team1Score, team2Id: $team2Id, team2Score: $team2Score, winReason: $winReason, winningTeamId: $winningTeamId, scores: {data: $data, onConflict: {constraint: event_game_scores_game_id_team_id_key, updateColumns: score}}}
  ) {
    id
    matchId
    team1Score
    team2Score
    team1Id
    team2Id
    winReason
    winningTeamId
    losingTeamId
  }
  updateEventMatchesByPk(
    pkColumns: {id: $matchId}
    _set: {winningTeamId: $winningTeamId, losingTeamId: $losingTeamId, winReason: $winReason}
  ) {
    id
    losingTeamId
    winReason
    winningTeamId
    courtNumber
  }
  updateEventCourtsByPk(pkColumns: {id: $courtId}, _set: {activeMatchId: null}) {
    id
    activeMatchId
  }
}
    `;
export type SetMatchScoresFreeCourtMutationFn = Apollo.MutationFunction<SetMatchScoresFreeCourtMutation, SetMatchScoresFreeCourtMutationVariables>;

/**
 * __useSetMatchScoresFreeCourtMutation__
 *
 * To run a mutation, you first call `useSetMatchScoresFreeCourtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetMatchScoresFreeCourtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setMatchScoresFreeCourtMutation, { data, loading, error }] = useSetMatchScoresFreeCourtMutation({
 *   variables: {
 *      losingTeamId: // value for 'losingTeamId'
 *      matchId: // value for 'matchId'
 *      team1Id: // value for 'team1Id'
 *      team1Score: // value for 'team1Score'
 *      team2Id: // value for 'team2Id'
 *      team2Score: // value for 'team2Score'
 *      winReason: // value for 'winReason'
 *      winningTeamId: // value for 'winningTeamId'
 *      data: // value for 'data'
 *      courtId: // value for 'courtId'
 *   },
 * });
 */
export function useSetMatchScoresFreeCourtMutation(baseOptions?: Apollo.MutationHookOptions<SetMatchScoresFreeCourtMutation, SetMatchScoresFreeCourtMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetMatchScoresFreeCourtMutation, SetMatchScoresFreeCourtMutationVariables>(SetMatchScoresFreeCourtDocument, options);
      }
export type SetMatchScoresFreeCourtMutationHookResult = ReturnType<typeof useSetMatchScoresFreeCourtMutation>;
export type SetMatchScoresFreeCourtMutationResult = Apollo.MutationResult<SetMatchScoresFreeCourtMutation>;
export type SetMatchScoresFreeCourtMutationOptions = Apollo.BaseMutationOptions<SetMatchScoresFreeCourtMutation, SetMatchScoresFreeCourtMutationVariables>;
export const SetMatchScoresUpdateNextMatchCourtDocument = gql`
    mutation setMatchScoresUpdateNextMatchCourt($losingTeamId: uuid!, $matchId: uuid!, $team1Id: uuid!, $team1Score: numeric!, $team2Id: uuid!, $team2Score: numeric!, $winReason: WinReasonsEnum!, $winningTeamId: uuid!, $data: [EventGameScoresInsertInput!] = [], $courtId: uuid!, $courtNumber: Int!, $nextMatchId: uuid!) {
  insertEventMatchGamesOne(
    object: {losingTeamId: $losingTeamId, matchId: $matchId, team1Id: $team1Id, team1Score: $team1Score, team2Id: $team2Id, team2Score: $team2Score, winReason: $winReason, winningTeamId: $winningTeamId, scores: {data: $data, onConflict: {constraint: event_game_scores_game_id_team_id_key, updateColumns: score}}}
  ) {
    id
    matchId
    team1Score
    team2Score
    winReason
    winningTeamId
    losingTeamId
  }
  updatePreviousMatch: updateEventMatchesByPk(
    pkColumns: {id: $matchId}
    _set: {winningTeamId: $winningTeamId, losingTeamId: $losingTeamId, winReason: $winReason}
  ) {
    id
    losingTeamId
    winReason
    winningTeamId
    courtNumber
    eventCourtId
  }
  updateNextMatch: updateEventMatchesByPk(
    pkColumns: {id: $nextMatchId}
    _set: {courtNumber: $courtNumber, eventCourtId: $courtId}
  ) {
    id
    losingTeamId
    winReason
    winningTeamId
    courtNumber
    eventCourtId
  }
  updateEventCourtsByPk(
    pkColumns: {id: $courtId}
    _set: {activeMatchId: $nextMatchId}
  ) {
    id
    activeMatchId
  }
}
    `;
export type SetMatchScoresUpdateNextMatchCourtMutationFn = Apollo.MutationFunction<SetMatchScoresUpdateNextMatchCourtMutation, SetMatchScoresUpdateNextMatchCourtMutationVariables>;

/**
 * __useSetMatchScoresUpdateNextMatchCourtMutation__
 *
 * To run a mutation, you first call `useSetMatchScoresUpdateNextMatchCourtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetMatchScoresUpdateNextMatchCourtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setMatchScoresUpdateNextMatchCourtMutation, { data, loading, error }] = useSetMatchScoresUpdateNextMatchCourtMutation({
 *   variables: {
 *      losingTeamId: // value for 'losingTeamId'
 *      matchId: // value for 'matchId'
 *      team1Id: // value for 'team1Id'
 *      team1Score: // value for 'team1Score'
 *      team2Id: // value for 'team2Id'
 *      team2Score: // value for 'team2Score'
 *      winReason: // value for 'winReason'
 *      winningTeamId: // value for 'winningTeamId'
 *      data: // value for 'data'
 *      courtId: // value for 'courtId'
 *      courtNumber: // value for 'courtNumber'
 *      nextMatchId: // value for 'nextMatchId'
 *   },
 * });
 */
export function useSetMatchScoresUpdateNextMatchCourtMutation(baseOptions?: Apollo.MutationHookOptions<SetMatchScoresUpdateNextMatchCourtMutation, SetMatchScoresUpdateNextMatchCourtMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetMatchScoresUpdateNextMatchCourtMutation, SetMatchScoresUpdateNextMatchCourtMutationVariables>(SetMatchScoresUpdateNextMatchCourtDocument, options);
      }
export type SetMatchScoresUpdateNextMatchCourtMutationHookResult = ReturnType<typeof useSetMatchScoresUpdateNextMatchCourtMutation>;
export type SetMatchScoresUpdateNextMatchCourtMutationResult = Apollo.MutationResult<SetMatchScoresUpdateNextMatchCourtMutation>;
export type SetMatchScoresUpdateNextMatchCourtMutationOptions = Apollo.BaseMutationOptions<SetMatchScoresUpdateNextMatchCourtMutation, SetMatchScoresUpdateNextMatchCourtMutationVariables>;
export const SetMatchScoresDocument = gql`
    mutation setMatchScores($losingTeamId: uuid!, $matchId: uuid!, $team1Id: uuid!, $team1Score: numeric!, $team2Id: uuid!, $team2Score: numeric!, $winReason: WinReasonsEnum!, $winningTeamId: uuid!, $data: [EventGameScoresInsertInput!] = []) {
  insertEventMatchGamesOne(
    object: {losingTeamId: $losingTeamId, matchId: $matchId, team1Id: $team1Id, team1Score: $team1Score, team2Id: $team2Id, team2Score: $team2Score, winReason: $winReason, winningTeamId: $winningTeamId, scores: {data: $data, onConflict: {constraint: event_game_scores_game_id_team_id_key, updateColumns: score}}}
  ) {
    id
    matchId
    team1Score
    team2Score
    winReason
    winningTeamId
    losingTeamId
  }
  updatePreviousMatch: updateEventMatchesByPk(
    pkColumns: {id: $matchId}
    _set: {winningTeamId: $winningTeamId, losingTeamId: $losingTeamId, winReason: $winReason}
  ) {
    id
    losingTeamId
    winReason
    winningTeamId
    courtNumber
    eventCourtId
  }
}
    `;
export type SetMatchScoresMutationFn = Apollo.MutationFunction<SetMatchScoresMutation, SetMatchScoresMutationVariables>;

/**
 * __useSetMatchScoresMutation__
 *
 * To run a mutation, you first call `useSetMatchScoresMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetMatchScoresMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setMatchScoresMutation, { data, loading, error }] = useSetMatchScoresMutation({
 *   variables: {
 *      losingTeamId: // value for 'losingTeamId'
 *      matchId: // value for 'matchId'
 *      team1Id: // value for 'team1Id'
 *      team1Score: // value for 'team1Score'
 *      team2Id: // value for 'team2Id'
 *      team2Score: // value for 'team2Score'
 *      winReason: // value for 'winReason'
 *      winningTeamId: // value for 'winningTeamId'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSetMatchScoresMutation(baseOptions?: Apollo.MutationHookOptions<SetMatchScoresMutation, SetMatchScoresMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetMatchScoresMutation, SetMatchScoresMutationVariables>(SetMatchScoresDocument, options);
      }
export type SetMatchScoresMutationHookResult = ReturnType<typeof useSetMatchScoresMutation>;
export type SetMatchScoresMutationResult = Apollo.MutationResult<SetMatchScoresMutation>;
export type SetMatchScoresMutationOptions = Apollo.BaseMutationOptions<SetMatchScoresMutation, SetMatchScoresMutationVariables>;
export const UpdateGameScoreDocument = gql`
    mutation updateGameScore($gameId: uuid!, $team1Score: numeric!, $team2Score: numeric!, $losingTeamId: uuid!, $winningTeamId: uuid!, $matchId: uuid!, $matchWinningTeamId: uuid!, $matchLosingTeamId: uuid!, $updates: [EventGameScoresUpdates!] = []) {
  updateEventMatchGamesByPk(
    pkColumns: {id: $gameId}
    _set: {team1Score: $team1Score, team2Score: $team2Score, losingTeamId: $losingTeamId, winningTeamId: $winningTeamId}
  ) {
    id
    team2Id
    team2Score
    team1Id
    team1Score
    losingTeamId
  }
  updateEventMatchesByPk(
    pkColumns: {id: $matchId}
    _set: {winningTeamId: $matchWinningTeamId, losingTeamId: $matchLosingTeamId}
  ) {
    id
    losingTeamId
    winningTeamId
  }
  updateEventGameScoresMany(updates: $updates) {
    returning {
      id
      score
    }
  }
}
    `;
export type UpdateGameScoreMutationFn = Apollo.MutationFunction<UpdateGameScoreMutation, UpdateGameScoreMutationVariables>;

/**
 * __useUpdateGameScoreMutation__
 *
 * To run a mutation, you first call `useUpdateGameScoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGameScoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGameScoreMutation, { data, loading, error }] = useUpdateGameScoreMutation({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      team1Score: // value for 'team1Score'
 *      team2Score: // value for 'team2Score'
 *      losingTeamId: // value for 'losingTeamId'
 *      winningTeamId: // value for 'winningTeamId'
 *      matchId: // value for 'matchId'
 *      matchWinningTeamId: // value for 'matchWinningTeamId'
 *      matchLosingTeamId: // value for 'matchLosingTeamId'
 *      updates: // value for 'updates'
 *   },
 * });
 */
export function useUpdateGameScoreMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGameScoreMutation, UpdateGameScoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGameScoreMutation, UpdateGameScoreMutationVariables>(UpdateGameScoreDocument, options);
      }
export type UpdateGameScoreMutationHookResult = ReturnType<typeof useUpdateGameScoreMutation>;
export type UpdateGameScoreMutationResult = Apollo.MutationResult<UpdateGameScoreMutation>;
export type UpdateGameScoreMutationOptions = Apollo.BaseMutationOptions<UpdateGameScoreMutation, UpdateGameScoreMutationVariables>;
export const UpdateSingleEliminationMatchProgressionDocument = gql`
    mutation updateSingleEliminationMatchProgression($updates: [EventMatchesUpdates!] = []) {
  updateEventMatchesMany(updates: $updates) {
    returning {
      team1Id
      team2Id
    }
  }
}
    `;
export type UpdateSingleEliminationMatchProgressionMutationFn = Apollo.MutationFunction<UpdateSingleEliminationMatchProgressionMutation, UpdateSingleEliminationMatchProgressionMutationVariables>;

/**
 * __useUpdateSingleEliminationMatchProgressionMutation__
 *
 * To run a mutation, you first call `useUpdateSingleEliminationMatchProgressionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSingleEliminationMatchProgressionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSingleEliminationMatchProgressionMutation, { data, loading, error }] = useUpdateSingleEliminationMatchProgressionMutation({
 *   variables: {
 *      updates: // value for 'updates'
 *   },
 * });
 */
export function useUpdateSingleEliminationMatchProgressionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSingleEliminationMatchProgressionMutation, UpdateSingleEliminationMatchProgressionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSingleEliminationMatchProgressionMutation, UpdateSingleEliminationMatchProgressionMutationVariables>(UpdateSingleEliminationMatchProgressionDocument, options);
      }
export type UpdateSingleEliminationMatchProgressionMutationHookResult = ReturnType<typeof useUpdateSingleEliminationMatchProgressionMutation>;
export type UpdateSingleEliminationMatchProgressionMutationResult = Apollo.MutationResult<UpdateSingleEliminationMatchProgressionMutation>;
export type UpdateSingleEliminationMatchProgressionMutationOptions = Apollo.BaseMutationOptions<UpdateSingleEliminationMatchProgressionMutation, UpdateSingleEliminationMatchProgressionMutationVariables>;
export const UpdatedUnassignCourtDocument = gql`
    mutation updatedUnassignCourt($id: uuid!) {
  updateEventCourtsByPk(
    pkColumns: {id: $id}
    _set: {activeEventGroupId: null, activeEventGroupPoolId: null, activeMatchId: null}
  ) {
    id
    courtNumber
    courtStatus
    activeMatchId
    activeEventGroupId
    activeEventGroupPoolId
  }
}
    `;
export type UpdatedUnassignCourtMutationFn = Apollo.MutationFunction<UpdatedUnassignCourtMutation, UpdatedUnassignCourtMutationVariables>;

/**
 * __useUpdatedUnassignCourtMutation__
 *
 * To run a mutation, you first call `useUpdatedUnassignCourtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatedUnassignCourtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatedUnassignCourtMutation, { data, loading, error }] = useUpdatedUnassignCourtMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUpdatedUnassignCourtMutation(baseOptions?: Apollo.MutationHookOptions<UpdatedUnassignCourtMutation, UpdatedUnassignCourtMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatedUnassignCourtMutation, UpdatedUnassignCourtMutationVariables>(UpdatedUnassignCourtDocument, options);
      }
export type UpdatedUnassignCourtMutationHookResult = ReturnType<typeof useUpdatedUnassignCourtMutation>;
export type UpdatedUnassignCourtMutationResult = Apollo.MutationResult<UpdatedUnassignCourtMutation>;
export type UpdatedUnassignCourtMutationOptions = Apollo.BaseMutationOptions<UpdatedUnassignCourtMutation, UpdatedUnassignCourtMutationVariables>;
export const UpdateCourtsStartGroupDocument = gql`
    mutation updateCourtsStartGroup($courtUpdates: [EventCourtsUpdates!] = [], $matchUpdates: [EventMatchesUpdates!] = []) {
  updateEventCourtsMany(updates: $courtUpdates) {
    returning {
      id
      updatedAt
      courtNumber
      courtStatus
      activeMatchId
      activeMatch {
        id
        teams {
          id
          team {
            id
            members {
              userProfile {
                id
                preferredName
                fullName
              }
            }
          }
        }
      }
    }
  }
  updateEventMatchesMany(updates: $matchUpdates) {
    returning {
      id
      isBye
      matchOrder
      courtNumber
      eventCourtId
    }
  }
}
    `;
export type UpdateCourtsStartGroupMutationFn = Apollo.MutationFunction<UpdateCourtsStartGroupMutation, UpdateCourtsStartGroupMutationVariables>;

/**
 * __useUpdateCourtsStartGroupMutation__
 *
 * To run a mutation, you first call `useUpdateCourtsStartGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCourtsStartGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCourtsStartGroupMutation, { data, loading, error }] = useUpdateCourtsStartGroupMutation({
 *   variables: {
 *      courtUpdates: // value for 'courtUpdates'
 *      matchUpdates: // value for 'matchUpdates'
 *   },
 * });
 */
export function useUpdateCourtsStartGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCourtsStartGroupMutation, UpdateCourtsStartGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCourtsStartGroupMutation, UpdateCourtsStartGroupMutationVariables>(UpdateCourtsStartGroupDocument, options);
      }
export type UpdateCourtsStartGroupMutationHookResult = ReturnType<typeof useUpdateCourtsStartGroupMutation>;
export type UpdateCourtsStartGroupMutationResult = Apollo.MutationResult<UpdateCourtsStartGroupMutation>;
export type UpdateCourtsStartGroupMutationOptions = Apollo.BaseMutationOptions<UpdateCourtsStartGroupMutation, UpdateCourtsStartGroupMutationVariables>;
export const UpdateRemoveCourtFromMatchDocument = gql`
    mutation updateRemoveCourtFromMatch($matchId: uuid!, $courtId: uuid!) {
  updateEventMatchesByPk(
    pkColumns: {id: $matchId}
    _set: {courtNumber: null, eventCourtId: null}
  ) {
    id
    eventCourtId
    courtNumber
  }
  updateEventCourtsByPk(pkColumns: {id: $courtId}, _set: {activeMatchId: null}) {
    activeMatchId
    id
  }
}
    `;
export type UpdateRemoveCourtFromMatchMutationFn = Apollo.MutationFunction<UpdateRemoveCourtFromMatchMutation, UpdateRemoveCourtFromMatchMutationVariables>;

/**
 * __useUpdateRemoveCourtFromMatchMutation__
 *
 * To run a mutation, you first call `useUpdateRemoveCourtFromMatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRemoveCourtFromMatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRemoveCourtFromMatchMutation, { data, loading, error }] = useUpdateRemoveCourtFromMatchMutation({
 *   variables: {
 *      matchId: // value for 'matchId'
 *      courtId: // value for 'courtId'
 *   },
 * });
 */
export function useUpdateRemoveCourtFromMatchMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRemoveCourtFromMatchMutation, UpdateRemoveCourtFromMatchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRemoveCourtFromMatchMutation, UpdateRemoveCourtFromMatchMutationVariables>(UpdateRemoveCourtFromMatchDocument, options);
      }
export type UpdateRemoveCourtFromMatchMutationHookResult = ReturnType<typeof useUpdateRemoveCourtFromMatchMutation>;
export type UpdateRemoveCourtFromMatchMutationResult = Apollo.MutationResult<UpdateRemoveCourtFromMatchMutation>;
export type UpdateRemoveCourtFromMatchMutationOptions = Apollo.BaseMutationOptions<UpdateRemoveCourtFromMatchMutation, UpdateRemoveCourtFromMatchMutationVariables>;
export const UpdateReleaseCourtsFromGroupDocument = gql`
    mutation updateReleaseCourtsFromGroup($activeEventGroupId: uuid!) {
  updateEventCourts(
    where: {activeEventGroupId: {_eq: $activeEventGroupId}}
    _set: {activeEventGroupId: null, activeEventGroupPoolId: null, activeMatchId: null}
  ) {
    returning {
      id
      activeEventGroupId
      activeEventGroupPoolId
      activeMatchId
    }
  }
}
    `;
export type UpdateReleaseCourtsFromGroupMutationFn = Apollo.MutationFunction<UpdateReleaseCourtsFromGroupMutation, UpdateReleaseCourtsFromGroupMutationVariables>;

/**
 * __useUpdateReleaseCourtsFromGroupMutation__
 *
 * To run a mutation, you first call `useUpdateReleaseCourtsFromGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateReleaseCourtsFromGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateReleaseCourtsFromGroupMutation, { data, loading, error }] = useUpdateReleaseCourtsFromGroupMutation({
 *   variables: {
 *      activeEventGroupId: // value for 'activeEventGroupId'
 *   },
 * });
 */
export function useUpdateReleaseCourtsFromGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReleaseCourtsFromGroupMutation, UpdateReleaseCourtsFromGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateReleaseCourtsFromGroupMutation, UpdateReleaseCourtsFromGroupMutationVariables>(UpdateReleaseCourtsFromGroupDocument, options);
      }
export type UpdateReleaseCourtsFromGroupMutationHookResult = ReturnType<typeof useUpdateReleaseCourtsFromGroupMutation>;
export type UpdateReleaseCourtsFromGroupMutationResult = Apollo.MutationResult<UpdateReleaseCourtsFromGroupMutation>;
export type UpdateReleaseCourtsFromGroupMutationOptions = Apollo.BaseMutationOptions<UpdateReleaseCourtsFromGroupMutation, UpdateReleaseCourtsFromGroupMutationVariables>;
export const UpdateCompleteSequenceDocument = gql`
    mutation updateCompleteSequence($id: uuid!) {
  updateEventGroupSequencesByPk(
    pkColumns: {id: $id}
    _set: {completeReason: ALL_SCORES, isSequenceComplete: true}
  ) {
    id
    isSequenceComplete
    completeReason
  }
}
    `;
export type UpdateCompleteSequenceMutationFn = Apollo.MutationFunction<UpdateCompleteSequenceMutation, UpdateCompleteSequenceMutationVariables>;

/**
 * __useUpdateCompleteSequenceMutation__
 *
 * To run a mutation, you first call `useUpdateCompleteSequenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCompleteSequenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCompleteSequenceMutation, { data, loading, error }] = useUpdateCompleteSequenceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUpdateCompleteSequenceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCompleteSequenceMutation, UpdateCompleteSequenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCompleteSequenceMutation, UpdateCompleteSequenceMutationVariables>(UpdateCompleteSequenceDocument, options);
      }
export type UpdateCompleteSequenceMutationHookResult = ReturnType<typeof useUpdateCompleteSequenceMutation>;
export type UpdateCompleteSequenceMutationResult = Apollo.MutationResult<UpdateCompleteSequenceMutation>;
export type UpdateCompleteSequenceMutationOptions = Apollo.BaseMutationOptions<UpdateCompleteSequenceMutation, UpdateCompleteSequenceMutationVariables>;
export const GetUserGroupsDocument = gql`
    query getUserGroups($id: uuid!) {
  usersByPk(id: $id) {
    id
    groups(where: {isActive: {_eq: true}}) {
      id
      isActive
      groupId
    }
  }
}
    `;

/**
 * __useGetUserGroupsQuery__
 *
 * To run a query within a React component, call `useGetUserGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserGroupsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserGroupsQuery(baseOptions: Apollo.QueryHookOptions<GetUserGroupsQuery, GetUserGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserGroupsQuery, GetUserGroupsQueryVariables>(GetUserGroupsDocument, options);
      }
export function useGetUserGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserGroupsQuery, GetUserGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserGroupsQuery, GetUserGroupsQueryVariables>(GetUserGroupsDocument, options);
        }
export type GetUserGroupsQueryHookResult = ReturnType<typeof useGetUserGroupsQuery>;
export type GetUserGroupsLazyQueryHookResult = ReturnType<typeof useGetUserGroupsLazyQuery>;
export type GetUserGroupsQueryResult = Apollo.QueryResult<GetUserGroupsQuery, GetUserGroupsQueryVariables>;
export const GetGroupByIdDocument = gql`
    query getGroupById($id: uuid!, $userId: uuid!) {
  groupsByPk(id: $id) {
    contactEmail
    contactMessage
    contactPhoneNumber
    contactUrl
    coverPhotoUrl
    createdAt
    description
    displayOwnerContactInfo
    headline
    id
    isPrivate
    ownerUserId
    profilePhotoUrl
    skillLevelMaximum
    skillLevelMinimum
    slug
    title
    allowMemberInvites
    allowMemberSessionInvites
    accessCode
    city {
      id
      name
    }
    threads(orderBy: {createdAt: DESC}, limit: 50) {
      createdAt
      id
      comments(orderBy: {createdAt: ASC}, limit: 1) {
        createdAt
        content
        groupCommentId
        groupRootCommentId
        groupThreadId
        id
        isOriginalThreadComment
        votesAggregate(where: {vote: {_eq: POSITIVE}}) {
          aggregate {
            count
          }
        }
        userProfile {
          id
          fullName
          preferredName
          profileImagePath
          username
          defaultSport
        }
        votes(where: {userId: {_eq: $userId}}) {
          id
          userId
          groupThreadCommentId
          vote
        }
        files {
          id
          url
          path
        }
      }
      commentsAggregate {
        aggregate {
          count
        }
      }
    }
    membersAggregate {
      aggregate {
        count
      }
    }
    ownerUserProfile {
      id
      fullName
      profileImagePath
    }
    venuesAggregate(where: {venue: {isActive: {_eq: true}}}) {
      aggregate {
        count
      }
    }
  }
}
    `;

/**
 * __useGetGroupByIdQuery__
 *
 * To run a query within a React component, call `useGetGroupByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGroupByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGroupByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetGroupByIdQuery(baseOptions: Apollo.QueryHookOptions<GetGroupByIdQuery, GetGroupByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGroupByIdQuery, GetGroupByIdQueryVariables>(GetGroupByIdDocument, options);
      }
export function useGetGroupByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGroupByIdQuery, GetGroupByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGroupByIdQuery, GetGroupByIdQueryVariables>(GetGroupByIdDocument, options);
        }
export type GetGroupByIdQueryHookResult = ReturnType<typeof useGetGroupByIdQuery>;
export type GetGroupByIdLazyQueryHookResult = ReturnType<typeof useGetGroupByIdLazyQuery>;
export type GetGroupByIdQueryResult = Apollo.QueryResult<GetGroupByIdQuery, GetGroupByIdQueryVariables>;
export const InsertThreadWithCommentDocument = gql`
    mutation insertThreadWithComment($groupId: uuid!, $userId: uuid!, $content: String = "", $files: [GroupThreadCommentFilesInsertInput!] = []) {
  insertGroupThreadsOne(
    object: {groupId: $groupId, userId: $userId, comments: {data: {userId: $userId, votes: {data: {vote: POSITIVE, userId: $userId}}, isOriginalThreadComment: true, content: $content, files: {data: $files}}}}
  ) {
    id
  }
}
    `;
export type InsertThreadWithCommentMutationFn = Apollo.MutationFunction<InsertThreadWithCommentMutation, InsertThreadWithCommentMutationVariables>;

/**
 * __useInsertThreadWithCommentMutation__
 *
 * To run a mutation, you first call `useInsertThreadWithCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertThreadWithCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertThreadWithCommentMutation, { data, loading, error }] = useInsertThreadWithCommentMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      userId: // value for 'userId'
 *      content: // value for 'content'
 *      files: // value for 'files'
 *   },
 * });
 */
export function useInsertThreadWithCommentMutation(baseOptions?: Apollo.MutationHookOptions<InsertThreadWithCommentMutation, InsertThreadWithCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertThreadWithCommentMutation, InsertThreadWithCommentMutationVariables>(InsertThreadWithCommentDocument, options);
      }
export type InsertThreadWithCommentMutationHookResult = ReturnType<typeof useInsertThreadWithCommentMutation>;
export type InsertThreadWithCommentMutationResult = Apollo.MutationResult<InsertThreadWithCommentMutation>;
export type InsertThreadWithCommentMutationOptions = Apollo.BaseMutationOptions<InsertThreadWithCommentMutation, InsertThreadWithCommentMutationVariables>;
export const UpdateCommentFileAsDeletedDocument = gql`
    mutation updateCommentFileAsDeleted($id: uuid!) {
  updateGroupThreadCommentFilesByPk(
    pkColumns: {id: $id}
    _set: {deletedAt: "now()"}
  ) {
    id
    deletedAt
  }
}
    `;
export type UpdateCommentFileAsDeletedMutationFn = Apollo.MutationFunction<UpdateCommentFileAsDeletedMutation, UpdateCommentFileAsDeletedMutationVariables>;

/**
 * __useUpdateCommentFileAsDeletedMutation__
 *
 * To run a mutation, you first call `useUpdateCommentFileAsDeletedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCommentFileAsDeletedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCommentFileAsDeletedMutation, { data, loading, error }] = useUpdateCommentFileAsDeletedMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUpdateCommentFileAsDeletedMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCommentFileAsDeletedMutation, UpdateCommentFileAsDeletedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCommentFileAsDeletedMutation, UpdateCommentFileAsDeletedMutationVariables>(UpdateCommentFileAsDeletedDocument, options);
      }
export type UpdateCommentFileAsDeletedMutationHookResult = ReturnType<typeof useUpdateCommentFileAsDeletedMutation>;
export type UpdateCommentFileAsDeletedMutationResult = Apollo.MutationResult<UpdateCommentFileAsDeletedMutation>;
export type UpdateCommentFileAsDeletedMutationOptions = Apollo.BaseMutationOptions<UpdateCommentFileAsDeletedMutation, UpdateCommentFileAsDeletedMutationVariables>;
export const GetGroupMembersDocument = gql`
    query getGroupMembers($id: uuid!) {
  groupsByPk(id: $id) {
    id
    members {
      userProfile {
        id
        preferredName
        fullName
        profileImagePath
        username
      }
    }
  }
}
    `;

/**
 * __useGetGroupMembersQuery__
 *
 * To run a query within a React component, call `useGetGroupMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGroupMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGroupMembersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGroupMembersQuery(baseOptions: Apollo.QueryHookOptions<GetGroupMembersQuery, GetGroupMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGroupMembersQuery, GetGroupMembersQueryVariables>(GetGroupMembersDocument, options);
      }
export function useGetGroupMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGroupMembersQuery, GetGroupMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGroupMembersQuery, GetGroupMembersQueryVariables>(GetGroupMembersDocument, options);
        }
export type GetGroupMembersQueryHookResult = ReturnType<typeof useGetGroupMembersQuery>;
export type GetGroupMembersLazyQueryHookResult = ReturnType<typeof useGetGroupMembersLazyQuery>;
export type GetGroupMembersQueryResult = Apollo.QueryResult<GetGroupMembersQuery, GetGroupMembersQueryVariables>;
export const GetUserAvailableLessonContentDocument = gql`
    query getUserAvailableLessonContent($id: uuid!) {
  usersByPk(id: $id) {
    id
    customCourts(orderBy: {createdAt: DESC}) {
      createdAt
      deletedAt
      fullAddress
      id
      title
    }
    lessonTemplates {
      coverImageUrl
      createdAt
      currency
      deletedAt
      description
      id
      originalLessonId
      participantLimit
      priceUnitAmount
      privacy
      templateName
      title
      type
      typeCustom
      updatedAt
      userId
      userCustomCourtId
      sport
    }
  }
}
    `;

/**
 * __useGetUserAvailableLessonContentQuery__
 *
 * To run a query within a React component, call `useGetUserAvailableLessonContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserAvailableLessonContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserAvailableLessonContentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserAvailableLessonContentQuery(baseOptions: Apollo.QueryHookOptions<GetUserAvailableLessonContentQuery, GetUserAvailableLessonContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserAvailableLessonContentQuery, GetUserAvailableLessonContentQueryVariables>(GetUserAvailableLessonContentDocument, options);
      }
export function useGetUserAvailableLessonContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserAvailableLessonContentQuery, GetUserAvailableLessonContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserAvailableLessonContentQuery, GetUserAvailableLessonContentQueryVariables>(GetUserAvailableLessonContentDocument, options);
        }
export type GetUserAvailableLessonContentQueryHookResult = ReturnType<typeof useGetUserAvailableLessonContentQuery>;
export type GetUserAvailableLessonContentLazyQueryHookResult = ReturnType<typeof useGetUserAvailableLessonContentLazyQuery>;
export type GetUserAvailableLessonContentQueryResult = Apollo.QueryResult<GetUserAvailableLessonContentQuery, GetUserAvailableLessonContentQueryVariables>;
export const InsertNewLessonWithNewCourtDocument = gql`
    mutation insertNewLessonWithNewCourt($title: String!, $type: LessonTypesEnum!, $typeCustom: String = "", $status: LessonStatusesEnum = PENDING, $description: String!, $startDateTime: timestamptz!, $endDateTime: timestamptz!, $ownerUserId: uuid!, $participantLimit: Int!, $paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum!, $priceUnitAmount: Int!, $privacy: LessonPrivacyEnum = PUBLIC, $coverImageUrl: String = "", $usedTemplateId: uuid, $lessonTimeData: [LessonTimesInsertInput!]!, $customCourtData: UserCustomCourtsInsertInput!, $lessonEquipment: [LessonEquipmentInsertInput!] = [], $locale: String!, $timezoneName: String!, $timezoneAbbreviation: String!, $timezoneOffsetMinutes: Int!, $sport: SportsEnum!) {
  insertLessonsOne(
    object: {title: $title, sport: $sport, type: $type, typeCustom: $typeCustom, status: $status, startDateTime: $startDateTime, endDateTime: $endDateTime, description: $description, ownerUserId: $ownerUserId, participantLimit: $participantLimit, paymentFulfillmentChannel: $paymentFulfillmentChannel, priceUnitAmount: $priceUnitAmount, privacy: $privacy, coverImageUrl: $coverImageUrl, usedTemplateId: $usedTemplateId, locale: $locale, timezoneName: $timezoneName, timezoneAbbreviation: $timezoneAbbreviation, timezoneOffsetMinutes: $timezoneOffsetMinutes, times: {data: $lessonTimeData}, userCustomCourt: {data: $customCourtData}, equipment: {data: $lessonEquipment, onConflict: {constraint: lesson_equipment_lesson_id_equipment_option_id_key, updateColumns: deletedAt}}}
  ) {
    ...lessonFields
  }
}
    ${LessonFieldsFragmentDoc}`;
export type InsertNewLessonWithNewCourtMutationFn = Apollo.MutationFunction<InsertNewLessonWithNewCourtMutation, InsertNewLessonWithNewCourtMutationVariables>;

/**
 * __useInsertNewLessonWithNewCourtMutation__
 *
 * To run a mutation, you first call `useInsertNewLessonWithNewCourtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNewLessonWithNewCourtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNewLessonWithNewCourtMutation, { data, loading, error }] = useInsertNewLessonWithNewCourtMutation({
 *   variables: {
 *      title: // value for 'title'
 *      type: // value for 'type'
 *      typeCustom: // value for 'typeCustom'
 *      status: // value for 'status'
 *      description: // value for 'description'
 *      startDateTime: // value for 'startDateTime'
 *      endDateTime: // value for 'endDateTime'
 *      ownerUserId: // value for 'ownerUserId'
 *      participantLimit: // value for 'participantLimit'
 *      paymentFulfillmentChannel: // value for 'paymentFulfillmentChannel'
 *      priceUnitAmount: // value for 'priceUnitAmount'
 *      privacy: // value for 'privacy'
 *      coverImageUrl: // value for 'coverImageUrl'
 *      usedTemplateId: // value for 'usedTemplateId'
 *      lessonTimeData: // value for 'lessonTimeData'
 *      customCourtData: // value for 'customCourtData'
 *      lessonEquipment: // value for 'lessonEquipment'
 *      locale: // value for 'locale'
 *      timezoneName: // value for 'timezoneName'
 *      timezoneAbbreviation: // value for 'timezoneAbbreviation'
 *      timezoneOffsetMinutes: // value for 'timezoneOffsetMinutes'
 *      sport: // value for 'sport'
 *   },
 * });
 */
export function useInsertNewLessonWithNewCourtMutation(baseOptions?: Apollo.MutationHookOptions<InsertNewLessonWithNewCourtMutation, InsertNewLessonWithNewCourtMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNewLessonWithNewCourtMutation, InsertNewLessonWithNewCourtMutationVariables>(InsertNewLessonWithNewCourtDocument, options);
      }
export type InsertNewLessonWithNewCourtMutationHookResult = ReturnType<typeof useInsertNewLessonWithNewCourtMutation>;
export type InsertNewLessonWithNewCourtMutationResult = Apollo.MutationResult<InsertNewLessonWithNewCourtMutation>;
export type InsertNewLessonWithNewCourtMutationOptions = Apollo.BaseMutationOptions<InsertNewLessonWithNewCourtMutation, InsertNewLessonWithNewCourtMutationVariables>;
export const InsertNewLessonWithExistingCourtDocument = gql`
    mutation insertNewLessonWithExistingCourt($title: String!, $sport: SportsEnum!, $type: LessonTypesEnum!, $typeCustom: String = "", $status: LessonStatusesEnum = PENDING, $description: String!, $startDateTime: timestamptz!, $endDateTime: timestamptz!, $ownerUserId: uuid!, $participantLimit: Int!, $paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum!, $priceUnitAmount: Int!, $privacy: LessonPrivacyEnum = PUBLIC, $coverImageUrl: String = "", $usedTemplateId: uuid, $lessonTimeData: [LessonTimesInsertInput!]!, $userCustomCourtId: uuid, $lessonEquipment: [LessonEquipmentInsertInput!] = [], $locale: String!, $timezoneName: String!, $timezoneAbbreviation: String!, $timezoneOffsetMinutes: Int!) {
  insertLessonsOne(
    object: {title: $title, sport: $sport, type: $type, typeCustom: $typeCustom, status: $status, startDateTime: $startDateTime, endDateTime: $endDateTime, description: $description, ownerUserId: $ownerUserId, participantLimit: $participantLimit, paymentFulfillmentChannel: $paymentFulfillmentChannel, priceUnitAmount: $priceUnitAmount, privacy: $privacy, coverImageUrl: $coverImageUrl, usedTemplateId: $usedTemplateId, locale: $locale, timezoneName: $timezoneName, timezoneAbbreviation: $timezoneAbbreviation, timezoneOffsetMinutes: $timezoneOffsetMinutes, times: {data: $lessonTimeData}, userCustomCourtId: $userCustomCourtId, equipment: {data: $lessonEquipment, onConflict: {constraint: lesson_equipment_lesson_id_equipment_option_id_key, updateColumns: deletedAt}}}
  ) {
    ...lessonFields
  }
}
    ${LessonFieldsFragmentDoc}`;
export type InsertNewLessonWithExistingCourtMutationFn = Apollo.MutationFunction<InsertNewLessonWithExistingCourtMutation, InsertNewLessonWithExistingCourtMutationVariables>;

/**
 * __useInsertNewLessonWithExistingCourtMutation__
 *
 * To run a mutation, you first call `useInsertNewLessonWithExistingCourtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNewLessonWithExistingCourtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNewLessonWithExistingCourtMutation, { data, loading, error }] = useInsertNewLessonWithExistingCourtMutation({
 *   variables: {
 *      title: // value for 'title'
 *      sport: // value for 'sport'
 *      type: // value for 'type'
 *      typeCustom: // value for 'typeCustom'
 *      status: // value for 'status'
 *      description: // value for 'description'
 *      startDateTime: // value for 'startDateTime'
 *      endDateTime: // value for 'endDateTime'
 *      ownerUserId: // value for 'ownerUserId'
 *      participantLimit: // value for 'participantLimit'
 *      paymentFulfillmentChannel: // value for 'paymentFulfillmentChannel'
 *      priceUnitAmount: // value for 'priceUnitAmount'
 *      privacy: // value for 'privacy'
 *      coverImageUrl: // value for 'coverImageUrl'
 *      usedTemplateId: // value for 'usedTemplateId'
 *      lessonTimeData: // value for 'lessonTimeData'
 *      userCustomCourtId: // value for 'userCustomCourtId'
 *      lessonEquipment: // value for 'lessonEquipment'
 *      locale: // value for 'locale'
 *      timezoneName: // value for 'timezoneName'
 *      timezoneAbbreviation: // value for 'timezoneAbbreviation'
 *      timezoneOffsetMinutes: // value for 'timezoneOffsetMinutes'
 *   },
 * });
 */
export function useInsertNewLessonWithExistingCourtMutation(baseOptions?: Apollo.MutationHookOptions<InsertNewLessonWithExistingCourtMutation, InsertNewLessonWithExistingCourtMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNewLessonWithExistingCourtMutation, InsertNewLessonWithExistingCourtMutationVariables>(InsertNewLessonWithExistingCourtDocument, options);
      }
export type InsertNewLessonWithExistingCourtMutationHookResult = ReturnType<typeof useInsertNewLessonWithExistingCourtMutation>;
export type InsertNewLessonWithExistingCourtMutationResult = Apollo.MutationResult<InsertNewLessonWithExistingCourtMutation>;
export type InsertNewLessonWithExistingCourtMutationOptions = Apollo.BaseMutationOptions<InsertNewLessonWithExistingCourtMutation, InsertNewLessonWithExistingCourtMutationVariables>;
export const InsertUserCustomCourtDocument = gql`
    mutation insertUserCustomCourt($customCourtData: UserCustomCourtsInsertInput!) {
  insertUserCustomCourtsOne(object: $customCourtData) {
    id
  }
}
    `;
export type InsertUserCustomCourtMutationFn = Apollo.MutationFunction<InsertUserCustomCourtMutation, InsertUserCustomCourtMutationVariables>;

/**
 * __useInsertUserCustomCourtMutation__
 *
 * To run a mutation, you first call `useInsertUserCustomCourtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertUserCustomCourtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertUserCustomCourtMutation, { data, loading, error }] = useInsertUserCustomCourtMutation({
 *   variables: {
 *      customCourtData: // value for 'customCourtData'
 *   },
 * });
 */
export function useInsertUserCustomCourtMutation(baseOptions?: Apollo.MutationHookOptions<InsertUserCustomCourtMutation, InsertUserCustomCourtMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertUserCustomCourtMutation, InsertUserCustomCourtMutationVariables>(InsertUserCustomCourtDocument, options);
      }
export type InsertUserCustomCourtMutationHookResult = ReturnType<typeof useInsertUserCustomCourtMutation>;
export type InsertUserCustomCourtMutationResult = Apollo.MutationResult<InsertUserCustomCourtMutation>;
export type InsertUserCustomCourtMutationOptions = Apollo.BaseMutationOptions<InsertUserCustomCourtMutation, InsertUserCustomCourtMutationVariables>;
export const UpdateLessonTimesDocument = gql`
    mutation updateLessonTimes($lessonId: uuid!, $lessonTimeData: [LessonTimesInsertInput!]!) {
  deleteLessonTimes(where: {lessonId: {_eq: $lessonId}}) {
    affectedRows
  }
  insertLessonTimes(objects: $lessonTimeData) {
    affectedRows
  }
}
    `;
export type UpdateLessonTimesMutationFn = Apollo.MutationFunction<UpdateLessonTimesMutation, UpdateLessonTimesMutationVariables>;

/**
 * __useUpdateLessonTimesMutation__
 *
 * To run a mutation, you first call `useUpdateLessonTimesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLessonTimesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLessonTimesMutation, { data, loading, error }] = useUpdateLessonTimesMutation({
 *   variables: {
 *      lessonId: // value for 'lessonId'
 *      lessonTimeData: // value for 'lessonTimeData'
 *   },
 * });
 */
export function useUpdateLessonTimesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLessonTimesMutation, UpdateLessonTimesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLessonTimesMutation, UpdateLessonTimesMutationVariables>(UpdateLessonTimesDocument, options);
      }
export type UpdateLessonTimesMutationHookResult = ReturnType<typeof useUpdateLessonTimesMutation>;
export type UpdateLessonTimesMutationResult = Apollo.MutationResult<UpdateLessonTimesMutation>;
export type UpdateLessonTimesMutationOptions = Apollo.BaseMutationOptions<UpdateLessonTimesMutation, UpdateLessonTimesMutationVariables>;
export const UpdateLessonEquipmentDocument = gql`
    mutation updateLessonEquipment($lessonId: uuid!, $lessonEquipmentData: [LessonEquipmentInsertInput!] = []) {
  deleteLessonEquipment(where: {lessonId: {_eq: $lessonId}}) {
    affectedRows
  }
  insertLessonEquipment(objects: $lessonEquipmentData) {
    affectedRows
  }
}
    `;
export type UpdateLessonEquipmentMutationFn = Apollo.MutationFunction<UpdateLessonEquipmentMutation, UpdateLessonEquipmentMutationVariables>;

/**
 * __useUpdateLessonEquipmentMutation__
 *
 * To run a mutation, you first call `useUpdateLessonEquipmentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLessonEquipmentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLessonEquipmentMutation, { data, loading, error }] = useUpdateLessonEquipmentMutation({
 *   variables: {
 *      lessonId: // value for 'lessonId'
 *      lessonEquipmentData: // value for 'lessonEquipmentData'
 *   },
 * });
 */
export function useUpdateLessonEquipmentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLessonEquipmentMutation, UpdateLessonEquipmentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLessonEquipmentMutation, UpdateLessonEquipmentMutationVariables>(UpdateLessonEquipmentDocument, options);
      }
export type UpdateLessonEquipmentMutationHookResult = ReturnType<typeof useUpdateLessonEquipmentMutation>;
export type UpdateLessonEquipmentMutationResult = Apollo.MutationResult<UpdateLessonEquipmentMutation>;
export type UpdateLessonEquipmentMutationOptions = Apollo.BaseMutationOptions<UpdateLessonEquipmentMutation, UpdateLessonEquipmentMutationVariables>;
export const UpdateNewLessonByIdDocument = gql`
    mutation updateNewLessonById($lessonId: uuid!, $title: String!, $sport: SportsEnum!, $type: LessonTypesEnum!, $typeCustom: String = "", $status: LessonStatusesEnum = PENDING, $description: String!, $startDateTime: timestamptz!, $endDateTime: timestamptz!, $participantLimit: Int!, $paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum!, $priceUnitAmount: Int!, $privacy: LessonPrivacyEnum = PUBLIC, $coverImageUrl: String = "", $usedTemplateId: uuid, $userCustomCourtId: uuid!) {
  updateLessonsByPk(
    pkColumns: {id: $lessonId}
    _set: {title: $title, sport: $sport, type: $type, typeCustom: $typeCustom, status: $status, startDateTime: $startDateTime, endDateTime: $endDateTime, description: $description, participantLimit: $participantLimit, paymentFulfillmentChannel: $paymentFulfillmentChannel, priceUnitAmount: $priceUnitAmount, privacy: $privacy, coverImageUrl: $coverImageUrl, usedTemplateId: $usedTemplateId, userCustomCourtId: $userCustomCourtId}
  ) {
    ...lessonFields
  }
}
    ${LessonFieldsFragmentDoc}`;
export type UpdateNewLessonByIdMutationFn = Apollo.MutationFunction<UpdateNewLessonByIdMutation, UpdateNewLessonByIdMutationVariables>;

/**
 * __useUpdateNewLessonByIdMutation__
 *
 * To run a mutation, you first call `useUpdateNewLessonByIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNewLessonByIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNewLessonByIdMutation, { data, loading, error }] = useUpdateNewLessonByIdMutation({
 *   variables: {
 *      lessonId: // value for 'lessonId'
 *      title: // value for 'title'
 *      sport: // value for 'sport'
 *      type: // value for 'type'
 *      typeCustom: // value for 'typeCustom'
 *      status: // value for 'status'
 *      description: // value for 'description'
 *      startDateTime: // value for 'startDateTime'
 *      endDateTime: // value for 'endDateTime'
 *      participantLimit: // value for 'participantLimit'
 *      paymentFulfillmentChannel: // value for 'paymentFulfillmentChannel'
 *      priceUnitAmount: // value for 'priceUnitAmount'
 *      privacy: // value for 'privacy'
 *      coverImageUrl: // value for 'coverImageUrl'
 *      usedTemplateId: // value for 'usedTemplateId'
 *      userCustomCourtId: // value for 'userCustomCourtId'
 *   },
 * });
 */
export function useUpdateNewLessonByIdMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNewLessonByIdMutation, UpdateNewLessonByIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNewLessonByIdMutation, UpdateNewLessonByIdMutationVariables>(UpdateNewLessonByIdDocument, options);
      }
export type UpdateNewLessonByIdMutationHookResult = ReturnType<typeof useUpdateNewLessonByIdMutation>;
export type UpdateNewLessonByIdMutationResult = Apollo.MutationResult<UpdateNewLessonByIdMutation>;
export type UpdateNewLessonByIdMutationOptions = Apollo.BaseMutationOptions<UpdateNewLessonByIdMutation, UpdateNewLessonByIdMutationVariables>;
export const UpdateExistingLessonByIdDocument = gql`
    mutation updateExistingLessonById($lessonId: uuid!, $title: String!, $description: String!, $sport: SportsEnum = TENNIS, $paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum!, $participantLimit: Int!) {
  updateLessonsByPk(
    pkColumns: {id: $lessonId}
    _set: {title: $title, description: $description, sport: $sport, paymentFulfillmentChannel: $paymentFulfillmentChannel, participantLimit: $participantLimit}
  ) {
    ...lessonFields
  }
}
    ${LessonFieldsFragmentDoc}`;
export type UpdateExistingLessonByIdMutationFn = Apollo.MutationFunction<UpdateExistingLessonByIdMutation, UpdateExistingLessonByIdMutationVariables>;

/**
 * __useUpdateExistingLessonByIdMutation__
 *
 * To run a mutation, you first call `useUpdateExistingLessonByIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateExistingLessonByIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateExistingLessonByIdMutation, { data, loading, error }] = useUpdateExistingLessonByIdMutation({
 *   variables: {
 *      lessonId: // value for 'lessonId'
 *      title: // value for 'title'
 *      description: // value for 'description'
 *      sport: // value for 'sport'
 *      paymentFulfillmentChannel: // value for 'paymentFulfillmentChannel'
 *      participantLimit: // value for 'participantLimit'
 *   },
 * });
 */
export function useUpdateExistingLessonByIdMutation(baseOptions?: Apollo.MutationHookOptions<UpdateExistingLessonByIdMutation, UpdateExistingLessonByIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateExistingLessonByIdMutation, UpdateExistingLessonByIdMutationVariables>(UpdateExistingLessonByIdDocument, options);
      }
export type UpdateExistingLessonByIdMutationHookResult = ReturnType<typeof useUpdateExistingLessonByIdMutation>;
export type UpdateExistingLessonByIdMutationResult = Apollo.MutationResult<UpdateExistingLessonByIdMutation>;
export type UpdateExistingLessonByIdMutationOptions = Apollo.BaseMutationOptions<UpdateExistingLessonByIdMutation, UpdateExistingLessonByIdMutationVariables>;
export const UpdateUserDefaultCoachPaymentFulfillmentChannelDocument = gql`
    mutation updateUserDefaultCoachPaymentFulfillmentChannel($id: uuid!, $defaultCoachPaymentFulfillmentChannel: PaymentFulfillmentChannelsEnum!) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {defaultCoachPaymentFulfillmentChannel: $defaultCoachPaymentFulfillmentChannel}
  ) {
    defaultCoachPaymentFulfillmentChannel
    id
  }
}
    `;
export type UpdateUserDefaultCoachPaymentFulfillmentChannelMutationFn = Apollo.MutationFunction<UpdateUserDefaultCoachPaymentFulfillmentChannelMutation, UpdateUserDefaultCoachPaymentFulfillmentChannelMutationVariables>;

/**
 * __useUpdateUserDefaultCoachPaymentFulfillmentChannelMutation__
 *
 * To run a mutation, you first call `useUpdateUserDefaultCoachPaymentFulfillmentChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserDefaultCoachPaymentFulfillmentChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserDefaultCoachPaymentFulfillmentChannelMutation, { data, loading, error }] = useUpdateUserDefaultCoachPaymentFulfillmentChannelMutation({
 *   variables: {
 *      id: // value for 'id'
 *      defaultCoachPaymentFulfillmentChannel: // value for 'defaultCoachPaymentFulfillmentChannel'
 *   },
 * });
 */
export function useUpdateUserDefaultCoachPaymentFulfillmentChannelMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserDefaultCoachPaymentFulfillmentChannelMutation, UpdateUserDefaultCoachPaymentFulfillmentChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserDefaultCoachPaymentFulfillmentChannelMutation, UpdateUserDefaultCoachPaymentFulfillmentChannelMutationVariables>(UpdateUserDefaultCoachPaymentFulfillmentChannelDocument, options);
      }
export type UpdateUserDefaultCoachPaymentFulfillmentChannelMutationHookResult = ReturnType<typeof useUpdateUserDefaultCoachPaymentFulfillmentChannelMutation>;
export type UpdateUserDefaultCoachPaymentFulfillmentChannelMutationResult = Apollo.MutationResult<UpdateUserDefaultCoachPaymentFulfillmentChannelMutation>;
export type UpdateUserDefaultCoachPaymentFulfillmentChannelMutationOptions = Apollo.BaseMutationOptions<UpdateUserDefaultCoachPaymentFulfillmentChannelMutation, UpdateUserDefaultCoachPaymentFulfillmentChannelMutationVariables>;
export const GetUserCreditCardsDocument = gql`
    query getUserCreditCards($userId: uuid!) {
  userCreditCards(where: {userId: {_eq: $userId}}, orderBy: {updatedAt: DESC}) {
    id
    last4
    provider
    providerCardId
    expireYear
    expireMonth
    brand
    billingName
    billingPostalCode
  }
}
    `;

/**
 * __useGetUserCreditCardsQuery__
 *
 * To run a query within a React component, call `useGetUserCreditCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserCreditCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserCreditCardsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserCreditCardsQuery(baseOptions: Apollo.QueryHookOptions<GetUserCreditCardsQuery, GetUserCreditCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserCreditCardsQuery, GetUserCreditCardsQueryVariables>(GetUserCreditCardsDocument, options);
      }
export function useGetUserCreditCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserCreditCardsQuery, GetUserCreditCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserCreditCardsQuery, GetUserCreditCardsQueryVariables>(GetUserCreditCardsDocument, options);
        }
export type GetUserCreditCardsQueryHookResult = ReturnType<typeof useGetUserCreditCardsQuery>;
export type GetUserCreditCardsLazyQueryHookResult = ReturnType<typeof useGetUserCreditCardsLazyQuery>;
export type GetUserCreditCardsQueryResult = Apollo.QueryResult<GetUserCreditCardsQuery, GetUserCreditCardsQueryVariables>;
export const SetLessonAsActiveDocument = gql`
    mutation setLessonAsActive($id: uuid!) {
  updateLessonsByPk(
    pkColumns: {id: $id}
    _set: {status: ACTIVE, publishedAt: "now()"}
  ) {
    id
    status
    publishedAt
  }
}
    `;
export type SetLessonAsActiveMutationFn = Apollo.MutationFunction<SetLessonAsActiveMutation, SetLessonAsActiveMutationVariables>;

/**
 * __useSetLessonAsActiveMutation__
 *
 * To run a mutation, you first call `useSetLessonAsActiveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetLessonAsActiveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setLessonAsActiveMutation, { data, loading, error }] = useSetLessonAsActiveMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSetLessonAsActiveMutation(baseOptions?: Apollo.MutationHookOptions<SetLessonAsActiveMutation, SetLessonAsActiveMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetLessonAsActiveMutation, SetLessonAsActiveMutationVariables>(SetLessonAsActiveDocument, options);
      }
export type SetLessonAsActiveMutationHookResult = ReturnType<typeof useSetLessonAsActiveMutation>;
export type SetLessonAsActiveMutationResult = Apollo.MutationResult<SetLessonAsActiveMutation>;
export type SetLessonAsActiveMutationOptions = Apollo.BaseMutationOptions<SetLessonAsActiveMutation, SetLessonAsActiveMutationVariables>;
export const InsertLessonTemplateDocument = gql`
    mutation insertLessonTemplate($coverImageUrl: String = "", $currency: String!, $description: String!, $originalLessonId: uuid!, $participantLimit: Int!, $priceUnitAmount: Int!, $privacy: LessonPrivacyEnum!, $templateName: String!, $title: String!, $type: LessonTypesEnum!, $typeCustom: String!, $userId: uuid!, $userCustomCourtId: uuid!, $sport: SportsEnum!) {
  insertLessonTemplatesOne(
    object: {coverImageUrl: $coverImageUrl, currency: $currency, description: $description, originalLessonId: $originalLessonId, participantLimit: $participantLimit, priceUnitAmount: $priceUnitAmount, privacy: $privacy, templateName: $templateName, title: $title, type: $type, typeCustom: $typeCustom, userId: $userId, userCustomCourtId: $userCustomCourtId, sport: $sport}
  ) {
    id
    type
    title
    templateName
    coverImageUrl
    currency
    description
    originalLessonId
    participantLimit
    priceUnitAmount
    privacy
    templateName
    type
    typeCustom
    userId
    userCustomCourtId
    sport
  }
}
    `;
export type InsertLessonTemplateMutationFn = Apollo.MutationFunction<InsertLessonTemplateMutation, InsertLessonTemplateMutationVariables>;

/**
 * __useInsertLessonTemplateMutation__
 *
 * To run a mutation, you first call `useInsertLessonTemplateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertLessonTemplateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertLessonTemplateMutation, { data, loading, error }] = useInsertLessonTemplateMutation({
 *   variables: {
 *      coverImageUrl: // value for 'coverImageUrl'
 *      currency: // value for 'currency'
 *      description: // value for 'description'
 *      originalLessonId: // value for 'originalLessonId'
 *      participantLimit: // value for 'participantLimit'
 *      priceUnitAmount: // value for 'priceUnitAmount'
 *      privacy: // value for 'privacy'
 *      templateName: // value for 'templateName'
 *      title: // value for 'title'
 *      type: // value for 'type'
 *      typeCustom: // value for 'typeCustom'
 *      userId: // value for 'userId'
 *      userCustomCourtId: // value for 'userCustomCourtId'
 *      sport: // value for 'sport'
 *   },
 * });
 */
export function useInsertLessonTemplateMutation(baseOptions?: Apollo.MutationHookOptions<InsertLessonTemplateMutation, InsertLessonTemplateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertLessonTemplateMutation, InsertLessonTemplateMutationVariables>(InsertLessonTemplateDocument, options);
      }
export type InsertLessonTemplateMutationHookResult = ReturnType<typeof useInsertLessonTemplateMutation>;
export type InsertLessonTemplateMutationResult = Apollo.MutationResult<InsertLessonTemplateMutation>;
export type InsertLessonTemplateMutationOptions = Apollo.BaseMutationOptions<InsertLessonTemplateMutation, InsertLessonTemplateMutationVariables>;
export const GetLessonParticipantOrderDetailsDocument = gql`
    query getLessonParticipantOrderDetails($userId: uuid!, $lessonId: uuid!) {
  lessonParticipants(where: {userId: {_eq: $userId}, lessonId: {_eq: $lessonId}}) {
    id
    userId
    lessonId
    status
    paymentFulfillmentChannel
    orderItems {
      id
      status
      totalUnitAmount
      order {
        paidUnitAmount
        refundUnitAmount
        status
        orderTotalUnitAmount
        orderSubtotalUnitAmount
      }
      priceUnitAmount
    }
  }
}
    `;

/**
 * __useGetLessonParticipantOrderDetailsQuery__
 *
 * To run a query within a React component, call `useGetLessonParticipantOrderDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLessonParticipantOrderDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLessonParticipantOrderDetailsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      lessonId: // value for 'lessonId'
 *   },
 * });
 */
export function useGetLessonParticipantOrderDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetLessonParticipantOrderDetailsQuery, GetLessonParticipantOrderDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLessonParticipantOrderDetailsQuery, GetLessonParticipantOrderDetailsQueryVariables>(GetLessonParticipantOrderDetailsDocument, options);
      }
export function useGetLessonParticipantOrderDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLessonParticipantOrderDetailsQuery, GetLessonParticipantOrderDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLessonParticipantOrderDetailsQuery, GetLessonParticipantOrderDetailsQueryVariables>(GetLessonParticipantOrderDetailsDocument, options);
        }
export type GetLessonParticipantOrderDetailsQueryHookResult = ReturnType<typeof useGetLessonParticipantOrderDetailsQuery>;
export type GetLessonParticipantOrderDetailsLazyQueryHookResult = ReturnType<typeof useGetLessonParticipantOrderDetailsLazyQuery>;
export type GetLessonParticipantOrderDetailsQueryResult = Apollo.QueryResult<GetLessonParticipantOrderDetailsQuery, GetLessonParticipantOrderDetailsQueryVariables>;
export const GetLessonWaitlistDocument = gql`
    query getLessonWaitlist($lessonId: uuid!) {
  lessonWaitlists(where: {lessonId: {_eq: $lessonId}, status: {_eq: ACTIVE}}) {
    id
    status
    userId
    userProfile {
      id
      fullName
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      username
    }
  }
}
    `;

/**
 * __useGetLessonWaitlistQuery__
 *
 * To run a query within a React component, call `useGetLessonWaitlistQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLessonWaitlistQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLessonWaitlistQuery({
 *   variables: {
 *      lessonId: // value for 'lessonId'
 *   },
 * });
 */
export function useGetLessonWaitlistQuery(baseOptions: Apollo.QueryHookOptions<GetLessonWaitlistQuery, GetLessonWaitlistQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLessonWaitlistQuery, GetLessonWaitlistQueryVariables>(GetLessonWaitlistDocument, options);
      }
export function useGetLessonWaitlistLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLessonWaitlistQuery, GetLessonWaitlistQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLessonWaitlistQuery, GetLessonWaitlistQueryVariables>(GetLessonWaitlistDocument, options);
        }
export type GetLessonWaitlistQueryHookResult = ReturnType<typeof useGetLessonWaitlistQuery>;
export type GetLessonWaitlistLazyQueryHookResult = ReturnType<typeof useGetLessonWaitlistLazyQuery>;
export type GetLessonWaitlistQueryResult = Apollo.QueryResult<GetLessonWaitlistQuery, GetLessonWaitlistQueryVariables>;
export const UpsertLessonWaitlistDocument = gql`
    mutation upsertLessonWaitlist($userId: uuid!, $lessonId: uuid!, $status: LessonWaitlistStatusesEnum!) {
  insertLessonWaitlistsOne(
    object: {userId: $userId, lessonId: $lessonId, status: $status}
    onConflict: {constraint: lesson_waitlists_user_id_lesson_id_key, updateColumns: status}
  ) {
    lessonId
    status
    userId
    id
  }
}
    `;
export type UpsertLessonWaitlistMutationFn = Apollo.MutationFunction<UpsertLessonWaitlistMutation, UpsertLessonWaitlistMutationVariables>;

/**
 * __useUpsertLessonWaitlistMutation__
 *
 * To run a mutation, you first call `useUpsertLessonWaitlistMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertLessonWaitlistMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertLessonWaitlistMutation, { data, loading, error }] = useUpsertLessonWaitlistMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      lessonId: // value for 'lessonId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useUpsertLessonWaitlistMutation(baseOptions?: Apollo.MutationHookOptions<UpsertLessonWaitlistMutation, UpsertLessonWaitlistMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertLessonWaitlistMutation, UpsertLessonWaitlistMutationVariables>(UpsertLessonWaitlistDocument, options);
      }
export type UpsertLessonWaitlistMutationHookResult = ReturnType<typeof useUpsertLessonWaitlistMutation>;
export type UpsertLessonWaitlistMutationResult = Apollo.MutationResult<UpsertLessonWaitlistMutation>;
export type UpsertLessonWaitlistMutationOptions = Apollo.BaseMutationOptions<UpsertLessonWaitlistMutation, UpsertLessonWaitlistMutationVariables>;
export const GetUserCommunicationPreferencesDocument = gql`
    query getUserCommunicationPreferences($id: uuid!) {
  usersByPk(id: $id) {
    id
    coachStatus
    communicationPreferences {
      id
      lessonBookedEmail
      lessonBookedPush
      lessonCanceledEmail
      lessonCanceledPushed
      lessonReminderEmail
      lessonReminderPush
      marketingEmail
      marketingPush
      newFollowerEmail
      newFollowerPush
      newLessonPublishedEmail
      newLessonPublishedPush
      participantLeftLessonEmail
      participantLeftLessonPush
      payoutEmail
      payoutPush
      playSessionCanceledEmail
      playSessionCanceledPush
      playSessionParticipantJoinedEmail
      playSessionParticipantJoinedPush
      playSessionParticipantLeftEmail
      playSessionParticipantLeftPush
      playSessionReminderEmail
      playSessionReminderPush
    }
  }
}
    `;

/**
 * __useGetUserCommunicationPreferencesQuery__
 *
 * To run a query within a React component, call `useGetUserCommunicationPreferencesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserCommunicationPreferencesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserCommunicationPreferencesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserCommunicationPreferencesQuery(baseOptions: Apollo.QueryHookOptions<GetUserCommunicationPreferencesQuery, GetUserCommunicationPreferencesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserCommunicationPreferencesQuery, GetUserCommunicationPreferencesQueryVariables>(GetUserCommunicationPreferencesDocument, options);
      }
export function useGetUserCommunicationPreferencesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserCommunicationPreferencesQuery, GetUserCommunicationPreferencesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserCommunicationPreferencesQuery, GetUserCommunicationPreferencesQueryVariables>(GetUserCommunicationPreferencesDocument, options);
        }
export type GetUserCommunicationPreferencesQueryHookResult = ReturnType<typeof useGetUserCommunicationPreferencesQuery>;
export type GetUserCommunicationPreferencesLazyQueryHookResult = ReturnType<typeof useGetUserCommunicationPreferencesLazyQuery>;
export type GetUserCommunicationPreferencesQueryResult = Apollo.QueryResult<GetUserCommunicationPreferencesQuery, GetUserCommunicationPreferencesQueryVariables>;
export const UpdateUserCommunicationPreferencesDocument = gql`
    mutation updateUserCommunicationPreferences($id: uuid!, $_set: UserCommunicationPreferencesSetInput!) {
  updateUserCommunicationPreferencesByPk(pkColumns: {id: $id}, _set: $_set) {
    id
    lessonBookedEmail
    lessonBookedPush
    lessonCanceledEmail
    lessonCanceledPushed
    lessonReminderEmail
    lessonReminderPush
    marketingEmail
    marketingPush
    newFollowerEmail
    newFollowerPush
    newLessonPublishedEmail
    newLessonPublishedPush
    participantLeftLessonEmail
    participantLeftLessonPush
    payoutEmail
    payoutPush
    playSessionCanceledEmail
    playSessionCanceledPush
    playSessionParticipantJoinedEmail
    playSessionParticipantJoinedPush
    playSessionParticipantLeftEmail
    playSessionParticipantLeftPush
    playSessionReminderEmail
    playSessionReminderPush
  }
}
    `;
export type UpdateUserCommunicationPreferencesMutationFn = Apollo.MutationFunction<UpdateUserCommunicationPreferencesMutation, UpdateUserCommunicationPreferencesMutationVariables>;

/**
 * __useUpdateUserCommunicationPreferencesMutation__
 *
 * To run a mutation, you first call `useUpdateUserCommunicationPreferencesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserCommunicationPreferencesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserCommunicationPreferencesMutation, { data, loading, error }] = useUpdateUserCommunicationPreferencesMutation({
 *   variables: {
 *      id: // value for 'id'
 *      _set: // value for '_set'
 *   },
 * });
 */
export function useUpdateUserCommunicationPreferencesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserCommunicationPreferencesMutation, UpdateUserCommunicationPreferencesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserCommunicationPreferencesMutation, UpdateUserCommunicationPreferencesMutationVariables>(UpdateUserCommunicationPreferencesDocument, options);
      }
export type UpdateUserCommunicationPreferencesMutationHookResult = ReturnType<typeof useUpdateUserCommunicationPreferencesMutation>;
export type UpdateUserCommunicationPreferencesMutationResult = Apollo.MutationResult<UpdateUserCommunicationPreferencesMutation>;
export type UpdateUserCommunicationPreferencesMutationOptions = Apollo.BaseMutationOptions<UpdateUserCommunicationPreferencesMutation, UpdateUserCommunicationPreferencesMutationVariables>;
export const GetUserNotificationsDocument = gql`
    query getUserNotifications($limit: Int!, $offset: Int!, $userId: uuid!) {
  userNotifications(
    limit: $limit
    offset: $offset
    orderBy: {createdAt: DESC_NULLS_LAST}
    where: {userId: {_eq: $userId}}
  ) {
    id
    status
    notificationDetails {
      actionType
      id
      primaryEntity {
        actingUserProfile {
          id
          fullName
          coachStatus
        }
        lesson {
          id
          ownerUserId
          ownerProfile {
            username
            preferredName
            fullName
            coachStatus
            id
          }
          startDateTime
          endDateTime
          title
          status
        }
        playSession {
          id
          startDateTime
          endDateTime
          title
          status
          organizerUserId
          organizerProfile {
            username
            preferredName
            fullName
            coachStatus
            id
          }
          format
          sport
          targetSkillLevel
        }
        group {
          id
          title
          slug
        }
        groupThread {
          groupId
          id
          comments(where: {isOriginalThreadComment: {_eq: true}}) {
            id
            content
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetUserNotificationsQuery__
 *
 * To run a query within a React component, call `useGetUserNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserNotificationsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserNotificationsQuery(baseOptions: Apollo.QueryHookOptions<GetUserNotificationsQuery, GetUserNotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserNotificationsQuery, GetUserNotificationsQueryVariables>(GetUserNotificationsDocument, options);
      }
export function useGetUserNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserNotificationsQuery, GetUserNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserNotificationsQuery, GetUserNotificationsQueryVariables>(GetUserNotificationsDocument, options);
        }
export type GetUserNotificationsQueryHookResult = ReturnType<typeof useGetUserNotificationsQuery>;
export type GetUserNotificationsLazyQueryHookResult = ReturnType<typeof useGetUserNotificationsLazyQuery>;
export type GetUserNotificationsQueryResult = Apollo.QueryResult<GetUserNotificationsQuery, GetUserNotificationsQueryVariables>;
export const GetUserNotificationsCountDocument = gql`
    query getUserNotificationsCount($userId: uuid!) {
  userNotificationsAggregate(where: {userId: {_eq: $userId}}) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetUserNotificationsCountQuery__
 *
 * To run a query within a React component, call `useGetUserNotificationsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserNotificationsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserNotificationsCountQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserNotificationsCountQuery(baseOptions: Apollo.QueryHookOptions<GetUserNotificationsCountQuery, GetUserNotificationsCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserNotificationsCountQuery, GetUserNotificationsCountQueryVariables>(GetUserNotificationsCountDocument, options);
      }
export function useGetUserNotificationsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserNotificationsCountQuery, GetUserNotificationsCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserNotificationsCountQuery, GetUserNotificationsCountQueryVariables>(GetUserNotificationsCountDocument, options);
        }
export type GetUserNotificationsCountQueryHookResult = ReturnType<typeof useGetUserNotificationsCountQuery>;
export type GetUserNotificationsCountLazyQueryHookResult = ReturnType<typeof useGetUserNotificationsCountLazyQuery>;
export type GetUserNotificationsCountQueryResult = Apollo.QueryResult<GetUserNotificationsCountQuery, GetUserNotificationsCountQueryVariables>;
export const UpdateNotificationsAsReadDocument = gql`
    mutation updateNotificationsAsRead($updates: [UserNotificationsUpdates!]!) {
  updateUserNotificationsMany(updates: $updates) {
    returning {
      id
      status
    }
  }
}
    `;
export type UpdateNotificationsAsReadMutationFn = Apollo.MutationFunction<UpdateNotificationsAsReadMutation, UpdateNotificationsAsReadMutationVariables>;

/**
 * __useUpdateNotificationsAsReadMutation__
 *
 * To run a mutation, you first call `useUpdateNotificationsAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNotificationsAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNotificationsAsReadMutation, { data, loading, error }] = useUpdateNotificationsAsReadMutation({
 *   variables: {
 *      updates: // value for 'updates'
 *   },
 * });
 */
export function useUpdateNotificationsAsReadMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNotificationsAsReadMutation, UpdateNotificationsAsReadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNotificationsAsReadMutation, UpdateNotificationsAsReadMutationVariables>(UpdateNotificationsAsReadDocument, options);
      }
export type UpdateNotificationsAsReadMutationHookResult = ReturnType<typeof useUpdateNotificationsAsReadMutation>;
export type UpdateNotificationsAsReadMutationResult = Apollo.MutationResult<UpdateNotificationsAsReadMutation>;
export type UpdateNotificationsAsReadMutationOptions = Apollo.BaseMutationOptions<UpdateNotificationsAsReadMutation, UpdateNotificationsAsReadMutationVariables>;
export const UpdateUserGenderDocument = gql`
    mutation updateUserGender($id: uuid!, $gender: GenderEnum!, $genderPreference: String!) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {gender: $gender, genderPreference: $genderPreference}
  ) {
    id
    gender
    genderPreference
  }
}
    `;
export type UpdateUserGenderMutationFn = Apollo.MutationFunction<UpdateUserGenderMutation, UpdateUserGenderMutationVariables>;

/**
 * __useUpdateUserGenderMutation__
 *
 * To run a mutation, you first call `useUpdateUserGenderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserGenderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserGenderMutation, { data, loading, error }] = useUpdateUserGenderMutation({
 *   variables: {
 *      id: // value for 'id'
 *      gender: // value for 'gender'
 *      genderPreference: // value for 'genderPreference'
 *   },
 * });
 */
export function useUpdateUserGenderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserGenderMutation, UpdateUserGenderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserGenderMutation, UpdateUserGenderMutationVariables>(UpdateUserGenderDocument, options);
      }
export type UpdateUserGenderMutationHookResult = ReturnType<typeof useUpdateUserGenderMutation>;
export type UpdateUserGenderMutationResult = Apollo.MutationResult<UpdateUserGenderMutation>;
export type UpdateUserGenderMutationOptions = Apollo.BaseMutationOptions<UpdateUserGenderMutation, UpdateUserGenderMutationVariables>;
export const InsertRepeatLessonsDocument = gql`
    mutation insertRepeatLessons($objects: [LessonsInsertInput!] = {}) {
  insertLessons(objects: $objects) {
    returning {
      ...lessonFields
    }
  }
}
    ${LessonFieldsFragmentDoc}`;
export type InsertRepeatLessonsMutationFn = Apollo.MutationFunction<InsertRepeatLessonsMutation, InsertRepeatLessonsMutationVariables>;

/**
 * __useInsertRepeatLessonsMutation__
 *
 * To run a mutation, you first call `useInsertRepeatLessonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRepeatLessonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRepeatLessonsMutation, { data, loading, error }] = useInsertRepeatLessonsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useInsertRepeatLessonsMutation(baseOptions?: Apollo.MutationHookOptions<InsertRepeatLessonsMutation, InsertRepeatLessonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRepeatLessonsMutation, InsertRepeatLessonsMutationVariables>(InsertRepeatLessonsDocument, options);
      }
export type InsertRepeatLessonsMutationHookResult = ReturnType<typeof useInsertRepeatLessonsMutation>;
export type InsertRepeatLessonsMutationResult = Apollo.MutationResult<InsertRepeatLessonsMutation>;
export type InsertRepeatLessonsMutationOptions = Apollo.BaseMutationOptions<InsertRepeatLessonsMutation, InsertRepeatLessonsMutationVariables>;
export const UpdateUserOnboardBioDocument = gql`
    mutation updateUserOnboardBio($id: uuid!, $birthday: date!, $gender: GenderEnum!, $genderPreference: String = "") {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {birthday: $birthday, gender: $gender, genderPreference: $genderPreference}
  ) {
    id
    gender
    genderPreference
    fullName
    email
    birthday
    normalizedTennisRating
    normalizedTennisRatingScaleId
    tennisRating
    tennisRatingScaleId
  }
}
    `;
export type UpdateUserOnboardBioMutationFn = Apollo.MutationFunction<UpdateUserOnboardBioMutation, UpdateUserOnboardBioMutationVariables>;

/**
 * __useUpdateUserOnboardBioMutation__
 *
 * To run a mutation, you first call `useUpdateUserOnboardBioMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserOnboardBioMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserOnboardBioMutation, { data, loading, error }] = useUpdateUserOnboardBioMutation({
 *   variables: {
 *      id: // value for 'id'
 *      birthday: // value for 'birthday'
 *      gender: // value for 'gender'
 *      genderPreference: // value for 'genderPreference'
 *   },
 * });
 */
export function useUpdateUserOnboardBioMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserOnboardBioMutation, UpdateUserOnboardBioMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserOnboardBioMutation, UpdateUserOnboardBioMutationVariables>(UpdateUserOnboardBioDocument, options);
      }
export type UpdateUserOnboardBioMutationHookResult = ReturnType<typeof useUpdateUserOnboardBioMutation>;
export type UpdateUserOnboardBioMutationResult = Apollo.MutationResult<UpdateUserOnboardBioMutation>;
export type UpdateUserOnboardBioMutationOptions = Apollo.BaseMutationOptions<UpdateUserOnboardBioMutation, UpdateUserOnboardBioMutationVariables>;
export const SetOnboardCompleteDocument = gql`
    mutation setOnboardComplete($id: uuid!) {
  updateUsersByPk(pkColumns: {id: $id}, _set: {isOnboardComplete: true}) {
    id
    isOnboardComplete
  }
}
    `;
export type SetOnboardCompleteMutationFn = Apollo.MutationFunction<SetOnboardCompleteMutation, SetOnboardCompleteMutationVariables>;

/**
 * __useSetOnboardCompleteMutation__
 *
 * To run a mutation, you first call `useSetOnboardCompleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetOnboardCompleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setOnboardCompleteMutation, { data, loading, error }] = useSetOnboardCompleteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSetOnboardCompleteMutation(baseOptions?: Apollo.MutationHookOptions<SetOnboardCompleteMutation, SetOnboardCompleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetOnboardCompleteMutation, SetOnboardCompleteMutationVariables>(SetOnboardCompleteDocument, options);
      }
export type SetOnboardCompleteMutationHookResult = ReturnType<typeof useSetOnboardCompleteMutation>;
export type SetOnboardCompleteMutationResult = Apollo.MutationResult<SetOnboardCompleteMutation>;
export type SetOnboardCompleteMutationOptions = Apollo.BaseMutationOptions<SetOnboardCompleteMutation, SetOnboardCompleteMutationVariables>;
export const UpdateMarketingCommunicationPreferencesDocument = gql`
    mutation updateMarketingCommunicationPreferences($id: uuid!, $marketingPreference: CommunicationPreferenceStatusesEnum = ACTIVE) {
  updateUserCommunicationPreferencesByPk(
    pkColumns: {id: $id}
    _set: {marketingEmail: $marketingPreference, marketingPush: $marketingPreference}
  ) {
    id
    marketingEmail
    marketingPush
  }
}
    `;
export type UpdateMarketingCommunicationPreferencesMutationFn = Apollo.MutationFunction<UpdateMarketingCommunicationPreferencesMutation, UpdateMarketingCommunicationPreferencesMutationVariables>;

/**
 * __useUpdateMarketingCommunicationPreferencesMutation__
 *
 * To run a mutation, you first call `useUpdateMarketingCommunicationPreferencesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMarketingCommunicationPreferencesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMarketingCommunicationPreferencesMutation, { data, loading, error }] = useUpdateMarketingCommunicationPreferencesMutation({
 *   variables: {
 *      id: // value for 'id'
 *      marketingPreference: // value for 'marketingPreference'
 *   },
 * });
 */
export function useUpdateMarketingCommunicationPreferencesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMarketingCommunicationPreferencesMutation, UpdateMarketingCommunicationPreferencesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMarketingCommunicationPreferencesMutation, UpdateMarketingCommunicationPreferencesMutationVariables>(UpdateMarketingCommunicationPreferencesDocument, options);
      }
export type UpdateMarketingCommunicationPreferencesMutationHookResult = ReturnType<typeof useUpdateMarketingCommunicationPreferencesMutation>;
export type UpdateMarketingCommunicationPreferencesMutationResult = Apollo.MutationResult<UpdateMarketingCommunicationPreferencesMutation>;
export type UpdateMarketingCommunicationPreferencesMutationOptions = Apollo.BaseMutationOptions<UpdateMarketingCommunicationPreferencesMutation, UpdateMarketingCommunicationPreferencesMutationVariables>;
export const InsertAcceptTermsOfServiceDocument = gql`
    mutation insertAcceptTermsOfService($ip: String = "", $userAgent: String = "", $userId: uuid!) {
  insertUserTermsOfServiceOne(
    object: {acceptedAt: "now()", ip: $ip, userAgent: $userAgent, userId: $userId}
  ) {
    id
    ip
    acceptedAt
    userAgent
    userId
  }
}
    `;
export type InsertAcceptTermsOfServiceMutationFn = Apollo.MutationFunction<InsertAcceptTermsOfServiceMutation, InsertAcceptTermsOfServiceMutationVariables>;

/**
 * __useInsertAcceptTermsOfServiceMutation__
 *
 * To run a mutation, you first call `useInsertAcceptTermsOfServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertAcceptTermsOfServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertAcceptTermsOfServiceMutation, { data, loading, error }] = useInsertAcceptTermsOfServiceMutation({
 *   variables: {
 *      ip: // value for 'ip'
 *      userAgent: // value for 'userAgent'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertAcceptTermsOfServiceMutation(baseOptions?: Apollo.MutationHookOptions<InsertAcceptTermsOfServiceMutation, InsertAcceptTermsOfServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertAcceptTermsOfServiceMutation, InsertAcceptTermsOfServiceMutationVariables>(InsertAcceptTermsOfServiceDocument, options);
      }
export type InsertAcceptTermsOfServiceMutationHookResult = ReturnType<typeof useInsertAcceptTermsOfServiceMutation>;
export type InsertAcceptTermsOfServiceMutationResult = Apollo.MutationResult<InsertAcceptTermsOfServiceMutation>;
export type InsertAcceptTermsOfServiceMutationOptions = Apollo.BaseMutationOptions<InsertAcceptTermsOfServiceMutation, InsertAcceptTermsOfServiceMutationVariables>;
export const SetUserLocationDocument = gql`
    mutation setUserLocation($id: uuid!, $countryId: String!, $countrySubdivisionId: uuid, $cityName: String!) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {countryId: $countryId, countrySubdivisionId: $countrySubdivisionId, cityName: $cityName}
  ) {
    id
    countrySubdivisionId
    countryId
  }
}
    `;
export type SetUserLocationMutationFn = Apollo.MutationFunction<SetUserLocationMutation, SetUserLocationMutationVariables>;

/**
 * __useSetUserLocationMutation__
 *
 * To run a mutation, you first call `useSetUserLocationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetUserLocationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setUserLocationMutation, { data, loading, error }] = useSetUserLocationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      countryId: // value for 'countryId'
 *      countrySubdivisionId: // value for 'countrySubdivisionId'
 *      cityName: // value for 'cityName'
 *   },
 * });
 */
export function useSetUserLocationMutation(baseOptions?: Apollo.MutationHookOptions<SetUserLocationMutation, SetUserLocationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetUserLocationMutation, SetUserLocationMutationVariables>(SetUserLocationDocument, options);
      }
export type SetUserLocationMutationHookResult = ReturnType<typeof useSetUserLocationMutation>;
export type SetUserLocationMutationResult = Apollo.MutationResult<SetUserLocationMutation>;
export type SetUserLocationMutationOptions = Apollo.BaseMutationOptions<SetUserLocationMutation, SetUserLocationMutationVariables>;
export const SetUserCoachQualificationsDocument = gql`
    mutation setUserCoachQualifications($userId: uuid!, $coachExperienceYears: numeric = 0, $objects: [UsersCoachQualificationsInsertInput!] = {}) {
  updateUsersByPk(
    pkColumns: {id: $userId}
    _set: {coachExperienceYears: $coachExperienceYears, coachExperienceSetAt: "now()"}
  ) {
    id
    coachExperienceSetAt
    coachExperienceYears
  }
  insertUsersCoachQualifications(
    objects: $objects
    onConflict: {constraint: users_coach_qualifications_user_id_coach_qualification_id_key, updateColumns: status}
  ) {
    returning {
      id
      status
      coachQualificationId
      userId
    }
  }
}
    `;
export type SetUserCoachQualificationsMutationFn = Apollo.MutationFunction<SetUserCoachQualificationsMutation, SetUserCoachQualificationsMutationVariables>;

/**
 * __useSetUserCoachQualificationsMutation__
 *
 * To run a mutation, you first call `useSetUserCoachQualificationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetUserCoachQualificationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setUserCoachQualificationsMutation, { data, loading, error }] = useSetUserCoachQualificationsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      coachExperienceYears: // value for 'coachExperienceYears'
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useSetUserCoachQualificationsMutation(baseOptions?: Apollo.MutationHookOptions<SetUserCoachQualificationsMutation, SetUserCoachQualificationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetUserCoachQualificationsMutation, SetUserCoachQualificationsMutationVariables>(SetUserCoachQualificationsDocument, options);
      }
export type SetUserCoachQualificationsMutationHookResult = ReturnType<typeof useSetUserCoachQualificationsMutation>;
export type SetUserCoachQualificationsMutationResult = Apollo.MutationResult<SetUserCoachQualificationsMutation>;
export type SetUserCoachQualificationsMutationOptions = Apollo.BaseMutationOptions<SetUserCoachQualificationsMutation, SetUserCoachQualificationsMutationVariables>;
export const GetSkillLevelsDocument = gql`
    query getSkillLevels {
  skillLevels(orderBy: {rank: ASC}) {
    displayName
    id
    isDisplayed
    rank
  }
}
    `;

/**
 * __useGetSkillLevelsQuery__
 *
 * To run a query within a React component, call `useGetSkillLevelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSkillLevelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSkillLevelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSkillLevelsQuery(baseOptions?: Apollo.QueryHookOptions<GetSkillLevelsQuery, GetSkillLevelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSkillLevelsQuery, GetSkillLevelsQueryVariables>(GetSkillLevelsDocument, options);
      }
export function useGetSkillLevelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSkillLevelsQuery, GetSkillLevelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSkillLevelsQuery, GetSkillLevelsQueryVariables>(GetSkillLevelsDocument, options);
        }
export type GetSkillLevelsQueryHookResult = ReturnType<typeof useGetSkillLevelsQuery>;
export type GetSkillLevelsLazyQueryHookResult = ReturnType<typeof useGetSkillLevelsLazyQuery>;
export type GetSkillLevelsQueryResult = Apollo.QueryResult<GetSkillLevelsQuery, GetSkillLevelsQueryVariables>;
export const UpdateUserTennisSkillLevelDocument = gql`
    mutation updateUserTennisSkillLevel($id: uuid!, $tennisSkillLevelId: String) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {tennisSkillLevelId: $tennisSkillLevelId}
  ) {
    id
    tennisSkillLevelId
  }
}
    `;
export type UpdateUserTennisSkillLevelMutationFn = Apollo.MutationFunction<UpdateUserTennisSkillLevelMutation, UpdateUserTennisSkillLevelMutationVariables>;

/**
 * __useUpdateUserTennisSkillLevelMutation__
 *
 * To run a mutation, you first call `useUpdateUserTennisSkillLevelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserTennisSkillLevelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserTennisSkillLevelMutation, { data, loading, error }] = useUpdateUserTennisSkillLevelMutation({
 *   variables: {
 *      id: // value for 'id'
 *      tennisSkillLevelId: // value for 'tennisSkillLevelId'
 *   },
 * });
 */
export function useUpdateUserTennisSkillLevelMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserTennisSkillLevelMutation, UpdateUserTennisSkillLevelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserTennisSkillLevelMutation, UpdateUserTennisSkillLevelMutationVariables>(UpdateUserTennisSkillLevelDocument, options);
      }
export type UpdateUserTennisSkillLevelMutationHookResult = ReturnType<typeof useUpdateUserTennisSkillLevelMutation>;
export type UpdateUserTennisSkillLevelMutationResult = Apollo.MutationResult<UpdateUserTennisSkillLevelMutation>;
export type UpdateUserTennisSkillLevelMutationOptions = Apollo.BaseMutationOptions<UpdateUserTennisSkillLevelMutation, UpdateUserTennisSkillLevelMutationVariables>;
export const UpdateUserPickleballSkillLevelDocument = gql`
    mutation updateUserPickleballSkillLevel($id: uuid!, $pickleballSkillLevelId: String) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {pickleballSkillLevelId: $pickleballSkillLevelId}
  ) {
    id
    pickleballSkillLevelId
  }
}
    `;
export type UpdateUserPickleballSkillLevelMutationFn = Apollo.MutationFunction<UpdateUserPickleballSkillLevelMutation, UpdateUserPickleballSkillLevelMutationVariables>;

/**
 * __useUpdateUserPickleballSkillLevelMutation__
 *
 * To run a mutation, you first call `useUpdateUserPickleballSkillLevelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserPickleballSkillLevelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserPickleballSkillLevelMutation, { data, loading, error }] = useUpdateUserPickleballSkillLevelMutation({
 *   variables: {
 *      id: // value for 'id'
 *      pickleballSkillLevelId: // value for 'pickleballSkillLevelId'
 *   },
 * });
 */
export function useUpdateUserPickleballSkillLevelMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserPickleballSkillLevelMutation, UpdateUserPickleballSkillLevelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserPickleballSkillLevelMutation, UpdateUserPickleballSkillLevelMutationVariables>(UpdateUserPickleballSkillLevelDocument, options);
      }
export type UpdateUserPickleballSkillLevelMutationHookResult = ReturnType<typeof useUpdateUserPickleballSkillLevelMutation>;
export type UpdateUserPickleballSkillLevelMutationResult = Apollo.MutationResult<UpdateUserPickleballSkillLevelMutation>;
export type UpdateUserPickleballSkillLevelMutationOptions = Apollo.BaseMutationOptions<UpdateUserPickleballSkillLevelMutation, UpdateUserPickleballSkillLevelMutationVariables>;
export const GetPublishedEventsDocument = gql`
    query getPublishedEvents {
  events {
    id
    title
    cityString
    startDateTime
    addressString
    displayLocation
    endDate
    coverImageUrl
    endDateTime
    latitude
    longitude
    status
    startDate
    publishedAt
    city {
      id
      name
      countrySubdivision {
        id
        name
        code
      }
    }
  }
}
    `;

/**
 * __useGetPublishedEventsQuery__
 *
 * To run a query within a React component, call `useGetPublishedEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPublishedEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPublishedEventsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPublishedEventsQuery(baseOptions?: Apollo.QueryHookOptions<GetPublishedEventsQuery, GetPublishedEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPublishedEventsQuery, GetPublishedEventsQueryVariables>(GetPublishedEventsDocument, options);
      }
export function useGetPublishedEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPublishedEventsQuery, GetPublishedEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPublishedEventsQuery, GetPublishedEventsQueryVariables>(GetPublishedEventsDocument, options);
        }
export type GetPublishedEventsQueryHookResult = ReturnType<typeof useGetPublishedEventsQuery>;
export type GetPublishedEventsLazyQueryHookResult = ReturnType<typeof useGetPublishedEventsLazyQuery>;
export type GetPublishedEventsQueryResult = Apollo.QueryResult<GetPublishedEventsQuery, GetPublishedEventsQueryVariables>;
export const UpdateEventContentsDocument = gql`
    mutation UpdateEventContents($id: uuid!, $input: EventsSetInput!) {
  updateEventsByPk(pkColumns: {id: $id}, _set: $input) {
    id
    title
    hasPrizes
    isSanctioned
    privacy
    registrationDeadlineDate
    registrationPriceUnitAmount
    coverImageUrl
  }
}
    `;
export type UpdateEventContentsMutationFn = Apollo.MutationFunction<UpdateEventContentsMutation, UpdateEventContentsMutationVariables>;

/**
 * __useUpdateEventContentsMutation__
 *
 * To run a mutation, you first call `useUpdateEventContentsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventContentsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventContentsMutation, { data, loading, error }] = useUpdateEventContentsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateEventContentsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventContentsMutation, UpdateEventContentsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventContentsMutation, UpdateEventContentsMutationVariables>(UpdateEventContentsDocument, options);
      }
export type UpdateEventContentsMutationHookResult = ReturnType<typeof useUpdateEventContentsMutation>;
export type UpdateEventContentsMutationResult = Apollo.MutationResult<UpdateEventContentsMutation>;
export type UpdateEventContentsMutationOptions = Apollo.BaseMutationOptions<UpdateEventContentsMutation, UpdateEventContentsMutationVariables>;
export const UpdateFaqByIdDocument = gql`
    mutation UpdateFaqById($id: uuid!, $input: EventFaqsSetInput!) {
  updateEventFaqsByPk(pkColumns: {id: $id}, _set: $input) {
    id
    answer
    question
  }
}
    `;
export type UpdateFaqByIdMutationFn = Apollo.MutationFunction<UpdateFaqByIdMutation, UpdateFaqByIdMutationVariables>;

/**
 * __useUpdateFaqByIdMutation__
 *
 * To run a mutation, you first call `useUpdateFaqByIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFaqByIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFaqByIdMutation, { data, loading, error }] = useUpdateFaqByIdMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFaqByIdMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFaqByIdMutation, UpdateFaqByIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFaqByIdMutation, UpdateFaqByIdMutationVariables>(UpdateFaqByIdDocument, options);
      }
export type UpdateFaqByIdMutationHookResult = ReturnType<typeof useUpdateFaqByIdMutation>;
export type UpdateFaqByIdMutationResult = Apollo.MutationResult<UpdateFaqByIdMutation>;
export type UpdateFaqByIdMutationOptions = Apollo.BaseMutationOptions<UpdateFaqByIdMutation, UpdateFaqByIdMutationVariables>;
export const UpdateEventSponsorsByPkDocument = gql`
    mutation UpdateEventSponsorsByPk($id: uuid!, $input: EventSponsorsSetInput!) {
  updateEventSponsorsByPk(pkColumns: {id: $id}, _set: $input) {
    id
    name
    isTitleSponsor
    categoryName
    imageUrl
  }
}
    `;
export type UpdateEventSponsorsByPkMutationFn = Apollo.MutationFunction<UpdateEventSponsorsByPkMutation, UpdateEventSponsorsByPkMutationVariables>;

/**
 * __useUpdateEventSponsorsByPkMutation__
 *
 * To run a mutation, you first call `useUpdateEventSponsorsByPkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventSponsorsByPkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventSponsorsByPkMutation, { data, loading, error }] = useUpdateEventSponsorsByPkMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateEventSponsorsByPkMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventSponsorsByPkMutation, UpdateEventSponsorsByPkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventSponsorsByPkMutation, UpdateEventSponsorsByPkMutationVariables>(UpdateEventSponsorsByPkDocument, options);
      }
export type UpdateEventSponsorsByPkMutationHookResult = ReturnType<typeof useUpdateEventSponsorsByPkMutation>;
export type UpdateEventSponsorsByPkMutationResult = Apollo.MutationResult<UpdateEventSponsorsByPkMutation>;
export type UpdateEventSponsorsByPkMutationOptions = Apollo.BaseMutationOptions<UpdateEventSponsorsByPkMutation, UpdateEventSponsorsByPkMutationVariables>;
export const UpdateEventGroupsByPkDocument = gql`
    mutation UpdateEventGroupsByPk($id: uuid!, $input: EventGroupsSetInput!) {
  updateEventGroupsByPk(pkColumns: {id: $id}, _set: $input) {
    id
    title
    format
    formatCustomName
    gamesPerMatch
    gender
    maximumAge
    minimumAge
    maximumRating
    minimumRating
    minimumNumberOfGames
    priceUnitAmount
    teamLimit
    scoringFormat
    startsAt
    endsAt
  }
}
    `;
export type UpdateEventGroupsByPkMutationFn = Apollo.MutationFunction<UpdateEventGroupsByPkMutation, UpdateEventGroupsByPkMutationVariables>;

/**
 * __useUpdateEventGroupsByPkMutation__
 *
 * To run a mutation, you first call `useUpdateEventGroupsByPkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventGroupsByPkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventGroupsByPkMutation, { data, loading, error }] = useUpdateEventGroupsByPkMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateEventGroupsByPkMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventGroupsByPkMutation, UpdateEventGroupsByPkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventGroupsByPkMutation, UpdateEventGroupsByPkMutationVariables>(UpdateEventGroupsByPkDocument, options);
      }
export type UpdateEventGroupsByPkMutationHookResult = ReturnType<typeof useUpdateEventGroupsByPkMutation>;
export type UpdateEventGroupsByPkMutationResult = Apollo.MutationResult<UpdateEventGroupsByPkMutation>;
export type UpdateEventGroupsByPkMutationOptions = Apollo.BaseMutationOptions<UpdateEventGroupsByPkMutation, UpdateEventGroupsByPkMutationVariables>;
export const GetPlaySessionFeedDocument = gql`
    query getPlaySessionFeed($startDateTime: timestamptz!, $groupId: uuid!, $userId: uuid!) {
  playSessions(
    where: {startDateTime: {_gte: $startDateTime}, groupId: {_eq: $groupId}, status: {_eq: ACTIVE}, privacy: {_eq: PUBLIC}}
  ) {
    ...playSessionFields
    commentsAggregate {
      aggregate {
        count
      }
    }
    currentUserAsParticipant: participants(
      where: {userId: {_eq: $userId}, status: {_eq: ACTIVE}}
    ) {
      id
      status
    }
  }
}
    ${PlaySessionFieldsFragmentDoc}`;

/**
 * __useGetPlaySessionFeedQuery__
 *
 * To run a query within a React component, call `useGetPlaySessionFeedQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlaySessionFeedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlaySessionFeedQuery({
 *   variables: {
 *      startDateTime: // value for 'startDateTime'
 *      groupId: // value for 'groupId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPlaySessionFeedQuery(baseOptions: Apollo.QueryHookOptions<GetPlaySessionFeedQuery, GetPlaySessionFeedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlaySessionFeedQuery, GetPlaySessionFeedQueryVariables>(GetPlaySessionFeedDocument, options);
      }
export function useGetPlaySessionFeedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlaySessionFeedQuery, GetPlaySessionFeedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlaySessionFeedQuery, GetPlaySessionFeedQueryVariables>(GetPlaySessionFeedDocument, options);
        }
export type GetPlaySessionFeedQueryHookResult = ReturnType<typeof useGetPlaySessionFeedQuery>;
export type GetPlaySessionFeedLazyQueryHookResult = ReturnType<typeof useGetPlaySessionFeedLazyQuery>;
export type GetPlaySessionFeedQueryResult = Apollo.QueryResult<GetPlaySessionFeedQuery, GetPlaySessionFeedQueryVariables>;
export const GetActiveJoinedPlaySessionsDocument = gql`
    query getActiveJoinedPlaySessions($userId: uuid!, $startDateTime: timestamptz!) {
  playSessionParticipants(
    where: {userId: {_eq: $userId}, playSession: {status: {_eq: ACTIVE}, startDateTime: {_gte: $startDateTime}}, status: {_eq: ACTIVE}}
  ) {
    playSession {
      ...playSessionFields
      commentsAggregate {
        aggregate {
          count
        }
      }
    }
  }
}
    ${PlaySessionFieldsFragmentDoc}`;

/**
 * __useGetActiveJoinedPlaySessionsQuery__
 *
 * To run a query within a React component, call `useGetActiveJoinedPlaySessionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActiveJoinedPlaySessionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActiveJoinedPlaySessionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      startDateTime: // value for 'startDateTime'
 *   },
 * });
 */
export function useGetActiveJoinedPlaySessionsQuery(baseOptions: Apollo.QueryHookOptions<GetActiveJoinedPlaySessionsQuery, GetActiveJoinedPlaySessionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActiveJoinedPlaySessionsQuery, GetActiveJoinedPlaySessionsQueryVariables>(GetActiveJoinedPlaySessionsDocument, options);
      }
export function useGetActiveJoinedPlaySessionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActiveJoinedPlaySessionsQuery, GetActiveJoinedPlaySessionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActiveJoinedPlaySessionsQuery, GetActiveJoinedPlaySessionsQueryVariables>(GetActiveJoinedPlaySessionsDocument, options);
        }
export type GetActiveJoinedPlaySessionsQueryHookResult = ReturnType<typeof useGetActiveJoinedPlaySessionsQuery>;
export type GetActiveJoinedPlaySessionsLazyQueryHookResult = ReturnType<typeof useGetActiveJoinedPlaySessionsLazyQuery>;
export type GetActiveJoinedPlaySessionsQueryResult = Apollo.QueryResult<GetActiveJoinedPlaySessionsQuery, GetActiveJoinedPlaySessionsQueryVariables>;
export const GetUserCustomCourtsDocument = gql`
    query getUserCustomCourts($id: uuid!) {
  usersByPk(id: $id) {
    id
    customCourts(orderBy: {createdAt: DESC}) {
      createdAt
      deletedAt
      fullAddress
      id
      title
    }
  }
}
    `;

/**
 * __useGetUserCustomCourtsQuery__
 *
 * To run a query within a React component, call `useGetUserCustomCourtsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserCustomCourtsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserCustomCourtsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserCustomCourtsQuery(baseOptions: Apollo.QueryHookOptions<GetUserCustomCourtsQuery, GetUserCustomCourtsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserCustomCourtsQuery, GetUserCustomCourtsQueryVariables>(GetUserCustomCourtsDocument, options);
      }
export function useGetUserCustomCourtsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserCustomCourtsQuery, GetUserCustomCourtsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserCustomCourtsQuery, GetUserCustomCourtsQueryVariables>(GetUserCustomCourtsDocument, options);
        }
export type GetUserCustomCourtsQueryHookResult = ReturnType<typeof useGetUserCustomCourtsQuery>;
export type GetUserCustomCourtsLazyQueryHookResult = ReturnType<typeof useGetUserCustomCourtsLazyQuery>;
export type GetUserCustomCourtsQueryResult = Apollo.QueryResult<GetUserCustomCourtsQuery, GetUserCustomCourtsQueryVariables>;
export const InsertNewPlaySessionDocument = gql`
    mutation insertNewPlaySession($competitiveness: PlaySessionMatchCompetitivenessEnum!, $courtBookingStatus: PlaySessionCourtBookingStatusesEnum!, $description: String = "", $endDateTime: timestamptz!, $extraRacketCount: Int = null, $format: PlaySessionFormatsEnum!, $isBringingNet: Boolean = false, $locale: String!, $organizerUserId: uuid!, $participantLimit: Int = null, $sport: SportsEnum!, $startDateTime: timestamptz!, $status: PlaySessionStatusesEnum = PENDING, $targetSkillLevel: String, $timezoneAbbreviation: String!, $timezoneName: String!, $timezoneOffsetMinutes: Int!, $title: String = "", $userCustomCourtId: uuid, $tennisRatingScaleId: uuid = null, $pickleballRatingScaleId: uuid = null, $privacy: PlaySessionPrivacyEnum = PRIVATE, $skillRatingMaximum: numeric = null, $skillRatingMinimum: numeric = null, $groupId: uuid = null, $venueId: uuid = null, $commentData: [PlaySessionCommentsInsertInput!] = [], $data: [GroupsPlaySessionsInsertInput!] = []) {
  insertPlaySessionsOne(
    object: {competitiveness: $competitiveness, courtBookingStatus: $courtBookingStatus, description: $description, endDateTime: $endDateTime, extraRacketCount: $extraRacketCount, format: $format, isBringingNet: $isBringingNet, locale: $locale, organizerUserId: $organizerUserId, participantLimit: $participantLimit, sport: $sport, startDateTime: $startDateTime, status: $status, targetSkillLevel: $targetSkillLevel, timezoneAbbreviation: $timezoneAbbreviation, timezoneName: $timezoneName, timezoneOffsetMinutes: $timezoneOffsetMinutes, title: $title, userCustomCourtId: $userCustomCourtId, tennisRatingScaleId: $tennisRatingScaleId, pickleballRatingScaleId: $pickleballRatingScaleId, privacy: $privacy, skillRatingMaximum: $skillRatingMaximum, skillRatingMinimum: $skillRatingMinimum, comments: {data: $commentData}, groupId: $groupId, venueId: $venueId, groupsPlaySessions: {data: $data}, participants: {data: {addedByPersona: PLAYER, addedAt: "now()", status: ACTIVE, addedByUserId: $organizerUserId, userId: $organizerUserId}}}
  ) {
    ...playSessionFields
  }
}
    ${PlaySessionFieldsFragmentDoc}`;
export type InsertNewPlaySessionMutationFn = Apollo.MutationFunction<InsertNewPlaySessionMutation, InsertNewPlaySessionMutationVariables>;

/**
 * __useInsertNewPlaySessionMutation__
 *
 * To run a mutation, you first call `useInsertNewPlaySessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNewPlaySessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNewPlaySessionMutation, { data, loading, error }] = useInsertNewPlaySessionMutation({
 *   variables: {
 *      competitiveness: // value for 'competitiveness'
 *      courtBookingStatus: // value for 'courtBookingStatus'
 *      description: // value for 'description'
 *      endDateTime: // value for 'endDateTime'
 *      extraRacketCount: // value for 'extraRacketCount'
 *      format: // value for 'format'
 *      isBringingNet: // value for 'isBringingNet'
 *      locale: // value for 'locale'
 *      organizerUserId: // value for 'organizerUserId'
 *      participantLimit: // value for 'participantLimit'
 *      sport: // value for 'sport'
 *      startDateTime: // value for 'startDateTime'
 *      status: // value for 'status'
 *      targetSkillLevel: // value for 'targetSkillLevel'
 *      timezoneAbbreviation: // value for 'timezoneAbbreviation'
 *      timezoneName: // value for 'timezoneName'
 *      timezoneOffsetMinutes: // value for 'timezoneOffsetMinutes'
 *      title: // value for 'title'
 *      userCustomCourtId: // value for 'userCustomCourtId'
 *      tennisRatingScaleId: // value for 'tennisRatingScaleId'
 *      pickleballRatingScaleId: // value for 'pickleballRatingScaleId'
 *      privacy: // value for 'privacy'
 *      skillRatingMaximum: // value for 'skillRatingMaximum'
 *      skillRatingMinimum: // value for 'skillRatingMinimum'
 *      groupId: // value for 'groupId'
 *      venueId: // value for 'venueId'
 *      commentData: // value for 'commentData'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useInsertNewPlaySessionMutation(baseOptions?: Apollo.MutationHookOptions<InsertNewPlaySessionMutation, InsertNewPlaySessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNewPlaySessionMutation, InsertNewPlaySessionMutationVariables>(InsertNewPlaySessionDocument, options);
      }
export type InsertNewPlaySessionMutationHookResult = ReturnType<typeof useInsertNewPlaySessionMutation>;
export type InsertNewPlaySessionMutationResult = Apollo.MutationResult<InsertNewPlaySessionMutation>;
export type InsertNewPlaySessionMutationOptions = Apollo.BaseMutationOptions<InsertNewPlaySessionMutation, InsertNewPlaySessionMutationVariables>;
export const UpdateNewPlaySessionByIdDocument = gql`
    mutation updateNewPlaySessionById($playSessionId: uuid!, $competitiveness: PlaySessionMatchCompetitivenessEnum!, $courtBookingStatus: PlaySessionCourtBookingStatusesEnum!, $description: String = "", $endDateTime: timestamptz!, $extraRacketCount: Int = null, $format: PlaySessionFormatsEnum!, $isBringingNet: Boolean = false, $participantLimit: Int = null, $sport: SportsEnum!, $startDateTime: timestamptz!, $status: PlaySessionStatusesEnum = PENDING, $targetSkillLevel: String, $title: String = "", $userCustomCourtId: uuid, $tennisRatingScaleId: uuid, $pickleballRatingScaleId: uuid, $skillRatingMaximum: numeric, $skillRatingMinimum: numeric, $privacy: PlaySessionPrivacyEnum = PRIVATE, $venueId: uuid = null, $commentObjects: [PlaySessionCommentsInsertInput!] = []) {
  updatePlaySessionComments(
    where: {playSessionId: {_eq: $playSessionId}}
    _set: {deletedAt: "now()"}
  ) {
    affectedRows
  }
  updatePlaySessionsByPk(
    pkColumns: {id: $playSessionId}
    _set: {competitiveness: $competitiveness, courtBookingStatus: $courtBookingStatus, description: $description, endDateTime: $endDateTime, extraRacketCount: $extraRacketCount, format: $format, isBringingNet: $isBringingNet, participantLimit: $participantLimit, sport: $sport, startDateTime: $startDateTime, status: $status, targetSkillLevel: $targetSkillLevel, title: $title, userCustomCourtId: $userCustomCourtId, tennisRatingScaleId: $tennisRatingScaleId, pickleballRatingScaleId: $pickleballRatingScaleId, skillRatingMaximum: $skillRatingMaximum, skillRatingMinimum: $skillRatingMinimum, privacy: $privacy, venueId: $venueId}
  ) {
    ...playSessionFields
  }
  insertPlaySessionComments(objects: $commentObjects) {
    affectedRows
  }
}
    ${PlaySessionFieldsFragmentDoc}`;
export type UpdateNewPlaySessionByIdMutationFn = Apollo.MutationFunction<UpdateNewPlaySessionByIdMutation, UpdateNewPlaySessionByIdMutationVariables>;

/**
 * __useUpdateNewPlaySessionByIdMutation__
 *
 * To run a mutation, you first call `useUpdateNewPlaySessionByIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNewPlaySessionByIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNewPlaySessionByIdMutation, { data, loading, error }] = useUpdateNewPlaySessionByIdMutation({
 *   variables: {
 *      playSessionId: // value for 'playSessionId'
 *      competitiveness: // value for 'competitiveness'
 *      courtBookingStatus: // value for 'courtBookingStatus'
 *      description: // value for 'description'
 *      endDateTime: // value for 'endDateTime'
 *      extraRacketCount: // value for 'extraRacketCount'
 *      format: // value for 'format'
 *      isBringingNet: // value for 'isBringingNet'
 *      participantLimit: // value for 'participantLimit'
 *      sport: // value for 'sport'
 *      startDateTime: // value for 'startDateTime'
 *      status: // value for 'status'
 *      targetSkillLevel: // value for 'targetSkillLevel'
 *      title: // value for 'title'
 *      userCustomCourtId: // value for 'userCustomCourtId'
 *      tennisRatingScaleId: // value for 'tennisRatingScaleId'
 *      pickleballRatingScaleId: // value for 'pickleballRatingScaleId'
 *      skillRatingMaximum: // value for 'skillRatingMaximum'
 *      skillRatingMinimum: // value for 'skillRatingMinimum'
 *      privacy: // value for 'privacy'
 *      venueId: // value for 'venueId'
 *      commentObjects: // value for 'commentObjects'
 *   },
 * });
 */
export function useUpdateNewPlaySessionByIdMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNewPlaySessionByIdMutation, UpdateNewPlaySessionByIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNewPlaySessionByIdMutation, UpdateNewPlaySessionByIdMutationVariables>(UpdateNewPlaySessionByIdDocument, options);
      }
export type UpdateNewPlaySessionByIdMutationHookResult = ReturnType<typeof useUpdateNewPlaySessionByIdMutation>;
export type UpdateNewPlaySessionByIdMutationResult = Apollo.MutationResult<UpdateNewPlaySessionByIdMutation>;
export type UpdateNewPlaySessionByIdMutationOptions = Apollo.BaseMutationOptions<UpdateNewPlaySessionByIdMutation, UpdateNewPlaySessionByIdMutationVariables>;
export const UpdateExistingPlaySessionByIdDocument = gql`
    mutation updateExistingPlaySessionById($playSessionId: uuid!, $title: String!, $description: String!, $sport: SportsEnum!, $format: PlaySessionFormatsEnum!, $targetSkillLevel: String, $courtBookingStatus: PlaySessionCourtBookingStatusesEnum!, $competitiveness: PlaySessionMatchCompetitivenessEnum!, $extraRacketCount: Int = 0, $isBringingNet: Boolean = false, $participantLimit: Int = null, $pickleballRatingScaleId: uuid, $privacy: PlaySessionPrivacyEnum = PRIVATE, $skillRatingMaximum: numeric, $skillRatingMinimum: numeric, $startDateTime: timestamptz!, $endDateTime: timestamptz!, $tennisRatingScaleId: uuid, $venueId: uuid = null) {
  updatePlaySessionsByPk(
    pkColumns: {id: $playSessionId}
    _set: {title: $title, description: $description, sport: $sport, format: $format, targetSkillLevel: $targetSkillLevel, courtBookingStatus: $courtBookingStatus, competitiveness: $competitiveness, extraRacketCount: $extraRacketCount, isBringingNet: $isBringingNet, participantLimit: $participantLimit, pickleballRatingScaleId: $pickleballRatingScaleId, privacy: $privacy, skillRatingMaximum: $skillRatingMaximum, skillRatingMinimum: $skillRatingMinimum, startDateTime: $startDateTime, endDateTime: $endDateTime, tennisRatingScaleId: $tennisRatingScaleId, venueId: $venueId}
  ) {
    ...playSessionFields
  }
}
    ${PlaySessionFieldsFragmentDoc}`;
export type UpdateExistingPlaySessionByIdMutationFn = Apollo.MutationFunction<UpdateExistingPlaySessionByIdMutation, UpdateExistingPlaySessionByIdMutationVariables>;

/**
 * __useUpdateExistingPlaySessionByIdMutation__
 *
 * To run a mutation, you first call `useUpdateExistingPlaySessionByIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateExistingPlaySessionByIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateExistingPlaySessionByIdMutation, { data, loading, error }] = useUpdateExistingPlaySessionByIdMutation({
 *   variables: {
 *      playSessionId: // value for 'playSessionId'
 *      title: // value for 'title'
 *      description: // value for 'description'
 *      sport: // value for 'sport'
 *      format: // value for 'format'
 *      targetSkillLevel: // value for 'targetSkillLevel'
 *      courtBookingStatus: // value for 'courtBookingStatus'
 *      competitiveness: // value for 'competitiveness'
 *      extraRacketCount: // value for 'extraRacketCount'
 *      isBringingNet: // value for 'isBringingNet'
 *      participantLimit: // value for 'participantLimit'
 *      pickleballRatingScaleId: // value for 'pickleballRatingScaleId'
 *      privacy: // value for 'privacy'
 *      skillRatingMaximum: // value for 'skillRatingMaximum'
 *      skillRatingMinimum: // value for 'skillRatingMinimum'
 *      startDateTime: // value for 'startDateTime'
 *      endDateTime: // value for 'endDateTime'
 *      tennisRatingScaleId: // value for 'tennisRatingScaleId'
 *      venueId: // value for 'venueId'
 *   },
 * });
 */
export function useUpdateExistingPlaySessionByIdMutation(baseOptions?: Apollo.MutationHookOptions<UpdateExistingPlaySessionByIdMutation, UpdateExistingPlaySessionByIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateExistingPlaySessionByIdMutation, UpdateExistingPlaySessionByIdMutationVariables>(UpdateExistingPlaySessionByIdDocument, options);
      }
export type UpdateExistingPlaySessionByIdMutationHookResult = ReturnType<typeof useUpdateExistingPlaySessionByIdMutation>;
export type UpdateExistingPlaySessionByIdMutationResult = Apollo.MutationResult<UpdateExistingPlaySessionByIdMutation>;
export type UpdateExistingPlaySessionByIdMutationOptions = Apollo.BaseMutationOptions<UpdateExistingPlaySessionByIdMutation, UpdateExistingPlaySessionByIdMutationVariables>;
export const SetPlaySessionAsActiveDocument = gql`
    mutation setPlaySessionAsActive($id: uuid!) {
  updatePlaySessionsByPk(
    pkColumns: {id: $id}
    _set: {status: ACTIVE, publishedAt: "now()"}
  ) {
    id
    status
    publishedAt
  }
}
    `;
export type SetPlaySessionAsActiveMutationFn = Apollo.MutationFunction<SetPlaySessionAsActiveMutation, SetPlaySessionAsActiveMutationVariables>;

/**
 * __useSetPlaySessionAsActiveMutation__
 *
 * To run a mutation, you first call `useSetPlaySessionAsActiveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetPlaySessionAsActiveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setPlaySessionAsActiveMutation, { data, loading, error }] = useSetPlaySessionAsActiveMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSetPlaySessionAsActiveMutation(baseOptions?: Apollo.MutationHookOptions<SetPlaySessionAsActiveMutation, SetPlaySessionAsActiveMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetPlaySessionAsActiveMutation, SetPlaySessionAsActiveMutationVariables>(SetPlaySessionAsActiveDocument, options);
      }
export type SetPlaySessionAsActiveMutationHookResult = ReturnType<typeof useSetPlaySessionAsActiveMutation>;
export type SetPlaySessionAsActiveMutationResult = Apollo.MutationResult<SetPlaySessionAsActiveMutation>;
export type SetPlaySessionAsActiveMutationOptions = Apollo.BaseMutationOptions<SetPlaySessionAsActiveMutation, SetPlaySessionAsActiveMutationVariables>;
export const UpdateCoachProfileDocument = gql`
    mutation updateCoachProfile($id: uuid!, $fullName: String = "", $aboutMe: String = "", $preferredName: String = "", $existingCoachServices: [UserCoachServicesUpdates!] = [], $newCoachServices: [UserCoachServicesInsertInput!] = [], $qualificationObjects: [UsersCoachQualificationsInsertInput!] = []) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {fullName: $fullName, aboutMe: $aboutMe, preferredName: $preferredName}
  ) {
    id
    fullName
    preferredName
    username
    aboutMe
    countryId
    countrySubdivisionId
    cityName
    profile {
      id
      preferredName
      fullName
      aboutMe
      username
      countryId
      countrySubdivisionId
      cityName
    }
  }
  updateUserCoachServicesMany(updates: $existingCoachServices) {
    returning {
      coverImageUrl
      currency
      description
      id
      priceUnitAmount
      title
      type
      userId
    }
  }
  insertUserCoachServices(
    objects: $newCoachServices
    onConflict: {constraint: user_coach_services_pkey, updateColumns: [title, description, currency, coverImageUrl, priceUnitAmount, type]}
  ) {
    returning {
      coverImageUrl
      currency
      description
      id
      priceUnitAmount
      title
      type
      userId
    }
  }
  insertUsersCoachQualifications(
    objects: $qualificationObjects
    onConflict: {constraint: users_coach_qualifications_user_id_coach_qualification_id_key, updateColumns: status}
  ) {
    returning {
      id
      status
      coachQualificationId
      userId
    }
  }
}
    `;
export type UpdateCoachProfileMutationFn = Apollo.MutationFunction<UpdateCoachProfileMutation, UpdateCoachProfileMutationVariables>;

/**
 * __useUpdateCoachProfileMutation__
 *
 * To run a mutation, you first call `useUpdateCoachProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCoachProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCoachProfileMutation, { data, loading, error }] = useUpdateCoachProfileMutation({
 *   variables: {
 *      id: // value for 'id'
 *      fullName: // value for 'fullName'
 *      aboutMe: // value for 'aboutMe'
 *      preferredName: // value for 'preferredName'
 *      existingCoachServices: // value for 'existingCoachServices'
 *      newCoachServices: // value for 'newCoachServices'
 *      qualificationObjects: // value for 'qualificationObjects'
 *   },
 * });
 */
export function useUpdateCoachProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCoachProfileMutation, UpdateCoachProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCoachProfileMutation, UpdateCoachProfileMutationVariables>(UpdateCoachProfileDocument, options);
      }
export type UpdateCoachProfileMutationHookResult = ReturnType<typeof useUpdateCoachProfileMutation>;
export type UpdateCoachProfileMutationResult = Apollo.MutationResult<UpdateCoachProfileMutation>;
export type UpdateCoachProfileMutationOptions = Apollo.BaseMutationOptions<UpdateCoachProfileMutation, UpdateCoachProfileMutationVariables>;
export const UpdatePlayerProfileDocument = gql`
    mutation updatePlayerProfile($id: uuid!, $fullName: String = "", $aboutMe: String = "", $preferredName: String = "", $normalizedTennisRating: numeric, $normalizedTennisRatingScaleId: uuid, $tennisRating: numeric, $tennisRatingScaleId: uuid) {
  updateUsersByPk(
    pkColumns: {id: $id}
    _set: {fullName: $fullName, aboutMe: $aboutMe, preferredName: $preferredName, normalizedTennisRating: $normalizedTennisRating, normalizedTennisRatingScaleId: $normalizedTennisRatingScaleId, tennisRating: $tennisRating, tennisRatingScaleId: $tennisRatingScaleId}
  ) {
    id
    fullName
    preferredName
    username
    aboutMe
    countryId
    countrySubdivisionId
    cityName
    normalizedTennisRating
    normalizedTennisRatingScaleId
    tennisRating
    tennisRatingScaleId
    profile {
      id
      preferredName
      fullName
      aboutMe
      username
      countryId
      countrySubdivisionId
      cityName
      normalizedTennisRating
      normalizedTennisRatingScaleId
      tennisRating
      tennisRatingScaleId
    }
  }
}
    `;
export type UpdatePlayerProfileMutationFn = Apollo.MutationFunction<UpdatePlayerProfileMutation, UpdatePlayerProfileMutationVariables>;

/**
 * __useUpdatePlayerProfileMutation__
 *
 * To run a mutation, you first call `useUpdatePlayerProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePlayerProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePlayerProfileMutation, { data, loading, error }] = useUpdatePlayerProfileMutation({
 *   variables: {
 *      id: // value for 'id'
 *      fullName: // value for 'fullName'
 *      aboutMe: // value for 'aboutMe'
 *      preferredName: // value for 'preferredName'
 *      normalizedTennisRating: // value for 'normalizedTennisRating'
 *      normalizedTennisRatingScaleId: // value for 'normalizedTennisRatingScaleId'
 *      tennisRating: // value for 'tennisRating'
 *      tennisRatingScaleId: // value for 'tennisRatingScaleId'
 *   },
 * });
 */
export function useUpdatePlayerProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePlayerProfileMutation, UpdatePlayerProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePlayerProfileMutation, UpdatePlayerProfileMutationVariables>(UpdatePlayerProfileDocument, options);
      }
export type UpdatePlayerProfileMutationHookResult = ReturnType<typeof useUpdatePlayerProfileMutation>;
export type UpdatePlayerProfileMutationResult = Apollo.MutationResult<UpdatePlayerProfileMutation>;
export type UpdatePlayerProfileMutationOptions = Apollo.BaseMutationOptions<UpdatePlayerProfileMutation, UpdatePlayerProfileMutationVariables>;
export const GetCountriesAndActiveSubdivisionsDocument = gql`
    query getCountriesAndActiveSubdivisions($countryId: String!) {
  countries {
    id
    name
    slug
  }
  countrySubdivisions(where: {countryId: {_eq: $countryId}}) {
    id
    name
    type
  }
}
    `;

/**
 * __useGetCountriesAndActiveSubdivisionsQuery__
 *
 * To run a query within a React component, call `useGetCountriesAndActiveSubdivisionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCountriesAndActiveSubdivisionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCountriesAndActiveSubdivisionsQuery({
 *   variables: {
 *      countryId: // value for 'countryId'
 *   },
 * });
 */
export function useGetCountriesAndActiveSubdivisionsQuery(baseOptions: Apollo.QueryHookOptions<GetCountriesAndActiveSubdivisionsQuery, GetCountriesAndActiveSubdivisionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCountriesAndActiveSubdivisionsQuery, GetCountriesAndActiveSubdivisionsQueryVariables>(GetCountriesAndActiveSubdivisionsDocument, options);
      }
export function useGetCountriesAndActiveSubdivisionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCountriesAndActiveSubdivisionsQuery, GetCountriesAndActiveSubdivisionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCountriesAndActiveSubdivisionsQuery, GetCountriesAndActiveSubdivisionsQueryVariables>(GetCountriesAndActiveSubdivisionsDocument, options);
        }
export type GetCountriesAndActiveSubdivisionsQueryHookResult = ReturnType<typeof useGetCountriesAndActiveSubdivisionsQuery>;
export type GetCountriesAndActiveSubdivisionsLazyQueryHookResult = ReturnType<typeof useGetCountriesAndActiveSubdivisionsLazyQuery>;
export type GetCountriesAndActiveSubdivisionsQueryResult = Apollo.QueryResult<GetCountriesAndActiveSubdivisionsQuery, GetCountriesAndActiveSubdivisionsQueryVariables>;
export const GetAvailableCoachQualificationsDocument = gql`
    query getAvailableCoachQualifications {
  coachQualifications(orderBy: {order: ASC}) {
    id
    name
    order
    groupId
    displayKey
  }
}
    `;

/**
 * __useGetAvailableCoachQualificationsQuery__
 *
 * To run a query within a React component, call `useGetAvailableCoachQualificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAvailableCoachQualificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAvailableCoachQualificationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAvailableCoachQualificationsQuery(baseOptions?: Apollo.QueryHookOptions<GetAvailableCoachQualificationsQuery, GetAvailableCoachQualificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAvailableCoachQualificationsQuery, GetAvailableCoachQualificationsQueryVariables>(GetAvailableCoachQualificationsDocument, options);
      }
export function useGetAvailableCoachQualificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAvailableCoachQualificationsQuery, GetAvailableCoachQualificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAvailableCoachQualificationsQuery, GetAvailableCoachQualificationsQueryVariables>(GetAvailableCoachQualificationsDocument, options);
        }
export type GetAvailableCoachQualificationsQueryHookResult = ReturnType<typeof useGetAvailableCoachQualificationsQuery>;
export type GetAvailableCoachQualificationsLazyQueryHookResult = ReturnType<typeof useGetAvailableCoachQualificationsLazyQuery>;
export type GetAvailableCoachQualificationsQueryResult = Apollo.QueryResult<GetAvailableCoachQualificationsQuery, GetAvailableCoachQualificationsQueryVariables>;
export const GetTennisRatingScalesDocument = gql`
    query getTennisRatingScales {
  tennisRatingScales(orderBy: {order: ASC}) {
    id
    maximum
    minimum
    name
    order
    shortName
  }
}
    `;

/**
 * __useGetTennisRatingScalesQuery__
 *
 * To run a query within a React component, call `useGetTennisRatingScalesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTennisRatingScalesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTennisRatingScalesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTennisRatingScalesQuery(baseOptions?: Apollo.QueryHookOptions<GetTennisRatingScalesQuery, GetTennisRatingScalesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTennisRatingScalesQuery, GetTennisRatingScalesQueryVariables>(GetTennisRatingScalesDocument, options);
      }
export function useGetTennisRatingScalesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTennisRatingScalesQuery, GetTennisRatingScalesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTennisRatingScalesQuery, GetTennisRatingScalesQueryVariables>(GetTennisRatingScalesDocument, options);
        }
export type GetTennisRatingScalesQueryHookResult = ReturnType<typeof useGetTennisRatingScalesQuery>;
export type GetTennisRatingScalesLazyQueryHookResult = ReturnType<typeof useGetTennisRatingScalesLazyQuery>;
export type GetTennisRatingScalesQueryResult = Apollo.QueryResult<GetTennisRatingScalesQuery, GetTennisRatingScalesQueryVariables>;
export const GetCoachEarningsUnitAmountDocument = gql`
    query getCoachEarningsUnitAmount($sellerUserId: uuid!) {
  lessonOrdersAggregate(
    where: {sellerUserId: {_eq: $sellerUserId}, status: {_eq: SUCCEEDED}}
  ) {
    aggregate {
      sum {
        transferUnitAmount
      }
    }
  }
}
    `;

/**
 * __useGetCoachEarningsUnitAmountQuery__
 *
 * To run a query within a React component, call `useGetCoachEarningsUnitAmountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCoachEarningsUnitAmountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCoachEarningsUnitAmountQuery({
 *   variables: {
 *      sellerUserId: // value for 'sellerUserId'
 *   },
 * });
 */
export function useGetCoachEarningsUnitAmountQuery(baseOptions: Apollo.QueryHookOptions<GetCoachEarningsUnitAmountQuery, GetCoachEarningsUnitAmountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCoachEarningsUnitAmountQuery, GetCoachEarningsUnitAmountQueryVariables>(GetCoachEarningsUnitAmountDocument, options);
      }
export function useGetCoachEarningsUnitAmountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCoachEarningsUnitAmountQuery, GetCoachEarningsUnitAmountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCoachEarningsUnitAmountQuery, GetCoachEarningsUnitAmountQueryVariables>(GetCoachEarningsUnitAmountDocument, options);
        }
export type GetCoachEarningsUnitAmountQueryHookResult = ReturnType<typeof useGetCoachEarningsUnitAmountQuery>;
export type GetCoachEarningsUnitAmountLazyQueryHookResult = ReturnType<typeof useGetCoachEarningsUnitAmountLazyQuery>;
export type GetCoachEarningsUnitAmountQueryResult = Apollo.QueryResult<GetCoachEarningsUnitAmountQuery, GetCoachEarningsUnitAmountQueryVariables>;
export const GetEventDetailsDocument = gql`
    query getEventDetails($id: uuid!) {
  eventsByPk(id: $id) {
    addressString
    cityId
    coverImageFileName
    coverImagePath
    coverImageUrl
    currency
    longitude
    latitude
    createdAt
    description
    displayLocation
    endDate
    endDateTime
    externalUrl
    geometry
    hasPrizes
    id
    isExternal
    organizerImageUrl
    organizerImagePath
    locale
    isSanctioned
    privacy
    prizeDescription
    publishedAt
    registrationClosedAt
    registrationDeadlineDate
    registrationDeadlineDateTime
    registrationPriceUnitAmount
    registrationOpenDate
    registrationOpenDateTime
    isRatingRequired
    slug
    scoringFormat
    sport
    startDate
    startDateTime
    status
    title
    type
    timezoneName
    timezoneOffsetMinutes
    timezoneAbbreviation
    sourceRegistrationCount
    sourceOrganizerTitle
    groupFormat
    city {
      id
      name
      slug
      countrySubdivision {
        id
        name
        slug
        code
        country {
          id
          name
          slug
        }
      }
    }
    venue {
      id
      title
      slug
      pickleballLines
      pickleballNets
      longitude
      latitude
      geometry
      addressString
      outdoorCourtCount
      indoorCourtCount
      timezone
      images {
        id
        path
        url
      }
      courtSurfaces {
        id
        courtSurface
      }
    }
    pickleballRatingScale {
      id
      maximum
      minimum
      name
      shortName
    }
    hostUserProfile {
      id
      fullName
      profileImagePath
      profileImageProviderUrl
      preferredName
      profileImageFileName
      profileImageProvider
    }
    faqs {
      id
      question
      answer
    }
    ballCustomName
    ballType
    registrations {
      id
      userProfile {
        id
        fullName
        username
        preferredName
        profileImageFileName
        profileImagePath
        profileImageProvider
        profileImageProviderUrl
      }
    }
    groups {
      id
      gender
      gamesPerMatch
      formatCustomName
      format
      endsAt
      maximumAge
      maximumRating
      minimumNumberOfGames
      minimumAge
      minimumRating
      priceUnitAmount
      scoringFormat
      startsAt
      teamLimit
      teamType
      title
      totalPoints
      winBy
      teams {
        id
        members {
          id
          userId
          userProfile {
            id
            fullName
            preferredName
            profileImageFileName
            profileImagePath
            profileImageProvider
            profileImageProviderUrl
          }
        }
      }
      registrations {
        id
        userId
        userProfile {
          id
          preferredName
          profileImageFileName
          profileImagePath
          profileImageProvider
          profileImageProviderUrl
        }
      }
    }
  }
}
    `;

/**
 * __useGetEventDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetEventDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
      }
export function useGetEventDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
        }
export type GetEventDetailsQueryHookResult = ReturnType<typeof useGetEventDetailsQuery>;
export type GetEventDetailsLazyQueryHookResult = ReturnType<typeof useGetEventDetailsLazyQuery>;
export type GetEventDetailsQueryResult = Apollo.QueryResult<GetEventDetailsQuery, GetEventDetailsQueryVariables>;
export const GetUserEventRegistrationDocument = gql`
    query getUserEventRegistration($eventId: uuid!, $userId: uuid!) {
  eventRegistrations(where: {eventId: {_eq: $eventId}, userId: {_eq: $userId}}) {
    id
  }
  eventGroupRegistrations(
    where: {userId: {_eq: $userId}, group: {eventId: {_eq: $eventId}}}
  ) {
    id
    status
    group {
      id
      title
      format
      formatCustomName
      maximumAge
      maximumRating
      minimumAge
      minimumNumberOfGames
      minimumRating
      teamType
      teams(where: {members: {userId: {_eq: $userId}}}) {
        members {
          userId
          id
          status
          userProfile {
            id
            fullName
            preferredName
            profileImageFileName
            profileImagePath
            profileImageProvider
            profileImageProviderUrl
          }
        }
        id
      }
    }
    invitations(where: {senderUserId: {_eq: $userId}}) {
      id
      invitationEmail
      status
    }
  }
}
    `;

/**
 * __useGetUserEventRegistrationQuery__
 *
 * To run a query within a React component, call `useGetUserEventRegistrationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserEventRegistrationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserEventRegistrationQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserEventRegistrationQuery(baseOptions: Apollo.QueryHookOptions<GetUserEventRegistrationQuery, GetUserEventRegistrationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserEventRegistrationQuery, GetUserEventRegistrationQueryVariables>(GetUserEventRegistrationDocument, options);
      }
export function useGetUserEventRegistrationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserEventRegistrationQuery, GetUserEventRegistrationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserEventRegistrationQuery, GetUserEventRegistrationQueryVariables>(GetUserEventRegistrationDocument, options);
        }
export type GetUserEventRegistrationQueryHookResult = ReturnType<typeof useGetUserEventRegistrationQuery>;
export type GetUserEventRegistrationLazyQueryHookResult = ReturnType<typeof useGetUserEventRegistrationLazyQuery>;
export type GetUserEventRegistrationQueryResult = Apollo.QueryResult<GetUserEventRegistrationQuery, GetUserEventRegistrationQueryVariables>;
export const GetEventTeamInvitationByIdDocument = gql`
    query getEventTeamInvitationById($id: uuid!) {
  eventTeamsByPk(id: $id) {
    id
    groupId
    group {
      id
    }
    members {
      id
      userProfile {
        id
        fullName
        preferredName
        profileImageFileName
        profileImagePath
        profileImageProvider
        profileImageProviderUrl
      }
    }
  }
}
    `;

/**
 * __useGetEventTeamInvitationByIdQuery__
 *
 * To run a query within a React component, call `useGetEventTeamInvitationByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventTeamInvitationByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventTeamInvitationByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetEventTeamInvitationByIdQuery(baseOptions: Apollo.QueryHookOptions<GetEventTeamInvitationByIdQuery, GetEventTeamInvitationByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventTeamInvitationByIdQuery, GetEventTeamInvitationByIdQueryVariables>(GetEventTeamInvitationByIdDocument, options);
      }
export function useGetEventTeamInvitationByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventTeamInvitationByIdQuery, GetEventTeamInvitationByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventTeamInvitationByIdQuery, GetEventTeamInvitationByIdQueryVariables>(GetEventTeamInvitationByIdDocument, options);
        }
export type GetEventTeamInvitationByIdQueryHookResult = ReturnType<typeof useGetEventTeamInvitationByIdQuery>;
export type GetEventTeamInvitationByIdLazyQueryHookResult = ReturnType<typeof useGetEventTeamInvitationByIdLazyQuery>;
export type GetEventTeamInvitationByIdQueryResult = Apollo.QueryResult<GetEventTeamInvitationByIdQuery, GetEventTeamInvitationByIdQueryVariables>;
export const GetActiveLessonsFromFollowedCoachesDocument = gql`
    query getActiveLessonsFromFollowedCoaches($followerUserId: uuid!) {
  userFollows(
    where: {followedProfile: {coachStatus: {_eq: "ACTIVE"}}, status: {_eq: ACTIVE}, followerUserId: {_eq: $followerUserId}}
  ) {
    id
    followedUserId
    followerUserId
    followedProfile {
      coachStatus
      coverImageFileName
      coverImagePath
      coverImageProviderUrl
      fullName
      id
      preferredName
      profileImageFileName
      profileImagePath
      profileImageProviderUrl
      username
      coachLessons(
        where: {status: {_eq: ACTIVE}, startDateTime: {_gte: "now()"}, privacy: {_eq: PUBLIC}}
      ) {
        ...lessonFields
      }
    }
  }
}
    ${LessonFieldsFragmentDoc}`;

/**
 * __useGetActiveLessonsFromFollowedCoachesQuery__
 *
 * To run a query within a React component, call `useGetActiveLessonsFromFollowedCoachesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActiveLessonsFromFollowedCoachesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActiveLessonsFromFollowedCoachesQuery({
 *   variables: {
 *      followerUserId: // value for 'followerUserId'
 *   },
 * });
 */
export function useGetActiveLessonsFromFollowedCoachesQuery(baseOptions: Apollo.QueryHookOptions<GetActiveLessonsFromFollowedCoachesQuery, GetActiveLessonsFromFollowedCoachesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActiveLessonsFromFollowedCoachesQuery, GetActiveLessonsFromFollowedCoachesQueryVariables>(GetActiveLessonsFromFollowedCoachesDocument, options);
      }
export function useGetActiveLessonsFromFollowedCoachesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActiveLessonsFromFollowedCoachesQuery, GetActiveLessonsFromFollowedCoachesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActiveLessonsFromFollowedCoachesQuery, GetActiveLessonsFromFollowedCoachesQueryVariables>(GetActiveLessonsFromFollowedCoachesDocument, options);
        }
export type GetActiveLessonsFromFollowedCoachesQueryHookResult = ReturnType<typeof useGetActiveLessonsFromFollowedCoachesQuery>;
export type GetActiveLessonsFromFollowedCoachesLazyQueryHookResult = ReturnType<typeof useGetActiveLessonsFromFollowedCoachesLazyQuery>;
export type GetActiveLessonsFromFollowedCoachesQueryResult = Apollo.QueryResult<GetActiveLessonsFromFollowedCoachesQuery, GetActiveLessonsFromFollowedCoachesQueryVariables>;