export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  date: any;
  geography: any;
  geometry: any;
  jsonb: any;
  numeric: any;
  timestamptz: any;
  uuid: any;
};

/** columns and relationships of "amenities" */
export type Amenities = {
  __typename?: 'Amenities';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "amenities" */
export type AmenitiesAggregate = {
  __typename?: 'AmenitiesAggregate';
  aggregate?: Maybe<AmenitiesAggregateFields>;
  nodes: Array<Amenities>;
};

/** aggregate fields of "amenities" */
export type AmenitiesAggregateFields = {
  __typename?: 'AmenitiesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<AmenitiesMaxFields>;
  min?: Maybe<AmenitiesMinFields>;
};


/** aggregate fields of "amenities" */
export type AmenitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AmenitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "amenities". All fields are combined with a logical 'AND'. */
export type AmenitiesBoolExp = {
  _and?: InputMaybe<Array<AmenitiesBoolExp>>;
  _not?: InputMaybe<AmenitiesBoolExp>;
  _or?: InputMaybe<Array<AmenitiesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "amenities" */
export enum AmenitiesConstraint {
  /** unique or primary key constraint on columns "value" */
  AmenitiesPkey = 'amenities_pkey'
}

export enum AmenitiesEnum {
  Food = 'FOOD',
  Lights = 'LIGHTS',
  LockerRooms = 'LOCKER_ROOMS',
  ProShop = 'PRO_SHOP',
  Restrooms = 'RESTROOMS',
  Training = 'TRAINING',
  Water = 'WATER',
  WheelchairAccessible = 'WHEELCHAIR_ACCESSIBLE'
}

/** Boolean expression to compare columns of type "AmenitiesEnum". All fields are combined with logical 'AND'. */
export type AmenitiesEnumComparisonExp = {
  _eq?: InputMaybe<AmenitiesEnum>;
  _in?: InputMaybe<Array<AmenitiesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<AmenitiesEnum>;
  _nin?: InputMaybe<Array<AmenitiesEnum>>;
};

/** input type for inserting data into table "amenities" */
export type AmenitiesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AmenitiesMaxFields = {
  __typename?: 'AmenitiesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AmenitiesMinFields = {
  __typename?: 'AmenitiesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "amenities" */
export type AmenitiesMutationResponse = {
  __typename?: 'AmenitiesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Amenities>;
};

/** on_conflict condition type for table "amenities" */
export type AmenitiesOnConflict = {
  constraint: AmenitiesConstraint;
  updateColumns?: Array<AmenitiesUpdateColumn>;
  where?: InputMaybe<AmenitiesBoolExp>;
};

/** Ordering options when selecting data from "amenities". */
export type AmenitiesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: amenities */
export type AmenitiesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "amenities" */
export enum AmenitiesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "amenities" */
export type AmenitiesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "amenities" */
export type AmenitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AmenitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AmenitiesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "amenities" */
export enum AmenitiesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type AmenitiesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AmenitiesSetInput>;
  /** filter the rows which have to be updated */
  where: AmenitiesBoolExp;
};

/** columns and relationships of "app_personas" */
export type AppPersonas = {
  __typename?: 'AppPersonas';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "app_personas" */
export type AppPersonasAggregate = {
  __typename?: 'AppPersonasAggregate';
  aggregate?: Maybe<AppPersonasAggregateFields>;
  nodes: Array<AppPersonas>;
};

/** aggregate fields of "app_personas" */
export type AppPersonasAggregateFields = {
  __typename?: 'AppPersonasAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<AppPersonasMaxFields>;
  min?: Maybe<AppPersonasMinFields>;
};


/** aggregate fields of "app_personas" */
export type AppPersonasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AppPersonasSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "app_personas". All fields are combined with a logical 'AND'. */
export type AppPersonasBoolExp = {
  _and?: InputMaybe<Array<AppPersonasBoolExp>>;
  _not?: InputMaybe<AppPersonasBoolExp>;
  _or?: InputMaybe<Array<AppPersonasBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "app_personas" */
export enum AppPersonasConstraint {
  /** unique or primary key constraint on columns "value" */
  AppPersonasPkey = 'app_personas_pkey'
}

export enum AppPersonasEnum {
  Admin = 'ADMIN',
  Coach = 'COACH',
  Organizer = 'ORGANIZER',
  Player = 'PLAYER',
  System = 'SYSTEM'
}

/** Boolean expression to compare columns of type "AppPersonasEnum". All fields are combined with logical 'AND'. */
export type AppPersonasEnumComparisonExp = {
  _eq?: InputMaybe<AppPersonasEnum>;
  _in?: InputMaybe<Array<AppPersonasEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<AppPersonasEnum>;
  _nin?: InputMaybe<Array<AppPersonasEnum>>;
};

/** input type for inserting data into table "app_personas" */
export type AppPersonasInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AppPersonasMaxFields = {
  __typename?: 'AppPersonasMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AppPersonasMinFields = {
  __typename?: 'AppPersonasMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "app_personas" */
export type AppPersonasMutationResponse = {
  __typename?: 'AppPersonasMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AppPersonas>;
};

/** on_conflict condition type for table "app_personas" */
export type AppPersonasOnConflict = {
  constraint: AppPersonasConstraint;
  updateColumns?: Array<AppPersonasUpdateColumn>;
  where?: InputMaybe<AppPersonasBoolExp>;
};

/** Ordering options when selecting data from "app_personas". */
export type AppPersonasOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: app_personas */
export type AppPersonasPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "app_personas" */
export enum AppPersonasSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "app_personas" */
export type AppPersonasSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "app_personas" */
export type AppPersonasStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AppPersonasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AppPersonasStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "app_personas" */
export enum AppPersonasUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type AppPersonasUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AppPersonasSetInput>;
  /** filter the rows which have to be updated */
  where: AppPersonasBoolExp;
};

/** columns and relationships of "app_pings" */
export type AppPings = {
  __typename?: 'AppPings';
  city: Scalars['String'];
  country: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  firebaseId?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  ip: Scalars['String'];
  ipResponse?: Maybe<Scalars['jsonb']>;
  pathname: Scalars['String'];
  /** iOS, Android, Web */
  platform: Scalars['String'];
  queryString: Scalars['String'];
  region: Scalars['String'];
  timezone: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']>;
  zip: Scalars['String'];
};


/** columns and relationships of "app_pings" */
export type AppPingsIpResponseArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "app_pings" */
export type AppPingsAggregate = {
  __typename?: 'AppPingsAggregate';
  aggregate?: Maybe<AppPingsAggregateFields>;
  nodes: Array<AppPings>;
};

/** aggregate fields of "app_pings" */
export type AppPingsAggregateFields = {
  __typename?: 'AppPingsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<AppPingsMaxFields>;
  min?: Maybe<AppPingsMinFields>;
};


/** aggregate fields of "app_pings" */
export type AppPingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AppPingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AppPingsAppendInput = {
  ipResponse?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "app_pings". All fields are combined with a logical 'AND'. */
export type AppPingsBoolExp = {
  _and?: InputMaybe<Array<AppPingsBoolExp>>;
  _not?: InputMaybe<AppPingsBoolExp>;
  _or?: InputMaybe<Array<AppPingsBoolExp>>;
  city?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  firebaseId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ip?: InputMaybe<StringComparisonExp>;
  ipResponse?: InputMaybe<JsonbComparisonExp>;
  pathname?: InputMaybe<StringComparisonExp>;
  platform?: InputMaybe<StringComparisonExp>;
  queryString?: InputMaybe<StringComparisonExp>;
  region?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  zip?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "app_pings" */
export enum AppPingsConstraint {
  /** unique or primary key constraint on columns "id" */
  AppPingsPkey = 'app_pings_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AppPingsDeleteAtPathInput = {
  ipResponse?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AppPingsDeleteElemInput = {
  ipResponse?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AppPingsDeleteKeyInput = {
  ipResponse?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "app_pings" */
export type AppPingsInsertInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  firebaseId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  ipResponse?: InputMaybe<Scalars['jsonb']>;
  pathname?: InputMaybe<Scalars['String']>;
  /** iOS, Android, Web */
  platform?: InputMaybe<Scalars['String']>;
  queryString?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AppPingsMaxFields = {
  __typename?: 'AppPingsMaxFields';
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  firebaseId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  pathname?: Maybe<Scalars['String']>;
  /** iOS, Android, Web */
  platform?: Maybe<Scalars['String']>;
  queryString?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  zip?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AppPingsMinFields = {
  __typename?: 'AppPingsMinFields';
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  firebaseId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  pathname?: Maybe<Scalars['String']>;
  /** iOS, Android, Web */
  platform?: Maybe<Scalars['String']>;
  queryString?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  zip?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "app_pings" */
export type AppPingsMutationResponse = {
  __typename?: 'AppPingsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AppPings>;
};

/** on_conflict condition type for table "app_pings" */
export type AppPingsOnConflict = {
  constraint: AppPingsConstraint;
  updateColumns?: Array<AppPingsUpdateColumn>;
  where?: InputMaybe<AppPingsBoolExp>;
};

/** Ordering options when selecting data from "app_pings". */
export type AppPingsOrderBy = {
  city?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  firebaseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  ipResponse?: InputMaybe<OrderBy>;
  pathname?: InputMaybe<OrderBy>;
  platform?: InputMaybe<OrderBy>;
  queryString?: InputMaybe<OrderBy>;
  region?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  zip?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: app_pings */
export type AppPingsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AppPingsPrependInput = {
  ipResponse?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "app_pings" */
export enum AppPingsSelectColumn {
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FirebaseId = 'firebaseId',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  IpResponse = 'ipResponse',
  /** column name */
  Pathname = 'pathname',
  /** column name */
  Platform = 'platform',
  /** column name */
  QueryString = 'queryString',
  /** column name */
  Region = 'region',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Zip = 'zip'
}

/** input type for updating data in table "app_pings" */
export type AppPingsSetInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  firebaseId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  ipResponse?: InputMaybe<Scalars['jsonb']>;
  pathname?: InputMaybe<Scalars['String']>;
  /** iOS, Android, Web */
  platform?: InputMaybe<Scalars['String']>;
  queryString?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "app_pings" */
export type AppPingsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AppPingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AppPingsStreamCursorValueInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  firebaseId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  ipResponse?: InputMaybe<Scalars['jsonb']>;
  pathname?: InputMaybe<Scalars['String']>;
  /** iOS, Android, Web */
  platform?: InputMaybe<Scalars['String']>;
  queryString?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** update columns of table "app_pings" */
export enum AppPingsUpdateColumn {
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FirebaseId = 'firebaseId',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  IpResponse = 'ipResponse',
  /** column name */
  Pathname = 'pathname',
  /** column name */
  Platform = 'platform',
  /** column name */
  QueryString = 'queryString',
  /** column name */
  Region = 'region',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Zip = 'zip'
}

export type AppPingsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AppPingsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AppPingsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AppPingsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AppPingsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AppPingsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AppPingsSetInput>;
  /** filter the rows which have to be updated */
  where: AppPingsBoolExp;
};

/** columns and relationships of "ball_types" */
export type BallTypes = {
  __typename?: 'BallTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "ball_types" */
export type BallTypesAggregate = {
  __typename?: 'BallTypesAggregate';
  aggregate?: Maybe<BallTypesAggregateFields>;
  nodes: Array<BallTypes>;
};

/** aggregate fields of "ball_types" */
export type BallTypesAggregateFields = {
  __typename?: 'BallTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<BallTypesMaxFields>;
  min?: Maybe<BallTypesMinFields>;
};


/** aggregate fields of "ball_types" */
export type BallTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BallTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "ball_types". All fields are combined with a logical 'AND'. */
export type BallTypesBoolExp = {
  _and?: InputMaybe<Array<BallTypesBoolExp>>;
  _not?: InputMaybe<BallTypesBoolExp>;
  _or?: InputMaybe<Array<BallTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "ball_types" */
export enum BallTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  BallTypesPkey = 'ball_types_pkey'
}

export enum BallTypesEnum {
  Custom = 'CUSTOM',
  FranklinX_40Pickleball = 'FRANKLIN_X_40_PICKLEBALL',
  GammaPhotonPickleball = 'GAMMA_PHOTON_PICKLEBALL',
  NotSelected = 'NOT_SELECTED',
  OnixDuraFast_40Pickleball = 'ONIX_DURA_FAST_40_PICKLEBALL',
  OnixFuseG2Pickleball = 'ONIX_FUSE_G2_PICKLEBALL',
  SelkirkProS1Pickleball = 'SELKIRK_PRO_S1_PICKLEBALL'
}

/** Boolean expression to compare columns of type "BallTypesEnum". All fields are combined with logical 'AND'. */
export type BallTypesEnumComparisonExp = {
  _eq?: InputMaybe<BallTypesEnum>;
  _in?: InputMaybe<Array<BallTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<BallTypesEnum>;
  _nin?: InputMaybe<Array<BallTypesEnum>>;
};

/** input type for inserting data into table "ball_types" */
export type BallTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type BallTypesMaxFields = {
  __typename?: 'BallTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type BallTypesMinFields = {
  __typename?: 'BallTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "ball_types" */
export type BallTypesMutationResponse = {
  __typename?: 'BallTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<BallTypes>;
};

/** on_conflict condition type for table "ball_types" */
export type BallTypesOnConflict = {
  constraint: BallTypesConstraint;
  updateColumns?: Array<BallTypesUpdateColumn>;
  where?: InputMaybe<BallTypesBoolExp>;
};

/** Ordering options when selecting data from "ball_types". */
export type BallTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: ball_types */
export type BallTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "ball_types" */
export enum BallTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "ball_types" */
export type BallTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "ball_types" */
export type BallTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BallTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BallTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "ball_types" */
export enum BallTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type BallTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BallTypesSetInput>;
  /** filter the rows which have to be updated */
  where: BallTypesBoolExp;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

/** columns and relationships of "cities" */
export type Cities = {
  __typename?: 'Cities';
  citySlug: Scalars['String'];
  /** An object relationship */
  countrySubdivision: CountrySubdivisions;
  countrySubdivisionId: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  geometry?: Maybe<Scalars['geography']>;
  /** An array relationship */
  groups: Array<Groups>;
  /** An aggregate relationship */
  groupsAggregate: GroupsAggregate;
  id: Scalars['uuid'];
  isActive: Scalars['Boolean'];
  latitude: Scalars['numeric'];
  longitude: Scalars['numeric'];
  name: Scalars['String'];
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  sourceCitySlug?: Maybe<Scalars['String']>;
  sourceCountrySlug?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceStateSlug?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  venues: Array<Venues>;
  /** An aggregate relationship */
  venuesAggregate: VenuesAggregate;
};


/** columns and relationships of "cities" */
export type CitiesGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


/** columns and relationships of "cities" */
export type CitiesGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


/** columns and relationships of "cities" */
export type CitiesVenuesArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


/** columns and relationships of "cities" */
export type CitiesVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};

/** aggregated selection of "cities" */
export type CitiesAggregate = {
  __typename?: 'CitiesAggregate';
  aggregate?: Maybe<CitiesAggregateFields>;
  nodes: Array<Cities>;
};

export type CitiesAggregateBoolExp = {
  bool_and?: InputMaybe<CitiesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<CitiesAggregateBoolExpBool_Or>;
  count?: InputMaybe<CitiesAggregateBoolExpCount>;
};

/** aggregate fields of "cities" */
export type CitiesAggregateFields = {
  __typename?: 'CitiesAggregateFields';
  avg?: Maybe<CitiesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<CitiesMaxFields>;
  min?: Maybe<CitiesMinFields>;
  stddev?: Maybe<CitiesStddevFields>;
  stddevPop?: Maybe<CitiesStddevPopFields>;
  stddevSamp?: Maybe<CitiesStddevSampFields>;
  sum?: Maybe<CitiesSumFields>;
  varPop?: Maybe<CitiesVarPopFields>;
  varSamp?: Maybe<CitiesVarSampFields>;
  variance?: Maybe<CitiesVarianceFields>;
};


/** aggregate fields of "cities" */
export type CitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "cities" */
export type CitiesAggregateOrderBy = {
  avg?: InputMaybe<CitiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CitiesMaxOrderBy>;
  min?: InputMaybe<CitiesMinOrderBy>;
  stddev?: InputMaybe<CitiesStddevOrderBy>;
  stddevPop?: InputMaybe<CitiesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<CitiesStddevSampOrderBy>;
  sum?: InputMaybe<CitiesSumOrderBy>;
  varPop?: InputMaybe<CitiesVarPopOrderBy>;
  varSamp?: InputMaybe<CitiesVarSampOrderBy>;
  variance?: InputMaybe<CitiesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "cities" */
export type CitiesArrRelInsertInput = {
  data: Array<CitiesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<CitiesOnConflict>;
};

/** aggregate avg on columns */
export type CitiesAvgFields = {
  __typename?: 'CitiesAvgFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "cities" */
export type CitiesAvgOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "cities". All fields are combined with a logical 'AND'. */
export type CitiesBoolExp = {
  _and?: InputMaybe<Array<CitiesBoolExp>>;
  _not?: InputMaybe<CitiesBoolExp>;
  _or?: InputMaybe<Array<CitiesBoolExp>>;
  citySlug?: InputMaybe<StringComparisonExp>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsBoolExp>;
  countrySubdivisionId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groups?: InputMaybe<GroupsBoolExp>;
  groupsAggregate?: InputMaybe<GroupsAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  source?: InputMaybe<StringComparisonExp>;
  sourceCitySlug?: InputMaybe<StringComparisonExp>;
  sourceCountrySlug?: InputMaybe<StringComparisonExp>;
  sourceId?: InputMaybe<StringComparisonExp>;
  sourceStateSlug?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venues?: InputMaybe<VenuesBoolExp>;
  venuesAggregate?: InputMaybe<VenuesAggregateBoolExp>;
};

/** unique or primary key constraints on table "cities" */
export enum CitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  CitiesPkey = 'cities_pkey',
  /** unique or primary key constraint on columns "slug" */
  CitiesSlugKey = 'cities_slug_key',
  /** unique or primary key constraint on columns "source_id" */
  CitiesSourceIdKey = 'cities_source_id_key'
}

/** input type for incrementing numeric columns in table "cities" */
export type CitiesIncInput = {
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "cities" */
export type CitiesInsertInput = {
  citySlug?: InputMaybe<Scalars['String']>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsObjRelInsertInput>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groups?: InputMaybe<GroupsArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceCitySlug?: InputMaybe<Scalars['String']>;
  sourceCountrySlug?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceStateSlug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venues?: InputMaybe<VenuesArrRelInsertInput>;
};

/** aggregate max on columns */
export type CitiesMaxFields = {
  __typename?: 'CitiesMaxFields';
  citySlug?: Maybe<Scalars['String']>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  sourceCitySlug?: Maybe<Scalars['String']>;
  sourceCountrySlug?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceStateSlug?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "cities" */
export type CitiesMaxOrderBy = {
  citySlug?: InputMaybe<OrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceCitySlug?: InputMaybe<OrderBy>;
  sourceCountrySlug?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceStateSlug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CitiesMinFields = {
  __typename?: 'CitiesMinFields';
  citySlug?: Maybe<Scalars['String']>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  sourceCitySlug?: Maybe<Scalars['String']>;
  sourceCountrySlug?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceStateSlug?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "cities" */
export type CitiesMinOrderBy = {
  citySlug?: InputMaybe<OrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceCitySlug?: InputMaybe<OrderBy>;
  sourceCountrySlug?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceStateSlug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "cities" */
export type CitiesMutationResponse = {
  __typename?: 'CitiesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cities>;
};

/** input type for inserting object relation for remote table "cities" */
export type CitiesObjRelInsertInput = {
  data: CitiesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<CitiesOnConflict>;
};

/** on_conflict condition type for table "cities" */
export type CitiesOnConflict = {
  constraint: CitiesConstraint;
  updateColumns?: Array<CitiesUpdateColumn>;
  where?: InputMaybe<CitiesBoolExp>;
};

/** Ordering options when selecting data from "cities". */
export type CitiesOrderBy = {
  citySlug?: InputMaybe<OrderBy>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsOrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<GroupsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceCitySlug?: InputMaybe<OrderBy>;
  sourceCountrySlug?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceStateSlug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venuesAggregate?: InputMaybe<VenuesAggregateOrderBy>;
};

/** primary key columns input for table: cities */
export type CitiesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "cities" */
export enum CitiesSelectColumn {
  /** column name */
  CitySlug = 'citySlug',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceCitySlug = 'sourceCitySlug',
  /** column name */
  SourceCountrySlug = 'sourceCountrySlug',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  SourceStateSlug = 'sourceStateSlug',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "citiesAggregateBoolExpBool_andArgumentsColumns" columns of table "cities" */
export enum CitiesSelectColumnCitiesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsActive = 'isActive'
}

/** select "citiesAggregateBoolExpBool_orArgumentsColumns" columns of table "cities" */
export enum CitiesSelectColumnCitiesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsActive = 'isActive'
}

/** input type for updating data in table "cities" */
export type CitiesSetInput = {
  citySlug?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceCitySlug?: InputMaybe<Scalars['String']>;
  sourceCountrySlug?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceStateSlug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type CitiesStddevFields = {
  __typename?: 'CitiesStddevFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "cities" */
export type CitiesStddevOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type CitiesStddevPopFields = {
  __typename?: 'CitiesStddevPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "cities" */
export type CitiesStddevPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type CitiesStddevSampFields = {
  __typename?: 'CitiesStddevSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "cities" */
export type CitiesStddevSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "cities" */
export type CitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CitiesStreamCursorValueInput = {
  citySlug?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceCitySlug?: InputMaybe<Scalars['String']>;
  sourceCountrySlug?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceStateSlug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type CitiesSumFields = {
  __typename?: 'CitiesSumFields';
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "cities" */
export type CitiesSumOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** update columns of table "cities" */
export enum CitiesUpdateColumn {
  /** column name */
  CitySlug = 'citySlug',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceCitySlug = 'sourceCitySlug',
  /** column name */
  SourceCountrySlug = 'sourceCountrySlug',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  SourceStateSlug = 'sourceStateSlug',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type CitiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CitiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CitiesSetInput>;
  /** filter the rows which have to be updated */
  where: CitiesBoolExp;
};

/** aggregate varPop on columns */
export type CitiesVarPopFields = {
  __typename?: 'CitiesVarPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "cities" */
export type CitiesVarPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type CitiesVarSampFields = {
  __typename?: 'CitiesVarSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "cities" */
export type CitiesVarSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CitiesVarianceFields = {
  __typename?: 'CitiesVarianceFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "cities" */
export type CitiesVarianceOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** columns and relationships of "coach_qualification_groups" */
export type CoachQualificationGroups = {
  __typename?: 'CoachQualificationGroups';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "coach_qualification_groups" */
export type CoachQualificationGroupsAggregate = {
  __typename?: 'CoachQualificationGroupsAggregate';
  aggregate?: Maybe<CoachQualificationGroupsAggregateFields>;
  nodes: Array<CoachQualificationGroups>;
};

/** aggregate fields of "coach_qualification_groups" */
export type CoachQualificationGroupsAggregateFields = {
  __typename?: 'CoachQualificationGroupsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CoachQualificationGroupsMaxFields>;
  min?: Maybe<CoachQualificationGroupsMinFields>;
};


/** aggregate fields of "coach_qualification_groups" */
export type CoachQualificationGroupsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "coach_qualification_groups". All fields are combined with a logical 'AND'. */
export type CoachQualificationGroupsBoolExp = {
  _and?: InputMaybe<Array<CoachQualificationGroupsBoolExp>>;
  _not?: InputMaybe<CoachQualificationGroupsBoolExp>;
  _or?: InputMaybe<Array<CoachQualificationGroupsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "coach_qualification_groups" */
export enum CoachQualificationGroupsConstraint {
  /** unique or primary key constraint on columns "value" */
  CoachQualificationGroupsPkey = 'coach_qualification_groups_pkey'
}

export enum CoachQualificationGroupsEnum {
  Certificate = 'CERTIFICATE',
  CurrentCollegePlayer = 'CURRENT_COLLEGE_PLAYER',
  FormerCollegePlayer = 'FORMER_COLLEGE_PLAYER'
}

/** Boolean expression to compare columns of type "CoachQualificationGroupsEnum". All fields are combined with logical 'AND'. */
export type CoachQualificationGroupsEnumComparisonExp = {
  _eq?: InputMaybe<CoachQualificationGroupsEnum>;
  _in?: InputMaybe<Array<CoachQualificationGroupsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CoachQualificationGroupsEnum>;
  _nin?: InputMaybe<Array<CoachQualificationGroupsEnum>>;
};

/** input type for inserting data into table "coach_qualification_groups" */
export type CoachQualificationGroupsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CoachQualificationGroupsMaxFields = {
  __typename?: 'CoachQualificationGroupsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CoachQualificationGroupsMinFields = {
  __typename?: 'CoachQualificationGroupsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "coach_qualification_groups" */
export type CoachQualificationGroupsMutationResponse = {
  __typename?: 'CoachQualificationGroupsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CoachQualificationGroups>;
};

/** on_conflict condition type for table "coach_qualification_groups" */
export type CoachQualificationGroupsOnConflict = {
  constraint: CoachQualificationGroupsConstraint;
  updateColumns?: Array<CoachQualificationGroupsUpdateColumn>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};

/** Ordering options when selecting data from "coach_qualification_groups". */
export type CoachQualificationGroupsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coach_qualification_groups */
export type CoachQualificationGroupsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "coach_qualification_groups" */
export enum CoachQualificationGroupsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "coach_qualification_groups" */
export type CoachQualificationGroupsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "coach_qualification_groups" */
export type CoachQualificationGroupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachQualificationGroupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachQualificationGroupsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "coach_qualification_groups" */
export enum CoachQualificationGroupsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CoachQualificationGroupsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoachQualificationGroupsSetInput>;
  /** filter the rows which have to be updated */
  where: CoachQualificationGroupsBoolExp;
};

/** columns and relationships of "coach_qualification_statuses" */
export type CoachQualificationStatuses = {
  __typename?: 'CoachQualificationStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "coach_qualification_statuses" */
export type CoachQualificationStatusesAggregate = {
  __typename?: 'CoachQualificationStatusesAggregate';
  aggregate?: Maybe<CoachQualificationStatusesAggregateFields>;
  nodes: Array<CoachQualificationStatuses>;
};

/** aggregate fields of "coach_qualification_statuses" */
export type CoachQualificationStatusesAggregateFields = {
  __typename?: 'CoachQualificationStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CoachQualificationStatusesMaxFields>;
  min?: Maybe<CoachQualificationStatusesMinFields>;
};


/** aggregate fields of "coach_qualification_statuses" */
export type CoachQualificationStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoachQualificationStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "coach_qualification_statuses". All fields are combined with a logical 'AND'. */
export type CoachQualificationStatusesBoolExp = {
  _and?: InputMaybe<Array<CoachQualificationStatusesBoolExp>>;
  _not?: InputMaybe<CoachQualificationStatusesBoolExp>;
  _or?: InputMaybe<Array<CoachQualificationStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "coach_qualification_statuses" */
export enum CoachQualificationStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  CoachQualificationStatusesPkey = 'coach_qualification_statuses_pkey'
}

export enum CoachQualificationStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "CoachQualificationStatusesEnum". All fields are combined with logical 'AND'. */
export type CoachQualificationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<CoachQualificationStatusesEnum>;
  _in?: InputMaybe<Array<CoachQualificationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CoachQualificationStatusesEnum>;
  _nin?: InputMaybe<Array<CoachQualificationStatusesEnum>>;
};

/** input type for inserting data into table "coach_qualification_statuses" */
export type CoachQualificationStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CoachQualificationStatusesMaxFields = {
  __typename?: 'CoachQualificationStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CoachQualificationStatusesMinFields = {
  __typename?: 'CoachQualificationStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "coach_qualification_statuses" */
export type CoachQualificationStatusesMutationResponse = {
  __typename?: 'CoachQualificationStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CoachQualificationStatuses>;
};

/** on_conflict condition type for table "coach_qualification_statuses" */
export type CoachQualificationStatusesOnConflict = {
  constraint: CoachQualificationStatusesConstraint;
  updateColumns?: Array<CoachQualificationStatusesUpdateColumn>;
  where?: InputMaybe<CoachQualificationStatusesBoolExp>;
};

/** Ordering options when selecting data from "coach_qualification_statuses". */
export type CoachQualificationStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coach_qualification_statuses */
export type CoachQualificationStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "coach_qualification_statuses" */
export enum CoachQualificationStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "coach_qualification_statuses" */
export type CoachQualificationStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "coach_qualification_statuses" */
export type CoachQualificationStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachQualificationStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachQualificationStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "coach_qualification_statuses" */
export enum CoachQualificationStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CoachQualificationStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoachQualificationStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: CoachQualificationStatusesBoolExp;
};

/** columns and relationships of "coach_qualifications" */
export type CoachQualifications = {
  __typename?: 'CoachQualifications';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayKey: Scalars['String'];
  groupId?: Maybe<CoachQualificationGroupsEnum>;
  id: Scalars['uuid'];
  name: Scalars['String'];
  order: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "coach_qualifications" */
export type CoachQualificationsAggregate = {
  __typename?: 'CoachQualificationsAggregate';
  aggregate?: Maybe<CoachQualificationsAggregateFields>;
  nodes: Array<CoachQualifications>;
};

/** aggregate fields of "coach_qualifications" */
export type CoachQualificationsAggregateFields = {
  __typename?: 'CoachQualificationsAggregateFields';
  avg?: Maybe<CoachQualificationsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<CoachQualificationsMaxFields>;
  min?: Maybe<CoachQualificationsMinFields>;
  stddev?: Maybe<CoachQualificationsStddevFields>;
  stddevPop?: Maybe<CoachQualificationsStddevPopFields>;
  stddevSamp?: Maybe<CoachQualificationsStddevSampFields>;
  sum?: Maybe<CoachQualificationsSumFields>;
  varPop?: Maybe<CoachQualificationsVarPopFields>;
  varSamp?: Maybe<CoachQualificationsVarSampFields>;
  variance?: Maybe<CoachQualificationsVarianceFields>;
};


/** aggregate fields of "coach_qualifications" */
export type CoachQualificationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type CoachQualificationsAvgFields = {
  __typename?: 'CoachQualificationsAvgFields';
  order?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "coach_qualifications". All fields are combined with a logical 'AND'. */
export type CoachQualificationsBoolExp = {
  _and?: InputMaybe<Array<CoachQualificationsBoolExp>>;
  _not?: InputMaybe<CoachQualificationsBoolExp>;
  _or?: InputMaybe<Array<CoachQualificationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  displayKey?: InputMaybe<StringComparisonExp>;
  groupId?: InputMaybe<CoachQualificationGroupsEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "coach_qualifications" */
export enum CoachQualificationsConstraint {
  /** unique or primary key constraint on columns "display_key" */
  CoachQualificationsDisplayKeyKey = 'coach_qualifications_display_key_key',
  /** unique or primary key constraint on columns "id" */
  CoachQualificationsPkey = 'coach_qualifications_pkey'
}

/** input type for incrementing numeric columns in table "coach_qualifications" */
export type CoachQualificationsIncInput = {
  order?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "coach_qualifications" */
export type CoachQualificationsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayKey?: InputMaybe<Scalars['String']>;
  groupId?: InputMaybe<CoachQualificationGroupsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type CoachQualificationsMaxFields = {
  __typename?: 'CoachQualificationsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayKey?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type CoachQualificationsMinFields = {
  __typename?: 'CoachQualificationsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayKey?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "coach_qualifications" */
export type CoachQualificationsMutationResponse = {
  __typename?: 'CoachQualificationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CoachQualifications>;
};

/** input type for inserting object relation for remote table "coach_qualifications" */
export type CoachQualificationsObjRelInsertInput = {
  data: CoachQualificationsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<CoachQualificationsOnConflict>;
};

/** on_conflict condition type for table "coach_qualifications" */
export type CoachQualificationsOnConflict = {
  constraint: CoachQualificationsConstraint;
  updateColumns?: Array<CoachQualificationsUpdateColumn>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};

/** Ordering options when selecting data from "coach_qualifications". */
export type CoachQualificationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayKey?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coach_qualifications */
export type CoachQualificationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "coach_qualifications" */
export enum CoachQualificationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayKey = 'displayKey',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "coach_qualifications" */
export type CoachQualificationsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayKey?: InputMaybe<Scalars['String']>;
  groupId?: InputMaybe<CoachQualificationGroupsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type CoachQualificationsStddevFields = {
  __typename?: 'CoachQualificationsStddevFields';
  order?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type CoachQualificationsStddevPopFields = {
  __typename?: 'CoachQualificationsStddevPopFields';
  order?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type CoachQualificationsStddevSampFields = {
  __typename?: 'CoachQualificationsStddevSampFields';
  order?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "coach_qualifications" */
export type CoachQualificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachQualificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachQualificationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayKey?: InputMaybe<Scalars['String']>;
  groupId?: InputMaybe<CoachQualificationGroupsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type CoachQualificationsSumFields = {
  __typename?: 'CoachQualificationsSumFields';
  order?: Maybe<Scalars['Int']>;
};

/** update columns of table "coach_qualifications" */
export enum CoachQualificationsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayKey = 'displayKey',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type CoachQualificationsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CoachQualificationsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoachQualificationsSetInput>;
  /** filter the rows which have to be updated */
  where: CoachQualificationsBoolExp;
};

/** aggregate varPop on columns */
export type CoachQualificationsVarPopFields = {
  __typename?: 'CoachQualificationsVarPopFields';
  order?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type CoachQualificationsVarSampFields = {
  __typename?: 'CoachQualificationsVarSampFields';
  order?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type CoachQualificationsVarianceFields = {
  __typename?: 'CoachQualificationsVarianceFields';
  order?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "coach_status" */
export type CoachStatus = {
  __typename?: 'CoachStatus';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "coach_status" */
export type CoachStatusAggregate = {
  __typename?: 'CoachStatusAggregate';
  aggregate?: Maybe<CoachStatusAggregateFields>;
  nodes: Array<CoachStatus>;
};

/** aggregate fields of "coach_status" */
export type CoachStatusAggregateFields = {
  __typename?: 'CoachStatusAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CoachStatusMaxFields>;
  min?: Maybe<CoachStatusMinFields>;
};


/** aggregate fields of "coach_status" */
export type CoachStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoachStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "coach_status". All fields are combined with a logical 'AND'. */
export type CoachStatusBoolExp = {
  _and?: InputMaybe<Array<CoachStatusBoolExp>>;
  _not?: InputMaybe<CoachStatusBoolExp>;
  _or?: InputMaybe<Array<CoachStatusBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "coach_status" */
export enum CoachStatusConstraint {
  /** unique or primary key constraint on columns "value" */
  CoachStatusPkey = 'coach_status_pkey'
}

export enum CoachStatusEnum {
  Active = 'ACTIVE',
  Blocked = 'BLOCKED',
  Inactive = 'INACTIVE',
  None = 'NONE'
}

/** Boolean expression to compare columns of type "CoachStatusEnum". All fields are combined with logical 'AND'. */
export type CoachStatusEnumComparisonExp = {
  _eq?: InputMaybe<CoachStatusEnum>;
  _in?: InputMaybe<Array<CoachStatusEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CoachStatusEnum>;
  _nin?: InputMaybe<Array<CoachStatusEnum>>;
};

/** input type for inserting data into table "coach_status" */
export type CoachStatusInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CoachStatusMaxFields = {
  __typename?: 'CoachStatusMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CoachStatusMinFields = {
  __typename?: 'CoachStatusMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "coach_status" */
export type CoachStatusMutationResponse = {
  __typename?: 'CoachStatusMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CoachStatus>;
};

/** on_conflict condition type for table "coach_status" */
export type CoachStatusOnConflict = {
  constraint: CoachStatusConstraint;
  updateColumns?: Array<CoachStatusUpdateColumn>;
  where?: InputMaybe<CoachStatusBoolExp>;
};

/** Ordering options when selecting data from "coach_status". */
export type CoachStatusOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coach_status */
export type CoachStatusPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "coach_status" */
export enum CoachStatusSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "coach_status" */
export type CoachStatusSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "coach_status" */
export type CoachStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CoachStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoachStatusStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "coach_status" */
export enum CoachStatusUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CoachStatusUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoachStatusSetInput>;
  /** filter the rows which have to be updated */
  where: CoachStatusBoolExp;
};

/** columns and relationships of "comment_vote" */
export type CommentVote = {
  __typename?: 'CommentVote';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "comment_vote" */
export type CommentVoteAggregate = {
  __typename?: 'CommentVoteAggregate';
  aggregate?: Maybe<CommentVoteAggregateFields>;
  nodes: Array<CommentVote>;
};

/** aggregate fields of "comment_vote" */
export type CommentVoteAggregateFields = {
  __typename?: 'CommentVoteAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CommentVoteMaxFields>;
  min?: Maybe<CommentVoteMinFields>;
};


/** aggregate fields of "comment_vote" */
export type CommentVoteAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CommentVoteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "comment_vote". All fields are combined with a logical 'AND'. */
export type CommentVoteBoolExp = {
  _and?: InputMaybe<Array<CommentVoteBoolExp>>;
  _not?: InputMaybe<CommentVoteBoolExp>;
  _or?: InputMaybe<Array<CommentVoteBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "comment_vote" */
export enum CommentVoteConstraint {
  /** unique or primary key constraint on columns "value" */
  CommentVotePkey = 'comment_vote_pkey'
}

export enum CommentVoteEnum {
  Negative = 'NEGATIVE',
  None = 'NONE',
  Positive = 'POSITIVE'
}

/** Boolean expression to compare columns of type "CommentVoteEnum". All fields are combined with logical 'AND'. */
export type CommentVoteEnumComparisonExp = {
  _eq?: InputMaybe<CommentVoteEnum>;
  _in?: InputMaybe<Array<CommentVoteEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CommentVoteEnum>;
  _nin?: InputMaybe<Array<CommentVoteEnum>>;
};

/** input type for inserting data into table "comment_vote" */
export type CommentVoteInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CommentVoteMaxFields = {
  __typename?: 'CommentVoteMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CommentVoteMinFields = {
  __typename?: 'CommentVoteMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "comment_vote" */
export type CommentVoteMutationResponse = {
  __typename?: 'CommentVoteMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CommentVote>;
};

/** on_conflict condition type for table "comment_vote" */
export type CommentVoteOnConflict = {
  constraint: CommentVoteConstraint;
  updateColumns?: Array<CommentVoteUpdateColumn>;
  where?: InputMaybe<CommentVoteBoolExp>;
};

/** Ordering options when selecting data from "comment_vote". */
export type CommentVoteOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: comment_vote */
export type CommentVotePkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "comment_vote" */
export enum CommentVoteSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "comment_vote" */
export type CommentVoteSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "comment_vote" */
export type CommentVoteStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CommentVoteStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CommentVoteStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "comment_vote" */
export enum CommentVoteUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CommentVoteUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CommentVoteSetInput>;
  /** filter the rows which have to be updated */
  where: CommentVoteBoolExp;
};

/** columns and relationships of "communication_preference_statuses" */
export type CommunicationPreferenceStatuses = {
  __typename?: 'CommunicationPreferenceStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "communication_preference_statuses" */
export type CommunicationPreferenceStatusesAggregate = {
  __typename?: 'CommunicationPreferenceStatusesAggregate';
  aggregate?: Maybe<CommunicationPreferenceStatusesAggregateFields>;
  nodes: Array<CommunicationPreferenceStatuses>;
};

/** aggregate fields of "communication_preference_statuses" */
export type CommunicationPreferenceStatusesAggregateFields = {
  __typename?: 'CommunicationPreferenceStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CommunicationPreferenceStatusesMaxFields>;
  min?: Maybe<CommunicationPreferenceStatusesMinFields>;
};


/** aggregate fields of "communication_preference_statuses" */
export type CommunicationPreferenceStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "communication_preference_statuses". All fields are combined with a logical 'AND'. */
export type CommunicationPreferenceStatusesBoolExp = {
  _and?: InputMaybe<Array<CommunicationPreferenceStatusesBoolExp>>;
  _not?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
  _or?: InputMaybe<Array<CommunicationPreferenceStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "communication_preference_statuses" */
export enum CommunicationPreferenceStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  CommunicationPreferenceStatusesPkey = 'communication_preference_statuses_pkey'
}

export enum CommunicationPreferenceStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "CommunicationPreferenceStatusesEnum". All fields are combined with logical 'AND'. */
export type CommunicationPreferenceStatusesEnumComparisonExp = {
  _eq?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  _in?: InputMaybe<Array<CommunicationPreferenceStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  _nin?: InputMaybe<Array<CommunicationPreferenceStatusesEnum>>;
};

/** input type for inserting data into table "communication_preference_statuses" */
export type CommunicationPreferenceStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CommunicationPreferenceStatusesMaxFields = {
  __typename?: 'CommunicationPreferenceStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CommunicationPreferenceStatusesMinFields = {
  __typename?: 'CommunicationPreferenceStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "communication_preference_statuses" */
export type CommunicationPreferenceStatusesMutationResponse = {
  __typename?: 'CommunicationPreferenceStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CommunicationPreferenceStatuses>;
};

/** on_conflict condition type for table "communication_preference_statuses" */
export type CommunicationPreferenceStatusesOnConflict = {
  constraint: CommunicationPreferenceStatusesConstraint;
  updateColumns?: Array<CommunicationPreferenceStatusesUpdateColumn>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};

/** Ordering options when selecting data from "communication_preference_statuses". */
export type CommunicationPreferenceStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: communication_preference_statuses */
export type CommunicationPreferenceStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "communication_preference_statuses" */
export enum CommunicationPreferenceStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "communication_preference_statuses" */
export type CommunicationPreferenceStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "communication_preference_statuses" */
export type CommunicationPreferenceStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CommunicationPreferenceStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CommunicationPreferenceStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "communication_preference_statuses" */
export enum CommunicationPreferenceStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CommunicationPreferenceStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CommunicationPreferenceStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: CommunicationPreferenceStatusesBoolExp;
};

/** columns and relationships of "competition_formats" */
export type CompetitionFormats = {
  __typename?: 'CompetitionFormats';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "competition_formats" */
export type CompetitionFormatsAggregate = {
  __typename?: 'CompetitionFormatsAggregate';
  aggregate?: Maybe<CompetitionFormatsAggregateFields>;
  nodes: Array<CompetitionFormats>;
};

/** aggregate fields of "competition_formats" */
export type CompetitionFormatsAggregateFields = {
  __typename?: 'CompetitionFormatsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CompetitionFormatsMaxFields>;
  min?: Maybe<CompetitionFormatsMinFields>;
};


/** aggregate fields of "competition_formats" */
export type CompetitionFormatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "competition_formats". All fields are combined with a logical 'AND'. */
export type CompetitionFormatsBoolExp = {
  _and?: InputMaybe<Array<CompetitionFormatsBoolExp>>;
  _not?: InputMaybe<CompetitionFormatsBoolExp>;
  _or?: InputMaybe<Array<CompetitionFormatsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "competition_formats" */
export enum CompetitionFormatsConstraint {
  /** unique or primary key constraint on columns "value" */
  CompetitionFormatsPkey = 'competition_formats_pkey'
}

export enum CompetitionFormatsEnum {
  Custom = 'CUSTOM',
  DoubleElimination = 'DOUBLE_ELIMINATION',
  RoundRobin = 'ROUND_ROBIN',
  SingleElimination = 'SINGLE_ELIMINATION'
}

/** Boolean expression to compare columns of type "CompetitionFormatsEnum". All fields are combined with logical 'AND'. */
export type CompetitionFormatsEnumComparisonExp = {
  _eq?: InputMaybe<CompetitionFormatsEnum>;
  _in?: InputMaybe<Array<CompetitionFormatsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CompetitionFormatsEnum>;
  _nin?: InputMaybe<Array<CompetitionFormatsEnum>>;
};

/** input type for inserting data into table "competition_formats" */
export type CompetitionFormatsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CompetitionFormatsMaxFields = {
  __typename?: 'CompetitionFormatsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CompetitionFormatsMinFields = {
  __typename?: 'CompetitionFormatsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "competition_formats" */
export type CompetitionFormatsMutationResponse = {
  __typename?: 'CompetitionFormatsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CompetitionFormats>;
};

/** on_conflict condition type for table "competition_formats" */
export type CompetitionFormatsOnConflict = {
  constraint: CompetitionFormatsConstraint;
  updateColumns?: Array<CompetitionFormatsUpdateColumn>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};

/** Ordering options when selecting data from "competition_formats". */
export type CompetitionFormatsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: competition_formats */
export type CompetitionFormatsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "competition_formats" */
export enum CompetitionFormatsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "competition_formats" */
export type CompetitionFormatsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "competition_formats" */
export type CompetitionFormatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CompetitionFormatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CompetitionFormatsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "competition_formats" */
export enum CompetitionFormatsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CompetitionFormatsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CompetitionFormatsSetInput>;
  /** filter the rows which have to be updated */
  where: CompetitionFormatsBoolExp;
};

/** columns and relationships of "competition_gender" */
export type CompetitionGender = {
  __typename?: 'CompetitionGender';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "competition_gender" */
export type CompetitionGenderAggregate = {
  __typename?: 'CompetitionGenderAggregate';
  aggregate?: Maybe<CompetitionGenderAggregateFields>;
  nodes: Array<CompetitionGender>;
};

/** aggregate fields of "competition_gender" */
export type CompetitionGenderAggregateFields = {
  __typename?: 'CompetitionGenderAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CompetitionGenderMaxFields>;
  min?: Maybe<CompetitionGenderMinFields>;
};


/** aggregate fields of "competition_gender" */
export type CompetitionGenderAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "competition_gender". All fields are combined with a logical 'AND'. */
export type CompetitionGenderBoolExp = {
  _and?: InputMaybe<Array<CompetitionGenderBoolExp>>;
  _not?: InputMaybe<CompetitionGenderBoolExp>;
  _or?: InputMaybe<Array<CompetitionGenderBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "competition_gender" */
export enum CompetitionGenderConstraint {
  /** unique or primary key constraint on columns "value" */
  CompetitionGenderPkey = 'competition_gender_pkey'
}

export enum CompetitionGenderEnum {
  Female = 'FEMALE',
  Male = 'MALE',
  Mixed = 'MIXED'
}

/** Boolean expression to compare columns of type "CompetitionGenderEnum". All fields are combined with logical 'AND'. */
export type CompetitionGenderEnumComparisonExp = {
  _eq?: InputMaybe<CompetitionGenderEnum>;
  _in?: InputMaybe<Array<CompetitionGenderEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CompetitionGenderEnum>;
  _nin?: InputMaybe<Array<CompetitionGenderEnum>>;
};

/** input type for inserting data into table "competition_gender" */
export type CompetitionGenderInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CompetitionGenderMaxFields = {
  __typename?: 'CompetitionGenderMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CompetitionGenderMinFields = {
  __typename?: 'CompetitionGenderMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "competition_gender" */
export type CompetitionGenderMutationResponse = {
  __typename?: 'CompetitionGenderMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CompetitionGender>;
};

/** on_conflict condition type for table "competition_gender" */
export type CompetitionGenderOnConflict = {
  constraint: CompetitionGenderConstraint;
  updateColumns?: Array<CompetitionGenderUpdateColumn>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};

/** Ordering options when selecting data from "competition_gender". */
export type CompetitionGenderOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: competition_gender */
export type CompetitionGenderPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "competition_gender" */
export enum CompetitionGenderSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "competition_gender" */
export type CompetitionGenderSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "competition_gender" */
export type CompetitionGenderStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CompetitionGenderStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CompetitionGenderStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "competition_gender" */
export enum CompetitionGenderUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CompetitionGenderUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CompetitionGenderSetInput>;
  /** filter the rows which have to be updated */
  where: CompetitionGenderBoolExp;
};

/** Note that this breaks from the standard and uses the country iso3 as a text field for the id */
export type Countries = {
  __typename?: 'Countries';
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  emoji: Scalars['String'];
  geometry?: Maybe<Scalars['geography']>;
  id: Scalars['String'];
  iso2: Scalars['String'];
  iso3: Scalars['String'];
  latitude: Scalars['numeric'];
  longitude: Scalars['numeric'];
  name: Scalars['String'];
  nameSlug: Scalars['String'];
  numericCode: Scalars['String'];
  phoneCode: Scalars['String'];
  slug: Scalars['String'];
  /** An array relationship */
  subdivisions: Array<CountrySubdivisions>;
  /** An aggregate relationship */
  subdivisionsAggregate: CountrySubdivisionsAggregate;
  updatedAt: Scalars['timestamptz'];
};


/** Note that this breaks from the standard and uses the country iso3 as a text field for the id */
export type CountriesSubdivisionsArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


/** Note that this breaks from the standard and uses the country iso3 as a text field for the id */
export type CountriesSubdivisionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};

/** aggregated selection of "countries" */
export type CountriesAggregate = {
  __typename?: 'CountriesAggregate';
  aggregate?: Maybe<CountriesAggregateFields>;
  nodes: Array<Countries>;
};

/** aggregate fields of "countries" */
export type CountriesAggregateFields = {
  __typename?: 'CountriesAggregateFields';
  avg?: Maybe<CountriesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<CountriesMaxFields>;
  min?: Maybe<CountriesMinFields>;
  stddev?: Maybe<CountriesStddevFields>;
  stddevPop?: Maybe<CountriesStddevPopFields>;
  stddevSamp?: Maybe<CountriesStddevSampFields>;
  sum?: Maybe<CountriesSumFields>;
  varPop?: Maybe<CountriesVarPopFields>;
  varSamp?: Maybe<CountriesVarSampFields>;
  variance?: Maybe<CountriesVarianceFields>;
};


/** aggregate fields of "countries" */
export type CountriesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CountriesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type CountriesAvgFields = {
  __typename?: 'CountriesAvgFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'. */
export type CountriesBoolExp = {
  _and?: InputMaybe<Array<CountriesBoolExp>>;
  _not?: InputMaybe<CountriesBoolExp>;
  _or?: InputMaybe<Array<CountriesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  emoji?: InputMaybe<StringComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  iso2?: InputMaybe<StringComparisonExp>;
  iso3?: InputMaybe<StringComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  nameSlug?: InputMaybe<StringComparisonExp>;
  numericCode?: InputMaybe<StringComparisonExp>;
  phoneCode?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  subdivisions?: InputMaybe<CountrySubdivisionsBoolExp>;
  subdivisionsAggregate?: InputMaybe<CountrySubdivisionsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "countries" */
export enum CountriesConstraint {
  /** unique or primary key constraint on columns "iso2" */
  CountriesIso2Key = 'countries_iso2_key',
  /** unique or primary key constraint on columns "name_slug" */
  CountriesNameSlugKey = 'countries_name_slug_key',
  /** unique or primary key constraint on columns "id" */
  CountriesPkey = 'countries_pkey',
  /** unique or primary key constraint on columns "slug" */
  CountriesSlugKey = 'countries_slug_key'
}

/** input type for incrementing numeric columns in table "countries" */
export type CountriesIncInput = {
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "countries" */
export type CountriesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  emoji?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['String']>;
  iso2?: InputMaybe<Scalars['String']>;
  iso3?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  nameSlug?: InputMaybe<Scalars['String']>;
  numericCode?: InputMaybe<Scalars['String']>;
  phoneCode?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  subdivisions?: InputMaybe<CountrySubdivisionsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type CountriesMaxFields = {
  __typename?: 'CountriesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  emoji?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  nameSlug?: Maybe<Scalars['String']>;
  numericCode?: Maybe<Scalars['String']>;
  phoneCode?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type CountriesMinFields = {
  __typename?: 'CountriesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  emoji?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  nameSlug?: Maybe<Scalars['String']>;
  numericCode?: Maybe<Scalars['String']>;
  phoneCode?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "countries" */
export type CountriesMutationResponse = {
  __typename?: 'CountriesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Countries>;
};

/** input type for inserting object relation for remote table "countries" */
export type CountriesObjRelInsertInput = {
  data: CountriesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<CountriesOnConflict>;
};

/** on_conflict condition type for table "countries" */
export type CountriesOnConflict = {
  constraint: CountriesConstraint;
  updateColumns?: Array<CountriesUpdateColumn>;
  where?: InputMaybe<CountriesBoolExp>;
};

/** Ordering options when selecting data from "countries". */
export type CountriesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  emoji?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  iso2?: InputMaybe<OrderBy>;
  iso3?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  nameSlug?: InputMaybe<OrderBy>;
  numericCode?: InputMaybe<OrderBy>;
  phoneCode?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  subdivisionsAggregate?: InputMaybe<CountrySubdivisionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: countries */
export type CountriesPkColumnsInput = {
  id: Scalars['String'];
};

/** select columns of table "countries" */
export enum CountriesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Emoji = 'emoji',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  Iso2 = 'iso2',
  /** column name */
  Iso3 = 'iso3',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  NameSlug = 'nameSlug',
  /** column name */
  NumericCode = 'numericCode',
  /** column name */
  PhoneCode = 'phoneCode',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "countries" */
export type CountriesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  emoji?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['String']>;
  iso2?: InputMaybe<Scalars['String']>;
  iso3?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  nameSlug?: InputMaybe<Scalars['String']>;
  numericCode?: InputMaybe<Scalars['String']>;
  phoneCode?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type CountriesStddevFields = {
  __typename?: 'CountriesStddevFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type CountriesStddevPopFields = {
  __typename?: 'CountriesStddevPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type CountriesStddevSampFields = {
  __typename?: 'CountriesStddevSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "countries" */
export type CountriesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CountriesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CountriesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  emoji?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['String']>;
  iso2?: InputMaybe<Scalars['String']>;
  iso3?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  nameSlug?: InputMaybe<Scalars['String']>;
  numericCode?: InputMaybe<Scalars['String']>;
  phoneCode?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type CountriesSumFields = {
  __typename?: 'CountriesSumFields';
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
};

/** update columns of table "countries" */
export enum CountriesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Emoji = 'emoji',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  Iso2 = 'iso2',
  /** column name */
  Iso3 = 'iso3',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  NameSlug = 'nameSlug',
  /** column name */
  NumericCode = 'numericCode',
  /** column name */
  PhoneCode = 'phoneCode',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type CountriesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CountriesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CountriesSetInput>;
  /** filter the rows which have to be updated */
  where: CountriesBoolExp;
};

/** aggregate varPop on columns */
export type CountriesVarPopFields = {
  __typename?: 'CountriesVarPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type CountriesVarSampFields = {
  __typename?: 'CountriesVarSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type CountriesVarianceFields = {
  __typename?: 'CountriesVarianceFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "country_subdivisions" */
export type CountrySubdivisions = {
  __typename?: 'CountrySubdivisions';
  /** An array relationship */
  cities: Array<Cities>;
  /** An aggregate relationship */
  citiesAggregate: CitiesAggregate;
  code: Scalars['String'];
  /** An object relationship */
  country: Countries;
  countryId: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  geometry?: Maybe<Scalars['geography']>;
  id: Scalars['uuid'];
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name: Scalars['String'];
  slug: Scalars['String'];
  type: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "country_subdivisions" */
export type CountrySubdivisionsCitiesArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


/** columns and relationships of "country_subdivisions" */
export type CountrySubdivisionsCitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};

/** aggregated selection of "country_subdivisions" */
export type CountrySubdivisionsAggregate = {
  __typename?: 'CountrySubdivisionsAggregate';
  aggregate?: Maybe<CountrySubdivisionsAggregateFields>;
  nodes: Array<CountrySubdivisions>;
};

export type CountrySubdivisionsAggregateBoolExp = {
  count?: InputMaybe<CountrySubdivisionsAggregateBoolExpCount>;
};

/** aggregate fields of "country_subdivisions" */
export type CountrySubdivisionsAggregateFields = {
  __typename?: 'CountrySubdivisionsAggregateFields';
  avg?: Maybe<CountrySubdivisionsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<CountrySubdivisionsMaxFields>;
  min?: Maybe<CountrySubdivisionsMinFields>;
  stddev?: Maybe<CountrySubdivisionsStddevFields>;
  stddevPop?: Maybe<CountrySubdivisionsStddevPopFields>;
  stddevSamp?: Maybe<CountrySubdivisionsStddevSampFields>;
  sum?: Maybe<CountrySubdivisionsSumFields>;
  varPop?: Maybe<CountrySubdivisionsVarPopFields>;
  varSamp?: Maybe<CountrySubdivisionsVarSampFields>;
  variance?: Maybe<CountrySubdivisionsVarianceFields>;
};


/** aggregate fields of "country_subdivisions" */
export type CountrySubdivisionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "country_subdivisions" */
export type CountrySubdivisionsAggregateOrderBy = {
  avg?: InputMaybe<CountrySubdivisionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CountrySubdivisionsMaxOrderBy>;
  min?: InputMaybe<CountrySubdivisionsMinOrderBy>;
  stddev?: InputMaybe<CountrySubdivisionsStddevOrderBy>;
  stddevPop?: InputMaybe<CountrySubdivisionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<CountrySubdivisionsStddevSampOrderBy>;
  sum?: InputMaybe<CountrySubdivisionsSumOrderBy>;
  varPop?: InputMaybe<CountrySubdivisionsVarPopOrderBy>;
  varSamp?: InputMaybe<CountrySubdivisionsVarSampOrderBy>;
  variance?: InputMaybe<CountrySubdivisionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "country_subdivisions" */
export type CountrySubdivisionsArrRelInsertInput = {
  data: Array<CountrySubdivisionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<CountrySubdivisionsOnConflict>;
};

/** aggregate avg on columns */
export type CountrySubdivisionsAvgFields = {
  __typename?: 'CountrySubdivisionsAvgFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "country_subdivisions" */
export type CountrySubdivisionsAvgOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "country_subdivisions". All fields are combined with a logical 'AND'. */
export type CountrySubdivisionsBoolExp = {
  _and?: InputMaybe<Array<CountrySubdivisionsBoolExp>>;
  _not?: InputMaybe<CountrySubdivisionsBoolExp>;
  _or?: InputMaybe<Array<CountrySubdivisionsBoolExp>>;
  cities?: InputMaybe<CitiesBoolExp>;
  citiesAggregate?: InputMaybe<CitiesAggregateBoolExp>;
  code?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<CountriesBoolExp>;
  countryId?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "country_subdivisions" */
export enum CountrySubdivisionsConstraint {
  /** unique or primary key constraint on columns "id" */
  CountrySubdivisionsPkey = 'country_subdivisions_pkey',
  /** unique or primary key constraint on columns "slug" */
  CountrySubdivisionsSlugKey = 'country_subdivisions_slug_key'
}

/** input type for incrementing numeric columns in table "country_subdivisions" */
export type CountrySubdivisionsIncInput = {
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "country_subdivisions" */
export type CountrySubdivisionsInsertInput = {
  cities?: InputMaybe<CitiesArrRelInsertInput>;
  code?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<CountriesObjRelInsertInput>;
  countryId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type CountrySubdivisionsMaxFields = {
  __typename?: 'CountrySubdivisionsMaxFields';
  code?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "country_subdivisions" */
export type CountrySubdivisionsMaxOrderBy = {
  code?: InputMaybe<OrderBy>;
  countryId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CountrySubdivisionsMinFields = {
  __typename?: 'CountrySubdivisionsMinFields';
  code?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "country_subdivisions" */
export type CountrySubdivisionsMinOrderBy = {
  code?: InputMaybe<OrderBy>;
  countryId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "country_subdivisions" */
export type CountrySubdivisionsMutationResponse = {
  __typename?: 'CountrySubdivisionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CountrySubdivisions>;
};

/** input type for inserting object relation for remote table "country_subdivisions" */
export type CountrySubdivisionsObjRelInsertInput = {
  data: CountrySubdivisionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<CountrySubdivisionsOnConflict>;
};

/** on_conflict condition type for table "country_subdivisions" */
export type CountrySubdivisionsOnConflict = {
  constraint: CountrySubdivisionsConstraint;
  updateColumns?: Array<CountrySubdivisionsUpdateColumn>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};

/** Ordering options when selecting data from "country_subdivisions". */
export type CountrySubdivisionsOrderBy = {
  citiesAggregate?: InputMaybe<CitiesAggregateOrderBy>;
  code?: InputMaybe<OrderBy>;
  country?: InputMaybe<CountriesOrderBy>;
  countryId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: country_subdivisions */
export type CountrySubdivisionsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "country_subdivisions" */
export enum CountrySubdivisionsSelectColumn {
  /** column name */
  Code = 'code',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "country_subdivisions" */
export type CountrySubdivisionsSetInput = {
  code?: InputMaybe<Scalars['String']>;
  countryId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type CountrySubdivisionsStddevFields = {
  __typename?: 'CountrySubdivisionsStddevFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "country_subdivisions" */
export type CountrySubdivisionsStddevOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type CountrySubdivisionsStddevPopFields = {
  __typename?: 'CountrySubdivisionsStddevPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "country_subdivisions" */
export type CountrySubdivisionsStddevPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type CountrySubdivisionsStddevSampFields = {
  __typename?: 'CountrySubdivisionsStddevSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "country_subdivisions" */
export type CountrySubdivisionsStddevSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "country_subdivisions" */
export type CountrySubdivisionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CountrySubdivisionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CountrySubdivisionsStreamCursorValueInput = {
  code?: InputMaybe<Scalars['String']>;
  countryId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type CountrySubdivisionsSumFields = {
  __typename?: 'CountrySubdivisionsSumFields';
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "country_subdivisions" */
export type CountrySubdivisionsSumOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** update columns of table "country_subdivisions" */
export enum CountrySubdivisionsUpdateColumn {
  /** column name */
  Code = 'code',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type CountrySubdivisionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CountrySubdivisionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CountrySubdivisionsSetInput>;
  /** filter the rows which have to be updated */
  where: CountrySubdivisionsBoolExp;
};

/** aggregate varPop on columns */
export type CountrySubdivisionsVarPopFields = {
  __typename?: 'CountrySubdivisionsVarPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "country_subdivisions" */
export type CountrySubdivisionsVarPopOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type CountrySubdivisionsVarSampFields = {
  __typename?: 'CountrySubdivisionsVarSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "country_subdivisions" */
export type CountrySubdivisionsVarSampOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CountrySubdivisionsVarianceFields = {
  __typename?: 'CountrySubdivisionsVarianceFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "country_subdivisions" */
export type CountrySubdivisionsVarianceOrderBy = {
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
};

/** columns and relationships of "court_surfaces" */
export type CourtSurfaces = {
  __typename?: 'CourtSurfaces';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "court_surfaces" */
export type CourtSurfacesAggregate = {
  __typename?: 'CourtSurfacesAggregate';
  aggregate?: Maybe<CourtSurfacesAggregateFields>;
  nodes: Array<CourtSurfaces>;
};

/** aggregate fields of "court_surfaces" */
export type CourtSurfacesAggregateFields = {
  __typename?: 'CourtSurfacesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<CourtSurfacesMaxFields>;
  min?: Maybe<CourtSurfacesMinFields>;
};


/** aggregate fields of "court_surfaces" */
export type CourtSurfacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "court_surfaces". All fields are combined with a logical 'AND'. */
export type CourtSurfacesBoolExp = {
  _and?: InputMaybe<Array<CourtSurfacesBoolExp>>;
  _not?: InputMaybe<CourtSurfacesBoolExp>;
  _or?: InputMaybe<Array<CourtSurfacesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "court_surfaces" */
export enum CourtSurfacesConstraint {
  /** unique or primary key constraint on columns "value" */
  CourtSurfacesPkey = 'court_surfaces_pkey'
}

export enum CourtSurfacesEnum {
  Acrylic = 'ACRYLIC',
  Asphalt = 'ASPHALT',
  Carpet = 'CARPET',
  Clay = 'CLAY',
  Concrete = 'CONCRETE',
  Grass = 'GRASS',
  Hard = 'HARD',
  Wood = 'WOOD'
}

/** Boolean expression to compare columns of type "CourtSurfacesEnum". All fields are combined with logical 'AND'. */
export type CourtSurfacesEnumComparisonExp = {
  _eq?: InputMaybe<CourtSurfacesEnum>;
  _in?: InputMaybe<Array<CourtSurfacesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<CourtSurfacesEnum>;
  _nin?: InputMaybe<Array<CourtSurfacesEnum>>;
};

/** input type for inserting data into table "court_surfaces" */
export type CourtSurfacesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type CourtSurfacesMaxFields = {
  __typename?: 'CourtSurfacesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type CourtSurfacesMinFields = {
  __typename?: 'CourtSurfacesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "court_surfaces" */
export type CourtSurfacesMutationResponse = {
  __typename?: 'CourtSurfacesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CourtSurfaces>;
};

/** on_conflict condition type for table "court_surfaces" */
export type CourtSurfacesOnConflict = {
  constraint: CourtSurfacesConstraint;
  updateColumns?: Array<CourtSurfacesUpdateColumn>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};

/** Ordering options when selecting data from "court_surfaces". */
export type CourtSurfacesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: court_surfaces */
export type CourtSurfacesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "court_surfaces" */
export enum CourtSurfacesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "court_surfaces" */
export type CourtSurfacesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "court_surfaces" */
export type CourtSurfacesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CourtSurfacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CourtSurfacesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "court_surfaces" */
export enum CourtSurfacesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CourtSurfacesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CourtSurfacesSetInput>;
  /** filter the rows which have to be updated */
  where: CourtSurfacesBoolExp;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  _eq?: InputMaybe<Scalars['date']>;
  _gt?: InputMaybe<Scalars['date']>;
  _gte?: InputMaybe<Scalars['date']>;
  _in?: InputMaybe<Array<Scalars['date']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['date']>;
  _lte?: InputMaybe<Scalars['date']>;
  _neq?: InputMaybe<Scalars['date']>;
  _nin?: InputMaybe<Array<Scalars['date']>>;
};

/** columns and relationships of "event_contact_details" */
export type EventContactDetails = {
  __typename?: 'EventContactDetails';
  contactUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email: Scalars['String'];
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  phoneNumber: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_contact_details" */
export type EventContactDetailsAggregate = {
  __typename?: 'EventContactDetailsAggregate';
  aggregate?: Maybe<EventContactDetailsAggregateFields>;
  nodes: Array<EventContactDetails>;
};

/** aggregate fields of "event_contact_details" */
export type EventContactDetailsAggregateFields = {
  __typename?: 'EventContactDetailsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventContactDetailsMaxFields>;
  min?: Maybe<EventContactDetailsMinFields>;
};


/** aggregate fields of "event_contact_details" */
export type EventContactDetailsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_contact_details". All fields are combined with a logical 'AND'. */
export type EventContactDetailsBoolExp = {
  _and?: InputMaybe<Array<EventContactDetailsBoolExp>>;
  _not?: InputMaybe<EventContactDetailsBoolExp>;
  _or?: InputMaybe<Array<EventContactDetailsBoolExp>>;
  contactUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_contact_details" */
export enum EventContactDetailsConstraint {
  /** unique or primary key constraint on columns "event_id" */
  EventContactDetailsEventIdKey = 'event_contact_details_event_id_key',
  /** unique or primary key constraint on columns "id" */
  EventContactDetailsPkey = 'event_contact_details_pkey'
}

/** input type for inserting data into table "event_contact_details" */
export type EventContactDetailsInsertInput = {
  contactUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventContactDetailsMaxFields = {
  __typename?: 'EventContactDetailsMaxFields';
  contactUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  phoneNumber?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type EventContactDetailsMinFields = {
  __typename?: 'EventContactDetailsMinFields';
  contactUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  phoneNumber?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "event_contact_details" */
export type EventContactDetailsMutationResponse = {
  __typename?: 'EventContactDetailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventContactDetails>;
};

/** input type for inserting object relation for remote table "event_contact_details" */
export type EventContactDetailsObjRelInsertInput = {
  data: EventContactDetailsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventContactDetailsOnConflict>;
};

/** on_conflict condition type for table "event_contact_details" */
export type EventContactDetailsOnConflict = {
  constraint: EventContactDetailsConstraint;
  updateColumns?: Array<EventContactDetailsUpdateColumn>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};

/** Ordering options when selecting data from "event_contact_details". */
export type EventContactDetailsOrderBy = {
  contactUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_contact_details */
export type EventContactDetailsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_contact_details" */
export enum EventContactDetailsSelectColumn {
  /** column name */
  ContactUrl = 'contactUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_contact_details" */
export type EventContactDetailsSetInput = {
  contactUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_contact_details" */
export type EventContactDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventContactDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventContactDetailsStreamCursorValueInput = {
  contactUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_contact_details" */
export enum EventContactDetailsUpdateColumn {
  /** column name */
  ContactUrl = 'contactUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventContactDetailsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventContactDetailsSetInput>;
  /** filter the rows which have to be updated */
  where: EventContactDetailsBoolExp;
};

/** columns and relationships of "event_court_statuses" */
export type EventCourtStatuses = {
  __typename?: 'EventCourtStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_court_statuses" */
export type EventCourtStatusesAggregate = {
  __typename?: 'EventCourtStatusesAggregate';
  aggregate?: Maybe<EventCourtStatusesAggregateFields>;
  nodes: Array<EventCourtStatuses>;
};

/** aggregate fields of "event_court_statuses" */
export type EventCourtStatusesAggregateFields = {
  __typename?: 'EventCourtStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventCourtStatusesMaxFields>;
  min?: Maybe<EventCourtStatusesMinFields>;
};


/** aggregate fields of "event_court_statuses" */
export type EventCourtStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_court_statuses". All fields are combined with a logical 'AND'. */
export type EventCourtStatusesBoolExp = {
  _and?: InputMaybe<Array<EventCourtStatusesBoolExp>>;
  _not?: InputMaybe<EventCourtStatusesBoolExp>;
  _or?: InputMaybe<Array<EventCourtStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_court_statuses" */
export enum EventCourtStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventCourtStatusesPkey = 'event_court_statuses_pkey'
}

export enum EventCourtStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "EventCourtStatusesEnum". All fields are combined with logical 'AND'. */
export type EventCourtStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventCourtStatusesEnum>;
  _in?: InputMaybe<Array<EventCourtStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventCourtStatusesEnum>;
  _nin?: InputMaybe<Array<EventCourtStatusesEnum>>;
};

/** input type for inserting data into table "event_court_statuses" */
export type EventCourtStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventCourtStatusesMaxFields = {
  __typename?: 'EventCourtStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventCourtStatusesMinFields = {
  __typename?: 'EventCourtStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_court_statuses" */
export type EventCourtStatusesMutationResponse = {
  __typename?: 'EventCourtStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventCourtStatuses>;
};

/** on_conflict condition type for table "event_court_statuses" */
export type EventCourtStatusesOnConflict = {
  constraint: EventCourtStatusesConstraint;
  updateColumns?: Array<EventCourtStatusesUpdateColumn>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};

/** Ordering options when selecting data from "event_court_statuses". */
export type EventCourtStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_court_statuses */
export type EventCourtStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_court_statuses" */
export enum EventCourtStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_court_statuses" */
export type EventCourtStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_court_statuses" */
export type EventCourtStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventCourtStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventCourtStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_court_statuses" */
export enum EventCourtStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventCourtStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventCourtStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: EventCourtStatusesBoolExp;
};

/** Note: This table may be overly structured with the foreign keys. Consider removing some if they're not needed. */
export type EventCourts = {
  __typename?: 'EventCourts';
  activeEventGroupId?: Maybe<Scalars['uuid']>;
  activeEventGroupPoolId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  activeGroup?: Maybe<EventGroups>;
  /** An object relationship */
  activeMatch?: Maybe<EventMatches>;
  activeMatchId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  activePool?: Maybe<EventGroupPools>;
  courtNumber: Scalars['Int'];
  courtStatus: EventCourtStatusesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatches>;
  /** An aggregate relationship */
  matchesAggregate: EventMatchesAggregate;
  updatedAt: Scalars['timestamptz'];
};


/** Note: This table may be overly structured with the foreign keys. Consider removing some if they're not needed. */
export type EventCourtsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** Note: This table may be overly structured with the foreign keys. Consider removing some if they're not needed. */
export type EventCourtsMatchesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};

/** aggregated selection of "event_courts" */
export type EventCourtsAggregate = {
  __typename?: 'EventCourtsAggregate';
  aggregate?: Maybe<EventCourtsAggregateFields>;
  nodes: Array<EventCourts>;
};

export type EventCourtsAggregateBoolExp = {
  count?: InputMaybe<EventCourtsAggregateBoolExpCount>;
};

/** aggregate fields of "event_courts" */
export type EventCourtsAggregateFields = {
  __typename?: 'EventCourtsAggregateFields';
  avg?: Maybe<EventCourtsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventCourtsMaxFields>;
  min?: Maybe<EventCourtsMinFields>;
  stddev?: Maybe<EventCourtsStddevFields>;
  stddevPop?: Maybe<EventCourtsStddevPopFields>;
  stddevSamp?: Maybe<EventCourtsStddevSampFields>;
  sum?: Maybe<EventCourtsSumFields>;
  varPop?: Maybe<EventCourtsVarPopFields>;
  varSamp?: Maybe<EventCourtsVarSampFields>;
  variance?: Maybe<EventCourtsVarianceFields>;
};


/** aggregate fields of "event_courts" */
export type EventCourtsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventCourtsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_courts" */
export type EventCourtsAggregateOrderBy = {
  avg?: InputMaybe<EventCourtsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventCourtsMaxOrderBy>;
  min?: InputMaybe<EventCourtsMinOrderBy>;
  stddev?: InputMaybe<EventCourtsStddevOrderBy>;
  stddevPop?: InputMaybe<EventCourtsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventCourtsStddevSampOrderBy>;
  sum?: InputMaybe<EventCourtsSumOrderBy>;
  varPop?: InputMaybe<EventCourtsVarPopOrderBy>;
  varSamp?: InputMaybe<EventCourtsVarSampOrderBy>;
  variance?: InputMaybe<EventCourtsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_courts" */
export type EventCourtsArrRelInsertInput = {
  data: Array<EventCourtsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventCourtsOnConflict>;
};

/** aggregate avg on columns */
export type EventCourtsAvgFields = {
  __typename?: 'EventCourtsAvgFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_courts" */
export type EventCourtsAvgOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_courts". All fields are combined with a logical 'AND'. */
export type EventCourtsBoolExp = {
  _and?: InputMaybe<Array<EventCourtsBoolExp>>;
  _not?: InputMaybe<EventCourtsBoolExp>;
  _or?: InputMaybe<Array<EventCourtsBoolExp>>;
  activeEventGroupId?: InputMaybe<UuidComparisonExp>;
  activeEventGroupPoolId?: InputMaybe<UuidComparisonExp>;
  activeGroup?: InputMaybe<EventGroupsBoolExp>;
  activeMatch?: InputMaybe<EventMatchesBoolExp>;
  activeMatchId?: InputMaybe<UuidComparisonExp>;
  activePool?: InputMaybe<EventGroupPoolsBoolExp>;
  courtNumber?: InputMaybe<IntComparisonExp>;
  courtStatus?: InputMaybe<EventCourtStatusesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesBoolExp>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_courts" */
export enum EventCourtsConstraint {
  /** unique or primary key constraint on columns "court_number", "event_id" */
  EventCourtsEventIdCourtNumberKey = 'event_courts_event_id_court_number_key',
  /** unique or primary key constraint on columns "id" */
  EventCourtsPkey = 'event_courts_pkey'
}

/** input type for incrementing numeric columns in table "event_courts" */
export type EventCourtsIncInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_courts" */
export type EventCourtsInsertInput = {
  activeEventGroupId?: InputMaybe<Scalars['uuid']>;
  activeEventGroupPoolId?: InputMaybe<Scalars['uuid']>;
  activeGroup?: InputMaybe<EventGroupsObjRelInsertInput>;
  activeMatch?: InputMaybe<EventMatchesObjRelInsertInput>;
  activeMatchId?: InputMaybe<Scalars['uuid']>;
  activePool?: InputMaybe<EventGroupPoolsObjRelInsertInput>;
  courtNumber?: InputMaybe<Scalars['Int']>;
  courtStatus?: InputMaybe<EventCourtStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  matches?: InputMaybe<EventMatchesArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventCourtsMaxFields = {
  __typename?: 'EventCourtsMaxFields';
  activeEventGroupId?: Maybe<Scalars['uuid']>;
  activeEventGroupPoolId?: Maybe<Scalars['uuid']>;
  activeMatchId?: Maybe<Scalars['uuid']>;
  courtNumber?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_courts" */
export type EventCourtsMaxOrderBy = {
  activeEventGroupId?: InputMaybe<OrderBy>;
  activeEventGroupPoolId?: InputMaybe<OrderBy>;
  activeMatchId?: InputMaybe<OrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventCourtsMinFields = {
  __typename?: 'EventCourtsMinFields';
  activeEventGroupId?: Maybe<Scalars['uuid']>;
  activeEventGroupPoolId?: Maybe<Scalars['uuid']>;
  activeMatchId?: Maybe<Scalars['uuid']>;
  courtNumber?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_courts" */
export type EventCourtsMinOrderBy = {
  activeEventGroupId?: InputMaybe<OrderBy>;
  activeEventGroupPoolId?: InputMaybe<OrderBy>;
  activeMatchId?: InputMaybe<OrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_courts" */
export type EventCourtsMutationResponse = {
  __typename?: 'EventCourtsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventCourts>;
};

/** input type for inserting object relation for remote table "event_courts" */
export type EventCourtsObjRelInsertInput = {
  data: EventCourtsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventCourtsOnConflict>;
};

/** on_conflict condition type for table "event_courts" */
export type EventCourtsOnConflict = {
  constraint: EventCourtsConstraint;
  updateColumns?: Array<EventCourtsUpdateColumn>;
  where?: InputMaybe<EventCourtsBoolExp>;
};

/** Ordering options when selecting data from "event_courts". */
export type EventCourtsOrderBy = {
  activeEventGroupId?: InputMaybe<OrderBy>;
  activeEventGroupPoolId?: InputMaybe<OrderBy>;
  activeGroup?: InputMaybe<EventGroupsOrderBy>;
  activeMatch?: InputMaybe<EventMatchesOrderBy>;
  activeMatchId?: InputMaybe<OrderBy>;
  activePool?: InputMaybe<EventGroupPoolsOrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  courtStatus?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_courts */
export type EventCourtsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_courts" */
export enum EventCourtsSelectColumn {
  /** column name */
  ActiveEventGroupId = 'activeEventGroupId',
  /** column name */
  ActiveEventGroupPoolId = 'activeEventGroupPoolId',
  /** column name */
  ActiveMatchId = 'activeMatchId',
  /** column name */
  CourtNumber = 'courtNumber',
  /** column name */
  CourtStatus = 'courtStatus',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_courts" */
export type EventCourtsSetInput = {
  activeEventGroupId?: InputMaybe<Scalars['uuid']>;
  activeEventGroupPoolId?: InputMaybe<Scalars['uuid']>;
  activeMatchId?: InputMaybe<Scalars['uuid']>;
  courtNumber?: InputMaybe<Scalars['Int']>;
  courtStatus?: InputMaybe<EventCourtStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventCourtsStddevFields = {
  __typename?: 'EventCourtsStddevFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_courts" */
export type EventCourtsStddevOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventCourtsStddevPopFields = {
  __typename?: 'EventCourtsStddevPopFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_courts" */
export type EventCourtsStddevPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventCourtsStddevSampFields = {
  __typename?: 'EventCourtsStddevSampFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_courts" */
export type EventCourtsStddevSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_courts" */
export type EventCourtsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventCourtsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventCourtsStreamCursorValueInput = {
  activeEventGroupId?: InputMaybe<Scalars['uuid']>;
  activeEventGroupPoolId?: InputMaybe<Scalars['uuid']>;
  activeMatchId?: InputMaybe<Scalars['uuid']>;
  courtNumber?: InputMaybe<Scalars['Int']>;
  courtStatus?: InputMaybe<EventCourtStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventCourtsSumFields = {
  __typename?: 'EventCourtsSumFields';
  courtNumber?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_courts" */
export type EventCourtsSumOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** update columns of table "event_courts" */
export enum EventCourtsUpdateColumn {
  /** column name */
  ActiveEventGroupId = 'activeEventGroupId',
  /** column name */
  ActiveEventGroupPoolId = 'activeEventGroupPoolId',
  /** column name */
  ActiveMatchId = 'activeMatchId',
  /** column name */
  CourtNumber = 'courtNumber',
  /** column name */
  CourtStatus = 'courtStatus',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventCourtsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventCourtsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventCourtsSetInput>;
  /** filter the rows which have to be updated */
  where: EventCourtsBoolExp;
};

/** aggregate varPop on columns */
export type EventCourtsVarPopFields = {
  __typename?: 'EventCourtsVarPopFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_courts" */
export type EventCourtsVarPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventCourtsVarSampFields = {
  __typename?: 'EventCourtsVarSampFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_courts" */
export type EventCourtsVarSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventCourtsVarianceFields = {
  __typename?: 'EventCourtsVarianceFields';
  courtNumber?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_courts" */
export type EventCourtsVarianceOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_faqs" */
export type EventFaqs = {
  __typename?: 'EventFaqs';
  answer: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  question: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_faqs" */
export type EventFaqsAggregate = {
  __typename?: 'EventFaqsAggregate';
  aggregate?: Maybe<EventFaqsAggregateFields>;
  nodes: Array<EventFaqs>;
};

export type EventFaqsAggregateBoolExp = {
  count?: InputMaybe<EventFaqsAggregateBoolExpCount>;
};

/** aggregate fields of "event_faqs" */
export type EventFaqsAggregateFields = {
  __typename?: 'EventFaqsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventFaqsMaxFields>;
  min?: Maybe<EventFaqsMinFields>;
};


/** aggregate fields of "event_faqs" */
export type EventFaqsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventFaqsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_faqs" */
export type EventFaqsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventFaqsMaxOrderBy>;
  min?: InputMaybe<EventFaqsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_faqs" */
export type EventFaqsArrRelInsertInput = {
  data: Array<EventFaqsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventFaqsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_faqs". All fields are combined with a logical 'AND'. */
export type EventFaqsBoolExp = {
  _and?: InputMaybe<Array<EventFaqsBoolExp>>;
  _not?: InputMaybe<EventFaqsBoolExp>;
  _or?: InputMaybe<Array<EventFaqsBoolExp>>;
  answer?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  question?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_faqs" */
export enum EventFaqsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventFaqsPkey = 'event_faqs_pkey'
}

/** input type for inserting data into table "event_faqs" */
export type EventFaqsInsertInput = {
  answer?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventFaqsMaxFields = {
  __typename?: 'EventFaqsMaxFields';
  answer?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  question?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_faqs" */
export type EventFaqsMaxOrderBy = {
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventFaqsMinFields = {
  __typename?: 'EventFaqsMinFields';
  answer?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  question?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_faqs" */
export type EventFaqsMinOrderBy = {
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_faqs" */
export type EventFaqsMutationResponse = {
  __typename?: 'EventFaqsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventFaqs>;
};

/** on_conflict condition type for table "event_faqs" */
export type EventFaqsOnConflict = {
  constraint: EventFaqsConstraint;
  updateColumns?: Array<EventFaqsUpdateColumn>;
  where?: InputMaybe<EventFaqsBoolExp>;
};

/** Ordering options when selecting data from "event_faqs". */
export type EventFaqsOrderBy = {
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_faqs */
export type EventFaqsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_faqs" */
export enum EventFaqsSelectColumn {
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Question = 'question',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_faqs" */
export type EventFaqsSetInput = {
  answer?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_faqs" */
export type EventFaqsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventFaqsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventFaqsStreamCursorValueInput = {
  answer?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_faqs" */
export enum EventFaqsUpdateColumn {
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Question = 'question',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventFaqsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventFaqsSetInput>;
  /** filter the rows which have to be updated */
  where: EventFaqsBoolExp;
};

/** NOTE: We are currently not using this table, but it was considered as there were many complex game and team structures discussed. For now we are storing scores in event_match_games, but we can backfill this one if needed. */
export type EventGameScores = {
  __typename?: 'EventGameScores';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  game: EventMatchGames;
  gameId: Scalars['uuid'];
  id: Scalars['uuid'];
  score: Scalars['Int'];
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_game_scores" */
export type EventGameScoresAggregate = {
  __typename?: 'EventGameScoresAggregate';
  aggregate?: Maybe<EventGameScoresAggregateFields>;
  nodes: Array<EventGameScores>;
};

export type EventGameScoresAggregateBoolExp = {
  count?: InputMaybe<EventGameScoresAggregateBoolExpCount>;
};

/** aggregate fields of "event_game_scores" */
export type EventGameScoresAggregateFields = {
  __typename?: 'EventGameScoresAggregateFields';
  avg?: Maybe<EventGameScoresAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventGameScoresMaxFields>;
  min?: Maybe<EventGameScoresMinFields>;
  stddev?: Maybe<EventGameScoresStddevFields>;
  stddevPop?: Maybe<EventGameScoresStddevPopFields>;
  stddevSamp?: Maybe<EventGameScoresStddevSampFields>;
  sum?: Maybe<EventGameScoresSumFields>;
  varPop?: Maybe<EventGameScoresVarPopFields>;
  varSamp?: Maybe<EventGameScoresVarSampFields>;
  variance?: Maybe<EventGameScoresVarianceFields>;
};


/** aggregate fields of "event_game_scores" */
export type EventGameScoresAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_game_scores" */
export type EventGameScoresAggregateOrderBy = {
  avg?: InputMaybe<EventGameScoresAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGameScoresMaxOrderBy>;
  min?: InputMaybe<EventGameScoresMinOrderBy>;
  stddev?: InputMaybe<EventGameScoresStddevOrderBy>;
  stddevPop?: InputMaybe<EventGameScoresStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGameScoresStddevSampOrderBy>;
  sum?: InputMaybe<EventGameScoresSumOrderBy>;
  varPop?: InputMaybe<EventGameScoresVarPopOrderBy>;
  varSamp?: InputMaybe<EventGameScoresVarSampOrderBy>;
  variance?: InputMaybe<EventGameScoresVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_game_scores" */
export type EventGameScoresArrRelInsertInput = {
  data: Array<EventGameScoresInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGameScoresOnConflict>;
};

/** aggregate avg on columns */
export type EventGameScoresAvgFields = {
  __typename?: 'EventGameScoresAvgFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_game_scores" */
export type EventGameScoresAvgOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_game_scores". All fields are combined with a logical 'AND'. */
export type EventGameScoresBoolExp = {
  _and?: InputMaybe<Array<EventGameScoresBoolExp>>;
  _not?: InputMaybe<EventGameScoresBoolExp>;
  _or?: InputMaybe<Array<EventGameScoresBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  game?: InputMaybe<EventMatchGamesBoolExp>;
  gameId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  score?: InputMaybe<IntComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_game_scores" */
export enum EventGameScoresConstraint {
  /** unique or primary key constraint on columns "game_id", "team_id" */
  EventGameScoresGameIdTeamIdKey = 'event_game_scores_game_id_team_id_key',
  /** unique or primary key constraint on columns "id" */
  EventGameScoresPkey = 'event_game_scores_pkey'
}

/** input type for incrementing numeric columns in table "event_game_scores" */
export type EventGameScoresIncInput = {
  score?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_game_scores" */
export type EventGameScoresInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  game?: InputMaybe<EventMatchGamesObjRelInsertInput>;
  gameId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  score?: InputMaybe<Scalars['Int']>;
  team?: InputMaybe<EventTeamsObjRelInsertInput>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventGameScoresMaxFields = {
  __typename?: 'EventGameScoresMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  gameId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  score?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_game_scores" */
export type EventGameScoresMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventGameScoresMinFields = {
  __typename?: 'EventGameScoresMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  gameId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  score?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_game_scores" */
export type EventGameScoresMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_game_scores" */
export type EventGameScoresMutationResponse = {
  __typename?: 'EventGameScoresMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGameScores>;
};

/** on_conflict condition type for table "event_game_scores" */
export type EventGameScoresOnConflict = {
  constraint: EventGameScoresConstraint;
  updateColumns?: Array<EventGameScoresUpdateColumn>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};

/** Ordering options when selecting data from "event_game_scores". */
export type EventGameScoresOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  game?: InputMaybe<EventMatchGamesOrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_game_scores */
export type EventGameScoresPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_game_scores" */
export enum EventGameScoresSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GameId = 'gameId',
  /** column name */
  Id = 'id',
  /** column name */
  Score = 'score',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_game_scores" */
export type EventGameScoresSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  gameId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  score?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventGameScoresStddevFields = {
  __typename?: 'EventGameScoresStddevFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_game_scores" */
export type EventGameScoresStddevOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventGameScoresStddevPopFields = {
  __typename?: 'EventGameScoresStddevPopFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_game_scores" */
export type EventGameScoresStddevPopOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventGameScoresStddevSampFields = {
  __typename?: 'EventGameScoresStddevSampFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_game_scores" */
export type EventGameScoresStddevSampOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_game_scores" */
export type EventGameScoresStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGameScoresStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGameScoresStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  gameId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  score?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventGameScoresSumFields = {
  __typename?: 'EventGameScoresSumFields';
  score?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_game_scores" */
export type EventGameScoresSumOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** update columns of table "event_game_scores" */
export enum EventGameScoresUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GameId = 'gameId',
  /** column name */
  Id = 'id',
  /** column name */
  Score = 'score',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventGameScoresUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventGameScoresIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGameScoresSetInput>;
  /** filter the rows which have to be updated */
  where: EventGameScoresBoolExp;
};

/** aggregate varPop on columns */
export type EventGameScoresVarPopFields = {
  __typename?: 'EventGameScoresVarPopFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_game_scores" */
export type EventGameScoresVarPopOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventGameScoresVarSampFields = {
  __typename?: 'EventGameScoresVarSampFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_game_scores" */
export type EventGameScoresVarSampOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventGameScoresVarianceFields = {
  __typename?: 'EventGameScoresVarianceFields';
  score?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_game_scores" */
export type EventGameScoresVarianceOrderBy = {
  score?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_group_formats" */
export type EventGroupFormats = {
  __typename?: 'EventGroupFormats';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_group_formats" */
export type EventGroupFormatsAggregate = {
  __typename?: 'EventGroupFormatsAggregate';
  aggregate?: Maybe<EventGroupFormatsAggregateFields>;
  nodes: Array<EventGroupFormats>;
};

/** aggregate fields of "event_group_formats" */
export type EventGroupFormatsAggregateFields = {
  __typename?: 'EventGroupFormatsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventGroupFormatsMaxFields>;
  min?: Maybe<EventGroupFormatsMinFields>;
};


/** aggregate fields of "event_group_formats" */
export type EventGroupFormatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_group_formats". All fields are combined with a logical 'AND'. */
export type EventGroupFormatsBoolExp = {
  _and?: InputMaybe<Array<EventGroupFormatsBoolExp>>;
  _not?: InputMaybe<EventGroupFormatsBoolExp>;
  _or?: InputMaybe<Array<EventGroupFormatsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_group_formats" */
export enum EventGroupFormatsConstraint {
  /** unique or primary key constraint on columns "value" */
  EventGroupFormatsPkey = 'event_group_formats_pkey'
}

export enum EventGroupFormatsEnum {
  Custom = 'CUSTOM',
  RoundRobin = 'ROUND_ROBIN',
  RoundRobinSingleElimination = 'ROUND_ROBIN_SINGLE_ELIMINATION',
  SingleElimination = 'SINGLE_ELIMINATION'
}

/** Boolean expression to compare columns of type "EventGroupFormatsEnum". All fields are combined with logical 'AND'. */
export type EventGroupFormatsEnumComparisonExp = {
  _eq?: InputMaybe<EventGroupFormatsEnum>;
  _in?: InputMaybe<Array<EventGroupFormatsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventGroupFormatsEnum>;
  _nin?: InputMaybe<Array<EventGroupFormatsEnum>>;
};

/** input type for inserting data into table "event_group_formats" */
export type EventGroupFormatsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventGroupFormatsMaxFields = {
  __typename?: 'EventGroupFormatsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventGroupFormatsMinFields = {
  __typename?: 'EventGroupFormatsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_group_formats" */
export type EventGroupFormatsMutationResponse = {
  __typename?: 'EventGroupFormatsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupFormats>;
};

/** on_conflict condition type for table "event_group_formats" */
export type EventGroupFormatsOnConflict = {
  constraint: EventGroupFormatsConstraint;
  updateColumns?: Array<EventGroupFormatsUpdateColumn>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};

/** Ordering options when selecting data from "event_group_formats". */
export type EventGroupFormatsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_group_formats */
export type EventGroupFormatsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_group_formats" */
export enum EventGroupFormatsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_group_formats" */
export type EventGroupFormatsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_group_formats" */
export type EventGroupFormatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupFormatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupFormatsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_group_formats" */
export enum EventGroupFormatsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventGroupFormatsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupFormatsSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupFormatsBoolExp;
};

/** columns and relationships of "event_group_pools" */
export type EventGroupPools = {
  __typename?: 'EventGroupPools';
  /** An array relationship */
  courts: Array<EventCourts>;
  /** An aggregate relationship */
  courtsAggregate: EventCourtsAggregate;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatches>;
  /** An aggregate relationship */
  matchesAggregate: EventMatchesAggregate;
  /** An array relationship */
  rounds: Array<EventPoolRounds>;
  /** An aggregate relationship */
  roundsAggregate: EventPoolRoundsAggregate;
  /** An object relationship */
  sequence: EventGroupSequences;
  sequenceId: Scalars['uuid'];
  startsAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  teams: Array<EventPoolsTeams>;
  /** An aggregate relationship */
  teamsAggregate: EventPoolsTeamsAggregate;
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsMatchesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsRoundsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsRoundsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


/** columns and relationships of "event_group_pools" */
export type EventGroupPoolsTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};

/** aggregated selection of "event_group_pools" */
export type EventGroupPoolsAggregate = {
  __typename?: 'EventGroupPoolsAggregate';
  aggregate?: Maybe<EventGroupPoolsAggregateFields>;
  nodes: Array<EventGroupPools>;
};

export type EventGroupPoolsAggregateBoolExp = {
  count?: InputMaybe<EventGroupPoolsAggregateBoolExpCount>;
};

/** aggregate fields of "event_group_pools" */
export type EventGroupPoolsAggregateFields = {
  __typename?: 'EventGroupPoolsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventGroupPoolsMaxFields>;
  min?: Maybe<EventGroupPoolsMinFields>;
};


/** aggregate fields of "event_group_pools" */
export type EventGroupPoolsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_group_pools" */
export type EventGroupPoolsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupPoolsMaxOrderBy>;
  min?: InputMaybe<EventGroupPoolsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_group_pools" */
export type EventGroupPoolsArrRelInsertInput = {
  data: Array<EventGroupPoolsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupPoolsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_group_pools". All fields are combined with a logical 'AND'. */
export type EventGroupPoolsBoolExp = {
  _and?: InputMaybe<Array<EventGroupPoolsBoolExp>>;
  _not?: InputMaybe<EventGroupPoolsBoolExp>;
  _or?: InputMaybe<Array<EventGroupPoolsBoolExp>>;
  courts?: InputMaybe<EventCourtsBoolExp>;
  courtsAggregate?: InputMaybe<EventCourtsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  endsAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesBoolExp>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateBoolExp>;
  rounds?: InputMaybe<EventPoolRoundsBoolExp>;
  roundsAggregate?: InputMaybe<EventPoolRoundsAggregateBoolExp>;
  sequence?: InputMaybe<EventGroupSequencesBoolExp>;
  sequenceId?: InputMaybe<UuidComparisonExp>;
  startsAt?: InputMaybe<TimestamptzComparisonExp>;
  teams?: InputMaybe<EventPoolsTeamsBoolExp>;
  teamsAggregate?: InputMaybe<EventPoolsTeamsAggregateBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_group_pools" */
export enum EventGroupPoolsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventGroupPoolsPkey = 'event_group_pools_pkey'
}

/** input type for inserting data into table "event_group_pools" */
export type EventGroupPoolsInsertInput = {
  courts?: InputMaybe<EventCourtsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<EventGroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  matches?: InputMaybe<EventMatchesArrRelInsertInput>;
  rounds?: InputMaybe<EventPoolRoundsArrRelInsertInput>;
  sequence?: InputMaybe<EventGroupSequencesObjRelInsertInput>;
  sequenceId?: InputMaybe<Scalars['uuid']>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  teams?: InputMaybe<EventPoolsTeamsArrRelInsertInput>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventGroupPoolsMaxFields = {
  __typename?: 'EventGroupPoolsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  sequenceId?: Maybe<Scalars['uuid']>;
  startsAt?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_group_pools" */
export type EventGroupPoolsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventGroupPoolsMinFields = {
  __typename?: 'EventGroupPoolsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  sequenceId?: Maybe<Scalars['uuid']>;
  startsAt?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_group_pools" */
export type EventGroupPoolsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_group_pools" */
export type EventGroupPoolsMutationResponse = {
  __typename?: 'EventGroupPoolsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupPools>;
};

/** input type for inserting object relation for remote table "event_group_pools" */
export type EventGroupPoolsObjRelInsertInput = {
  data: EventGroupPoolsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupPoolsOnConflict>;
};

/** on_conflict condition type for table "event_group_pools" */
export type EventGroupPoolsOnConflict = {
  constraint: EventGroupPoolsConstraint;
  updateColumns?: Array<EventGroupPoolsUpdateColumn>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};

/** Ordering options when selecting data from "event_group_pools". */
export type EventGroupPoolsOrderBy = {
  courtsAggregate?: InputMaybe<EventCourtsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  roundsAggregate?: InputMaybe<EventPoolRoundsAggregateOrderBy>;
  sequence?: InputMaybe<EventGroupSequencesOrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamsAggregate?: InputMaybe<EventPoolsTeamsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_group_pools */
export type EventGroupPoolsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_group_pools" */
export enum EventGroupPoolsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndsAt = 'endsAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  SequenceId = 'sequenceId',
  /** column name */
  StartsAt = 'startsAt',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_group_pools" */
export type EventGroupPoolsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  sequenceId?: InputMaybe<Scalars['uuid']>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_group_pools" */
export type EventGroupPoolsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupPoolsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupPoolsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  sequenceId?: InputMaybe<Scalars['uuid']>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_group_pools" */
export enum EventGroupPoolsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndsAt = 'endsAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  SequenceId = 'sequenceId',
  /** column name */
  StartsAt = 'startsAt',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventGroupPoolsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupPoolsSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupPoolsBoolExp;
};

/** columns and relationships of "event_group_registration_statuses" */
export type EventGroupRegistrationStatuses = {
  __typename?: 'EventGroupRegistrationStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesAggregate = {
  __typename?: 'EventGroupRegistrationStatusesAggregate';
  aggregate?: Maybe<EventGroupRegistrationStatusesAggregateFields>;
  nodes: Array<EventGroupRegistrationStatuses>;
};

/** aggregate fields of "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesAggregateFields = {
  __typename?: 'EventGroupRegistrationStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventGroupRegistrationStatusesMaxFields>;
  min?: Maybe<EventGroupRegistrationStatusesMinFields>;
};


/** aggregate fields of "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_group_registration_statuses". All fields are combined with a logical 'AND'. */
export type EventGroupRegistrationStatusesBoolExp = {
  _and?: InputMaybe<Array<EventGroupRegistrationStatusesBoolExp>>;
  _not?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
  _or?: InputMaybe<Array<EventGroupRegistrationStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_group_registration_statuses" */
export enum EventGroupRegistrationStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventGroupRegistrationStatusesPkey = 'event_group_registration_statuses_pkey'
}

export enum EventGroupRegistrationStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventGroupRegistrationStatusesEnum". All fields are combined with logical 'AND'. */
export type EventGroupRegistrationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  _in?: InputMaybe<Array<EventGroupRegistrationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  _nin?: InputMaybe<Array<EventGroupRegistrationStatusesEnum>>;
};

/** input type for inserting data into table "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventGroupRegistrationStatusesMaxFields = {
  __typename?: 'EventGroupRegistrationStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventGroupRegistrationStatusesMinFields = {
  __typename?: 'EventGroupRegistrationStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesMutationResponse = {
  __typename?: 'EventGroupRegistrationStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupRegistrationStatuses>;
};

/** on_conflict condition type for table "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesOnConflict = {
  constraint: EventGroupRegistrationStatusesConstraint;
  updateColumns?: Array<EventGroupRegistrationStatusesUpdateColumn>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};

/** Ordering options when selecting data from "event_group_registration_statuses". */
export type EventGroupRegistrationStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_group_registration_statuses */
export type EventGroupRegistrationStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_group_registration_statuses" */
export enum EventGroupRegistrationStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_group_registration_statuses" */
export type EventGroupRegistrationStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupRegistrationStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupRegistrationStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_group_registration_statuses" */
export enum EventGroupRegistrationStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventGroupRegistrationStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupRegistrationStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupRegistrationStatusesBoolExp;
};

/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrations = {
  __typename?: 'EventGroupRegistrations';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An array relationship */
  invitations: Array<EventInvitations>;
  /** An aggregate relationship */
  invitationsAggregate: EventInvitationsAggregate;
  invitedPartnerEmail?: Maybe<Scalars['String']>;
  invitedPartnerName?: Maybe<Scalars['String']>;
  status: EventGroupRegistrationStatusesEnum;
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  /** An array relationship */
  transactionItems: Array<EventTransactionItems>;
  /** An aggregate relationship */
  transactionItemsAggregate: EventTransactionItemsAggregate;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrationsInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrationsInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrationsTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


/** columns and relationships of "event_group_registrations" */
export type EventGroupRegistrationsTransactionItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** aggregated selection of "event_group_registrations" */
export type EventGroupRegistrationsAggregate = {
  __typename?: 'EventGroupRegistrationsAggregate';
  aggregate?: Maybe<EventGroupRegistrationsAggregateFields>;
  nodes: Array<EventGroupRegistrations>;
};

export type EventGroupRegistrationsAggregateBoolExp = {
  count?: InputMaybe<EventGroupRegistrationsAggregateBoolExpCount>;
};

/** aggregate fields of "event_group_registrations" */
export type EventGroupRegistrationsAggregateFields = {
  __typename?: 'EventGroupRegistrationsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventGroupRegistrationsMaxFields>;
  min?: Maybe<EventGroupRegistrationsMinFields>;
};


/** aggregate fields of "event_group_registrations" */
export type EventGroupRegistrationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_group_registrations" */
export type EventGroupRegistrationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupRegistrationsMaxOrderBy>;
  min?: InputMaybe<EventGroupRegistrationsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_group_registrations" */
export type EventGroupRegistrationsArrRelInsertInput = {
  data: Array<EventGroupRegistrationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupRegistrationsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_group_registrations". All fields are combined with a logical 'AND'. */
export type EventGroupRegistrationsBoolExp = {
  _and?: InputMaybe<Array<EventGroupRegistrationsBoolExp>>;
  _not?: InputMaybe<EventGroupRegistrationsBoolExp>;
  _or?: InputMaybe<Array<EventGroupRegistrationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitations?: InputMaybe<EventInvitationsBoolExp>;
  invitationsAggregate?: InputMaybe<EventInvitationsAggregateBoolExp>;
  invitedPartnerEmail?: InputMaybe<StringComparisonExp>;
  invitedPartnerName?: InputMaybe<StringComparisonExp>;
  status?: InputMaybe<EventGroupRegistrationStatusesEnumComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  transactionItems?: InputMaybe<EventTransactionItemsBoolExp>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "event_group_registrations" */
export enum EventGroupRegistrationsConstraint {
  /** unique or primary key constraint on columns "user_id", "group_id" */
  EventGroupRegistrationsGroupIdUserIdKey = 'event_group_registrations_group_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  EventGroupRegistrationsPkey = 'event_group_registrations_pkey'
}

/** input type for inserting data into table "event_group_registrations" */
export type EventGroupRegistrationsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<EventGroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitations?: InputMaybe<EventInvitationsArrRelInsertInput>;
  invitedPartnerEmail?: InputMaybe<Scalars['String']>;
  invitedPartnerName?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  team?: InputMaybe<EventTeamsObjRelInsertInput>;
  teamId?: InputMaybe<Scalars['uuid']>;
  transactionItems?: InputMaybe<EventTransactionItemsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type EventGroupRegistrationsMaxFields = {
  __typename?: 'EventGroupRegistrationsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invitedPartnerEmail?: Maybe<Scalars['String']>;
  invitedPartnerName?: Maybe<Scalars['String']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_group_registrations" */
export type EventGroupRegistrationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitedPartnerEmail?: InputMaybe<OrderBy>;
  invitedPartnerName?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventGroupRegistrationsMinFields = {
  __typename?: 'EventGroupRegistrationsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invitedPartnerEmail?: Maybe<Scalars['String']>;
  invitedPartnerName?: Maybe<Scalars['String']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_group_registrations" */
export type EventGroupRegistrationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitedPartnerEmail?: InputMaybe<OrderBy>;
  invitedPartnerName?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_group_registrations" */
export type EventGroupRegistrationsMutationResponse = {
  __typename?: 'EventGroupRegistrationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupRegistrations>;
};

/** input type for inserting object relation for remote table "event_group_registrations" */
export type EventGroupRegistrationsObjRelInsertInput = {
  data: EventGroupRegistrationsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupRegistrationsOnConflict>;
};

/** on_conflict condition type for table "event_group_registrations" */
export type EventGroupRegistrationsOnConflict = {
  constraint: EventGroupRegistrationsConstraint;
  updateColumns?: Array<EventGroupRegistrationsUpdateColumn>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};

/** Ordering options when selecting data from "event_group_registrations". */
export type EventGroupRegistrationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationsAggregate?: InputMaybe<EventInvitationsAggregateOrderBy>;
  invitedPartnerEmail?: InputMaybe<OrderBy>;
  invitedPartnerName?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: event_group_registrations */
export type EventGroupRegistrationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_group_registrations" */
export enum EventGroupRegistrationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedPartnerEmail = 'invitedPartnerEmail',
  /** column name */
  InvitedPartnerName = 'invitedPartnerName',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "event_group_registrations" */
export type EventGroupRegistrationsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitedPartnerEmail?: InputMaybe<Scalars['String']>;
  invitedPartnerName?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "event_group_registrations" */
export type EventGroupRegistrationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupRegistrationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupRegistrationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitedPartnerEmail?: InputMaybe<Scalars['String']>;
  invitedPartnerName?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<EventGroupRegistrationStatusesEnum>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "event_group_registrations" */
export enum EventGroupRegistrationsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedPartnerEmail = 'invitedPartnerEmail',
  /** column name */
  InvitedPartnerName = 'invitedPartnerName',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type EventGroupRegistrationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupRegistrationsSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupRegistrationsBoolExp;
};

/** columns and relationships of "event_group_sequence_seeding" */
export type EventGroupSequenceSeeding = {
  __typename?: 'EventGroupSequenceSeeding';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventGroupSequenceId: Scalars['uuid'];
  eventTeamId: Scalars['uuid'];
  id: Scalars['uuid'];
  seed: Scalars['Int'];
  /** An object relationship */
  sequence: EventGroupSequences;
  /** An object relationship */
  team: EventTeams;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAggregate = {
  __typename?: 'EventGroupSequenceSeedingAggregate';
  aggregate?: Maybe<EventGroupSequenceSeedingAggregateFields>;
  nodes: Array<EventGroupSequenceSeeding>;
};

export type EventGroupSequenceSeedingAggregateBoolExp = {
  count?: InputMaybe<EventGroupSequenceSeedingAggregateBoolExpCount>;
};

/** aggregate fields of "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAggregateFields = {
  __typename?: 'EventGroupSequenceSeedingAggregateFields';
  avg?: Maybe<EventGroupSequenceSeedingAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventGroupSequenceSeedingMaxFields>;
  min?: Maybe<EventGroupSequenceSeedingMinFields>;
  stddev?: Maybe<EventGroupSequenceSeedingStddevFields>;
  stddevPop?: Maybe<EventGroupSequenceSeedingStddevPopFields>;
  stddevSamp?: Maybe<EventGroupSequenceSeedingStddevSampFields>;
  sum?: Maybe<EventGroupSequenceSeedingSumFields>;
  varPop?: Maybe<EventGroupSequenceSeedingVarPopFields>;
  varSamp?: Maybe<EventGroupSequenceSeedingVarSampFields>;
  variance?: Maybe<EventGroupSequenceSeedingVarianceFields>;
};


/** aggregate fields of "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAggregateOrderBy = {
  avg?: InputMaybe<EventGroupSequenceSeedingAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupSequenceSeedingMaxOrderBy>;
  min?: InputMaybe<EventGroupSequenceSeedingMinOrderBy>;
  stddev?: InputMaybe<EventGroupSequenceSeedingStddevOrderBy>;
  stddevPop?: InputMaybe<EventGroupSequenceSeedingStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGroupSequenceSeedingStddevSampOrderBy>;
  sum?: InputMaybe<EventGroupSequenceSeedingSumOrderBy>;
  varPop?: InputMaybe<EventGroupSequenceSeedingVarPopOrderBy>;
  varSamp?: InputMaybe<EventGroupSequenceSeedingVarSampOrderBy>;
  variance?: InputMaybe<EventGroupSequenceSeedingVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingArrRelInsertInput = {
  data: Array<EventGroupSequenceSeedingInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupSequenceSeedingOnConflict>;
};

/** aggregate avg on columns */
export type EventGroupSequenceSeedingAvgFields = {
  __typename?: 'EventGroupSequenceSeedingAvgFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingAvgOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_group_sequence_seeding". All fields are combined with a logical 'AND'. */
export type EventGroupSequenceSeedingBoolExp = {
  _and?: InputMaybe<Array<EventGroupSequenceSeedingBoolExp>>;
  _not?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
  _or?: InputMaybe<Array<EventGroupSequenceSeedingBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  eventGroupSequenceId?: InputMaybe<UuidComparisonExp>;
  eventTeamId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  seed?: InputMaybe<IntComparisonExp>;
  sequence?: InputMaybe<EventGroupSequencesBoolExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_group_sequence_seeding" */
export enum EventGroupSequenceSeedingConstraint {
  /** unique or primary key constraint on columns "event_team_id", "event_group_sequence_id" */
  EventGroupSequenceSeedingEventGroupSequenceIdEventKey = 'event_group_sequence_seeding_event_group_sequence_id_event__key',
  /** unique or primary key constraint on columns "seed", "event_group_sequence_id" */
  EventGroupSequenceSeedingEventGroupSequenceIdSeedKey = 'event_group_sequence_seeding_event_group_sequence_id_seed_key',
  /** unique or primary key constraint on columns "id" */
  EventGroupSequenceSeedingPkey = 'event_group_sequence_seeding_pkey'
}

/** input type for incrementing numeric columns in table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingIncInput = {
  seed?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventGroupSequenceId?: InputMaybe<Scalars['uuid']>;
  eventTeamId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  seed?: InputMaybe<Scalars['Int']>;
  sequence?: InputMaybe<EventGroupSequencesObjRelInsertInput>;
  team?: InputMaybe<EventTeamsObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventGroupSequenceSeedingMaxFields = {
  __typename?: 'EventGroupSequenceSeedingMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventGroupSequenceId?: Maybe<Scalars['uuid']>;
  eventTeamId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  seed?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventGroupSequenceId?: InputMaybe<OrderBy>;
  eventTeamId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  seed?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventGroupSequenceSeedingMinFields = {
  __typename?: 'EventGroupSequenceSeedingMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventGroupSequenceId?: Maybe<Scalars['uuid']>;
  eventTeamId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  seed?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventGroupSequenceId?: InputMaybe<OrderBy>;
  eventTeamId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  seed?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingMutationResponse = {
  __typename?: 'EventGroupSequenceSeedingMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupSequenceSeeding>;
};

/** on_conflict condition type for table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingOnConflict = {
  constraint: EventGroupSequenceSeedingConstraint;
  updateColumns?: Array<EventGroupSequenceSeedingUpdateColumn>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};

/** Ordering options when selecting data from "event_group_sequence_seeding". */
export type EventGroupSequenceSeedingOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventGroupSequenceId?: InputMaybe<OrderBy>;
  eventTeamId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  seed?: InputMaybe<OrderBy>;
  sequence?: InputMaybe<EventGroupSequencesOrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_group_sequence_seeding */
export type EventGroupSequenceSeedingPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_group_sequence_seeding" */
export enum EventGroupSequenceSeedingSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventGroupSequenceId = 'eventGroupSequenceId',
  /** column name */
  EventTeamId = 'eventTeamId',
  /** column name */
  Id = 'id',
  /** column name */
  Seed = 'seed',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventGroupSequenceId?: InputMaybe<Scalars['uuid']>;
  eventTeamId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  seed?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventGroupSequenceSeedingStddevFields = {
  __typename?: 'EventGroupSequenceSeedingStddevFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStddevOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventGroupSequenceSeedingStddevPopFields = {
  __typename?: 'EventGroupSequenceSeedingStddevPopFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStddevPopOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventGroupSequenceSeedingStddevSampFields = {
  __typename?: 'EventGroupSequenceSeedingStddevSampFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStddevSampOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupSequenceSeedingStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupSequenceSeedingStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventGroupSequenceId?: InputMaybe<Scalars['uuid']>;
  eventTeamId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  seed?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventGroupSequenceSeedingSumFields = {
  __typename?: 'EventGroupSequenceSeedingSumFields';
  seed?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingSumOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** update columns of table "event_group_sequence_seeding" */
export enum EventGroupSequenceSeedingUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventGroupSequenceId = 'eventGroupSequenceId',
  /** column name */
  EventTeamId = 'eventTeamId',
  /** column name */
  Id = 'id',
  /** column name */
  Seed = 'seed',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventGroupSequenceSeedingUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventGroupSequenceSeedingIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupSequenceSeedingSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupSequenceSeedingBoolExp;
};

/** aggregate varPop on columns */
export type EventGroupSequenceSeedingVarPopFields = {
  __typename?: 'EventGroupSequenceSeedingVarPopFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingVarPopOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventGroupSequenceSeedingVarSampFields = {
  __typename?: 'EventGroupSequenceSeedingVarSampFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingVarSampOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventGroupSequenceSeedingVarianceFields = {
  __typename?: 'EventGroupSequenceSeedingVarianceFields';
  seed?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_group_sequence_seeding" */
export type EventGroupSequenceSeedingVarianceOrderBy = {
  seed?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_group_sequences" */
export type EventGroupSequences = {
  __typename?: 'EventGroupSequences';
  competitionFormat: CompetitionFormatsEnum;
  completeReason: EventSequenceCompleteReasonsEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  isSequenceComplete: Scalars['Boolean'];
  /** An object relationship */
  nextSequence?: Maybe<EventGroupSequences>;
  nextSequenceId?: Maybe<Scalars['uuid']>;
  order: Scalars['Int'];
  /** An array relationship */
  pools: Array<EventGroupPools>;
  /** An aggregate relationship */
  poolsAggregate: EventGroupPoolsAggregate;
  /** An array relationship */
  seeding: Array<EventGroupSequenceSeeding>;
  /** An aggregate relationship */
  seedingAggregate: EventGroupSequenceSeedingAggregate;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_group_sequences" */
export type EventGroupSequencesPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


/** columns and relationships of "event_group_sequences" */
export type EventGroupSequencesPoolsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


/** columns and relationships of "event_group_sequences" */
export type EventGroupSequencesSeedingArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


/** columns and relationships of "event_group_sequences" */
export type EventGroupSequencesSeedingAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};

/** aggregated selection of "event_group_sequences" */
export type EventGroupSequencesAggregate = {
  __typename?: 'EventGroupSequencesAggregate';
  aggregate?: Maybe<EventGroupSequencesAggregateFields>;
  nodes: Array<EventGroupSequences>;
};

export type EventGroupSequencesAggregateBoolExp = {
  bool_and?: InputMaybe<EventGroupSequencesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<EventGroupSequencesAggregateBoolExpBool_Or>;
  count?: InputMaybe<EventGroupSequencesAggregateBoolExpCount>;
};

/** aggregate fields of "event_group_sequences" */
export type EventGroupSequencesAggregateFields = {
  __typename?: 'EventGroupSequencesAggregateFields';
  avg?: Maybe<EventGroupSequencesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventGroupSequencesMaxFields>;
  min?: Maybe<EventGroupSequencesMinFields>;
  stddev?: Maybe<EventGroupSequencesStddevFields>;
  stddevPop?: Maybe<EventGroupSequencesStddevPopFields>;
  stddevSamp?: Maybe<EventGroupSequencesStddevSampFields>;
  sum?: Maybe<EventGroupSequencesSumFields>;
  varPop?: Maybe<EventGroupSequencesVarPopFields>;
  varSamp?: Maybe<EventGroupSequencesVarSampFields>;
  variance?: Maybe<EventGroupSequencesVarianceFields>;
};


/** aggregate fields of "event_group_sequences" */
export type EventGroupSequencesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_group_sequences" */
export type EventGroupSequencesAggregateOrderBy = {
  avg?: InputMaybe<EventGroupSequencesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupSequencesMaxOrderBy>;
  min?: InputMaybe<EventGroupSequencesMinOrderBy>;
  stddev?: InputMaybe<EventGroupSequencesStddevOrderBy>;
  stddevPop?: InputMaybe<EventGroupSequencesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGroupSequencesStddevSampOrderBy>;
  sum?: InputMaybe<EventGroupSequencesSumOrderBy>;
  varPop?: InputMaybe<EventGroupSequencesVarPopOrderBy>;
  varSamp?: InputMaybe<EventGroupSequencesVarSampOrderBy>;
  variance?: InputMaybe<EventGroupSequencesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_group_sequences" */
export type EventGroupSequencesArrRelInsertInput = {
  data: Array<EventGroupSequencesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupSequencesOnConflict>;
};

/** aggregate avg on columns */
export type EventGroupSequencesAvgFields = {
  __typename?: 'EventGroupSequencesAvgFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_group_sequences" */
export type EventGroupSequencesAvgOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_group_sequences". All fields are combined with a logical 'AND'. */
export type EventGroupSequencesBoolExp = {
  _and?: InputMaybe<Array<EventGroupSequencesBoolExp>>;
  _not?: InputMaybe<EventGroupSequencesBoolExp>;
  _or?: InputMaybe<Array<EventGroupSequencesBoolExp>>;
  competitionFormat?: InputMaybe<CompetitionFormatsEnumComparisonExp>;
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isSequenceComplete?: InputMaybe<BooleanComparisonExp>;
  nextSequence?: InputMaybe<EventGroupSequencesBoolExp>;
  nextSequenceId?: InputMaybe<UuidComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  pools?: InputMaybe<EventGroupPoolsBoolExp>;
  poolsAggregate?: InputMaybe<EventGroupPoolsAggregateBoolExp>;
  seeding?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
  seedingAggregate?: InputMaybe<EventGroupSequenceSeedingAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_group_sequences" */
export enum EventGroupSequencesConstraint {
  /** unique or primary key constraint on columns "order", "group_id" */
  EventGroupSequencesGroupIdOrderKey = 'event_group_sequences_group_id_order_key',
  /** unique or primary key constraint on columns "id" */
  EventGroupSequencesPkey = 'event_group_sequences_pkey'
}

/** input type for incrementing numeric columns in table "event_group_sequences" */
export type EventGroupSequencesIncInput = {
  order?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_group_sequences" */
export type EventGroupSequencesInsertInput = {
  competitionFormat?: InputMaybe<CompetitionFormatsEnum>;
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<EventGroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isSequenceComplete?: InputMaybe<Scalars['Boolean']>;
  nextSequence?: InputMaybe<EventGroupSequencesObjRelInsertInput>;
  nextSequenceId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  pools?: InputMaybe<EventGroupPoolsArrRelInsertInput>;
  seeding?: InputMaybe<EventGroupSequenceSeedingArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventGroupSequencesMaxFields = {
  __typename?: 'EventGroupSequencesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  nextSequenceId?: Maybe<Scalars['uuid']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_group_sequences" */
export type EventGroupSequencesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  nextSequenceId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventGroupSequencesMinFields = {
  __typename?: 'EventGroupSequencesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  nextSequenceId?: Maybe<Scalars['uuid']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_group_sequences" */
export type EventGroupSequencesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  nextSequenceId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_group_sequences" */
export type EventGroupSequencesMutationResponse = {
  __typename?: 'EventGroupSequencesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroupSequences>;
};

/** input type for inserting object relation for remote table "event_group_sequences" */
export type EventGroupSequencesObjRelInsertInput = {
  data: EventGroupSequencesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupSequencesOnConflict>;
};

/** on_conflict condition type for table "event_group_sequences" */
export type EventGroupSequencesOnConflict = {
  constraint: EventGroupSequencesConstraint;
  updateColumns?: Array<EventGroupSequencesUpdateColumn>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};

/** Ordering options when selecting data from "event_group_sequences". */
export type EventGroupSequencesOrderBy = {
  competitionFormat?: InputMaybe<OrderBy>;
  completeReason?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isSequenceComplete?: InputMaybe<OrderBy>;
  nextSequence?: InputMaybe<EventGroupSequencesOrderBy>;
  nextSequenceId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  poolsAggregate?: InputMaybe<EventGroupPoolsAggregateOrderBy>;
  seedingAggregate?: InputMaybe<EventGroupSequenceSeedingAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_group_sequences */
export type EventGroupSequencesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_group_sequences" */
export enum EventGroupSequencesSelectColumn {
  /** column name */
  CompetitionFormat = 'competitionFormat',
  /** column name */
  CompleteReason = 'completeReason',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsSequenceComplete = 'isSequenceComplete',
  /** column name */
  NextSequenceId = 'nextSequenceId',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "eventGroupSequencesAggregateBoolExpBool_andArgumentsColumns" columns of table "event_group_sequences" */
export enum EventGroupSequencesSelectColumnEventGroupSequencesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsSequenceComplete = 'isSequenceComplete'
}

/** select "eventGroupSequencesAggregateBoolExpBool_orArgumentsColumns" columns of table "event_group_sequences" */
export enum EventGroupSequencesSelectColumnEventGroupSequencesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsSequenceComplete = 'isSequenceComplete'
}

/** input type for updating data in table "event_group_sequences" */
export type EventGroupSequencesSetInput = {
  competitionFormat?: InputMaybe<CompetitionFormatsEnum>;
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isSequenceComplete?: InputMaybe<Scalars['Boolean']>;
  nextSequenceId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventGroupSequencesStddevFields = {
  __typename?: 'EventGroupSequencesStddevFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_group_sequences" */
export type EventGroupSequencesStddevOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventGroupSequencesStddevPopFields = {
  __typename?: 'EventGroupSequencesStddevPopFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_group_sequences" */
export type EventGroupSequencesStddevPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventGroupSequencesStddevSampFields = {
  __typename?: 'EventGroupSequencesStddevSampFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_group_sequences" */
export type EventGroupSequencesStddevSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_group_sequences" */
export type EventGroupSequencesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupSequencesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupSequencesStreamCursorValueInput = {
  competitionFormat?: InputMaybe<CompetitionFormatsEnum>;
  completeReason?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isSequenceComplete?: InputMaybe<Scalars['Boolean']>;
  nextSequenceId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventGroupSequencesSumFields = {
  __typename?: 'EventGroupSequencesSumFields';
  order?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_group_sequences" */
export type EventGroupSequencesSumOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "event_group_sequences" */
export enum EventGroupSequencesUpdateColumn {
  /** column name */
  CompetitionFormat = 'competitionFormat',
  /** column name */
  CompleteReason = 'completeReason',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsSequenceComplete = 'isSequenceComplete',
  /** column name */
  NextSequenceId = 'nextSequenceId',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventGroupSequencesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventGroupSequencesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupSequencesSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupSequencesBoolExp;
};

/** aggregate varPop on columns */
export type EventGroupSequencesVarPopFields = {
  __typename?: 'EventGroupSequencesVarPopFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_group_sequences" */
export type EventGroupSequencesVarPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventGroupSequencesVarSampFields = {
  __typename?: 'EventGroupSequencesVarSampFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_group_sequences" */
export type EventGroupSequencesVarSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventGroupSequencesVarianceFields = {
  __typename?: 'EventGroupSequencesVarianceFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_group_sequences" */
export type EventGroupSequencesVarianceOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_groups" */
export type EventGroups = {
  __typename?: 'EventGroups';
  /** An array relationship */
  courts: Array<EventCourts>;
  /** An aggregate relationship */
  courtsAggregate: EventCourtsAggregate;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  format: EventGroupFormatsEnum;
  formatCustomName: Scalars['String'];
  gamesPerMatch: Scalars['Int'];
  gender: CompetitionGenderEnum;
  id: Scalars['uuid'];
  maximumAge?: Maybe<Scalars['Int']>;
  maximumRating?: Maybe<Scalars['numeric']>;
  minimumAge?: Maybe<Scalars['Int']>;
  minimumNumberOfGames: Scalars['Int'];
  minimumRating?: Maybe<Scalars['numeric']>;
  numberOfEliminationTeams?: Maybe<Scalars['Int']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Int']>;
  /** An array relationship */
  pools: Array<EventGroupPools>;
  /** An aggregate relationship */
  poolsAggregate: EventGroupPoolsAggregate;
  priceUnitAmount: Scalars['Int'];
  /** An array relationship */
  registrations: Array<EventGroupRegistrations>;
  /** An aggregate relationship */
  registrationsAggregate: EventGroupRegistrationsAggregate;
  scoringFormat: ScoringFormatEnum;
  /** An array relationship */
  sequences: Array<EventGroupSequences>;
  /** An aggregate relationship */
  sequencesAggregate: EventGroupSequencesAggregate;
  startsAt?: Maybe<Scalars['timestamptz']>;
  teamLimit: Scalars['Int'];
  teamType: TeamTypesEnum;
  /** An array relationship */
  teams: Array<EventTeams>;
  /** An aggregate relationship */
  teamsAggregate: EventTeamsAggregate;
  title: Scalars['String'];
  totalPoints: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  winBy?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsPoolsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsSequencesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsSequencesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


/** columns and relationships of "event_groups" */
export type EventGroupsTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};

/** aggregated selection of "event_groups" */
export type EventGroupsAggregate = {
  __typename?: 'EventGroupsAggregate';
  aggregate?: Maybe<EventGroupsAggregateFields>;
  nodes: Array<EventGroups>;
};

export type EventGroupsAggregateBoolExp = {
  count?: InputMaybe<EventGroupsAggregateBoolExpCount>;
};

/** aggregate fields of "event_groups" */
export type EventGroupsAggregateFields = {
  __typename?: 'EventGroupsAggregateFields';
  avg?: Maybe<EventGroupsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventGroupsMaxFields>;
  min?: Maybe<EventGroupsMinFields>;
  stddev?: Maybe<EventGroupsStddevFields>;
  stddevPop?: Maybe<EventGroupsStddevPopFields>;
  stddevSamp?: Maybe<EventGroupsStddevSampFields>;
  sum?: Maybe<EventGroupsSumFields>;
  varPop?: Maybe<EventGroupsVarPopFields>;
  varSamp?: Maybe<EventGroupsVarSampFields>;
  variance?: Maybe<EventGroupsVarianceFields>;
};


/** aggregate fields of "event_groups" */
export type EventGroupsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventGroupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_groups" */
export type EventGroupsAggregateOrderBy = {
  avg?: InputMaybe<EventGroupsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventGroupsMaxOrderBy>;
  min?: InputMaybe<EventGroupsMinOrderBy>;
  stddev?: InputMaybe<EventGroupsStddevOrderBy>;
  stddevPop?: InputMaybe<EventGroupsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventGroupsStddevSampOrderBy>;
  sum?: InputMaybe<EventGroupsSumOrderBy>;
  varPop?: InputMaybe<EventGroupsVarPopOrderBy>;
  varSamp?: InputMaybe<EventGroupsVarSampOrderBy>;
  variance?: InputMaybe<EventGroupsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_groups" */
export type EventGroupsArrRelInsertInput = {
  data: Array<EventGroupsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupsOnConflict>;
};

/** aggregate avg on columns */
export type EventGroupsAvgFields = {
  __typename?: 'EventGroupsAvgFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_groups" */
export type EventGroupsAvgOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_groups". All fields are combined with a logical 'AND'. */
export type EventGroupsBoolExp = {
  _and?: InputMaybe<Array<EventGroupsBoolExp>>;
  _not?: InputMaybe<EventGroupsBoolExp>;
  _or?: InputMaybe<Array<EventGroupsBoolExp>>;
  courts?: InputMaybe<EventCourtsBoolExp>;
  courtsAggregate?: InputMaybe<EventCourtsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  endsAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  format?: InputMaybe<EventGroupFormatsEnumComparisonExp>;
  formatCustomName?: InputMaybe<StringComparisonExp>;
  gamesPerMatch?: InputMaybe<IntComparisonExp>;
  gender?: InputMaybe<CompetitionGenderEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  maximumAge?: InputMaybe<IntComparisonExp>;
  maximumRating?: InputMaybe<NumericComparisonExp>;
  minimumAge?: InputMaybe<IntComparisonExp>;
  minimumNumberOfGames?: InputMaybe<IntComparisonExp>;
  minimumRating?: InputMaybe<NumericComparisonExp>;
  numberOfEliminationTeams?: InputMaybe<IntComparisonExp>;
  numberOfEstimatedCourts?: InputMaybe<IntComparisonExp>;
  pools?: InputMaybe<EventGroupPoolsBoolExp>;
  poolsAggregate?: InputMaybe<EventGroupPoolsAggregateBoolExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  registrations?: InputMaybe<EventGroupRegistrationsBoolExp>;
  registrationsAggregate?: InputMaybe<EventGroupRegistrationsAggregateBoolExp>;
  scoringFormat?: InputMaybe<ScoringFormatEnumComparisonExp>;
  sequences?: InputMaybe<EventGroupSequencesBoolExp>;
  sequencesAggregate?: InputMaybe<EventGroupSequencesAggregateBoolExp>;
  startsAt?: InputMaybe<TimestamptzComparisonExp>;
  teamLimit?: InputMaybe<IntComparisonExp>;
  teamType?: InputMaybe<TeamTypesEnumComparisonExp>;
  teams?: InputMaybe<EventTeamsBoolExp>;
  teamsAggregate?: InputMaybe<EventTeamsAggregateBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  totalPoints?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  winBy?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "event_groups" */
export enum EventGroupsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventGroupsPkey = 'event_groups_pkey'
}

/** input type for incrementing numeric columns in table "event_groups" */
export type EventGroupsIncInput = {
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_groups" */
export type EventGroupsInsertInput = {
  courts?: InputMaybe<EventCourtsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  format?: InputMaybe<EventGroupFormatsEnum>;
  formatCustomName?: InputMaybe<Scalars['String']>;
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  gender?: InputMaybe<CompetitionGenderEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  pools?: InputMaybe<EventGroupPoolsArrRelInsertInput>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  registrations?: InputMaybe<EventGroupRegistrationsArrRelInsertInput>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  sequences?: InputMaybe<EventGroupSequencesArrRelInsertInput>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  teamType?: InputMaybe<TeamTypesEnum>;
  teams?: InputMaybe<EventTeamsArrRelInsertInput>;
  title?: InputMaybe<Scalars['String']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type EventGroupsMaxFields = {
  __typename?: 'EventGroupsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  formatCustomName?: Maybe<Scalars['String']>;
  gamesPerMatch?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  maximumAge?: Maybe<Scalars['Int']>;
  maximumRating?: Maybe<Scalars['numeric']>;
  minimumAge?: Maybe<Scalars['Int']>;
  minimumNumberOfGames?: Maybe<Scalars['Int']>;
  minimumRating?: Maybe<Scalars['numeric']>;
  numberOfEliminationTeams?: Maybe<Scalars['Int']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  startsAt?: Maybe<Scalars['timestamptz']>;
  teamLimit?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  winBy?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "event_groups" */
export type EventGroupsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  formatCustomName?: InputMaybe<OrderBy>;
  gamesPerMatch?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventGroupsMinFields = {
  __typename?: 'EventGroupsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endsAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  formatCustomName?: Maybe<Scalars['String']>;
  gamesPerMatch?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  maximumAge?: Maybe<Scalars['Int']>;
  maximumRating?: Maybe<Scalars['numeric']>;
  minimumAge?: Maybe<Scalars['Int']>;
  minimumNumberOfGames?: Maybe<Scalars['Int']>;
  minimumRating?: Maybe<Scalars['numeric']>;
  numberOfEliminationTeams?: Maybe<Scalars['Int']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  startsAt?: Maybe<Scalars['timestamptz']>;
  teamLimit?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  winBy?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "event_groups" */
export type EventGroupsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  formatCustomName?: InputMaybe<OrderBy>;
  gamesPerMatch?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_groups" */
export type EventGroupsMutationResponse = {
  __typename?: 'EventGroupsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGroups>;
};

/** input type for inserting object relation for remote table "event_groups" */
export type EventGroupsObjRelInsertInput = {
  data: EventGroupsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventGroupsOnConflict>;
};

/** on_conflict condition type for table "event_groups" */
export type EventGroupsOnConflict = {
  constraint: EventGroupsConstraint;
  updateColumns?: Array<EventGroupsUpdateColumn>;
  where?: InputMaybe<EventGroupsBoolExp>;
};

/** Ordering options when selecting data from "event_groups". */
export type EventGroupsOrderBy = {
  courtsAggregate?: InputMaybe<EventCourtsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endsAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  format?: InputMaybe<OrderBy>;
  formatCustomName?: InputMaybe<OrderBy>;
  gamesPerMatch?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  poolsAggregate?: InputMaybe<EventGroupPoolsAggregateOrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  registrationsAggregate?: InputMaybe<EventGroupRegistrationsAggregateOrderBy>;
  scoringFormat?: InputMaybe<OrderBy>;
  sequencesAggregate?: InputMaybe<EventGroupSequencesAggregateOrderBy>;
  startsAt?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  teamType?: InputMaybe<OrderBy>;
  teamsAggregate?: InputMaybe<EventTeamsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_groups */
export type EventGroupsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_groups" */
export enum EventGroupsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndsAt = 'endsAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Format = 'format',
  /** column name */
  FormatCustomName = 'formatCustomName',
  /** column name */
  GamesPerMatch = 'gamesPerMatch',
  /** column name */
  Gender = 'gender',
  /** column name */
  Id = 'id',
  /** column name */
  MaximumAge = 'maximumAge',
  /** column name */
  MaximumRating = 'maximumRating',
  /** column name */
  MinimumAge = 'minimumAge',
  /** column name */
  MinimumNumberOfGames = 'minimumNumberOfGames',
  /** column name */
  MinimumRating = 'minimumRating',
  /** column name */
  NumberOfEliminationTeams = 'numberOfEliminationTeams',
  /** column name */
  NumberOfEstimatedCourts = 'numberOfEstimatedCourts',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  ScoringFormat = 'scoringFormat',
  /** column name */
  StartsAt = 'startsAt',
  /** column name */
  TeamLimit = 'teamLimit',
  /** column name */
  TeamType = 'teamType',
  /** column name */
  Title = 'title',
  /** column name */
  TotalPoints = 'totalPoints',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinBy = 'winBy'
}

/** input type for updating data in table "event_groups" */
export type EventGroupsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  format?: InputMaybe<EventGroupFormatsEnum>;
  formatCustomName?: InputMaybe<Scalars['String']>;
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  gender?: InputMaybe<CompetitionGenderEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  teamType?: InputMaybe<TeamTypesEnum>;
  title?: InputMaybe<Scalars['String']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type EventGroupsStddevFields = {
  __typename?: 'EventGroupsStddevFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_groups" */
export type EventGroupsStddevOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventGroupsStddevPopFields = {
  __typename?: 'EventGroupsStddevPopFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_groups" */
export type EventGroupsStddevPopOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventGroupsStddevSampFields = {
  __typename?: 'EventGroupsStddevSampFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_groups" */
export type EventGroupsStddevSampOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_groups" */
export type EventGroupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventGroupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGroupsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endsAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  format?: InputMaybe<EventGroupFormatsEnum>;
  formatCustomName?: InputMaybe<Scalars['String']>;
  gamesPerMatch?: InputMaybe<Scalars['Int']>;
  gender?: InputMaybe<CompetitionGenderEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  maximumAge?: InputMaybe<Scalars['Int']>;
  maximumRating?: InputMaybe<Scalars['numeric']>;
  minimumAge?: InputMaybe<Scalars['Int']>;
  minimumNumberOfGames?: InputMaybe<Scalars['Int']>;
  minimumRating?: InputMaybe<Scalars['numeric']>;
  numberOfEliminationTeams?: InputMaybe<Scalars['Int']>;
  numberOfEstimatedCourts?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  startsAt?: InputMaybe<Scalars['timestamptz']>;
  teamLimit?: InputMaybe<Scalars['Int']>;
  teamType?: InputMaybe<TeamTypesEnum>;
  title?: InputMaybe<Scalars['String']>;
  totalPoints?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winBy?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type EventGroupsSumFields = {
  __typename?: 'EventGroupsSumFields';
  gamesPerMatch?: Maybe<Scalars['Int']>;
  maximumAge?: Maybe<Scalars['Int']>;
  maximumRating?: Maybe<Scalars['numeric']>;
  minimumAge?: Maybe<Scalars['Int']>;
  minimumNumberOfGames?: Maybe<Scalars['Int']>;
  minimumRating?: Maybe<Scalars['numeric']>;
  numberOfEliminationTeams?: Maybe<Scalars['Int']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  teamLimit?: Maybe<Scalars['Int']>;
  totalPoints?: Maybe<Scalars['Int']>;
  winBy?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_groups" */
export type EventGroupsSumOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** update columns of table "event_groups" */
export enum EventGroupsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndsAt = 'endsAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Format = 'format',
  /** column name */
  FormatCustomName = 'formatCustomName',
  /** column name */
  GamesPerMatch = 'gamesPerMatch',
  /** column name */
  Gender = 'gender',
  /** column name */
  Id = 'id',
  /** column name */
  MaximumAge = 'maximumAge',
  /** column name */
  MaximumRating = 'maximumRating',
  /** column name */
  MinimumAge = 'minimumAge',
  /** column name */
  MinimumNumberOfGames = 'minimumNumberOfGames',
  /** column name */
  MinimumRating = 'minimumRating',
  /** column name */
  NumberOfEliminationTeams = 'numberOfEliminationTeams',
  /** column name */
  NumberOfEstimatedCourts = 'numberOfEstimatedCourts',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  ScoringFormat = 'scoringFormat',
  /** column name */
  StartsAt = 'startsAt',
  /** column name */
  TeamLimit = 'teamLimit',
  /** column name */
  TeamType = 'teamType',
  /** column name */
  Title = 'title',
  /** column name */
  TotalPoints = 'totalPoints',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinBy = 'winBy'
}

export type EventGroupsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventGroupsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGroupsSetInput>;
  /** filter the rows which have to be updated */
  where: EventGroupsBoolExp;
};

/** aggregate varPop on columns */
export type EventGroupsVarPopFields = {
  __typename?: 'EventGroupsVarPopFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_groups" */
export type EventGroupsVarPopOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventGroupsVarSampFields = {
  __typename?: 'EventGroupsVarSampFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_groups" */
export type EventGroupsVarSampOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventGroupsVarianceFields = {
  __typename?: 'EventGroupsVarianceFields';
  gamesPerMatch?: Maybe<Scalars['Float']>;
  maximumAge?: Maybe<Scalars['Float']>;
  maximumRating?: Maybe<Scalars['Float']>;
  minimumAge?: Maybe<Scalars['Float']>;
  minimumNumberOfGames?: Maybe<Scalars['Float']>;
  minimumRating?: Maybe<Scalars['Float']>;
  numberOfEliminationTeams?: Maybe<Scalars['Float']>;
  numberOfEstimatedCourts?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  teamLimit?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
  winBy?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_groups" */
export type EventGroupsVarianceOrderBy = {
  gamesPerMatch?: InputMaybe<OrderBy>;
  maximumAge?: InputMaybe<OrderBy>;
  maximumRating?: InputMaybe<OrderBy>;
  minimumAge?: InputMaybe<OrderBy>;
  minimumNumberOfGames?: InputMaybe<OrderBy>;
  minimumRating?: InputMaybe<OrderBy>;
  numberOfEliminationTeams?: InputMaybe<OrderBy>;
  numberOfEstimatedCourts?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  teamLimit?: InputMaybe<OrderBy>;
  totalPoints?: InputMaybe<OrderBy>;
  winBy?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_invitation_statuses" */
export type EventInvitationStatuses = {
  __typename?: 'EventInvitationStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_invitation_statuses" */
export type EventInvitationStatusesAggregate = {
  __typename?: 'EventInvitationStatusesAggregate';
  aggregate?: Maybe<EventInvitationStatusesAggregateFields>;
  nodes: Array<EventInvitationStatuses>;
};

/** aggregate fields of "event_invitation_statuses" */
export type EventInvitationStatusesAggregateFields = {
  __typename?: 'EventInvitationStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventInvitationStatusesMaxFields>;
  min?: Maybe<EventInvitationStatusesMinFields>;
};


/** aggregate fields of "event_invitation_statuses" */
export type EventInvitationStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_invitation_statuses". All fields are combined with a logical 'AND'. */
export type EventInvitationStatusesBoolExp = {
  _and?: InputMaybe<Array<EventInvitationStatusesBoolExp>>;
  _not?: InputMaybe<EventInvitationStatusesBoolExp>;
  _or?: InputMaybe<Array<EventInvitationStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_invitation_statuses" */
export enum EventInvitationStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventInvitationStatusesPkey = 'event_invitation_statuses_pkey'
}

export enum EventInvitationStatusesEnum {
  Accepted = 'ACCEPTED',
  Open = 'OPEN',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventInvitationStatusesEnum". All fields are combined with logical 'AND'. */
export type EventInvitationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventInvitationStatusesEnum>;
  _in?: InputMaybe<Array<EventInvitationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventInvitationStatusesEnum>;
  _nin?: InputMaybe<Array<EventInvitationStatusesEnum>>;
};

/** input type for inserting data into table "event_invitation_statuses" */
export type EventInvitationStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventInvitationStatusesMaxFields = {
  __typename?: 'EventInvitationStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventInvitationStatusesMinFields = {
  __typename?: 'EventInvitationStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_invitation_statuses" */
export type EventInvitationStatusesMutationResponse = {
  __typename?: 'EventInvitationStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventInvitationStatuses>;
};

/** on_conflict condition type for table "event_invitation_statuses" */
export type EventInvitationStatusesOnConflict = {
  constraint: EventInvitationStatusesConstraint;
  updateColumns?: Array<EventInvitationStatusesUpdateColumn>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};

/** Ordering options when selecting data from "event_invitation_statuses". */
export type EventInvitationStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_invitation_statuses */
export type EventInvitationStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_invitation_statuses" */
export enum EventInvitationStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_invitation_statuses" */
export type EventInvitationStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_invitation_statuses" */
export type EventInvitationStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventInvitationStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventInvitationStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_invitation_statuses" */
export enum EventInvitationStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventInvitationStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventInvitationStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: EventInvitationStatusesBoolExp;
};

/** columns and relationships of "event_invitations" */
export type EventInvitations = {
  __typename?: 'EventInvitations';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  /** An object relationship */
  groupRegistration?: Maybe<EventGroupRegistrations>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  invitationEmail: Scalars['String'];
  invitationName?: Maybe<Scalars['String']>;
  invitedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  invitedUser?: Maybe<Users>;
  invitedUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  invitedUserProfile?: Maybe<UserProfiles>;
  /** An object relationship */
  senderUser: Users;
  senderUserId: Scalars['uuid'];
  /** An object relationship */
  senderUserProfile?: Maybe<UserProfiles>;
  status: EventInvitationStatusesEnum;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_invitations" */
export type EventInvitationsAggregate = {
  __typename?: 'EventInvitationsAggregate';
  aggregate?: Maybe<EventInvitationsAggregateFields>;
  nodes: Array<EventInvitations>;
};

export type EventInvitationsAggregateBoolExp = {
  count?: InputMaybe<EventInvitationsAggregateBoolExpCount>;
};

/** aggregate fields of "event_invitations" */
export type EventInvitationsAggregateFields = {
  __typename?: 'EventInvitationsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventInvitationsMaxFields>;
  min?: Maybe<EventInvitationsMinFields>;
};


/** aggregate fields of "event_invitations" */
export type EventInvitationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_invitations" */
export type EventInvitationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventInvitationsMaxOrderBy>;
  min?: InputMaybe<EventInvitationsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_invitations" */
export type EventInvitationsArrRelInsertInput = {
  data: Array<EventInvitationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventInvitationsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_invitations". All fields are combined with a logical 'AND'. */
export type EventInvitationsBoolExp = {
  _and?: InputMaybe<Array<EventInvitationsBoolExp>>;
  _not?: InputMaybe<EventInvitationsBoolExp>;
  _or?: InputMaybe<Array<EventInvitationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsBoolExp>;
  groupRegistrationId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitationEmail?: InputMaybe<StringComparisonExp>;
  invitationName?: InputMaybe<StringComparisonExp>;
  invitedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  invitedUser?: InputMaybe<UsersBoolExp>;
  invitedUserId?: InputMaybe<UuidComparisonExp>;
  invitedUserProfile?: InputMaybe<UserProfilesBoolExp>;
  senderUser?: InputMaybe<UsersBoolExp>;
  senderUserId?: InputMaybe<UuidComparisonExp>;
  senderUserProfile?: InputMaybe<UserProfilesBoolExp>;
  status?: InputMaybe<EventInvitationStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_invitations" */
export enum EventInvitationsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventInvitationsPkey = 'event_invitations_pkey'
}

/** input type for inserting data into table "event_invitations" */
export type EventInvitationsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  group?: InputMaybe<EventGroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsObjRelInsertInput>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitationEmail?: InputMaybe<Scalars['String']>;
  invitationName?: InputMaybe<Scalars['String']>;
  invitedByPersona?: InputMaybe<AppPersonasEnum>;
  invitedUser?: InputMaybe<UsersObjRelInsertInput>;
  invitedUserId?: InputMaybe<Scalars['uuid']>;
  invitedUserProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  senderUser?: InputMaybe<UsersObjRelInsertInput>;
  senderUserId?: InputMaybe<Scalars['uuid']>;
  senderUserProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  status?: InputMaybe<EventInvitationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventInvitationsMaxFields = {
  __typename?: 'EventInvitationsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  groupId?: Maybe<Scalars['uuid']>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invitationEmail?: Maybe<Scalars['String']>;
  invitationName?: Maybe<Scalars['String']>;
  invitedUserId?: Maybe<Scalars['uuid']>;
  senderUserId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_invitations" */
export type EventInvitationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationEmail?: InputMaybe<OrderBy>;
  invitationName?: InputMaybe<OrderBy>;
  invitedUserId?: InputMaybe<OrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventInvitationsMinFields = {
  __typename?: 'EventInvitationsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  groupId?: Maybe<Scalars['uuid']>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  invitationEmail?: Maybe<Scalars['String']>;
  invitationName?: Maybe<Scalars['String']>;
  invitedUserId?: Maybe<Scalars['uuid']>;
  senderUserId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_invitations" */
export type EventInvitationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationEmail?: InputMaybe<OrderBy>;
  invitationName?: InputMaybe<OrderBy>;
  invitedUserId?: InputMaybe<OrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_invitations" */
export type EventInvitationsMutationResponse = {
  __typename?: 'EventInvitationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventInvitations>;
};

/** on_conflict condition type for table "event_invitations" */
export type EventInvitationsOnConflict = {
  constraint: EventInvitationsConstraint;
  updateColumns?: Array<EventInvitationsUpdateColumn>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};

/** Ordering options when selecting data from "event_invitations". */
export type EventInvitationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsOrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationEmail?: InputMaybe<OrderBy>;
  invitationName?: InputMaybe<OrderBy>;
  invitedByPersona?: InputMaybe<OrderBy>;
  invitedUser?: InputMaybe<UsersOrderBy>;
  invitedUserId?: InputMaybe<OrderBy>;
  invitedUserProfile?: InputMaybe<UserProfilesOrderBy>;
  senderUser?: InputMaybe<UsersOrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  senderUserProfile?: InputMaybe<UserProfilesOrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_invitations */
export type EventInvitationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_invitations" */
export enum EventInvitationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupRegistrationId = 'groupRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationEmail = 'invitationEmail',
  /** column name */
  InvitationName = 'invitationName',
  /** column name */
  InvitedByPersona = 'invitedByPersona',
  /** column name */
  InvitedUserId = 'invitedUserId',
  /** column name */
  SenderUserId = 'senderUserId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_invitations" */
export type EventInvitationsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitationEmail?: InputMaybe<Scalars['String']>;
  invitationName?: InputMaybe<Scalars['String']>;
  invitedByPersona?: InputMaybe<AppPersonasEnum>;
  invitedUserId?: InputMaybe<Scalars['uuid']>;
  senderUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventInvitationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_invitations" */
export type EventInvitationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventInvitationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventInvitationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitationEmail?: InputMaybe<Scalars['String']>;
  invitationName?: InputMaybe<Scalars['String']>;
  invitedByPersona?: InputMaybe<AppPersonasEnum>;
  invitedUserId?: InputMaybe<Scalars['uuid']>;
  senderUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventInvitationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_invitations" */
export enum EventInvitationsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupRegistrationId = 'groupRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationEmail = 'invitationEmail',
  /** column name */
  InvitationName = 'invitationName',
  /** column name */
  InvitedByPersona = 'invitedByPersona',
  /** column name */
  InvitedUserId = 'invitedUserId',
  /** column name */
  SenderUserId = 'senderUserId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventInvitationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventInvitationsSetInput>;
  /** filter the rows which have to be updated */
  where: EventInvitationsBoolExp;
};

/** columns and relationships of "event_listing_fees" */
export type EventListingFees = {
  __typename?: 'EventListingFees';
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creditCard: UserCreditCards;
  /** An object relationship */
  customer: Users;
  /** An object relationship */
  customerProfile?: Maybe<UserProfiles>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  orderSubtotalUnitAmount: Scalars['Int'];
  orderTotalUnitAmount: Scalars['Int'];
  paidUnitAmount: Scalars['Int'];
  /** An object relationship */
  paymentIntentExternal: StripePaymentIntents;
  /** An object relationship */
  paymentIntentInternal: StripePaymentIntents;
  paymentProcessor: PaymentProcessorsEnum;
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  status: OrderStatusesEnum;
  stripeCustomerId: Scalars['String'];
  stripePaymentStatus: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  userCreditCardId: Scalars['uuid'];
  userId: Scalars['uuid'];
};

/** aggregated selection of "event_listing_fees" */
export type EventListingFeesAggregate = {
  __typename?: 'EventListingFeesAggregate';
  aggregate?: Maybe<EventListingFeesAggregateFields>;
  nodes: Array<EventListingFees>;
};

export type EventListingFeesAggregateBoolExp = {
  count?: InputMaybe<EventListingFeesAggregateBoolExpCount>;
};

/** aggregate fields of "event_listing_fees" */
export type EventListingFeesAggregateFields = {
  __typename?: 'EventListingFeesAggregateFields';
  avg?: Maybe<EventListingFeesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventListingFeesMaxFields>;
  min?: Maybe<EventListingFeesMinFields>;
  stddev?: Maybe<EventListingFeesStddevFields>;
  stddevPop?: Maybe<EventListingFeesStddevPopFields>;
  stddevSamp?: Maybe<EventListingFeesStddevSampFields>;
  sum?: Maybe<EventListingFeesSumFields>;
  varPop?: Maybe<EventListingFeesVarPopFields>;
  varSamp?: Maybe<EventListingFeesVarSampFields>;
  variance?: Maybe<EventListingFeesVarianceFields>;
};


/** aggregate fields of "event_listing_fees" */
export type EventListingFeesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_listing_fees" */
export type EventListingFeesAggregateOrderBy = {
  avg?: InputMaybe<EventListingFeesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventListingFeesMaxOrderBy>;
  min?: InputMaybe<EventListingFeesMinOrderBy>;
  stddev?: InputMaybe<EventListingFeesStddevOrderBy>;
  stddevPop?: InputMaybe<EventListingFeesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventListingFeesStddevSampOrderBy>;
  sum?: InputMaybe<EventListingFeesSumOrderBy>;
  varPop?: InputMaybe<EventListingFeesVarPopOrderBy>;
  varSamp?: InputMaybe<EventListingFeesVarSampOrderBy>;
  variance?: InputMaybe<EventListingFeesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_listing_fees" */
export type EventListingFeesArrRelInsertInput = {
  data: Array<EventListingFeesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventListingFeesOnConflict>;
};

/** aggregate avg on columns */
export type EventListingFeesAvgFields = {
  __typename?: 'EventListingFeesAvgFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_listing_fees" */
export type EventListingFeesAvgOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_listing_fees". All fields are combined with a logical 'AND'. */
export type EventListingFeesBoolExp = {
  _and?: InputMaybe<Array<EventListingFeesBoolExp>>;
  _not?: InputMaybe<EventListingFeesBoolExp>;
  _or?: InputMaybe<Array<EventListingFeesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creditCard?: InputMaybe<UserCreditCardsBoolExp>;
  customer?: InputMaybe<UsersBoolExp>;
  customerProfile?: InputMaybe<UserProfilesBoolExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  orderSubtotalUnitAmount?: InputMaybe<IntComparisonExp>;
  orderTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  paidUnitAmount?: InputMaybe<IntComparisonExp>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnumComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripePaymentStatus?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCreditCardId?: InputMaybe<UuidComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "event_listing_fees" */
export enum EventListingFeesConstraint {
  /** unique or primary key constraint on columns "external_stripe_payment_intent_id" */
  EventListingFeesExternalStripePaymentIntentIdKey = 'event_listing_fees_external_stripe_payment_intent_id_key',
  /** unique or primary key constraint on columns "internal_stripe_payment_intent_id" */
  EventListingFeesInternalStripePaymentIntentIdKey = 'event_listing_fees_internal_stripe_payment_intent_id_key',
  /** unique or primary key constraint on columns "id" */
  EventListingFeesPkey = 'event_listing_fees_pkey'
}

/** input type for incrementing numeric columns in table "event_listing_fees" */
export type EventListingFeesIncInput = {
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_listing_fees" */
export type EventListingFeesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creditCard?: InputMaybe<UserCreditCardsObjRelInsertInput>;
  customer?: InputMaybe<UsersObjRelInsertInput>;
  customerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type EventListingFeesMaxFields = {
  __typename?: 'EventListingFeesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_listing_fees" */
export type EventListingFeesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventListingFeesMinFields = {
  __typename?: 'EventListingFeesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_listing_fees" */
export type EventListingFeesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_listing_fees" */
export type EventListingFeesMutationResponse = {
  __typename?: 'EventListingFeesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventListingFees>;
};

/** on_conflict condition type for table "event_listing_fees" */
export type EventListingFeesOnConflict = {
  constraint: EventListingFeesConstraint;
  updateColumns?: Array<EventListingFeesUpdateColumn>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};

/** Ordering options when selecting data from "event_listing_fees". */
export type EventListingFeesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  creditCard?: InputMaybe<UserCreditCardsOrderBy>;
  customer?: InputMaybe<UsersOrderBy>;
  customerProfile?: InputMaybe<UserProfilesOrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentProcessor?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_listing_fees */
export type EventListingFeesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_listing_fees" */
export enum EventListingFeesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "event_listing_fees" */
export type EventListingFeesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type EventListingFeesStddevFields = {
  __typename?: 'EventListingFeesStddevFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_listing_fees" */
export type EventListingFeesStddevOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventListingFeesStddevPopFields = {
  __typename?: 'EventListingFeesStddevPopFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_listing_fees" */
export type EventListingFeesStddevPopOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventListingFeesStddevSampFields = {
  __typename?: 'EventListingFeesStddevSampFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_listing_fees" */
export type EventListingFeesStddevSampOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_listing_fees" */
export type EventListingFeesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventListingFeesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventListingFeesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type EventListingFeesSumFields = {
  __typename?: 'EventListingFeesSumFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_listing_fees" */
export type EventListingFeesSumOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "event_listing_fees" */
export enum EventListingFeesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId',
  /** column name */
  UserId = 'userId'
}

export type EventListingFeesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventListingFeesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventListingFeesSetInput>;
  /** filter the rows which have to be updated */
  where: EventListingFeesBoolExp;
};

/** aggregate varPop on columns */
export type EventListingFeesVarPopFields = {
  __typename?: 'EventListingFeesVarPopFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_listing_fees" */
export type EventListingFeesVarPopOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventListingFeesVarSampFields = {
  __typename?: 'EventListingFeesVarSampFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_listing_fees" */
export type EventListingFeesVarSampOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventListingFeesVarianceFields = {
  __typename?: 'EventListingFeesVarianceFields';
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_listing_fees" */
export type EventListingFeesVarianceOrderBy = {
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_match_games" */
export type EventMatchGames = {
  __typename?: 'EventMatchGames';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  losingTeam: EventTeams;
  losingTeamId: Scalars['uuid'];
  /** An object relationship */
  match: EventMatches;
  matchId: Scalars['uuid'];
  /** An array relationship */
  scores: Array<EventGameScores>;
  /** An aggregate relationship */
  scoresAggregate: EventGameScoresAggregate;
  /** An object relationship */
  team1: EventTeams;
  team1Id: Scalars['uuid'];
  team1Score: Scalars['numeric'];
  /** An object relationship */
  team2: EventTeams;
  team2Id: Scalars['uuid'];
  team2Score: Scalars['numeric'];
  updatedAt: Scalars['timestamptz'];
  winReason: WinReasonsEnum;
  /** An object relationship */
  winningTeam: EventTeams;
  winningTeamId: Scalars['uuid'];
};


/** columns and relationships of "event_match_games" */
export type EventMatchGamesScoresArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


/** columns and relationships of "event_match_games" */
export type EventMatchGamesScoresAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};

/** aggregated selection of "event_match_games" */
export type EventMatchGamesAggregate = {
  __typename?: 'EventMatchGamesAggregate';
  aggregate?: Maybe<EventMatchGamesAggregateFields>;
  nodes: Array<EventMatchGames>;
};

export type EventMatchGamesAggregateBoolExp = {
  count?: InputMaybe<EventMatchGamesAggregateBoolExpCount>;
};

/** aggregate fields of "event_match_games" */
export type EventMatchGamesAggregateFields = {
  __typename?: 'EventMatchGamesAggregateFields';
  avg?: Maybe<EventMatchGamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventMatchGamesMaxFields>;
  min?: Maybe<EventMatchGamesMinFields>;
  stddev?: Maybe<EventMatchGamesStddevFields>;
  stddevPop?: Maybe<EventMatchGamesStddevPopFields>;
  stddevSamp?: Maybe<EventMatchGamesStddevSampFields>;
  sum?: Maybe<EventMatchGamesSumFields>;
  varPop?: Maybe<EventMatchGamesVarPopFields>;
  varSamp?: Maybe<EventMatchGamesVarSampFields>;
  variance?: Maybe<EventMatchGamesVarianceFields>;
};


/** aggregate fields of "event_match_games" */
export type EventMatchGamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_match_games" */
export type EventMatchGamesAggregateOrderBy = {
  avg?: InputMaybe<EventMatchGamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventMatchGamesMaxOrderBy>;
  min?: InputMaybe<EventMatchGamesMinOrderBy>;
  stddev?: InputMaybe<EventMatchGamesStddevOrderBy>;
  stddevPop?: InputMaybe<EventMatchGamesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventMatchGamesStddevSampOrderBy>;
  sum?: InputMaybe<EventMatchGamesSumOrderBy>;
  varPop?: InputMaybe<EventMatchGamesVarPopOrderBy>;
  varSamp?: InputMaybe<EventMatchGamesVarSampOrderBy>;
  variance?: InputMaybe<EventMatchGamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_match_games" */
export type EventMatchGamesArrRelInsertInput = {
  data: Array<EventMatchGamesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};

/** aggregate avg on columns */
export type EventMatchGamesAvgFields = {
  __typename?: 'EventMatchGamesAvgFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_match_games" */
export type EventMatchGamesAvgOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_match_games". All fields are combined with a logical 'AND'. */
export type EventMatchGamesBoolExp = {
  _and?: InputMaybe<Array<EventMatchGamesBoolExp>>;
  _not?: InputMaybe<EventMatchGamesBoolExp>;
  _or?: InputMaybe<Array<EventMatchGamesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  losingTeam?: InputMaybe<EventTeamsBoolExp>;
  losingTeamId?: InputMaybe<UuidComparisonExp>;
  match?: InputMaybe<EventMatchesBoolExp>;
  matchId?: InputMaybe<UuidComparisonExp>;
  scores?: InputMaybe<EventGameScoresBoolExp>;
  scoresAggregate?: InputMaybe<EventGameScoresAggregateBoolExp>;
  team1?: InputMaybe<EventTeamsBoolExp>;
  team1Id?: InputMaybe<UuidComparisonExp>;
  team1Score?: InputMaybe<NumericComparisonExp>;
  team2?: InputMaybe<EventTeamsBoolExp>;
  team2Id?: InputMaybe<UuidComparisonExp>;
  team2Score?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  winReason?: InputMaybe<WinReasonsEnumComparisonExp>;
  winningTeam?: InputMaybe<EventTeamsBoolExp>;
  winningTeamId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "event_match_games" */
export enum EventMatchGamesConstraint {
  /** unique or primary key constraint on columns "id" */
  EventMatchGamesPkey = 'event_match_games_pkey'
}

/** input type for incrementing numeric columns in table "event_match_games" */
export type EventMatchGamesIncInput = {
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "event_match_games" */
export type EventMatchGamesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  losingTeam?: InputMaybe<EventTeamsObjRelInsertInput>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  match?: InputMaybe<EventMatchesObjRelInsertInput>;
  matchId?: InputMaybe<Scalars['uuid']>;
  scores?: InputMaybe<EventGameScoresArrRelInsertInput>;
  team1?: InputMaybe<EventTeamsObjRelInsertInput>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2?: InputMaybe<EventTeamsObjRelInsertInput>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeam?: InputMaybe<EventTeamsObjRelInsertInput>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type EventMatchGamesMaxFields = {
  __typename?: 'EventMatchGamesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  losingTeamId?: Maybe<Scalars['uuid']>;
  matchId?: Maybe<Scalars['uuid']>;
  team1Id?: Maybe<Scalars['uuid']>;
  team1Score?: Maybe<Scalars['numeric']>;
  team2Id?: Maybe<Scalars['uuid']>;
  team2Score?: Maybe<Scalars['numeric']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  winningTeamId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_match_games" */
export type EventMatchGamesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team1Score?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventMatchGamesMinFields = {
  __typename?: 'EventMatchGamesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  losingTeamId?: Maybe<Scalars['uuid']>;
  matchId?: Maybe<Scalars['uuid']>;
  team1Id?: Maybe<Scalars['uuid']>;
  team1Score?: Maybe<Scalars['numeric']>;
  team2Id?: Maybe<Scalars['uuid']>;
  team2Score?: Maybe<Scalars['numeric']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  winningTeamId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_match_games" */
export type EventMatchGamesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team1Score?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_match_games" */
export type EventMatchGamesMutationResponse = {
  __typename?: 'EventMatchGamesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventMatchGames>;
};

/** input type for inserting object relation for remote table "event_match_games" */
export type EventMatchGamesObjRelInsertInput = {
  data: EventMatchGamesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};

/** on_conflict condition type for table "event_match_games" */
export type EventMatchGamesOnConflict = {
  constraint: EventMatchGamesConstraint;
  updateColumns?: Array<EventMatchGamesUpdateColumn>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};

/** Ordering options when selecting data from "event_match_games". */
export type EventMatchGamesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeam?: InputMaybe<EventTeamsOrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  match?: InputMaybe<EventMatchesOrderBy>;
  matchId?: InputMaybe<OrderBy>;
  scoresAggregate?: InputMaybe<EventGameScoresAggregateOrderBy>;
  team1?: InputMaybe<EventTeamsOrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team1Score?: InputMaybe<OrderBy>;
  team2?: InputMaybe<EventTeamsOrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winReason?: InputMaybe<OrderBy>;
  winningTeam?: InputMaybe<EventTeamsOrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_match_games */
export type EventMatchGamesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_match_games" */
export enum EventMatchGamesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  MatchId = 'matchId',
  /** column name */
  Team1Id = 'team1Id',
  /** column name */
  Team1Score = 'team1Score',
  /** column name */
  Team2Id = 'team2Id',
  /** column name */
  Team2Score = 'team2Score',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

/** input type for updating data in table "event_match_games" */
export type EventMatchGamesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type EventMatchGamesStddevFields = {
  __typename?: 'EventMatchGamesStddevFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_match_games" */
export type EventMatchGamesStddevOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventMatchGamesStddevPopFields = {
  __typename?: 'EventMatchGamesStddevPopFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_match_games" */
export type EventMatchGamesStddevPopOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventMatchGamesStddevSampFields = {
  __typename?: 'EventMatchGamesStddevSampFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_match_games" */
export type EventMatchGamesStddevSampOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_match_games" */
export type EventMatchGamesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventMatchGamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventMatchGamesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team1Score?: InputMaybe<Scalars['numeric']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  team2Score?: InputMaybe<Scalars['numeric']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type EventMatchGamesSumFields = {
  __typename?: 'EventMatchGamesSumFields';
  team1Score?: Maybe<Scalars['numeric']>;
  team2Score?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "event_match_games" */
export type EventMatchGamesSumOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** update columns of table "event_match_games" */
export enum EventMatchGamesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  MatchId = 'matchId',
  /** column name */
  Team1Id = 'team1Id',
  /** column name */
  Team1Score = 'team1Score',
  /** column name */
  Team2Id = 'team2Id',
  /** column name */
  Team2Score = 'team2Score',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

export type EventMatchGamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventMatchGamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventMatchGamesSetInput>;
  /** filter the rows which have to be updated */
  where: EventMatchGamesBoolExp;
};

/** aggregate varPop on columns */
export type EventMatchGamesVarPopFields = {
  __typename?: 'EventMatchGamesVarPopFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_match_games" */
export type EventMatchGamesVarPopOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventMatchGamesVarSampFields = {
  __typename?: 'EventMatchGamesVarSampFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_match_games" */
export type EventMatchGamesVarSampOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventMatchGamesVarianceFields = {
  __typename?: 'EventMatchGamesVarianceFields';
  team1Score?: Maybe<Scalars['Float']>;
  team2Score?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_match_games" */
export type EventMatchGamesVarianceOrderBy = {
  team1Score?: InputMaybe<OrderBy>;
  team2Score?: InputMaybe<OrderBy>;
};

/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatches = {
  __typename?: 'EventMatches';
  /** An object relationship */
  court?: Maybe<EventCourts>;
  courtNumber?: Maybe<Scalars['Int']>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventCourtId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  games: Array<EventMatchGames>;
  /** An aggregate relationship */
  gamesAggregate: EventMatchGamesAggregate;
  id: Scalars['uuid'];
  isBye: Scalars['Boolean'];
  /** An object relationship */
  losingTeam?: Maybe<EventTeams>;
  losingTeamId?: Maybe<Scalars['uuid']>;
  matchOrder: Scalars['Int'];
  /** An object relationship */
  pool?: Maybe<EventGroupPools>;
  poolId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  previousMatch1?: Maybe<EventMatches>;
  previousMatch1Id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  previousMatch2?: Maybe<EventMatches>;
  previousMatch2Id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  round: EventPoolRounds;
  roundId: Scalars['uuid'];
  selectionCriteriaPreviousMatch1?: Maybe<MatchSelectionCriteriaEnum>;
  selectionCriteriaPreviousMatch2?: Maybe<MatchSelectionCriteriaEnum>;
  /** An object relationship */
  team1?: Maybe<EventTeams>;
  team1Id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  team2?: Maybe<EventTeams>;
  team2Id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  teams: Array<EventMatchesTeams>;
  /** An aggregate relationship */
  teamsAggregate: EventMatchesTeamsAggregate;
  updatedAt: Scalars['timestamptz'];
  winReason?: Maybe<WinReasonsEnum>;
  /** An object relationship */
  winningTeam?: Maybe<EventTeams>;
  winningTeamId?: Maybe<Scalars['uuid']>;
};


/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatchesGamesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatchesGamesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatchesTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


/** NOTE: In the product direction, the concept of a round is becoming less structured. Currently over-structuring this until we understand what columns aren't needing. May add or remove some foreign keys, and potentially tie to and event or group. */
export type EventMatchesTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};

/** aggregated selection of "event_matches" */
export type EventMatchesAggregate = {
  __typename?: 'EventMatchesAggregate';
  aggregate?: Maybe<EventMatchesAggregateFields>;
  nodes: Array<EventMatches>;
};

export type EventMatchesAggregateBoolExp = {
  bool_and?: InputMaybe<EventMatchesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<EventMatchesAggregateBoolExpBool_Or>;
  count?: InputMaybe<EventMatchesAggregateBoolExpCount>;
};

/** aggregate fields of "event_matches" */
export type EventMatchesAggregateFields = {
  __typename?: 'EventMatchesAggregateFields';
  avg?: Maybe<EventMatchesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventMatchesMaxFields>;
  min?: Maybe<EventMatchesMinFields>;
  stddev?: Maybe<EventMatchesStddevFields>;
  stddevPop?: Maybe<EventMatchesStddevPopFields>;
  stddevSamp?: Maybe<EventMatchesStddevSampFields>;
  sum?: Maybe<EventMatchesSumFields>;
  varPop?: Maybe<EventMatchesVarPopFields>;
  varSamp?: Maybe<EventMatchesVarSampFields>;
  variance?: Maybe<EventMatchesVarianceFields>;
};


/** aggregate fields of "event_matches" */
export type EventMatchesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventMatchesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_matches" */
export type EventMatchesAggregateOrderBy = {
  avg?: InputMaybe<EventMatchesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventMatchesMaxOrderBy>;
  min?: InputMaybe<EventMatchesMinOrderBy>;
  stddev?: InputMaybe<EventMatchesStddevOrderBy>;
  stddevPop?: InputMaybe<EventMatchesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventMatchesStddevSampOrderBy>;
  sum?: InputMaybe<EventMatchesSumOrderBy>;
  varPop?: InputMaybe<EventMatchesVarPopOrderBy>;
  varSamp?: InputMaybe<EventMatchesVarSampOrderBy>;
  variance?: InputMaybe<EventMatchesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_matches" */
export type EventMatchesArrRelInsertInput = {
  data: Array<EventMatchesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventMatchesOnConflict>;
};

/** aggregate avg on columns */
export type EventMatchesAvgFields = {
  __typename?: 'EventMatchesAvgFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_matches" */
export type EventMatchesAvgOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_matches". All fields are combined with a logical 'AND'. */
export type EventMatchesBoolExp = {
  _and?: InputMaybe<Array<EventMatchesBoolExp>>;
  _not?: InputMaybe<EventMatchesBoolExp>;
  _or?: InputMaybe<Array<EventMatchesBoolExp>>;
  court?: InputMaybe<EventCourtsBoolExp>;
  courtNumber?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  eventCourtId?: InputMaybe<UuidComparisonExp>;
  games?: InputMaybe<EventMatchGamesBoolExp>;
  gamesAggregate?: InputMaybe<EventMatchGamesAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBye?: InputMaybe<BooleanComparisonExp>;
  losingTeam?: InputMaybe<EventTeamsBoolExp>;
  losingTeamId?: InputMaybe<UuidComparisonExp>;
  matchOrder?: InputMaybe<IntComparisonExp>;
  pool?: InputMaybe<EventGroupPoolsBoolExp>;
  poolId?: InputMaybe<UuidComparisonExp>;
  previousMatch1?: InputMaybe<EventMatchesBoolExp>;
  previousMatch1Id?: InputMaybe<UuidComparisonExp>;
  previousMatch2?: InputMaybe<EventMatchesBoolExp>;
  previousMatch2Id?: InputMaybe<UuidComparisonExp>;
  round?: InputMaybe<EventPoolRoundsBoolExp>;
  roundId?: InputMaybe<UuidComparisonExp>;
  selectionCriteriaPreviousMatch1?: InputMaybe<MatchSelectionCriteriaEnumComparisonExp>;
  selectionCriteriaPreviousMatch2?: InputMaybe<MatchSelectionCriteriaEnumComparisonExp>;
  team1?: InputMaybe<EventTeamsBoolExp>;
  team1Id?: InputMaybe<UuidComparisonExp>;
  team2?: InputMaybe<EventTeamsBoolExp>;
  team2Id?: InputMaybe<UuidComparisonExp>;
  teams?: InputMaybe<EventMatchesTeamsBoolExp>;
  teamsAggregate?: InputMaybe<EventMatchesTeamsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  winReason?: InputMaybe<WinReasonsEnumComparisonExp>;
  winningTeam?: InputMaybe<EventTeamsBoolExp>;
  winningTeamId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "event_matches" */
export enum EventMatchesConstraint {
  /** unique or primary key constraint on columns "id" */
  EventMatchesPkey = 'event_matches_pkey'
}

/** input type for incrementing numeric columns in table "event_matches" */
export type EventMatchesIncInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
  matchOrder?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_matches" */
export type EventMatchesInsertInput = {
  court?: InputMaybe<EventCourtsObjRelInsertInput>;
  courtNumber?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventCourtId?: InputMaybe<Scalars['uuid']>;
  games?: InputMaybe<EventMatchGamesArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  isBye?: InputMaybe<Scalars['Boolean']>;
  losingTeam?: InputMaybe<EventTeamsObjRelInsertInput>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchOrder?: InputMaybe<Scalars['Int']>;
  pool?: InputMaybe<EventGroupPoolsObjRelInsertInput>;
  poolId?: InputMaybe<Scalars['uuid']>;
  previousMatch1?: InputMaybe<EventMatchesObjRelInsertInput>;
  previousMatch1Id?: InputMaybe<Scalars['uuid']>;
  previousMatch2?: InputMaybe<EventMatchesObjRelInsertInput>;
  previousMatch2Id?: InputMaybe<Scalars['uuid']>;
  round?: InputMaybe<EventPoolRoundsObjRelInsertInput>;
  roundId?: InputMaybe<Scalars['uuid']>;
  selectionCriteriaPreviousMatch1?: InputMaybe<MatchSelectionCriteriaEnum>;
  selectionCriteriaPreviousMatch2?: InputMaybe<MatchSelectionCriteriaEnum>;
  team1?: InputMaybe<EventTeamsObjRelInsertInput>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team2?: InputMaybe<EventTeamsObjRelInsertInput>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  teams?: InputMaybe<EventMatchesTeamsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeam?: InputMaybe<EventTeamsObjRelInsertInput>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type EventMatchesMaxFields = {
  __typename?: 'EventMatchesMaxFields';
  courtNumber?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventCourtId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  losingTeamId?: Maybe<Scalars['uuid']>;
  matchOrder?: Maybe<Scalars['Int']>;
  poolId?: Maybe<Scalars['uuid']>;
  previousMatch1Id?: Maybe<Scalars['uuid']>;
  previousMatch2Id?: Maybe<Scalars['uuid']>;
  roundId?: Maybe<Scalars['uuid']>;
  team1Id?: Maybe<Scalars['uuid']>;
  team2Id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  winningTeamId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_matches" */
export type EventMatchesMaxOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventCourtId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  previousMatch1Id?: InputMaybe<OrderBy>;
  previousMatch2Id?: InputMaybe<OrderBy>;
  roundId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventMatchesMinFields = {
  __typename?: 'EventMatchesMinFields';
  courtNumber?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventCourtId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  losingTeamId?: Maybe<Scalars['uuid']>;
  matchOrder?: Maybe<Scalars['Int']>;
  poolId?: Maybe<Scalars['uuid']>;
  previousMatch1Id?: Maybe<Scalars['uuid']>;
  previousMatch2Id?: Maybe<Scalars['uuid']>;
  roundId?: Maybe<Scalars['uuid']>;
  team1Id?: Maybe<Scalars['uuid']>;
  team2Id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  winningTeamId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_matches" */
export type EventMatchesMinOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventCourtId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  previousMatch1Id?: InputMaybe<OrderBy>;
  previousMatch2Id?: InputMaybe<OrderBy>;
  roundId?: InputMaybe<OrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_matches" */
export type EventMatchesMutationResponse = {
  __typename?: 'EventMatchesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventMatches>;
};

/** input type for inserting object relation for remote table "event_matches" */
export type EventMatchesObjRelInsertInput = {
  data: EventMatchesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventMatchesOnConflict>;
};

/** on_conflict condition type for table "event_matches" */
export type EventMatchesOnConflict = {
  constraint: EventMatchesConstraint;
  updateColumns?: Array<EventMatchesUpdateColumn>;
  where?: InputMaybe<EventMatchesBoolExp>;
};

/** Ordering options when selecting data from "event_matches". */
export type EventMatchesOrderBy = {
  court?: InputMaybe<EventCourtsOrderBy>;
  courtNumber?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventCourtId?: InputMaybe<OrderBy>;
  gamesAggregate?: InputMaybe<EventMatchGamesAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isBye?: InputMaybe<OrderBy>;
  losingTeam?: InputMaybe<EventTeamsOrderBy>;
  losingTeamId?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
  pool?: InputMaybe<EventGroupPoolsOrderBy>;
  poolId?: InputMaybe<OrderBy>;
  previousMatch1?: InputMaybe<EventMatchesOrderBy>;
  previousMatch1Id?: InputMaybe<OrderBy>;
  previousMatch2?: InputMaybe<EventMatchesOrderBy>;
  previousMatch2Id?: InputMaybe<OrderBy>;
  round?: InputMaybe<EventPoolRoundsOrderBy>;
  roundId?: InputMaybe<OrderBy>;
  selectionCriteriaPreviousMatch1?: InputMaybe<OrderBy>;
  selectionCriteriaPreviousMatch2?: InputMaybe<OrderBy>;
  team1?: InputMaybe<EventTeamsOrderBy>;
  team1Id?: InputMaybe<OrderBy>;
  team2?: InputMaybe<EventTeamsOrderBy>;
  team2Id?: InputMaybe<OrderBy>;
  teamsAggregate?: InputMaybe<EventMatchesTeamsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  winReason?: InputMaybe<OrderBy>;
  winningTeam?: InputMaybe<EventTeamsOrderBy>;
  winningTeamId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_matches */
export type EventMatchesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_matches" */
export enum EventMatchesSelectColumn {
  /** column name */
  CourtNumber = 'courtNumber',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventCourtId = 'eventCourtId',
  /** column name */
  Id = 'id',
  /** column name */
  IsBye = 'isBye',
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  MatchOrder = 'matchOrder',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  PreviousMatch1Id = 'previousMatch1Id',
  /** column name */
  PreviousMatch2Id = 'previousMatch2Id',
  /** column name */
  RoundId = 'roundId',
  /** column name */
  SelectionCriteriaPreviousMatch1 = 'selectionCriteriaPreviousMatch1',
  /** column name */
  SelectionCriteriaPreviousMatch2 = 'selectionCriteriaPreviousMatch2',
  /** column name */
  Team1Id = 'team1Id',
  /** column name */
  Team2Id = 'team2Id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

/** select "eventMatchesAggregateBoolExpBool_andArgumentsColumns" columns of table "event_matches" */
export enum EventMatchesSelectColumnEventMatchesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsBye = 'isBye'
}

/** select "eventMatchesAggregateBoolExpBool_orArgumentsColumns" columns of table "event_matches" */
export enum EventMatchesSelectColumnEventMatchesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsBye = 'isBye'
}

/** input type for updating data in table "event_matches" */
export type EventMatchesSetInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventCourtId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isBye?: InputMaybe<Scalars['Boolean']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchOrder?: InputMaybe<Scalars['Int']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  previousMatch1Id?: InputMaybe<Scalars['uuid']>;
  previousMatch2Id?: InputMaybe<Scalars['uuid']>;
  roundId?: InputMaybe<Scalars['uuid']>;
  selectionCriteriaPreviousMatch1?: InputMaybe<MatchSelectionCriteriaEnum>;
  selectionCriteriaPreviousMatch2?: InputMaybe<MatchSelectionCriteriaEnum>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type EventMatchesStddevFields = {
  __typename?: 'EventMatchesStddevFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_matches" */
export type EventMatchesStddevOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventMatchesStddevPopFields = {
  __typename?: 'EventMatchesStddevPopFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_matches" */
export type EventMatchesStddevPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventMatchesStddevSampFields = {
  __typename?: 'EventMatchesStddevSampFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_matches" */
export type EventMatchesStddevSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_matches" */
export type EventMatchesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventMatchesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventMatchesStreamCursorValueInput = {
  courtNumber?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventCourtId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isBye?: InputMaybe<Scalars['Boolean']>;
  losingTeamId?: InputMaybe<Scalars['uuid']>;
  matchOrder?: InputMaybe<Scalars['Int']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  previousMatch1Id?: InputMaybe<Scalars['uuid']>;
  previousMatch2Id?: InputMaybe<Scalars['uuid']>;
  roundId?: InputMaybe<Scalars['uuid']>;
  selectionCriteriaPreviousMatch1?: InputMaybe<MatchSelectionCriteriaEnum>;
  selectionCriteriaPreviousMatch2?: InputMaybe<MatchSelectionCriteriaEnum>;
  team1Id?: InputMaybe<Scalars['uuid']>;
  team2Id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  winReason?: InputMaybe<WinReasonsEnum>;
  winningTeamId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type EventMatchesSumFields = {
  __typename?: 'EventMatchesSumFields';
  courtNumber?: Maybe<Scalars['Int']>;
  matchOrder?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_matches" */
export type EventMatchesSumOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_matches_teams" */
export type EventMatchesTeams = {
  __typename?: 'EventMatchesTeams';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  match: EventMatches;
  matchId: Scalars['uuid'];
  order: Scalars['Int'];
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_matches_teams" */
export type EventMatchesTeamsAggregate = {
  __typename?: 'EventMatchesTeamsAggregate';
  aggregate?: Maybe<EventMatchesTeamsAggregateFields>;
  nodes: Array<EventMatchesTeams>;
};

export type EventMatchesTeamsAggregateBoolExp = {
  count?: InputMaybe<EventMatchesTeamsAggregateBoolExpCount>;
};

/** aggregate fields of "event_matches_teams" */
export type EventMatchesTeamsAggregateFields = {
  __typename?: 'EventMatchesTeamsAggregateFields';
  avg?: Maybe<EventMatchesTeamsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventMatchesTeamsMaxFields>;
  min?: Maybe<EventMatchesTeamsMinFields>;
  stddev?: Maybe<EventMatchesTeamsStddevFields>;
  stddevPop?: Maybe<EventMatchesTeamsStddevPopFields>;
  stddevSamp?: Maybe<EventMatchesTeamsStddevSampFields>;
  sum?: Maybe<EventMatchesTeamsSumFields>;
  varPop?: Maybe<EventMatchesTeamsVarPopFields>;
  varSamp?: Maybe<EventMatchesTeamsVarSampFields>;
  variance?: Maybe<EventMatchesTeamsVarianceFields>;
};


/** aggregate fields of "event_matches_teams" */
export type EventMatchesTeamsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_matches_teams" */
export type EventMatchesTeamsAggregateOrderBy = {
  avg?: InputMaybe<EventMatchesTeamsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventMatchesTeamsMaxOrderBy>;
  min?: InputMaybe<EventMatchesTeamsMinOrderBy>;
  stddev?: InputMaybe<EventMatchesTeamsStddevOrderBy>;
  stddevPop?: InputMaybe<EventMatchesTeamsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventMatchesTeamsStddevSampOrderBy>;
  sum?: InputMaybe<EventMatchesTeamsSumOrderBy>;
  varPop?: InputMaybe<EventMatchesTeamsVarPopOrderBy>;
  varSamp?: InputMaybe<EventMatchesTeamsVarSampOrderBy>;
  variance?: InputMaybe<EventMatchesTeamsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_matches_teams" */
export type EventMatchesTeamsArrRelInsertInput = {
  data: Array<EventMatchesTeamsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventMatchesTeamsOnConflict>;
};

/** aggregate avg on columns */
export type EventMatchesTeamsAvgFields = {
  __typename?: 'EventMatchesTeamsAvgFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_matches_teams" */
export type EventMatchesTeamsAvgOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_matches_teams". All fields are combined with a logical 'AND'. */
export type EventMatchesTeamsBoolExp = {
  _and?: InputMaybe<Array<EventMatchesTeamsBoolExp>>;
  _not?: InputMaybe<EventMatchesTeamsBoolExp>;
  _or?: InputMaybe<Array<EventMatchesTeamsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  match?: InputMaybe<EventMatchesBoolExp>;
  matchId?: InputMaybe<UuidComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_matches_teams" */
export enum EventMatchesTeamsConstraint {
  /** unique or primary key constraint on columns "match_id", "team_id" */
  EventMatchesTeamsMatchIdTeamIdKey = 'event_matches_teams_match_id_team_id_key',
  /** unique or primary key constraint on columns "id" */
  EventMatchesTeamsPkey = 'event_matches_teams_pkey'
}

/** input type for incrementing numeric columns in table "event_matches_teams" */
export type EventMatchesTeamsIncInput = {
  order?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_matches_teams" */
export type EventMatchesTeamsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  match?: InputMaybe<EventMatchesObjRelInsertInput>;
  matchId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  team?: InputMaybe<EventTeamsObjRelInsertInput>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventMatchesTeamsMaxFields = {
  __typename?: 'EventMatchesTeamsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  matchId?: Maybe<Scalars['uuid']>;
  order?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_matches_teams" */
export type EventMatchesTeamsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventMatchesTeamsMinFields = {
  __typename?: 'EventMatchesTeamsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  matchId?: Maybe<Scalars['uuid']>;
  order?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_matches_teams" */
export type EventMatchesTeamsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_matches_teams" */
export type EventMatchesTeamsMutationResponse = {
  __typename?: 'EventMatchesTeamsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventMatchesTeams>;
};

/** on_conflict condition type for table "event_matches_teams" */
export type EventMatchesTeamsOnConflict = {
  constraint: EventMatchesTeamsConstraint;
  updateColumns?: Array<EventMatchesTeamsUpdateColumn>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};

/** Ordering options when selecting data from "event_matches_teams". */
export type EventMatchesTeamsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  match?: InputMaybe<EventMatchesOrderBy>;
  matchId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_matches_teams */
export type EventMatchesTeamsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_matches_teams" */
export enum EventMatchesTeamsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  MatchId = 'matchId',
  /** column name */
  Order = 'order',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_matches_teams" */
export type EventMatchesTeamsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventMatchesTeamsStddevFields = {
  __typename?: 'EventMatchesTeamsStddevFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_matches_teams" */
export type EventMatchesTeamsStddevOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventMatchesTeamsStddevPopFields = {
  __typename?: 'EventMatchesTeamsStddevPopFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_matches_teams" */
export type EventMatchesTeamsStddevPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventMatchesTeamsStddevSampFields = {
  __typename?: 'EventMatchesTeamsStddevSampFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_matches_teams" */
export type EventMatchesTeamsStddevSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_matches_teams" */
export type EventMatchesTeamsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventMatchesTeamsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventMatchesTeamsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  matchId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<Scalars['Int']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventMatchesTeamsSumFields = {
  __typename?: 'EventMatchesTeamsSumFields';
  order?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_matches_teams" */
export type EventMatchesTeamsSumOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "event_matches_teams" */
export enum EventMatchesTeamsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  MatchId = 'matchId',
  /** column name */
  Order = 'order',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventMatchesTeamsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventMatchesTeamsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventMatchesTeamsSetInput>;
  /** filter the rows which have to be updated */
  where: EventMatchesTeamsBoolExp;
};

/** aggregate varPop on columns */
export type EventMatchesTeamsVarPopFields = {
  __typename?: 'EventMatchesTeamsVarPopFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_matches_teams" */
export type EventMatchesTeamsVarPopOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventMatchesTeamsVarSampFields = {
  __typename?: 'EventMatchesTeamsVarSampFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_matches_teams" */
export type EventMatchesTeamsVarSampOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventMatchesTeamsVarianceFields = {
  __typename?: 'EventMatchesTeamsVarianceFields';
  order?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_matches_teams" */
export type EventMatchesTeamsVarianceOrderBy = {
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "event_matches" */
export enum EventMatchesUpdateColumn {
  /** column name */
  CourtNumber = 'courtNumber',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventCourtId = 'eventCourtId',
  /** column name */
  Id = 'id',
  /** column name */
  IsBye = 'isBye',
  /** column name */
  LosingTeamId = 'losingTeamId',
  /** column name */
  MatchOrder = 'matchOrder',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  PreviousMatch1Id = 'previousMatch1Id',
  /** column name */
  PreviousMatch2Id = 'previousMatch2Id',
  /** column name */
  RoundId = 'roundId',
  /** column name */
  SelectionCriteriaPreviousMatch1 = 'selectionCriteriaPreviousMatch1',
  /** column name */
  SelectionCriteriaPreviousMatch2 = 'selectionCriteriaPreviousMatch2',
  /** column name */
  Team1Id = 'team1Id',
  /** column name */
  Team2Id = 'team2Id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WinReason = 'winReason',
  /** column name */
  WinningTeamId = 'winningTeamId'
}

export type EventMatchesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventMatchesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventMatchesSetInput>;
  /** filter the rows which have to be updated */
  where: EventMatchesBoolExp;
};

/** aggregate varPop on columns */
export type EventMatchesVarPopFields = {
  __typename?: 'EventMatchesVarPopFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_matches" */
export type EventMatchesVarPopOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventMatchesVarSampFields = {
  __typename?: 'EventMatchesVarSampFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_matches" */
export type EventMatchesVarSampOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventMatchesVarianceFields = {
  __typename?: 'EventMatchesVarianceFields';
  courtNumber?: Maybe<Scalars['Float']>;
  matchOrder?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_matches" */
export type EventMatchesVarianceOrderBy = {
  courtNumber?: InputMaybe<OrderBy>;
  matchOrder?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_organizer_account_types" */
export type EventOrganizerAccountTypes = {
  __typename?: 'EventOrganizerAccountTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_organizer_account_types" */
export type EventOrganizerAccountTypesAggregate = {
  __typename?: 'EventOrganizerAccountTypesAggregate';
  aggregate?: Maybe<EventOrganizerAccountTypesAggregateFields>;
  nodes: Array<EventOrganizerAccountTypes>;
};

/** aggregate fields of "event_organizer_account_types" */
export type EventOrganizerAccountTypesAggregateFields = {
  __typename?: 'EventOrganizerAccountTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventOrganizerAccountTypesMaxFields>;
  min?: Maybe<EventOrganizerAccountTypesMinFields>;
};


/** aggregate fields of "event_organizer_account_types" */
export type EventOrganizerAccountTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_organizer_account_types". All fields are combined with a logical 'AND'. */
export type EventOrganizerAccountTypesBoolExp = {
  _and?: InputMaybe<Array<EventOrganizerAccountTypesBoolExp>>;
  _not?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
  _or?: InputMaybe<Array<EventOrganizerAccountTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_organizer_account_types" */
export enum EventOrganizerAccountTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventOrganizerAccountTypesPkey = 'event_organizer_account_types_pkey'
}

export enum EventOrganizerAccountTypesEnum {
  Club = 'CLUB',
  Inactive = 'INACTIVE',
  Individual = 'INDIVIDUAL',
  Other = 'OTHER',
  Tour = 'TOUR'
}

/** Boolean expression to compare columns of type "EventOrganizerAccountTypesEnum". All fields are combined with logical 'AND'. */
export type EventOrganizerAccountTypesEnumComparisonExp = {
  _eq?: InputMaybe<EventOrganizerAccountTypesEnum>;
  _in?: InputMaybe<Array<EventOrganizerAccountTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventOrganizerAccountTypesEnum>;
  _nin?: InputMaybe<Array<EventOrganizerAccountTypesEnum>>;
};

/** input type for inserting data into table "event_organizer_account_types" */
export type EventOrganizerAccountTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventOrganizerAccountTypesMaxFields = {
  __typename?: 'EventOrganizerAccountTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventOrganizerAccountTypesMinFields = {
  __typename?: 'EventOrganizerAccountTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_organizer_account_types" */
export type EventOrganizerAccountTypesMutationResponse = {
  __typename?: 'EventOrganizerAccountTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventOrganizerAccountTypes>;
};

/** on_conflict condition type for table "event_organizer_account_types" */
export type EventOrganizerAccountTypesOnConflict = {
  constraint: EventOrganizerAccountTypesConstraint;
  updateColumns?: Array<EventOrganizerAccountTypesUpdateColumn>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};

/** Ordering options when selecting data from "event_organizer_account_types". */
export type EventOrganizerAccountTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_organizer_account_types */
export type EventOrganizerAccountTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_organizer_account_types" */
export enum EventOrganizerAccountTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_organizer_account_types" */
export type EventOrganizerAccountTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_organizer_account_types" */
export type EventOrganizerAccountTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventOrganizerAccountTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventOrganizerAccountTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_organizer_account_types" */
export enum EventOrganizerAccountTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventOrganizerAccountTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventOrganizerAccountTypesSetInput>;
  /** filter the rows which have to be updated */
  where: EventOrganizerAccountTypesBoolExp;
};

/** columns and relationships of "event_pool_rounds" */
export type EventPoolRounds = {
  __typename?: 'EventPoolRounds';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatches>;
  /** An aggregate relationship */
  matchesAggregate: EventMatchesAggregate;
  /** An object relationship */
  pool: EventGroupPools;
  poolId: Scalars['uuid'];
  roundOrder: Scalars['Int'];
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_pool_rounds" */
export type EventPoolRoundsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_pool_rounds" */
export type EventPoolRoundsMatchesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};

/** aggregated selection of "event_pool_rounds" */
export type EventPoolRoundsAggregate = {
  __typename?: 'EventPoolRoundsAggregate';
  aggregate?: Maybe<EventPoolRoundsAggregateFields>;
  nodes: Array<EventPoolRounds>;
};

export type EventPoolRoundsAggregateBoolExp = {
  count?: InputMaybe<EventPoolRoundsAggregateBoolExpCount>;
};

/** aggregate fields of "event_pool_rounds" */
export type EventPoolRoundsAggregateFields = {
  __typename?: 'EventPoolRoundsAggregateFields';
  avg?: Maybe<EventPoolRoundsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventPoolRoundsMaxFields>;
  min?: Maybe<EventPoolRoundsMinFields>;
  stddev?: Maybe<EventPoolRoundsStddevFields>;
  stddevPop?: Maybe<EventPoolRoundsStddevPopFields>;
  stddevSamp?: Maybe<EventPoolRoundsStddevSampFields>;
  sum?: Maybe<EventPoolRoundsSumFields>;
  varPop?: Maybe<EventPoolRoundsVarPopFields>;
  varSamp?: Maybe<EventPoolRoundsVarSampFields>;
  variance?: Maybe<EventPoolRoundsVarianceFields>;
};


/** aggregate fields of "event_pool_rounds" */
export type EventPoolRoundsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_pool_rounds" */
export type EventPoolRoundsAggregateOrderBy = {
  avg?: InputMaybe<EventPoolRoundsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventPoolRoundsMaxOrderBy>;
  min?: InputMaybe<EventPoolRoundsMinOrderBy>;
  stddev?: InputMaybe<EventPoolRoundsStddevOrderBy>;
  stddevPop?: InputMaybe<EventPoolRoundsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventPoolRoundsStddevSampOrderBy>;
  sum?: InputMaybe<EventPoolRoundsSumOrderBy>;
  varPop?: InputMaybe<EventPoolRoundsVarPopOrderBy>;
  varSamp?: InputMaybe<EventPoolRoundsVarSampOrderBy>;
  variance?: InputMaybe<EventPoolRoundsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_pool_rounds" */
export type EventPoolRoundsArrRelInsertInput = {
  data: Array<EventPoolRoundsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventPoolRoundsOnConflict>;
};

/** aggregate avg on columns */
export type EventPoolRoundsAvgFields = {
  __typename?: 'EventPoolRoundsAvgFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_pool_rounds" */
export type EventPoolRoundsAvgOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_pool_rounds". All fields are combined with a logical 'AND'. */
export type EventPoolRoundsBoolExp = {
  _and?: InputMaybe<Array<EventPoolRoundsBoolExp>>;
  _not?: InputMaybe<EventPoolRoundsBoolExp>;
  _or?: InputMaybe<Array<EventPoolRoundsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesBoolExp>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateBoolExp>;
  pool?: InputMaybe<EventGroupPoolsBoolExp>;
  poolId?: InputMaybe<UuidComparisonExp>;
  roundOrder?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_pool_rounds" */
export enum EventPoolRoundsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventPoolRoundsPkey = 'event_pool_rounds_pkey',
  /** unique or primary key constraint on columns "pool_id", "round_order" */
  EventPoolRoundsPoolIdRoundOrderKey = 'event_pool_rounds_pool_id_round_order_key'
}

/** input type for incrementing numeric columns in table "event_pool_rounds" */
export type EventPoolRoundsIncInput = {
  roundOrder?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_pool_rounds" */
export type EventPoolRoundsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  matches?: InputMaybe<EventMatchesArrRelInsertInput>;
  pool?: InputMaybe<EventGroupPoolsObjRelInsertInput>;
  poolId?: InputMaybe<Scalars['uuid']>;
  roundOrder?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventPoolRoundsMaxFields = {
  __typename?: 'EventPoolRoundsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  poolId?: Maybe<Scalars['uuid']>;
  roundOrder?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_pool_rounds" */
export type EventPoolRoundsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  roundOrder?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventPoolRoundsMinFields = {
  __typename?: 'EventPoolRoundsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  poolId?: Maybe<Scalars['uuid']>;
  roundOrder?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_pool_rounds" */
export type EventPoolRoundsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  roundOrder?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_pool_rounds" */
export type EventPoolRoundsMutationResponse = {
  __typename?: 'EventPoolRoundsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventPoolRounds>;
};

/** input type for inserting object relation for remote table "event_pool_rounds" */
export type EventPoolRoundsObjRelInsertInput = {
  data: EventPoolRoundsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventPoolRoundsOnConflict>;
};

/** on_conflict condition type for table "event_pool_rounds" */
export type EventPoolRoundsOnConflict = {
  constraint: EventPoolRoundsConstraint;
  updateColumns?: Array<EventPoolRoundsUpdateColumn>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};

/** Ordering options when selecting data from "event_pool_rounds". */
export type EventPoolRoundsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  pool?: InputMaybe<EventGroupPoolsOrderBy>;
  poolId?: InputMaybe<OrderBy>;
  roundOrder?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_pool_rounds */
export type EventPoolRoundsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_pool_rounds" */
export enum EventPoolRoundsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  RoundOrder = 'roundOrder',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_pool_rounds" */
export type EventPoolRoundsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  roundOrder?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventPoolRoundsStddevFields = {
  __typename?: 'EventPoolRoundsStddevFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_pool_rounds" */
export type EventPoolRoundsStddevOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventPoolRoundsStddevPopFields = {
  __typename?: 'EventPoolRoundsStddevPopFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_pool_rounds" */
export type EventPoolRoundsStddevPopOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventPoolRoundsStddevSampFields = {
  __typename?: 'EventPoolRoundsStddevSampFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_pool_rounds" */
export type EventPoolRoundsStddevSampOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_pool_rounds" */
export type EventPoolRoundsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventPoolRoundsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventPoolRoundsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  roundOrder?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventPoolRoundsSumFields = {
  __typename?: 'EventPoolRoundsSumFields';
  roundOrder?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_pool_rounds" */
export type EventPoolRoundsSumOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** update columns of table "event_pool_rounds" */
export enum EventPoolRoundsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  RoundOrder = 'roundOrder',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventPoolRoundsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventPoolRoundsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventPoolRoundsSetInput>;
  /** filter the rows which have to be updated */
  where: EventPoolRoundsBoolExp;
};

/** aggregate varPop on columns */
export type EventPoolRoundsVarPopFields = {
  __typename?: 'EventPoolRoundsVarPopFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_pool_rounds" */
export type EventPoolRoundsVarPopOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventPoolRoundsVarSampFields = {
  __typename?: 'EventPoolRoundsVarSampFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_pool_rounds" */
export type EventPoolRoundsVarSampOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventPoolRoundsVarianceFields = {
  __typename?: 'EventPoolRoundsVarianceFields';
  roundOrder?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_pool_rounds" */
export type EventPoolRoundsVarianceOrderBy = {
  roundOrder?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_pools_teams" */
export type EventPoolsTeams = {
  __typename?: 'EventPoolsTeams';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  pool: EventGroupPools;
  poolId: Scalars['uuid'];
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_pools_teams" */
export type EventPoolsTeamsAggregate = {
  __typename?: 'EventPoolsTeamsAggregate';
  aggregate?: Maybe<EventPoolsTeamsAggregateFields>;
  nodes: Array<EventPoolsTeams>;
};

export type EventPoolsTeamsAggregateBoolExp = {
  count?: InputMaybe<EventPoolsTeamsAggregateBoolExpCount>;
};

/** aggregate fields of "event_pools_teams" */
export type EventPoolsTeamsAggregateFields = {
  __typename?: 'EventPoolsTeamsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventPoolsTeamsMaxFields>;
  min?: Maybe<EventPoolsTeamsMinFields>;
};


/** aggregate fields of "event_pools_teams" */
export type EventPoolsTeamsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_pools_teams" */
export type EventPoolsTeamsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventPoolsTeamsMaxOrderBy>;
  min?: InputMaybe<EventPoolsTeamsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_pools_teams" */
export type EventPoolsTeamsArrRelInsertInput = {
  data: Array<EventPoolsTeamsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventPoolsTeamsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_pools_teams". All fields are combined with a logical 'AND'. */
export type EventPoolsTeamsBoolExp = {
  _and?: InputMaybe<Array<EventPoolsTeamsBoolExp>>;
  _not?: InputMaybe<EventPoolsTeamsBoolExp>;
  _or?: InputMaybe<Array<EventPoolsTeamsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  pool?: InputMaybe<EventGroupPoolsBoolExp>;
  poolId?: InputMaybe<UuidComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_pools_teams" */
export enum EventPoolsTeamsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventPoolsTeamsPkey = 'event_pools_teams_pkey',
  /** unique or primary key constraint on columns "pool_id", "team_id" */
  EventPoolsTeamsPoolIdTeamIdKey = 'event_pools_teams_pool_id_team_id_key'
}

/** input type for inserting data into table "event_pools_teams" */
export type EventPoolsTeamsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pool?: InputMaybe<EventGroupPoolsObjRelInsertInput>;
  poolId?: InputMaybe<Scalars['uuid']>;
  team?: InputMaybe<EventTeamsObjRelInsertInput>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventPoolsTeamsMaxFields = {
  __typename?: 'EventPoolsTeamsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  poolId?: Maybe<Scalars['uuid']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_pools_teams" */
export type EventPoolsTeamsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventPoolsTeamsMinFields = {
  __typename?: 'EventPoolsTeamsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  poolId?: Maybe<Scalars['uuid']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_pools_teams" */
export type EventPoolsTeamsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  poolId?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_pools_teams" */
export type EventPoolsTeamsMutationResponse = {
  __typename?: 'EventPoolsTeamsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventPoolsTeams>;
};

/** on_conflict condition type for table "event_pools_teams" */
export type EventPoolsTeamsOnConflict = {
  constraint: EventPoolsTeamsConstraint;
  updateColumns?: Array<EventPoolsTeamsUpdateColumn>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};

/** Ordering options when selecting data from "event_pools_teams". */
export type EventPoolsTeamsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  pool?: InputMaybe<EventGroupPoolsOrderBy>;
  poolId?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_pools_teams */
export type EventPoolsTeamsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_pools_teams" */
export enum EventPoolsTeamsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_pools_teams" */
export type EventPoolsTeamsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_pools_teams" */
export type EventPoolsTeamsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventPoolsTeamsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventPoolsTeamsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  poolId?: InputMaybe<Scalars['uuid']>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_pools_teams" */
export enum EventPoolsTeamsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PoolId = 'poolId',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventPoolsTeamsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventPoolsTeamsSetInput>;
  /** filter the rows which have to be updated */
  where: EventPoolsTeamsBoolExp;
};

/** columns and relationships of "event_privacy" */
export type EventPrivacy = {
  __typename?: 'EventPrivacy';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_privacy" */
export type EventPrivacyAggregate = {
  __typename?: 'EventPrivacyAggregate';
  aggregate?: Maybe<EventPrivacyAggregateFields>;
  nodes: Array<EventPrivacy>;
};

/** aggregate fields of "event_privacy" */
export type EventPrivacyAggregateFields = {
  __typename?: 'EventPrivacyAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventPrivacyMaxFields>;
  min?: Maybe<EventPrivacyMinFields>;
};


/** aggregate fields of "event_privacy" */
export type EventPrivacyAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventPrivacySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_privacy". All fields are combined with a logical 'AND'. */
export type EventPrivacyBoolExp = {
  _and?: InputMaybe<Array<EventPrivacyBoolExp>>;
  _not?: InputMaybe<EventPrivacyBoolExp>;
  _or?: InputMaybe<Array<EventPrivacyBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_privacy" */
export enum EventPrivacyConstraint {
  /** unique or primary key constraint on columns "value" */
  EventPrivacyPkey = 'event_privacy_pkey'
}

export enum EventPrivacyEnum {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Unlisted = 'UNLISTED'
}

/** Boolean expression to compare columns of type "EventPrivacyEnum". All fields are combined with logical 'AND'. */
export type EventPrivacyEnumComparisonExp = {
  _eq?: InputMaybe<EventPrivacyEnum>;
  _in?: InputMaybe<Array<EventPrivacyEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventPrivacyEnum>;
  _nin?: InputMaybe<Array<EventPrivacyEnum>>;
};

/** input type for inserting data into table "event_privacy" */
export type EventPrivacyInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventPrivacyMaxFields = {
  __typename?: 'EventPrivacyMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventPrivacyMinFields = {
  __typename?: 'EventPrivacyMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_privacy" */
export type EventPrivacyMutationResponse = {
  __typename?: 'EventPrivacyMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventPrivacy>;
};

/** on_conflict condition type for table "event_privacy" */
export type EventPrivacyOnConflict = {
  constraint: EventPrivacyConstraint;
  updateColumns?: Array<EventPrivacyUpdateColumn>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};

/** Ordering options when selecting data from "event_privacy". */
export type EventPrivacyOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_privacy */
export type EventPrivacyPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_privacy" */
export enum EventPrivacySelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_privacy" */
export type EventPrivacySetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_privacy" */
export type EventPrivacyStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventPrivacyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventPrivacyStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_privacy" */
export enum EventPrivacyUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventPrivacyUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventPrivacySetInput>;
  /** filter the rows which have to be updated */
  where: EventPrivacyBoolExp;
};

/** columns and relationships of "event_registration_details" */
export type EventRegistrationDetails = {
  __typename?: 'EventRegistrationDetails';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventRegistrationId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  registration: EventRegistrations;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_registration_details" */
export type EventRegistrationDetailsAggregate = {
  __typename?: 'EventRegistrationDetailsAggregate';
  aggregate?: Maybe<EventRegistrationDetailsAggregateFields>;
  nodes: Array<EventRegistrationDetails>;
};

/** aggregate fields of "event_registration_details" */
export type EventRegistrationDetailsAggregateFields = {
  __typename?: 'EventRegistrationDetailsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventRegistrationDetailsMaxFields>;
  min?: Maybe<EventRegistrationDetailsMinFields>;
};


/** aggregate fields of "event_registration_details" */
export type EventRegistrationDetailsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_registration_details". All fields are combined with a logical 'AND'. */
export type EventRegistrationDetailsBoolExp = {
  _and?: InputMaybe<Array<EventRegistrationDetailsBoolExp>>;
  _not?: InputMaybe<EventRegistrationDetailsBoolExp>;
  _or?: InputMaybe<Array<EventRegistrationDetailsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  duprId?: InputMaybe<StringComparisonExp>;
  eventRegistrationId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  registration?: InputMaybe<EventRegistrationsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_registration_details" */
export enum EventRegistrationDetailsConstraint {
  /** unique or primary key constraint on columns "event_registration_id" */
  EventRegistrationDetailsEventRegistrationIdKey = 'event_registration_details_event_registration_id_key',
  /** unique or primary key constraint on columns "id" */
  EventRegistrationDetailsPkey = 'event_registration_details_pkey'
}

/** input type for inserting data into table "event_registration_details" */
export type EventRegistrationDetailsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  registration?: InputMaybe<EventRegistrationsObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventRegistrationDetailsMaxFields = {
  __typename?: 'EventRegistrationDetailsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventRegistrationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type EventRegistrationDetailsMinFields = {
  __typename?: 'EventRegistrationDetailsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventRegistrationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "event_registration_details" */
export type EventRegistrationDetailsMutationResponse = {
  __typename?: 'EventRegistrationDetailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventRegistrationDetails>;
};

/** input type for inserting object relation for remote table "event_registration_details" */
export type EventRegistrationDetailsObjRelInsertInput = {
  data: EventRegistrationDetailsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventRegistrationDetailsOnConflict>;
};

/** on_conflict condition type for table "event_registration_details" */
export type EventRegistrationDetailsOnConflict = {
  constraint: EventRegistrationDetailsConstraint;
  updateColumns?: Array<EventRegistrationDetailsUpdateColumn>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};

/** Ordering options when selecting data from "event_registration_details". */
export type EventRegistrationDetailsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  duprId?: InputMaybe<OrderBy>;
  eventRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  registration?: InputMaybe<EventRegistrationsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_registration_details */
export type EventRegistrationDetailsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_registration_details" */
export enum EventRegistrationDetailsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  EventRegistrationId = 'eventRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_registration_details" */
export type EventRegistrationDetailsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_registration_details" */
export type EventRegistrationDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventRegistrationDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventRegistrationDetailsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_registration_details" */
export enum EventRegistrationDetailsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  EventRegistrationId = 'eventRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventRegistrationDetailsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventRegistrationDetailsSetInput>;
  /** filter the rows which have to be updated */
  where: EventRegistrationDetailsBoolExp;
};

/** columns and relationships of "event_registrations" */
export type EventRegistrations = {
  __typename?: 'EventRegistrations';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  registrationDetails?: Maybe<EventRegistrationDetails>;
  /** An array relationship */
  transactionItems: Array<EventTransactionItems>;
  /** An aggregate relationship */
  transactionItemsAggregate: EventTransactionItemsAggregate;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "event_registrations" */
export type EventRegistrationsTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


/** columns and relationships of "event_registrations" */
export type EventRegistrationsTransactionItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** aggregated selection of "event_registrations" */
export type EventRegistrationsAggregate = {
  __typename?: 'EventRegistrationsAggregate';
  aggregate?: Maybe<EventRegistrationsAggregateFields>;
  nodes: Array<EventRegistrations>;
};

export type EventRegistrationsAggregateBoolExp = {
  count?: InputMaybe<EventRegistrationsAggregateBoolExpCount>;
};

/** aggregate fields of "event_registrations" */
export type EventRegistrationsAggregateFields = {
  __typename?: 'EventRegistrationsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventRegistrationsMaxFields>;
  min?: Maybe<EventRegistrationsMinFields>;
};


/** aggregate fields of "event_registrations" */
export type EventRegistrationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_registrations" */
export type EventRegistrationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventRegistrationsMaxOrderBy>;
  min?: InputMaybe<EventRegistrationsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_registrations" */
export type EventRegistrationsArrRelInsertInput = {
  data: Array<EventRegistrationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventRegistrationsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_registrations". All fields are combined with a logical 'AND'. */
export type EventRegistrationsBoolExp = {
  _and?: InputMaybe<Array<EventRegistrationsBoolExp>>;
  _not?: InputMaybe<EventRegistrationsBoolExp>;
  _or?: InputMaybe<Array<EventRegistrationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  registrationDetails?: InputMaybe<EventRegistrationDetailsBoolExp>;
  transactionItems?: InputMaybe<EventTransactionItemsBoolExp>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "event_registrations" */
export enum EventRegistrationsConstraint {
  /** unique or primary key constraint on columns "user_id", "event_id" */
  EventRegistrationsEventIdUserIdKey = 'event_registrations_event_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  EventRegistrationsPkey = 'event_registrations_pkey'
}

/** input type for inserting data into table "event_registrations" */
export type EventRegistrationsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  registrationDetails?: InputMaybe<EventRegistrationDetailsObjRelInsertInput>;
  transactionItems?: InputMaybe<EventTransactionItemsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type EventRegistrationsMaxFields = {
  __typename?: 'EventRegistrationsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_registrations" */
export type EventRegistrationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventRegistrationsMinFields = {
  __typename?: 'EventRegistrationsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_registrations" */
export type EventRegistrationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_registrations" */
export type EventRegistrationsMutationResponse = {
  __typename?: 'EventRegistrationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventRegistrations>;
};

/** input type for inserting object relation for remote table "event_registrations" */
export type EventRegistrationsObjRelInsertInput = {
  data: EventRegistrationsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventRegistrationsOnConflict>;
};

/** on_conflict condition type for table "event_registrations" */
export type EventRegistrationsOnConflict = {
  constraint: EventRegistrationsConstraint;
  updateColumns?: Array<EventRegistrationsUpdateColumn>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};

/** Ordering options when selecting data from "event_registrations". */
export type EventRegistrationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  registrationDetails?: InputMaybe<EventRegistrationDetailsOrderBy>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: event_registrations */
export type EventRegistrationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_registrations" */
export enum EventRegistrationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "event_registrations" */
export type EventRegistrationsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "event_registrations" */
export type EventRegistrationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventRegistrationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventRegistrationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "event_registrations" */
export enum EventRegistrationsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type EventRegistrationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventRegistrationsSetInput>;
  /** filter the rows which have to be updated */
  where: EventRegistrationsBoolExp;
};

/** columns and relationships of "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasons = {
  __typename?: 'EventSequenceCompleteReasons';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsAggregate = {
  __typename?: 'EventSequenceCompleteReasonsAggregate';
  aggregate?: Maybe<EventSequenceCompleteReasonsAggregateFields>;
  nodes: Array<EventSequenceCompleteReasons>;
};

/** aggregate fields of "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsAggregateFields = {
  __typename?: 'EventSequenceCompleteReasonsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventSequenceCompleteReasonsMaxFields>;
  min?: Maybe<EventSequenceCompleteReasonsMinFields>;
};


/** aggregate fields of "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_sequence_complete_reasons". All fields are combined with a logical 'AND'. */
export type EventSequenceCompleteReasonsBoolExp = {
  _and?: InputMaybe<Array<EventSequenceCompleteReasonsBoolExp>>;
  _not?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
  _or?: InputMaybe<Array<EventSequenceCompleteReasonsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_sequence_complete_reasons" */
export enum EventSequenceCompleteReasonsConstraint {
  /** unique or primary key constraint on columns "value" */
  EventSequenceCompleteReasonsPkey = 'event_sequence_complete_reasons_pkey'
}

export enum EventSequenceCompleteReasonsEnum {
  AllScores = 'ALL_SCORES',
  OrganizerSelected = 'ORGANIZER_SELECTED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventSequenceCompleteReasonsEnum". All fields are combined with logical 'AND'. */
export type EventSequenceCompleteReasonsEnumComparisonExp = {
  _eq?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  _in?: InputMaybe<Array<EventSequenceCompleteReasonsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventSequenceCompleteReasonsEnum>;
  _nin?: InputMaybe<Array<EventSequenceCompleteReasonsEnum>>;
};

/** input type for inserting data into table "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventSequenceCompleteReasonsMaxFields = {
  __typename?: 'EventSequenceCompleteReasonsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventSequenceCompleteReasonsMinFields = {
  __typename?: 'EventSequenceCompleteReasonsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsMutationResponse = {
  __typename?: 'EventSequenceCompleteReasonsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventSequenceCompleteReasons>;
};

/** on_conflict condition type for table "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsOnConflict = {
  constraint: EventSequenceCompleteReasonsConstraint;
  updateColumns?: Array<EventSequenceCompleteReasonsUpdateColumn>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};

/** Ordering options when selecting data from "event_sequence_complete_reasons". */
export type EventSequenceCompleteReasonsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_sequence_complete_reasons */
export type EventSequenceCompleteReasonsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_sequence_complete_reasons" */
export enum EventSequenceCompleteReasonsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_sequence_complete_reasons" */
export type EventSequenceCompleteReasonsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventSequenceCompleteReasonsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventSequenceCompleteReasonsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_sequence_complete_reasons" */
export enum EventSequenceCompleteReasonsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventSequenceCompleteReasonsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventSequenceCompleteReasonsSetInput>;
  /** filter the rows which have to be updated */
  where: EventSequenceCompleteReasonsBoolExp;
};

/** columns and relationships of "event_sponsors" */
export type EventSponsors = {
  __typename?: 'EventSponsors';
  categoryName: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  id: Scalars['uuid'];
  imageFileName: Scalars['String'];
  imageFileType: Scalars['String'];
  imageHost: Scalars['String'];
  imagePath: Scalars['String'];
  imageProvider: Scalars['String'];
  imageProviderUrl: Scalars['String'];
  imageUrl: Scalars['String'];
  isTitleSponsor: Scalars['Boolean'];
  name: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_sponsors" */
export type EventSponsorsAggregate = {
  __typename?: 'EventSponsorsAggregate';
  aggregate?: Maybe<EventSponsorsAggregateFields>;
  nodes: Array<EventSponsors>;
};

export type EventSponsorsAggregateBoolExp = {
  bool_and?: InputMaybe<EventSponsorsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<EventSponsorsAggregateBoolExpBool_Or>;
  count?: InputMaybe<EventSponsorsAggregateBoolExpCount>;
};

/** aggregate fields of "event_sponsors" */
export type EventSponsorsAggregateFields = {
  __typename?: 'EventSponsorsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventSponsorsMaxFields>;
  min?: Maybe<EventSponsorsMinFields>;
};


/** aggregate fields of "event_sponsors" */
export type EventSponsorsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_sponsors" */
export type EventSponsorsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventSponsorsMaxOrderBy>;
  min?: InputMaybe<EventSponsorsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_sponsors" */
export type EventSponsorsArrRelInsertInput = {
  data: Array<EventSponsorsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventSponsorsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_sponsors". All fields are combined with a logical 'AND'. */
export type EventSponsorsBoolExp = {
  _and?: InputMaybe<Array<EventSponsorsBoolExp>>;
  _not?: InputMaybe<EventSponsorsBoolExp>;
  _or?: InputMaybe<Array<EventSponsorsBoolExp>>;
  categoryName?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  imageFileName?: InputMaybe<StringComparisonExp>;
  imageFileType?: InputMaybe<StringComparisonExp>;
  imageHost?: InputMaybe<StringComparisonExp>;
  imagePath?: InputMaybe<StringComparisonExp>;
  imageProvider?: InputMaybe<StringComparisonExp>;
  imageProviderUrl?: InputMaybe<StringComparisonExp>;
  imageUrl?: InputMaybe<StringComparisonExp>;
  isTitleSponsor?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_sponsors" */
export enum EventSponsorsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventSponsorsPkey = 'event_sponsors_pkey'
}

/** input type for inserting data into table "event_sponsors" */
export type EventSponsorsInsertInput = {
  categoryName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  imageFileName?: InputMaybe<Scalars['String']>;
  imageFileType?: InputMaybe<Scalars['String']>;
  imageHost?: InputMaybe<Scalars['String']>;
  imagePath?: InputMaybe<Scalars['String']>;
  imageProvider?: InputMaybe<Scalars['String']>;
  imageProviderUrl?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  isTitleSponsor?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventSponsorsMaxFields = {
  __typename?: 'EventSponsorsMaxFields';
  categoryName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  imageFileName?: Maybe<Scalars['String']>;
  imageFileType?: Maybe<Scalars['String']>;
  imageHost?: Maybe<Scalars['String']>;
  imagePath?: Maybe<Scalars['String']>;
  imageProvider?: Maybe<Scalars['String']>;
  imageProviderUrl?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_sponsors" */
export type EventSponsorsMaxOrderBy = {
  categoryName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageFileName?: InputMaybe<OrderBy>;
  imageFileType?: InputMaybe<OrderBy>;
  imageHost?: InputMaybe<OrderBy>;
  imagePath?: InputMaybe<OrderBy>;
  imageProvider?: InputMaybe<OrderBy>;
  imageProviderUrl?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventSponsorsMinFields = {
  __typename?: 'EventSponsorsMinFields';
  categoryName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  imageFileName?: Maybe<Scalars['String']>;
  imageFileType?: Maybe<Scalars['String']>;
  imageHost?: Maybe<Scalars['String']>;
  imagePath?: Maybe<Scalars['String']>;
  imageProvider?: Maybe<Scalars['String']>;
  imageProviderUrl?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_sponsors" */
export type EventSponsorsMinOrderBy = {
  categoryName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageFileName?: InputMaybe<OrderBy>;
  imageFileType?: InputMaybe<OrderBy>;
  imageHost?: InputMaybe<OrderBy>;
  imagePath?: InputMaybe<OrderBy>;
  imageProvider?: InputMaybe<OrderBy>;
  imageProviderUrl?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_sponsors" */
export type EventSponsorsMutationResponse = {
  __typename?: 'EventSponsorsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventSponsors>;
};

/** on_conflict condition type for table "event_sponsors" */
export type EventSponsorsOnConflict = {
  constraint: EventSponsorsConstraint;
  updateColumns?: Array<EventSponsorsUpdateColumn>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};

/** Ordering options when selecting data from "event_sponsors". */
export type EventSponsorsOrderBy = {
  categoryName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageFileName?: InputMaybe<OrderBy>;
  imageFileType?: InputMaybe<OrderBy>;
  imageHost?: InputMaybe<OrderBy>;
  imagePath?: InputMaybe<OrderBy>;
  imageProvider?: InputMaybe<OrderBy>;
  imageProviderUrl?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  isTitleSponsor?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_sponsors */
export type EventSponsorsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_sponsors" */
export enum EventSponsorsSelectColumn {
  /** column name */
  CategoryName = 'categoryName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  ImageFileName = 'imageFileName',
  /** column name */
  ImageFileType = 'imageFileType',
  /** column name */
  ImageHost = 'imageHost',
  /** column name */
  ImagePath = 'imagePath',
  /** column name */
  ImageProvider = 'imageProvider',
  /** column name */
  ImageProviderUrl = 'imageProviderUrl',
  /** column name */
  ImageUrl = 'imageUrl',
  /** column name */
  IsTitleSponsor = 'isTitleSponsor',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "eventSponsorsAggregateBoolExpBool_andArgumentsColumns" columns of table "event_sponsors" */
export enum EventSponsorsSelectColumnEventSponsorsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsTitleSponsor = 'isTitleSponsor'
}

/** select "eventSponsorsAggregateBoolExpBool_orArgumentsColumns" columns of table "event_sponsors" */
export enum EventSponsorsSelectColumnEventSponsorsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsTitleSponsor = 'isTitleSponsor'
}

/** input type for updating data in table "event_sponsors" */
export type EventSponsorsSetInput = {
  categoryName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  imageFileName?: InputMaybe<Scalars['String']>;
  imageFileType?: InputMaybe<Scalars['String']>;
  imageHost?: InputMaybe<Scalars['String']>;
  imagePath?: InputMaybe<Scalars['String']>;
  imageProvider?: InputMaybe<Scalars['String']>;
  imageProviderUrl?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  isTitleSponsor?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_sponsors" */
export type EventSponsorsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventSponsorsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventSponsorsStreamCursorValueInput = {
  categoryName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  imageFileName?: InputMaybe<Scalars['String']>;
  imageFileType?: InputMaybe<Scalars['String']>;
  imageHost?: InputMaybe<Scalars['String']>;
  imagePath?: InputMaybe<Scalars['String']>;
  imageProvider?: InputMaybe<Scalars['String']>;
  imageProviderUrl?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  isTitleSponsor?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_sponsors" */
export enum EventSponsorsUpdateColumn {
  /** column name */
  CategoryName = 'categoryName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  ImageFileName = 'imageFileName',
  /** column name */
  ImageFileType = 'imageFileType',
  /** column name */
  ImageHost = 'imageHost',
  /** column name */
  ImagePath = 'imagePath',
  /** column name */
  ImageProvider = 'imageProvider',
  /** column name */
  ImageProviderUrl = 'imageProviderUrl',
  /** column name */
  ImageUrl = 'imageUrl',
  /** column name */
  IsTitleSponsor = 'isTitleSponsor',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventSponsorsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventSponsorsSetInput>;
  /** filter the rows which have to be updated */
  where: EventSponsorsBoolExp;
};

/** columns and relationships of "event_statuses" */
export type EventStatuses = {
  __typename?: 'EventStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_statuses" */
export type EventStatusesAggregate = {
  __typename?: 'EventStatusesAggregate';
  aggregate?: Maybe<EventStatusesAggregateFields>;
  nodes: Array<EventStatuses>;
};

/** aggregate fields of "event_statuses" */
export type EventStatusesAggregateFields = {
  __typename?: 'EventStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventStatusesMaxFields>;
  min?: Maybe<EventStatusesMinFields>;
};


/** aggregate fields of "event_statuses" */
export type EventStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_statuses". All fields are combined with a logical 'AND'. */
export type EventStatusesBoolExp = {
  _and?: InputMaybe<Array<EventStatusesBoolExp>>;
  _not?: InputMaybe<EventStatusesBoolExp>;
  _or?: InputMaybe<Array<EventStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_statuses" */
export enum EventStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventStatusesPkey = 'event_statuses_pkey'
}

export enum EventStatusesEnum {
  Canceled = 'CANCELED',
  Draft = 'DRAFT',
  Published = 'PUBLISHED'
}

/** Boolean expression to compare columns of type "EventStatusesEnum". All fields are combined with logical 'AND'. */
export type EventStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventStatusesEnum>;
  _in?: InputMaybe<Array<EventStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventStatusesEnum>;
  _nin?: InputMaybe<Array<EventStatusesEnum>>;
};

/** input type for inserting data into table "event_statuses" */
export type EventStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventStatusesMaxFields = {
  __typename?: 'EventStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventStatusesMinFields = {
  __typename?: 'EventStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_statuses" */
export type EventStatusesMutationResponse = {
  __typename?: 'EventStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventStatuses>;
};

/** on_conflict condition type for table "event_statuses" */
export type EventStatusesOnConflict = {
  constraint: EventStatusesConstraint;
  updateColumns?: Array<EventStatusesUpdateColumn>;
  where?: InputMaybe<EventStatusesBoolExp>;
};

/** Ordering options when selecting data from "event_statuses". */
export type EventStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_statuses */
export type EventStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_statuses" */
export enum EventStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_statuses" */
export type EventStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_statuses" */
export type EventStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_statuses" */
export enum EventStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: EventStatusesBoolExp;
};

/** columns and relationships of "event_team_member_statuses" */
export type EventTeamMemberStatuses = {
  __typename?: 'EventTeamMemberStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_team_member_statuses" */
export type EventTeamMemberStatusesAggregate = {
  __typename?: 'EventTeamMemberStatusesAggregate';
  aggregate?: Maybe<EventTeamMemberStatusesAggregateFields>;
  nodes: Array<EventTeamMemberStatuses>;
};

/** aggregate fields of "event_team_member_statuses" */
export type EventTeamMemberStatusesAggregateFields = {
  __typename?: 'EventTeamMemberStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventTeamMemberStatusesMaxFields>;
  min?: Maybe<EventTeamMemberStatusesMinFields>;
};


/** aggregate fields of "event_team_member_statuses" */
export type EventTeamMemberStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_team_member_statuses". All fields are combined with a logical 'AND'. */
export type EventTeamMemberStatusesBoolExp = {
  _and?: InputMaybe<Array<EventTeamMemberStatusesBoolExp>>;
  _not?: InputMaybe<EventTeamMemberStatusesBoolExp>;
  _or?: InputMaybe<Array<EventTeamMemberStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_team_member_statuses" */
export enum EventTeamMemberStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventTeamMemberStatusesPkey = 'event_team_member_statuses_pkey'
}

export enum EventTeamMemberStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "EventTeamMemberStatusesEnum". All fields are combined with logical 'AND'. */
export type EventTeamMemberStatusesEnumComparisonExp = {
  _eq?: InputMaybe<EventTeamMemberStatusesEnum>;
  _in?: InputMaybe<Array<EventTeamMemberStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventTeamMemberStatusesEnum>;
  _nin?: InputMaybe<Array<EventTeamMemberStatusesEnum>>;
};

/** input type for inserting data into table "event_team_member_statuses" */
export type EventTeamMemberStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventTeamMemberStatusesMaxFields = {
  __typename?: 'EventTeamMemberStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventTeamMemberStatusesMinFields = {
  __typename?: 'EventTeamMemberStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_team_member_statuses" */
export type EventTeamMemberStatusesMutationResponse = {
  __typename?: 'EventTeamMemberStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTeamMemberStatuses>;
};

/** on_conflict condition type for table "event_team_member_statuses" */
export type EventTeamMemberStatusesOnConflict = {
  constraint: EventTeamMemberStatusesConstraint;
  updateColumns?: Array<EventTeamMemberStatusesUpdateColumn>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};

/** Ordering options when selecting data from "event_team_member_statuses". */
export type EventTeamMemberStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_team_member_statuses */
export type EventTeamMemberStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_team_member_statuses" */
export enum EventTeamMemberStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_team_member_statuses" */
export type EventTeamMemberStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_team_member_statuses" */
export type EventTeamMemberStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTeamMemberStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTeamMemberStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_team_member_statuses" */
export enum EventTeamMemberStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventTeamMemberStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTeamMemberStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: EventTeamMemberStatusesBoolExp;
};

/** columns and relationships of "event_team_members" */
export type EventTeamMembers = {
  __typename?: 'EventTeamMembers';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  status: EventTeamMemberStatusesEnum;
  /** An object relationship */
  team: EventTeams;
  teamId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "event_team_members" */
export type EventTeamMembersAggregate = {
  __typename?: 'EventTeamMembersAggregate';
  aggregate?: Maybe<EventTeamMembersAggregateFields>;
  nodes: Array<EventTeamMembers>;
};

export type EventTeamMembersAggregateBoolExp = {
  count?: InputMaybe<EventTeamMembersAggregateBoolExpCount>;
};

/** aggregate fields of "event_team_members" */
export type EventTeamMembersAggregateFields = {
  __typename?: 'EventTeamMembersAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventTeamMembersMaxFields>;
  min?: Maybe<EventTeamMembersMinFields>;
};


/** aggregate fields of "event_team_members" */
export type EventTeamMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_team_members" */
export type EventTeamMembersAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTeamMembersMaxOrderBy>;
  min?: InputMaybe<EventTeamMembersMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_team_members" */
export type EventTeamMembersArrRelInsertInput = {
  data: Array<EventTeamMembersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventTeamMembersOnConflict>;
};

/** Boolean expression to filter rows from the table "event_team_members". All fields are combined with a logical 'AND'. */
export type EventTeamMembersBoolExp = {
  _and?: InputMaybe<Array<EventTeamMembersBoolExp>>;
  _not?: InputMaybe<EventTeamMembersBoolExp>;
  _or?: InputMaybe<Array<EventTeamMembersBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<EventTeamMemberStatusesEnumComparisonExp>;
  team?: InputMaybe<EventTeamsBoolExp>;
  teamId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "event_team_members" */
export enum EventTeamMembersConstraint {
  /** unique or primary key constraint on columns "id" */
  EventTeamMembersPkey = 'event_team_members_pkey',
  /** unique or primary key constraint on columns "user_id", "team_id" */
  EventTeamMembersTeamIdUserIdKey = 'event_team_members_team_id_user_id_key'
}

/** input type for inserting data into table "event_team_members" */
export type EventTeamMembersInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventTeamMemberStatusesEnum>;
  team?: InputMaybe<EventTeamsObjRelInsertInput>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type EventTeamMembersMaxFields = {
  __typename?: 'EventTeamMembersMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_team_members" */
export type EventTeamMembersMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventTeamMembersMinFields = {
  __typename?: 'EventTeamMembersMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  teamId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_team_members" */
export type EventTeamMembersMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_team_members" */
export type EventTeamMembersMutationResponse = {
  __typename?: 'EventTeamMembersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTeamMembers>;
};

/** on_conflict condition type for table "event_team_members" */
export type EventTeamMembersOnConflict = {
  constraint: EventTeamMembersConstraint;
  updateColumns?: Array<EventTeamMembersUpdateColumn>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};

/** Ordering options when selecting data from "event_team_members". */
export type EventTeamMembersOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  team?: InputMaybe<EventTeamsOrderBy>;
  teamId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: event_team_members */
export type EventTeamMembersPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_team_members" */
export enum EventTeamMembersSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "event_team_members" */
export type EventTeamMembersSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventTeamMemberStatusesEnum>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "event_team_members" */
export type EventTeamMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTeamMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTeamMembersStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<EventTeamMemberStatusesEnum>;
  teamId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "event_team_members" */
export enum EventTeamMembersUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'teamId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type EventTeamMembersUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTeamMembersSetInput>;
  /** filter the rows which have to be updated */
  where: EventTeamMembersBoolExp;
};

/** columns and relationships of "event_teams" */
export type EventTeams = {
  __typename?: 'EventTeams';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  gamesWon: Array<EventMatchGames>;
  /** An aggregate relationship */
  gamesWonAggregate: EventMatchGamesAggregate;
  /** An object relationship */
  group: EventGroups;
  groupId: Scalars['uuid'];
  /** An array relationship */
  groupRegistrations: Array<EventGroupRegistrations>;
  /** An aggregate relationship */
  groupRegistrationsAggregate: EventGroupRegistrationsAggregate;
  id: Scalars['uuid'];
  /** An array relationship */
  matches: Array<EventMatchesTeams>;
  /** An aggregate relationship */
  matchesAggregate: EventMatchesTeamsAggregate;
  /** An array relationship */
  matchesLost: Array<EventMatches>;
  /** An aggregate relationship */
  matchesLostAggregate: EventMatchesAggregate;
  /** An array relationship */
  matchesWon: Array<EventMatches>;
  /** An aggregate relationship */
  matchesWonAggregate: EventMatchesAggregate;
  /** An array relationship */
  members: Array<EventTeamMembers>;
  /** An aggregate relationship */
  membersAggregate: EventTeamMembersAggregate;
  /** An array relationship */
  pools: Array<EventPoolsTeams>;
  /** An aggregate relationship */
  poolsAggregate: EventPoolsTeamsAggregate;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "event_teams" */
export type EventTeamsGamesWonArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsGamesWonAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsGroupRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsGroupRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesLostArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesLostAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesWonArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMatchesWonAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMembersArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


/** columns and relationships of "event_teams" */
export type EventTeamsPoolsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};

/** aggregated selection of "event_teams" */
export type EventTeamsAggregate = {
  __typename?: 'EventTeamsAggregate';
  aggregate?: Maybe<EventTeamsAggregateFields>;
  nodes: Array<EventTeams>;
};

export type EventTeamsAggregateBoolExp = {
  count?: InputMaybe<EventTeamsAggregateBoolExpCount>;
};

/** aggregate fields of "event_teams" */
export type EventTeamsAggregateFields = {
  __typename?: 'EventTeamsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventTeamsMaxFields>;
  min?: Maybe<EventTeamsMinFields>;
};


/** aggregate fields of "event_teams" */
export type EventTeamsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTeamsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_teams" */
export type EventTeamsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTeamsMaxOrderBy>;
  min?: InputMaybe<EventTeamsMinOrderBy>;
};

/** input type for inserting array relation for remote table "event_teams" */
export type EventTeamsArrRelInsertInput = {
  data: Array<EventTeamsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventTeamsOnConflict>;
};

/** Boolean expression to filter rows from the table "event_teams". All fields are combined with a logical 'AND'. */
export type EventTeamsBoolExp = {
  _and?: InputMaybe<Array<EventTeamsBoolExp>>;
  _not?: InputMaybe<EventTeamsBoolExp>;
  _or?: InputMaybe<Array<EventTeamsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  gamesWon?: InputMaybe<EventMatchGamesBoolExp>;
  gamesWonAggregate?: InputMaybe<EventMatchGamesAggregateBoolExp>;
  group?: InputMaybe<EventGroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupRegistrations?: InputMaybe<EventGroupRegistrationsBoolExp>;
  groupRegistrationsAggregate?: InputMaybe<EventGroupRegistrationsAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  matches?: InputMaybe<EventMatchesTeamsBoolExp>;
  matchesAggregate?: InputMaybe<EventMatchesTeamsAggregateBoolExp>;
  matchesLost?: InputMaybe<EventMatchesBoolExp>;
  matchesLostAggregate?: InputMaybe<EventMatchesAggregateBoolExp>;
  matchesWon?: InputMaybe<EventMatchesBoolExp>;
  matchesWonAggregate?: InputMaybe<EventMatchesAggregateBoolExp>;
  members?: InputMaybe<EventTeamMembersBoolExp>;
  membersAggregate?: InputMaybe<EventTeamMembersAggregateBoolExp>;
  pools?: InputMaybe<EventPoolsTeamsBoolExp>;
  poolsAggregate?: InputMaybe<EventPoolsTeamsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_teams" */
export enum EventTeamsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventTeamsPkey = 'event_teams_pkey'
}

/** input type for inserting data into table "event_teams" */
export type EventTeamsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  gamesWon?: InputMaybe<EventMatchGamesArrRelInsertInput>;
  group?: InputMaybe<EventGroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupRegistrations?: InputMaybe<EventGroupRegistrationsArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  matches?: InputMaybe<EventMatchesTeamsArrRelInsertInput>;
  matchesLost?: InputMaybe<EventMatchesArrRelInsertInput>;
  matchesWon?: InputMaybe<EventMatchesArrRelInsertInput>;
  members?: InputMaybe<EventTeamMembersArrRelInsertInput>;
  pools?: InputMaybe<EventPoolsTeamsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventTeamsMaxFields = {
  __typename?: 'EventTeamsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_teams" */
export type EventTeamsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventTeamsMinFields = {
  __typename?: 'EventTeamsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_teams" */
export type EventTeamsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_teams" */
export type EventTeamsMutationResponse = {
  __typename?: 'EventTeamsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTeams>;
};

/** input type for inserting object relation for remote table "event_teams" */
export type EventTeamsObjRelInsertInput = {
  data: EventTeamsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventTeamsOnConflict>;
};

/** on_conflict condition type for table "event_teams" */
export type EventTeamsOnConflict = {
  constraint: EventTeamsConstraint;
  updateColumns?: Array<EventTeamsUpdateColumn>;
  where?: InputMaybe<EventTeamsBoolExp>;
};

/** Ordering options when selecting data from "event_teams". */
export type EventTeamsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  gamesWonAggregate?: InputMaybe<EventMatchGamesAggregateOrderBy>;
  group?: InputMaybe<EventGroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupRegistrationsAggregate?: InputMaybe<EventGroupRegistrationsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  matchesAggregate?: InputMaybe<EventMatchesTeamsAggregateOrderBy>;
  matchesLostAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  matchesWonAggregate?: InputMaybe<EventMatchesAggregateOrderBy>;
  membersAggregate?: InputMaybe<EventTeamMembersAggregateOrderBy>;
  poolsAggregate?: InputMaybe<EventPoolsTeamsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_teams */
export type EventTeamsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_teams" */
export enum EventTeamsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_teams" */
export type EventTeamsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "event_teams" */
export type EventTeamsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTeamsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTeamsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "event_teams" */
export enum EventTeamsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventTeamsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTeamsSetInput>;
  /** filter the rows which have to be updated */
  where: EventTeamsBoolExp;
};

/** columns and relationships of "event_transaction_item_types" */
export type EventTransactionItemTypes = {
  __typename?: 'EventTransactionItemTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_transaction_item_types" */
export type EventTransactionItemTypesAggregate = {
  __typename?: 'EventTransactionItemTypesAggregate';
  aggregate?: Maybe<EventTransactionItemTypesAggregateFields>;
  nodes: Array<EventTransactionItemTypes>;
};

/** aggregate fields of "event_transaction_item_types" */
export type EventTransactionItemTypesAggregateFields = {
  __typename?: 'EventTransactionItemTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventTransactionItemTypesMaxFields>;
  min?: Maybe<EventTransactionItemTypesMinFields>;
};


/** aggregate fields of "event_transaction_item_types" */
export type EventTransactionItemTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_transaction_item_types". All fields are combined with a logical 'AND'. */
export type EventTransactionItemTypesBoolExp = {
  _and?: InputMaybe<Array<EventTransactionItemTypesBoolExp>>;
  _not?: InputMaybe<EventTransactionItemTypesBoolExp>;
  _or?: InputMaybe<Array<EventTransactionItemTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_transaction_item_types" */
export enum EventTransactionItemTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventTransactionItemTypesPkey = 'event_transaction_item_types_pkey'
}

export enum EventTransactionItemTypesEnum {
  EventGroupRegistration = 'EVENT_GROUP_REGISTRATION',
  EventRegistration = 'EVENT_REGISTRATION'
}

/** Boolean expression to compare columns of type "EventTransactionItemTypesEnum". All fields are combined with logical 'AND'. */
export type EventTransactionItemTypesEnumComparisonExp = {
  _eq?: InputMaybe<EventTransactionItemTypesEnum>;
  _in?: InputMaybe<Array<EventTransactionItemTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventTransactionItemTypesEnum>;
  _nin?: InputMaybe<Array<EventTransactionItemTypesEnum>>;
};

/** input type for inserting data into table "event_transaction_item_types" */
export type EventTransactionItemTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventTransactionItemTypesMaxFields = {
  __typename?: 'EventTransactionItemTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventTransactionItemTypesMinFields = {
  __typename?: 'EventTransactionItemTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_transaction_item_types" */
export type EventTransactionItemTypesMutationResponse = {
  __typename?: 'EventTransactionItemTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTransactionItemTypes>;
};

/** on_conflict condition type for table "event_transaction_item_types" */
export type EventTransactionItemTypesOnConflict = {
  constraint: EventTransactionItemTypesConstraint;
  updateColumns?: Array<EventTransactionItemTypesUpdateColumn>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};

/** Ordering options when selecting data from "event_transaction_item_types". */
export type EventTransactionItemTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_transaction_item_types */
export type EventTransactionItemTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_transaction_item_types" */
export enum EventTransactionItemTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_transaction_item_types" */
export type EventTransactionItemTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_transaction_item_types" */
export type EventTransactionItemTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTransactionItemTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTransactionItemTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_transaction_item_types" */
export enum EventTransactionItemTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventTransactionItemTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTransactionItemTypesSetInput>;
  /** filter the rows which have to be updated */
  where: EventTransactionItemTypesBoolExp;
};

/** columns and relationships of "event_transaction_items" */
export type EventTransactionItems = {
  __typename?: 'EventTransactionItems';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  groupRegistration?: Maybe<EventGroupRegistrations>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  priceUnitAmount: Scalars['Int'];
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  registration?: Maybe<EventRegistrations>;
  registrationId?: Maybe<Scalars['uuid']>;
  status: OrderStatusesEnum;
  totalUnitAmount: Scalars['Int'];
  /** An object relationship */
  transaction: EventTransactions;
  transactionId: Scalars['uuid'];
  type: EventTransactionItemTypesEnum;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "event_transaction_items" */
export type EventTransactionItemsAggregate = {
  __typename?: 'EventTransactionItemsAggregate';
  aggregate?: Maybe<EventTransactionItemsAggregateFields>;
  nodes: Array<EventTransactionItems>;
};

export type EventTransactionItemsAggregateBoolExp = {
  count?: InputMaybe<EventTransactionItemsAggregateBoolExpCount>;
};

/** aggregate fields of "event_transaction_items" */
export type EventTransactionItemsAggregateFields = {
  __typename?: 'EventTransactionItemsAggregateFields';
  avg?: Maybe<EventTransactionItemsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventTransactionItemsMaxFields>;
  min?: Maybe<EventTransactionItemsMinFields>;
  stddev?: Maybe<EventTransactionItemsStddevFields>;
  stddevPop?: Maybe<EventTransactionItemsStddevPopFields>;
  stddevSamp?: Maybe<EventTransactionItemsStddevSampFields>;
  sum?: Maybe<EventTransactionItemsSumFields>;
  varPop?: Maybe<EventTransactionItemsVarPopFields>;
  varSamp?: Maybe<EventTransactionItemsVarSampFields>;
  variance?: Maybe<EventTransactionItemsVarianceFields>;
};


/** aggregate fields of "event_transaction_items" */
export type EventTransactionItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_transaction_items" */
export type EventTransactionItemsAggregateOrderBy = {
  avg?: InputMaybe<EventTransactionItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTransactionItemsMaxOrderBy>;
  min?: InputMaybe<EventTransactionItemsMinOrderBy>;
  stddev?: InputMaybe<EventTransactionItemsStddevOrderBy>;
  stddevPop?: InputMaybe<EventTransactionItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventTransactionItemsStddevSampOrderBy>;
  sum?: InputMaybe<EventTransactionItemsSumOrderBy>;
  varPop?: InputMaybe<EventTransactionItemsVarPopOrderBy>;
  varSamp?: InputMaybe<EventTransactionItemsVarSampOrderBy>;
  variance?: InputMaybe<EventTransactionItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_transaction_items" */
export type EventTransactionItemsArrRelInsertInput = {
  data: Array<EventTransactionItemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventTransactionItemsOnConflict>;
};

/** aggregate avg on columns */
export type EventTransactionItemsAvgFields = {
  __typename?: 'EventTransactionItemsAvgFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_transaction_items" */
export type EventTransactionItemsAvgOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_transaction_items". All fields are combined with a logical 'AND'. */
export type EventTransactionItemsBoolExp = {
  _and?: InputMaybe<Array<EventTransactionItemsBoolExp>>;
  _not?: InputMaybe<EventTransactionItemsBoolExp>;
  _or?: InputMaybe<Array<EventTransactionItemsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsBoolExp>;
  groupRegistrationId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  registration?: InputMaybe<EventRegistrationsBoolExp>;
  registrationId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  totalUnitAmount?: InputMaybe<IntComparisonExp>;
  transaction?: InputMaybe<EventTransactionsBoolExp>;
  transactionId?: InputMaybe<UuidComparisonExp>;
  type?: InputMaybe<EventTransactionItemTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "event_transaction_items" */
export enum EventTransactionItemsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventTransactionItemsPkey = 'event_transaction_items_pkey'
}

/** input type for incrementing numeric columns in table "event_transaction_items" */
export type EventTransactionItemsIncInput = {
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_transaction_items" */
export type EventTransactionItemsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsObjRelInsertInput>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  registration?: InputMaybe<EventRegistrationsObjRelInsertInput>;
  registrationId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  transaction?: InputMaybe<EventTransactionsObjRelInsertInput>;
  transactionId?: InputMaybe<Scalars['uuid']>;
  type?: InputMaybe<EventTransactionItemTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventTransactionItemsMaxFields = {
  __typename?: 'EventTransactionItemsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  registrationId?: Maybe<Scalars['uuid']>;
  totalUnitAmount?: Maybe<Scalars['Int']>;
  transactionId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "event_transaction_items" */
export type EventTransactionItemsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  registrationId?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  transactionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventTransactionItemsMinFields = {
  __typename?: 'EventTransactionItemsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupRegistrationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  registrationId?: Maybe<Scalars['uuid']>;
  totalUnitAmount?: Maybe<Scalars['Int']>;
  transactionId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "event_transaction_items" */
export type EventTransactionItemsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  registrationId?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  transactionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_transaction_items" */
export type EventTransactionItemsMutationResponse = {
  __typename?: 'EventTransactionItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTransactionItems>;
};

/** on_conflict condition type for table "event_transaction_items" */
export type EventTransactionItemsOnConflict = {
  constraint: EventTransactionItemsConstraint;
  updateColumns?: Array<EventTransactionItemsUpdateColumn>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** Ordering options when selecting data from "event_transaction_items". */
export type EventTransactionItemsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupRegistration?: InputMaybe<EventGroupRegistrationsOrderBy>;
  groupRegistrationId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  registration?: InputMaybe<EventRegistrationsOrderBy>;
  registrationId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  transaction?: InputMaybe<EventTransactionsOrderBy>;
  transactionId?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_transaction_items */
export type EventTransactionItemsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_transaction_items" */
export enum EventTransactionItemsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupRegistrationId = 'groupRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  RegistrationId = 'registrationId',
  /** column name */
  Status = 'status',
  /** column name */
  TotalUnitAmount = 'totalUnitAmount',
  /** column name */
  TransactionId = 'transactionId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "event_transaction_items" */
export type EventTransactionItemsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  registrationId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  transactionId?: InputMaybe<Scalars['uuid']>;
  type?: InputMaybe<EventTransactionItemTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type EventTransactionItemsStddevFields = {
  __typename?: 'EventTransactionItemsStddevFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_transaction_items" */
export type EventTransactionItemsStddevOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventTransactionItemsStddevPopFields = {
  __typename?: 'EventTransactionItemsStddevPopFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_transaction_items" */
export type EventTransactionItemsStddevPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventTransactionItemsStddevSampFields = {
  __typename?: 'EventTransactionItemsStddevSampFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_transaction_items" */
export type EventTransactionItemsStddevSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_transaction_items" */
export type EventTransactionItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTransactionItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTransactionItemsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupRegistrationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  registrationId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  transactionId?: InputMaybe<Scalars['uuid']>;
  type?: InputMaybe<EventTransactionItemTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type EventTransactionItemsSumFields = {
  __typename?: 'EventTransactionItemsSumFields';
  priceUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  totalUnitAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_transaction_items" */
export type EventTransactionItemsSumOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "event_transaction_items" */
export enum EventTransactionItemsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupRegistrationId = 'groupRegistrationId',
  /** column name */
  Id = 'id',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  RegistrationId = 'registrationId',
  /** column name */
  Status = 'status',
  /** column name */
  TotalUnitAmount = 'totalUnitAmount',
  /** column name */
  TransactionId = 'transactionId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type EventTransactionItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventTransactionItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTransactionItemsSetInput>;
  /** filter the rows which have to be updated */
  where: EventTransactionItemsBoolExp;
};

/** aggregate varPop on columns */
export type EventTransactionItemsVarPopFields = {
  __typename?: 'EventTransactionItemsVarPopFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_transaction_items" */
export type EventTransactionItemsVarPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventTransactionItemsVarSampFields = {
  __typename?: 'EventTransactionItemsVarSampFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_transaction_items" */
export type EventTransactionItemsVarSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventTransactionItemsVarianceFields = {
  __typename?: 'EventTransactionItemsVarianceFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_transaction_items" */
export type EventTransactionItemsVarianceOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_transactions" */
export type EventTransactions = {
  __typename?: 'EventTransactions';
  applicationFeeTotalUnitAmount: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  customer: Users;
  customerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  customerProfile?: Maybe<UserProfiles>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  event: Events;
  eventId: Scalars['uuid'];
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  orderSubtotalUnitAmount: Scalars['Int'];
  orderTotalUnitAmount: Scalars['Int'];
  paidUnitAmount: Scalars['Int'];
  /** An object relationship */
  paymentIntentExternal: StripePaymentIntents;
  /** An object relationship */
  paymentIntentInternal: StripePaymentIntents;
  /** An object relationship */
  paymentMethodUsed?: Maybe<UserCreditCards>;
  paymentProcessor: PaymentProcessorsEnum;
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  seller: Users;
  sellerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  sellerProfile?: Maybe<UserProfiles>;
  sellerUserId: Scalars['uuid'];
  status: OrderStatusesEnum;
  stripeCustomerId: Scalars['String'];
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus: Scalars['String'];
  /** An array relationship */
  transactionItems: Array<EventTransactionItems>;
  /** An aggregate relationship */
  transactionItemsAggregate: EventTransactionItemsAggregate;
  transferUnitAmount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  userCreditCardId?: Maybe<Scalars['uuid']>;
  userId: Scalars['uuid'];
};


/** columns and relationships of "event_transactions" */
export type EventTransactionsTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


/** columns and relationships of "event_transactions" */
export type EventTransactionsTransactionItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};

/** aggregated selection of "event_transactions" */
export type EventTransactionsAggregate = {
  __typename?: 'EventTransactionsAggregate';
  aggregate?: Maybe<EventTransactionsAggregateFields>;
  nodes: Array<EventTransactions>;
};

export type EventTransactionsAggregateBoolExp = {
  count?: InputMaybe<EventTransactionsAggregateBoolExpCount>;
};

/** aggregate fields of "event_transactions" */
export type EventTransactionsAggregateFields = {
  __typename?: 'EventTransactionsAggregateFields';
  avg?: Maybe<EventTransactionsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventTransactionsMaxFields>;
  min?: Maybe<EventTransactionsMinFields>;
  stddev?: Maybe<EventTransactionsStddevFields>;
  stddevPop?: Maybe<EventTransactionsStddevPopFields>;
  stddevSamp?: Maybe<EventTransactionsStddevSampFields>;
  sum?: Maybe<EventTransactionsSumFields>;
  varPop?: Maybe<EventTransactionsVarPopFields>;
  varSamp?: Maybe<EventTransactionsVarSampFields>;
  variance?: Maybe<EventTransactionsVarianceFields>;
};


/** aggregate fields of "event_transactions" */
export type EventTransactionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_transactions" */
export type EventTransactionsAggregateOrderBy = {
  avg?: InputMaybe<EventTransactionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EventTransactionsMaxOrderBy>;
  min?: InputMaybe<EventTransactionsMinOrderBy>;
  stddev?: InputMaybe<EventTransactionsStddevOrderBy>;
  stddevPop?: InputMaybe<EventTransactionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<EventTransactionsStddevSampOrderBy>;
  sum?: InputMaybe<EventTransactionsSumOrderBy>;
  varPop?: InputMaybe<EventTransactionsVarPopOrderBy>;
  varSamp?: InputMaybe<EventTransactionsVarSampOrderBy>;
  variance?: InputMaybe<EventTransactionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "event_transactions" */
export type EventTransactionsArrRelInsertInput = {
  data: Array<EventTransactionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EventTransactionsOnConflict>;
};

/** aggregate avg on columns */
export type EventTransactionsAvgFields = {
  __typename?: 'EventTransactionsAvgFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_transactions" */
export type EventTransactionsAvgOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "event_transactions". All fields are combined with a logical 'AND'. */
export type EventTransactionsBoolExp = {
  _and?: InputMaybe<Array<EventTransactionsBoolExp>>;
  _not?: InputMaybe<EventTransactionsBoolExp>;
  _or?: InputMaybe<Array<EventTransactionsBoolExp>>;
  applicationFeeTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  customer?: InputMaybe<UsersBoolExp>;
  customerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  customerProfile?: InputMaybe<UserProfilesBoolExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  event?: InputMaybe<EventsBoolExp>;
  eventId?: InputMaybe<UuidComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  orderSubtotalUnitAmount?: InputMaybe<IntComparisonExp>;
  orderTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  paidUnitAmount?: InputMaybe<IntComparisonExp>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsBoolExp>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnumComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  seller?: InputMaybe<UsersBoolExp>;
  sellerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  sellerProfile?: InputMaybe<UserProfilesBoolExp>;
  sellerUserId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripeMerchantId?: InputMaybe<StringComparisonExp>;
  stripePaymentStatus?: InputMaybe<StringComparisonExp>;
  transactionItems?: InputMaybe<EventTransactionItemsBoolExp>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateBoolExp>;
  transferUnitAmount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCreditCardId?: InputMaybe<UuidComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "event_transactions" */
export enum EventTransactionsConstraint {
  /** unique or primary key constraint on columns "external_stripe_payment_intent_id" */
  EventTransactionsExternalStripePaymentIntentIdKey = 'event_transactions_external_stripe_payment_intent_id_key',
  /** unique or primary key constraint on columns "internal_stripe_payment_intent_id" */
  EventTransactionsInternalStripePaymentIntentIdKey = 'event_transactions_internal_stripe_payment_intent_id_key',
  /** unique or primary key constraint on columns "id" */
  EventTransactionsPkey = 'event_transactions_pkey'
}

/** input type for incrementing numeric columns in table "event_transactions" */
export type EventTransactionsIncInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_transactions" */
export type EventTransactionsInsertInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customer?: InputMaybe<UsersObjRelInsertInput>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  customerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  event?: InputMaybe<EventsObjRelInsertInput>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsObjRelInsertInput>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  seller?: InputMaybe<UsersObjRelInsertInput>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  transactionItems?: InputMaybe<EventTransactionItemsArrRelInsertInput>;
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type EventTransactionsMaxFields = {
  __typename?: 'EventTransactionsMaxFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  sellerUserId?: Maybe<Scalars['uuid']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  transferUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "event_transactions" */
export type EventTransactionsMaxOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EventTransactionsMinFields = {
  __typename?: 'EventTransactionsMinFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  eventId?: Maybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  sellerUserId?: Maybe<Scalars['uuid']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  transferUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "event_transactions" */
export type EventTransactionsMinOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "event_transactions" */
export type EventTransactionsMutationResponse = {
  __typename?: 'EventTransactionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTransactions>;
};

/** input type for inserting object relation for remote table "event_transactions" */
export type EventTransactionsObjRelInsertInput = {
  data: EventTransactionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventTransactionsOnConflict>;
};

/** on_conflict condition type for table "event_transactions" */
export type EventTransactionsOnConflict = {
  constraint: EventTransactionsConstraint;
  updateColumns?: Array<EventTransactionsUpdateColumn>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};

/** Ordering options when selecting data from "event_transactions". */
export type EventTransactionsOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customer?: InputMaybe<UsersOrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  customerProfile?: InputMaybe<UserProfilesOrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  event?: InputMaybe<EventsOrderBy>;
  eventId?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsOrderBy>;
  paymentProcessor?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  seller?: InputMaybe<UsersOrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerProfile?: InputMaybe<UserProfilesOrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transactionItemsAggregate?: InputMaybe<EventTransactionItemsAggregateOrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_transactions */
export type EventTransactionsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "event_transactions" */
export enum EventTransactionsSelectColumn {
  /** column name */
  ApplicationFeeTotalUnitAmount = 'applicationFeeTotalUnitAmount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerApplicationFeeUnitAmount = 'customerApplicationFeeUnitAmount',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  SellerApplicationFeeUnitAmount = 'sellerApplicationFeeUnitAmount',
  /** column name */
  SellerUserId = 'sellerUserId',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  TransferUnitAmount = 'transferUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "event_transactions" */
export type EventTransactionsSetInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type EventTransactionsStddevFields = {
  __typename?: 'EventTransactionsStddevFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_transactions" */
export type EventTransactionsStddevOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type EventTransactionsStddevPopFields = {
  __typename?: 'EventTransactionsStddevPopFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "event_transactions" */
export type EventTransactionsStddevPopOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type EventTransactionsStddevSampFields = {
  __typename?: 'EventTransactionsStddevSampFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "event_transactions" */
export type EventTransactionsStddevSampOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "event_transactions" */
export type EventTransactionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTransactionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTransactionsStreamCursorValueInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  eventId?: InputMaybe<Scalars['uuid']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type EventTransactionsSumFields = {
  __typename?: 'EventTransactionsSumFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  transferUnitAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_transactions" */
export type EventTransactionsSumOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "event_transactions" */
export enum EventTransactionsUpdateColumn {
  /** column name */
  ApplicationFeeTotalUnitAmount = 'applicationFeeTotalUnitAmount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerApplicationFeeUnitAmount = 'customerApplicationFeeUnitAmount',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  SellerApplicationFeeUnitAmount = 'sellerApplicationFeeUnitAmount',
  /** column name */
  SellerUserId = 'sellerUserId',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  TransferUnitAmount = 'transferUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId',
  /** column name */
  UserId = 'userId'
}

export type EventTransactionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventTransactionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTransactionsSetInput>;
  /** filter the rows which have to be updated */
  where: EventTransactionsBoolExp;
};

/** aggregate varPop on columns */
export type EventTransactionsVarPopFields = {
  __typename?: 'EventTransactionsVarPopFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "event_transactions" */
export type EventTransactionsVarPopOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type EventTransactionsVarSampFields = {
  __typename?: 'EventTransactionsVarSampFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "event_transactions" */
export type EventTransactionsVarSampOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type EventTransactionsVarianceFields = {
  __typename?: 'EventTransactionsVarianceFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_transactions" */
export type EventTransactionsVarianceOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "event_types" */
export type EventTypes = {
  __typename?: 'EventTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "event_types" */
export type EventTypesAggregate = {
  __typename?: 'EventTypesAggregate';
  aggregate?: Maybe<EventTypesAggregateFields>;
  nodes: Array<EventTypes>;
};

/** aggregate fields of "event_types" */
export type EventTypesAggregateFields = {
  __typename?: 'EventTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<EventTypesMaxFields>;
  min?: Maybe<EventTypesMinFields>;
};


/** aggregate fields of "event_types" */
export type EventTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "event_types". All fields are combined with a logical 'AND'. */
export type EventTypesBoolExp = {
  _and?: InputMaybe<Array<EventTypesBoolExp>>;
  _not?: InputMaybe<EventTypesBoolExp>;
  _or?: InputMaybe<Array<EventTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "event_types" */
export enum EventTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  EventTypesPkey = 'event_types_pkey'
}

export enum EventTypesEnum {
  GeneralEvent = 'GENERAL_EVENT',
  League = 'LEAGUE',
  Tournament = 'TOURNAMENT'
}

/** Boolean expression to compare columns of type "EventTypesEnum". All fields are combined with logical 'AND'. */
export type EventTypesEnumComparisonExp = {
  _eq?: InputMaybe<EventTypesEnum>;
  _in?: InputMaybe<Array<EventTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<EventTypesEnum>;
  _nin?: InputMaybe<Array<EventTypesEnum>>;
};

/** input type for inserting data into table "event_types" */
export type EventTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventTypesMaxFields = {
  __typename?: 'EventTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventTypesMinFields = {
  __typename?: 'EventTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "event_types" */
export type EventTypesMutationResponse = {
  __typename?: 'EventTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<EventTypes>;
};

/** on_conflict condition type for table "event_types" */
export type EventTypesOnConflict = {
  constraint: EventTypesConstraint;
  updateColumns?: Array<EventTypesUpdateColumn>;
  where?: InputMaybe<EventTypesBoolExp>;
};

/** Ordering options when selecting data from "event_types". */
export type EventTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_types */
export type EventTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "event_types" */
export enum EventTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "event_types" */
export type EventTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "event_types" */
export type EventTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "event_types" */
export enum EventTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type EventTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventTypesSetInput>;
  /** filter the rows which have to be updated */
  where: EventTypesBoolExp;
};

/** columns and relationships of "events" */
export type Events = {
  __typename?: 'Events';
  addressString?: Maybe<Scalars['String']>;
  archivedAt?: Maybe<Scalars['timestamptz']>;
  ballCustomName: Scalars['String'];
  ballType: BallTypesEnum;
  cancelReason: Scalars['String'];
  canceledAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  city?: Maybe<Cities>;
  cityId?: Maybe<Scalars['uuid']>;
  cityString: Scalars['String'];
  /** An object relationship */
  contactDetails?: Maybe<EventContactDetails>;
  countryString: Scalars['String'];
  /** An array relationship */
  courts: Array<EventCourts>;
  /** An aggregate relationship */
  courtsAggregate: EventCourtsAggregate;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImageFileType?: Maybe<Scalars['String']>;
  coverImageHost?: Maybe<Scalars['String']>;
  coverImageOriginalFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  /** Fallback for when we don't have a city_id */
  displayLocation: Scalars['String'];
  endDate: Scalars['date'];
  endDateTime: Scalars['timestamptz'];
  externalUrl?: Maybe<Scalars['String']>;
  /** An array relationship */
  faqs: Array<EventFaqs>;
  /** An aggregate relationship */
  faqsAggregate: EventFaqsAggregate;
  geometry?: Maybe<Scalars['geography']>;
  groupFormat?: Maybe<EventGroupFormatsEnum>;
  /** An array relationship */
  groups: Array<EventGroups>;
  /** An aggregate relationship */
  groupsAggregate: EventGroupsAggregate;
  hasPrizes: Scalars['Boolean'];
  /** An object relationship */
  hostUser?: Maybe<Users>;
  hostUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  hostUserProfile?: Maybe<UserProfiles>;
  id: Scalars['uuid'];
  /** An array relationship */
  invitations: Array<EventInvitations>;
  /** An aggregate relationship */
  invitationsAggregate: EventInvitationsAggregate;
  isExternal: Scalars['Boolean'];
  isRatingRequired: Scalars['Boolean'];
  isRegisterOffPlatform: Scalars['Boolean'];
  isSanctioned: Scalars['Boolean'];
  latitude?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  listingFees: Array<EventListingFees>;
  /** An aggregate relationship */
  listingFeesAggregate: EventListingFeesAggregate;
  locale: Scalars['String'];
  longitude?: Maybe<Scalars['numeric']>;
  organizerImageFileName?: Maybe<Scalars['String']>;
  organizerImageFileType?: Maybe<Scalars['String']>;
  organizerImageHost?: Maybe<Scalars['String']>;
  organizerImageOriginalFileName?: Maybe<Scalars['String']>;
  organizerImagePath?: Maybe<Scalars['String']>;
  organizerImageProvider?: Maybe<Scalars['String']>;
  organizerImageProviderUrl?: Maybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: Maybe<Scalars['String']>;
  /** An object relationship */
  pickleballRatingScale?: Maybe<PickleballRatingScales>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  privacy: EventPrivacyEnum;
  prizeDescription: Scalars['String'];
  publishedAt?: Maybe<Scalars['timestamptz']>;
  regionString: Scalars['String'];
  registrationClosedAt?: Maybe<Scalars['timestamptz']>;
  registrationDeadlineDate: Scalars['date'];
  registrationDeadlineDateTime?: Maybe<Scalars['timestamptz']>;
  registrationOpenDate?: Maybe<Scalars['date']>;
  registrationOpenDateTime?: Maybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount: Scalars['Int'];
  /** An array relationship */
  registrations: Array<EventRegistrations>;
  /** An aggregate relationship */
  registrationsAggregate: EventRegistrationsAggregate;
  scoringFormat: ScoringFormatEnum;
  showInPublicDate?: Maybe<Scalars['date']>;
  showInPublicDateTime?: Maybe<Scalars['timestamptz']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  sourceEventId?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceIsAdvertiseOnly: Scalars['Boolean'];
  sourceIsFeatured: Scalars['Boolean'];
  sourceIsFeaturedPlus: Scalars['Boolean'];
  sourceLocationCity?: Maybe<Scalars['String']>;
  sourceLocationCountry?: Maybe<Scalars['String']>;
  sourceLocationState?: Maybe<Scalars['String']>;
  sourceLocationStreetAddress?: Maybe<Scalars['String']>;
  sourceLocationZip?: Maybe<Scalars['String']>;
  sourceLogoUrl?: Maybe<Scalars['String']>;
  sourceOrganizerId?: Maybe<Scalars['String']>;
  sourceOrganizerImageUrl?: Maybe<Scalars['String']>;
  sourceOrganizerTitle?: Maybe<Scalars['String']>;
  sourceRegistrationCount: Scalars['Int'];
  sourceVenueTitle?: Maybe<Scalars['String']>;
  /** An array relationship */
  sponsors: Array<EventSponsors>;
  /** An aggregate relationship */
  sponsorsAggregate: EventSponsorsAggregate;
  sport: SportsEnum;
  startDate: Scalars['date'];
  startDateTime: Scalars['timestamptz'];
  status: EventStatusesEnum;
  streetPrimaryString: Scalars['String'];
  streetSecondaryString: Scalars['String'];
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title: Scalars['String'];
  /** An array relationship */
  transactions: Array<EventTransactions>;
  /** An aggregate relationship */
  transactionsAggregate: EventTransactionsAggregate;
  type: EventTypesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue?: Maybe<Venues>;
  venueId?: Maybe<Scalars['uuid']>;
  zipcodeString: Scalars['String'];
};


/** columns and relationships of "events" */
export type EventsCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsFaqsArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsFaqsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsGroupsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsListingFeesArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


/** columns and relationships of "events" */
export type EventsListingFeesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


/** columns and relationships of "events" */
export type EventsRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsSponsorsArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsSponsorsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsTransactionsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


/** columns and relationships of "events" */
export type EventsTransactionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};

/** aggregated selection of "events" */
export type EventsAggregate = {
  __typename?: 'EventsAggregate';
  aggregate?: Maybe<EventsAggregateFields>;
  nodes: Array<Events>;
};

/** aggregate fields of "events" */
export type EventsAggregateFields = {
  __typename?: 'EventsAggregateFields';
  avg?: Maybe<EventsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<EventsMaxFields>;
  min?: Maybe<EventsMinFields>;
  stddev?: Maybe<EventsStddevFields>;
  stddevPop?: Maybe<EventsStddevPopFields>;
  stddevSamp?: Maybe<EventsStddevSampFields>;
  sum?: Maybe<EventsSumFields>;
  varPop?: Maybe<EventsVarPopFields>;
  varSamp?: Maybe<EventsVarSampFields>;
  variance?: Maybe<EventsVarianceFields>;
};


/** aggregate fields of "events" */
export type EventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type EventsAvgFields = {
  __typename?: 'EventsAvgFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
export type EventsBoolExp = {
  _and?: InputMaybe<Array<EventsBoolExp>>;
  _not?: InputMaybe<EventsBoolExp>;
  _or?: InputMaybe<Array<EventsBoolExp>>;
  addressString?: InputMaybe<StringComparisonExp>;
  archivedAt?: InputMaybe<TimestamptzComparisonExp>;
  ballCustomName?: InputMaybe<StringComparisonExp>;
  ballType?: InputMaybe<BallTypesEnumComparisonExp>;
  cancelReason?: InputMaybe<StringComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  city?: InputMaybe<CitiesBoolExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  cityString?: InputMaybe<StringComparisonExp>;
  contactDetails?: InputMaybe<EventContactDetailsBoolExp>;
  countryString?: InputMaybe<StringComparisonExp>;
  courts?: InputMaybe<EventCourtsBoolExp>;
  courtsAggregate?: InputMaybe<EventCourtsAggregateBoolExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImageFileType?: InputMaybe<StringComparisonExp>;
  coverImageHost?: InputMaybe<StringComparisonExp>;
  coverImageOriginalFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  displayLocation?: InputMaybe<StringComparisonExp>;
  endDate?: InputMaybe<DateComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  externalUrl?: InputMaybe<StringComparisonExp>;
  faqs?: InputMaybe<EventFaqsBoolExp>;
  faqsAggregate?: InputMaybe<EventFaqsAggregateBoolExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groupFormat?: InputMaybe<EventGroupFormatsEnumComparisonExp>;
  groups?: InputMaybe<EventGroupsBoolExp>;
  groupsAggregate?: InputMaybe<EventGroupsAggregateBoolExp>;
  hasPrizes?: InputMaybe<BooleanComparisonExp>;
  hostUser?: InputMaybe<UsersBoolExp>;
  hostUserId?: InputMaybe<UuidComparisonExp>;
  hostUserProfile?: InputMaybe<UserProfilesBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitations?: InputMaybe<EventInvitationsBoolExp>;
  invitationsAggregate?: InputMaybe<EventInvitationsAggregateBoolExp>;
  isExternal?: InputMaybe<BooleanComparisonExp>;
  isRatingRequired?: InputMaybe<BooleanComparisonExp>;
  isRegisterOffPlatform?: InputMaybe<BooleanComparisonExp>;
  isSanctioned?: InputMaybe<BooleanComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  listingFees?: InputMaybe<EventListingFeesBoolExp>;
  listingFeesAggregate?: InputMaybe<EventListingFeesAggregateBoolExp>;
  locale?: InputMaybe<StringComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  organizerImageFileName?: InputMaybe<StringComparisonExp>;
  organizerImageFileType?: InputMaybe<StringComparisonExp>;
  organizerImageHost?: InputMaybe<StringComparisonExp>;
  organizerImageOriginalFileName?: InputMaybe<StringComparisonExp>;
  organizerImagePath?: InputMaybe<StringComparisonExp>;
  organizerImageProvider?: InputMaybe<StringComparisonExp>;
  organizerImageProviderUrl?: InputMaybe<StringComparisonExp>;
  organizerImageUrl?: InputMaybe<StringComparisonExp>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesBoolExp>;
  pickleballRatingScaleId?: InputMaybe<UuidComparisonExp>;
  privacy?: InputMaybe<EventPrivacyEnumComparisonExp>;
  prizeDescription?: InputMaybe<StringComparisonExp>;
  publishedAt?: InputMaybe<TimestamptzComparisonExp>;
  regionString?: InputMaybe<StringComparisonExp>;
  registrationClosedAt?: InputMaybe<TimestamptzComparisonExp>;
  registrationDeadlineDate?: InputMaybe<DateComparisonExp>;
  registrationDeadlineDateTime?: InputMaybe<TimestamptzComparisonExp>;
  registrationOpenDate?: InputMaybe<DateComparisonExp>;
  registrationOpenDateTime?: InputMaybe<TimestamptzComparisonExp>;
  registrationPriceUnitAmount?: InputMaybe<IntComparisonExp>;
  registrations?: InputMaybe<EventRegistrationsBoolExp>;
  registrationsAggregate?: InputMaybe<EventRegistrationsAggregateBoolExp>;
  scoringFormat?: InputMaybe<ScoringFormatEnumComparisonExp>;
  showInPublicDate?: InputMaybe<DateComparisonExp>;
  showInPublicDateTime?: InputMaybe<TimestamptzComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  source?: InputMaybe<StringComparisonExp>;
  sourceEventId?: InputMaybe<StringComparisonExp>;
  sourceId?: InputMaybe<StringComparisonExp>;
  sourceIsAdvertiseOnly?: InputMaybe<BooleanComparisonExp>;
  sourceIsFeatured?: InputMaybe<BooleanComparisonExp>;
  sourceIsFeaturedPlus?: InputMaybe<BooleanComparisonExp>;
  sourceLocationCity?: InputMaybe<StringComparisonExp>;
  sourceLocationCountry?: InputMaybe<StringComparisonExp>;
  sourceLocationState?: InputMaybe<StringComparisonExp>;
  sourceLocationStreetAddress?: InputMaybe<StringComparisonExp>;
  sourceLocationZip?: InputMaybe<StringComparisonExp>;
  sourceLogoUrl?: InputMaybe<StringComparisonExp>;
  sourceOrganizerId?: InputMaybe<StringComparisonExp>;
  sourceOrganizerImageUrl?: InputMaybe<StringComparisonExp>;
  sourceOrganizerTitle?: InputMaybe<StringComparisonExp>;
  sourceRegistrationCount?: InputMaybe<IntComparisonExp>;
  sourceVenueTitle?: InputMaybe<StringComparisonExp>;
  sponsors?: InputMaybe<EventSponsorsBoolExp>;
  sponsorsAggregate?: InputMaybe<EventSponsorsAggregateBoolExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  startDate?: InputMaybe<DateComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<EventStatusesEnumComparisonExp>;
  streetPrimaryString?: InputMaybe<StringComparisonExp>;
  streetSecondaryString?: InputMaybe<StringComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  timezoneAbbreviation?: InputMaybe<StringComparisonExp>;
  timezoneName?: InputMaybe<StringComparisonExp>;
  timezoneOffsetMinutes?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  transactions?: InputMaybe<EventTransactionsBoolExp>;
  transactionsAggregate?: InputMaybe<EventTransactionsAggregateBoolExp>;
  type?: InputMaybe<EventTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
  zipcodeString?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "events" */
export enum EventsConstraint {
  /** unique or primary key constraint on columns "id" */
  EventsPkey = 'events_pkey',
  /** unique or primary key constraint on columns "slug" */
  EventsSlugKey = 'events_slug_key',
  /** unique or primary key constraint on columns "source_id" */
  EventsSourceIdKey = 'events_source_id_key'
}

/** input type for incrementing numeric columns in table "events" */
export type EventsIncInput = {
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  sourceRegistrationCount?: InputMaybe<Scalars['Int']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "events" */
export type EventsInsertInput = {
  addressString?: InputMaybe<Scalars['String']>;
  archivedAt?: InputMaybe<Scalars['timestamptz']>;
  ballCustomName?: InputMaybe<Scalars['String']>;
  ballType?: InputMaybe<BallTypesEnum>;
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  city?: InputMaybe<CitiesObjRelInsertInput>;
  cityId?: InputMaybe<Scalars['uuid']>;
  cityString?: InputMaybe<Scalars['String']>;
  contactDetails?: InputMaybe<EventContactDetailsObjRelInsertInput>;
  countryString?: InputMaybe<Scalars['String']>;
  courts?: InputMaybe<EventCourtsArrRelInsertInput>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImageFileType?: InputMaybe<Scalars['String']>;
  coverImageHost?: InputMaybe<Scalars['String']>;
  coverImageOriginalFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  /** Fallback for when we don't have a city_id */
  displayLocation?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['date']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  externalUrl?: InputMaybe<Scalars['String']>;
  faqs?: InputMaybe<EventFaqsArrRelInsertInput>;
  geometry?: InputMaybe<Scalars['geography']>;
  groupFormat?: InputMaybe<EventGroupFormatsEnum>;
  groups?: InputMaybe<EventGroupsArrRelInsertInput>;
  hasPrizes?: InputMaybe<Scalars['Boolean']>;
  hostUser?: InputMaybe<UsersObjRelInsertInput>;
  hostUserId?: InputMaybe<Scalars['uuid']>;
  hostUserProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  invitations?: InputMaybe<EventInvitationsArrRelInsertInput>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  isRatingRequired?: InputMaybe<Scalars['Boolean']>;
  isRegisterOffPlatform?: InputMaybe<Scalars['Boolean']>;
  isSanctioned?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  listingFees?: InputMaybe<EventListingFeesArrRelInsertInput>;
  locale?: InputMaybe<Scalars['String']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  organizerImageFileName?: InputMaybe<Scalars['String']>;
  organizerImageFileType?: InputMaybe<Scalars['String']>;
  organizerImageHost?: InputMaybe<Scalars['String']>;
  organizerImageOriginalFileName?: InputMaybe<Scalars['String']>;
  organizerImagePath?: InputMaybe<Scalars['String']>;
  organizerImageProvider?: InputMaybe<Scalars['String']>;
  organizerImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: InputMaybe<Scalars['String']>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesObjRelInsertInput>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<EventPrivacyEnum>;
  prizeDescription?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  regionString?: InputMaybe<Scalars['String']>;
  registrationClosedAt?: InputMaybe<Scalars['timestamptz']>;
  registrationDeadlineDate?: InputMaybe<Scalars['date']>;
  registrationDeadlineDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationOpenDate?: InputMaybe<Scalars['date']>;
  registrationOpenDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  registrations?: InputMaybe<EventRegistrationsArrRelInsertInput>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  showInPublicDate?: InputMaybe<Scalars['date']>;
  showInPublicDateTime?: InputMaybe<Scalars['timestamptz']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceEventId?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceIsAdvertiseOnly?: InputMaybe<Scalars['Boolean']>;
  sourceIsFeatured?: InputMaybe<Scalars['Boolean']>;
  sourceIsFeaturedPlus?: InputMaybe<Scalars['Boolean']>;
  sourceLocationCity?: InputMaybe<Scalars['String']>;
  sourceLocationCountry?: InputMaybe<Scalars['String']>;
  sourceLocationState?: InputMaybe<Scalars['String']>;
  sourceLocationStreetAddress?: InputMaybe<Scalars['String']>;
  sourceLocationZip?: InputMaybe<Scalars['String']>;
  sourceLogoUrl?: InputMaybe<Scalars['String']>;
  sourceOrganizerId?: InputMaybe<Scalars['String']>;
  sourceOrganizerImageUrl?: InputMaybe<Scalars['String']>;
  sourceOrganizerTitle?: InputMaybe<Scalars['String']>;
  sourceRegistrationCount?: InputMaybe<Scalars['Int']>;
  sourceVenueTitle?: InputMaybe<Scalars['String']>;
  sponsors?: InputMaybe<EventSponsorsArrRelInsertInput>;
  sport?: InputMaybe<SportsEnum>;
  startDate?: InputMaybe<Scalars['date']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<EventStatusesEnum>;
  streetPrimaryString?: InputMaybe<Scalars['String']>;
  streetSecondaryString?: InputMaybe<Scalars['String']>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesObjRelInsertInput>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  transactions?: InputMaybe<EventTransactionsArrRelInsertInput>;
  type?: InputMaybe<EventTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
  zipcodeString?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventsMaxFields = {
  __typename?: 'EventsMaxFields';
  addressString?: Maybe<Scalars['String']>;
  archivedAt?: Maybe<Scalars['timestamptz']>;
  ballCustomName?: Maybe<Scalars['String']>;
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  cityId?: Maybe<Scalars['uuid']>;
  cityString?: Maybe<Scalars['String']>;
  countryString?: Maybe<Scalars['String']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImageFileType?: Maybe<Scalars['String']>;
  coverImageHost?: Maybe<Scalars['String']>;
  coverImageOriginalFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  /** Fallback for when we don't have a city_id */
  displayLocation?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  externalUrl?: Maybe<Scalars['String']>;
  hostUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['numeric']>;
  locale?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['numeric']>;
  organizerImageFileName?: Maybe<Scalars['String']>;
  organizerImageFileType?: Maybe<Scalars['String']>;
  organizerImageHost?: Maybe<Scalars['String']>;
  organizerImageOriginalFileName?: Maybe<Scalars['String']>;
  organizerImagePath?: Maybe<Scalars['String']>;
  organizerImageProvider?: Maybe<Scalars['String']>;
  organizerImageProviderUrl?: Maybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: Maybe<Scalars['String']>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  prizeDescription?: Maybe<Scalars['String']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  regionString?: Maybe<Scalars['String']>;
  registrationClosedAt?: Maybe<Scalars['timestamptz']>;
  registrationDeadlineDate?: Maybe<Scalars['date']>;
  registrationDeadlineDateTime?: Maybe<Scalars['timestamptz']>;
  registrationOpenDate?: Maybe<Scalars['date']>;
  registrationOpenDateTime?: Maybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Int']>;
  showInPublicDate?: Maybe<Scalars['date']>;
  showInPublicDateTime?: Maybe<Scalars['timestamptz']>;
  slug?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  sourceEventId?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceLocationCity?: Maybe<Scalars['String']>;
  sourceLocationCountry?: Maybe<Scalars['String']>;
  sourceLocationState?: Maybe<Scalars['String']>;
  sourceLocationStreetAddress?: Maybe<Scalars['String']>;
  sourceLocationZip?: Maybe<Scalars['String']>;
  sourceLogoUrl?: Maybe<Scalars['String']>;
  sourceOrganizerId?: Maybe<Scalars['String']>;
  sourceOrganizerImageUrl?: Maybe<Scalars['String']>;
  sourceOrganizerTitle?: Maybe<Scalars['String']>;
  sourceRegistrationCount?: Maybe<Scalars['Int']>;
  sourceVenueTitle?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['date']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  streetPrimaryString?: Maybe<Scalars['String']>;
  streetSecondaryString?: Maybe<Scalars['String']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
  zipcodeString?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type EventsMinFields = {
  __typename?: 'EventsMinFields';
  addressString?: Maybe<Scalars['String']>;
  archivedAt?: Maybe<Scalars['timestamptz']>;
  ballCustomName?: Maybe<Scalars['String']>;
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  cityId?: Maybe<Scalars['uuid']>;
  cityString?: Maybe<Scalars['String']>;
  countryString?: Maybe<Scalars['String']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImageFileType?: Maybe<Scalars['String']>;
  coverImageHost?: Maybe<Scalars['String']>;
  coverImageOriginalFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  /** Fallback for when we don't have a city_id */
  displayLocation?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['date']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  externalUrl?: Maybe<Scalars['String']>;
  hostUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  latitude?: Maybe<Scalars['numeric']>;
  locale?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['numeric']>;
  organizerImageFileName?: Maybe<Scalars['String']>;
  organizerImageFileType?: Maybe<Scalars['String']>;
  organizerImageHost?: Maybe<Scalars['String']>;
  organizerImageOriginalFileName?: Maybe<Scalars['String']>;
  organizerImagePath?: Maybe<Scalars['String']>;
  organizerImageProvider?: Maybe<Scalars['String']>;
  organizerImageProviderUrl?: Maybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: Maybe<Scalars['String']>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  prizeDescription?: Maybe<Scalars['String']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  regionString?: Maybe<Scalars['String']>;
  registrationClosedAt?: Maybe<Scalars['timestamptz']>;
  registrationDeadlineDate?: Maybe<Scalars['date']>;
  registrationDeadlineDateTime?: Maybe<Scalars['timestamptz']>;
  registrationOpenDate?: Maybe<Scalars['date']>;
  registrationOpenDateTime?: Maybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Int']>;
  showInPublicDate?: Maybe<Scalars['date']>;
  showInPublicDateTime?: Maybe<Scalars['timestamptz']>;
  slug?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  sourceEventId?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceLocationCity?: Maybe<Scalars['String']>;
  sourceLocationCountry?: Maybe<Scalars['String']>;
  sourceLocationState?: Maybe<Scalars['String']>;
  sourceLocationStreetAddress?: Maybe<Scalars['String']>;
  sourceLocationZip?: Maybe<Scalars['String']>;
  sourceLogoUrl?: Maybe<Scalars['String']>;
  sourceOrganizerId?: Maybe<Scalars['String']>;
  sourceOrganizerImageUrl?: Maybe<Scalars['String']>;
  sourceOrganizerTitle?: Maybe<Scalars['String']>;
  sourceRegistrationCount?: Maybe<Scalars['Int']>;
  sourceVenueTitle?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['date']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  streetPrimaryString?: Maybe<Scalars['String']>;
  streetSecondaryString?: Maybe<Scalars['String']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
  zipcodeString?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "events" */
export type EventsMutationResponse = {
  __typename?: 'EventsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Events>;
};

/** input type for inserting object relation for remote table "events" */
export type EventsObjRelInsertInput = {
  data: EventsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EventsOnConflict>;
};

/** on_conflict condition type for table "events" */
export type EventsOnConflict = {
  constraint: EventsConstraint;
  updateColumns?: Array<EventsUpdateColumn>;
  where?: InputMaybe<EventsBoolExp>;
};

/** Ordering options when selecting data from "events". */
export type EventsOrderBy = {
  addressString?: InputMaybe<OrderBy>;
  archivedAt?: InputMaybe<OrderBy>;
  ballCustomName?: InputMaybe<OrderBy>;
  ballType?: InputMaybe<OrderBy>;
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  city?: InputMaybe<CitiesOrderBy>;
  cityId?: InputMaybe<OrderBy>;
  cityString?: InputMaybe<OrderBy>;
  contactDetails?: InputMaybe<EventContactDetailsOrderBy>;
  countryString?: InputMaybe<OrderBy>;
  courtsAggregate?: InputMaybe<EventCourtsAggregateOrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImageFileType?: InputMaybe<OrderBy>;
  coverImageHost?: InputMaybe<OrderBy>;
  coverImageOriginalFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  displayLocation?: InputMaybe<OrderBy>;
  endDate?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  externalUrl?: InputMaybe<OrderBy>;
  faqsAggregate?: InputMaybe<EventFaqsAggregateOrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupFormat?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<EventGroupsAggregateOrderBy>;
  hasPrizes?: InputMaybe<OrderBy>;
  hostUser?: InputMaybe<UsersOrderBy>;
  hostUserId?: InputMaybe<OrderBy>;
  hostUserProfile?: InputMaybe<UserProfilesOrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationsAggregate?: InputMaybe<EventInvitationsAggregateOrderBy>;
  isExternal?: InputMaybe<OrderBy>;
  isRatingRequired?: InputMaybe<OrderBy>;
  isRegisterOffPlatform?: InputMaybe<OrderBy>;
  isSanctioned?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  listingFeesAggregate?: InputMaybe<EventListingFeesAggregateOrderBy>;
  locale?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  organizerImageFileName?: InputMaybe<OrderBy>;
  organizerImageFileType?: InputMaybe<OrderBy>;
  organizerImageHost?: InputMaybe<OrderBy>;
  organizerImageOriginalFileName?: InputMaybe<OrderBy>;
  organizerImagePath?: InputMaybe<OrderBy>;
  organizerImageProvider?: InputMaybe<OrderBy>;
  organizerImageProviderUrl?: InputMaybe<OrderBy>;
  organizerImageUrl?: InputMaybe<OrderBy>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesOrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  prizeDescription?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  regionString?: InputMaybe<OrderBy>;
  registrationClosedAt?: InputMaybe<OrderBy>;
  registrationDeadlineDate?: InputMaybe<OrderBy>;
  registrationDeadlineDateTime?: InputMaybe<OrderBy>;
  registrationOpenDate?: InputMaybe<OrderBy>;
  registrationOpenDateTime?: InputMaybe<OrderBy>;
  registrationPriceUnitAmount?: InputMaybe<OrderBy>;
  registrationsAggregate?: InputMaybe<EventRegistrationsAggregateOrderBy>;
  scoringFormat?: InputMaybe<OrderBy>;
  showInPublicDate?: InputMaybe<OrderBy>;
  showInPublicDateTime?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceEventId?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceIsAdvertiseOnly?: InputMaybe<OrderBy>;
  sourceIsFeatured?: InputMaybe<OrderBy>;
  sourceIsFeaturedPlus?: InputMaybe<OrderBy>;
  sourceLocationCity?: InputMaybe<OrderBy>;
  sourceLocationCountry?: InputMaybe<OrderBy>;
  sourceLocationState?: InputMaybe<OrderBy>;
  sourceLocationStreetAddress?: InputMaybe<OrderBy>;
  sourceLocationZip?: InputMaybe<OrderBy>;
  sourceLogoUrl?: InputMaybe<OrderBy>;
  sourceOrganizerId?: InputMaybe<OrderBy>;
  sourceOrganizerImageUrl?: InputMaybe<OrderBy>;
  sourceOrganizerTitle?: InputMaybe<OrderBy>;
  sourceRegistrationCount?: InputMaybe<OrderBy>;
  sourceVenueTitle?: InputMaybe<OrderBy>;
  sponsorsAggregate?: InputMaybe<EventSponsorsAggregateOrderBy>;
  sport?: InputMaybe<OrderBy>;
  startDate?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  streetPrimaryString?: InputMaybe<OrderBy>;
  streetSecondaryString?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  transactionsAggregate?: InputMaybe<EventTransactionsAggregateOrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
  zipcodeString?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: events */
export type EventsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "events" */
export enum EventsSelectColumn {
  /** column name */
  AddressString = 'addressString',
  /** column name */
  ArchivedAt = 'archivedAt',
  /** column name */
  BallCustomName = 'ballCustomName',
  /** column name */
  BallType = 'ballType',
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CityId = 'cityId',
  /** column name */
  CityString = 'cityString',
  /** column name */
  CountryString = 'countryString',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImageFileType = 'coverImageFileType',
  /** column name */
  CoverImageHost = 'coverImageHost',
  /** column name */
  CoverImageOriginalFileName = 'coverImageOriginalFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DisplayLocation = 'displayLocation',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExternalUrl = 'externalUrl',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  GroupFormat = 'groupFormat',
  /** column name */
  HasPrizes = 'hasPrizes',
  /** column name */
  HostUserId = 'hostUserId',
  /** column name */
  Id = 'id',
  /** column name */
  IsExternal = 'isExternal',
  /** column name */
  IsRatingRequired = 'isRatingRequired',
  /** column name */
  IsRegisterOffPlatform = 'isRegisterOffPlatform',
  /** column name */
  IsSanctioned = 'isSanctioned',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Locale = 'locale',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  OrganizerImageFileName = 'organizerImageFileName',
  /** column name */
  OrganizerImageFileType = 'organizerImageFileType',
  /** column name */
  OrganizerImageHost = 'organizerImageHost',
  /** column name */
  OrganizerImageOriginalFileName = 'organizerImageOriginalFileName',
  /** column name */
  OrganizerImagePath = 'organizerImagePath',
  /** column name */
  OrganizerImageProvider = 'organizerImageProvider',
  /** column name */
  OrganizerImageProviderUrl = 'organizerImageProviderUrl',
  /** column name */
  OrganizerImageUrl = 'organizerImageUrl',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PrizeDescription = 'prizeDescription',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  RegionString = 'regionString',
  /** column name */
  RegistrationClosedAt = 'registrationClosedAt',
  /** column name */
  RegistrationDeadlineDate = 'registrationDeadlineDate',
  /** column name */
  RegistrationDeadlineDateTime = 'registrationDeadlineDateTime',
  /** column name */
  RegistrationOpenDate = 'registrationOpenDate',
  /** column name */
  RegistrationOpenDateTime = 'registrationOpenDateTime',
  /** column name */
  RegistrationPriceUnitAmount = 'registrationPriceUnitAmount',
  /** column name */
  ScoringFormat = 'scoringFormat',
  /** column name */
  ShowInPublicDate = 'showInPublicDate',
  /** column name */
  ShowInPublicDateTime = 'showInPublicDateTime',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceEventId = 'sourceEventId',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  SourceIsAdvertiseOnly = 'sourceIsAdvertiseOnly',
  /** column name */
  SourceIsFeatured = 'sourceIsFeatured',
  /** column name */
  SourceIsFeaturedPlus = 'sourceIsFeaturedPlus',
  /** column name */
  SourceLocationCity = 'sourceLocationCity',
  /** column name */
  SourceLocationCountry = 'sourceLocationCountry',
  /** column name */
  SourceLocationState = 'sourceLocationState',
  /** column name */
  SourceLocationStreetAddress = 'sourceLocationStreetAddress',
  /** column name */
  SourceLocationZip = 'sourceLocationZip',
  /** column name */
  SourceLogoUrl = 'sourceLogoUrl',
  /** column name */
  SourceOrganizerId = 'sourceOrganizerId',
  /** column name */
  SourceOrganizerImageUrl = 'sourceOrganizerImageUrl',
  /** column name */
  SourceOrganizerTitle = 'sourceOrganizerTitle',
  /** column name */
  SourceRegistrationCount = 'sourceRegistrationCount',
  /** column name */
  SourceVenueTitle = 'sourceVenueTitle',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  StreetPrimaryString = 'streetPrimaryString',
  /** column name */
  StreetSecondaryString = 'streetSecondaryString',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId',
  /** column name */
  ZipcodeString = 'zipcodeString'
}

/** input type for updating data in table "events" */
export type EventsSetInput = {
  addressString?: InputMaybe<Scalars['String']>;
  archivedAt?: InputMaybe<Scalars['timestamptz']>;
  ballCustomName?: InputMaybe<Scalars['String']>;
  ballType?: InputMaybe<BallTypesEnum>;
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  cityString?: InputMaybe<Scalars['String']>;
  countryString?: InputMaybe<Scalars['String']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImageFileType?: InputMaybe<Scalars['String']>;
  coverImageHost?: InputMaybe<Scalars['String']>;
  coverImageOriginalFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  /** Fallback for when we don't have a city_id */
  displayLocation?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['date']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  externalUrl?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groupFormat?: InputMaybe<EventGroupFormatsEnum>;
  hasPrizes?: InputMaybe<Scalars['Boolean']>;
  hostUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  isRatingRequired?: InputMaybe<Scalars['Boolean']>;
  isRegisterOffPlatform?: InputMaybe<Scalars['Boolean']>;
  isSanctioned?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  locale?: InputMaybe<Scalars['String']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  organizerImageFileName?: InputMaybe<Scalars['String']>;
  organizerImageFileType?: InputMaybe<Scalars['String']>;
  organizerImageHost?: InputMaybe<Scalars['String']>;
  organizerImageOriginalFileName?: InputMaybe<Scalars['String']>;
  organizerImagePath?: InputMaybe<Scalars['String']>;
  organizerImageProvider?: InputMaybe<Scalars['String']>;
  organizerImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: InputMaybe<Scalars['String']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<EventPrivacyEnum>;
  prizeDescription?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  regionString?: InputMaybe<Scalars['String']>;
  registrationClosedAt?: InputMaybe<Scalars['timestamptz']>;
  registrationDeadlineDate?: InputMaybe<Scalars['date']>;
  registrationDeadlineDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationOpenDate?: InputMaybe<Scalars['date']>;
  registrationOpenDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  showInPublicDate?: InputMaybe<Scalars['date']>;
  showInPublicDateTime?: InputMaybe<Scalars['timestamptz']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceEventId?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceIsAdvertiseOnly?: InputMaybe<Scalars['Boolean']>;
  sourceIsFeatured?: InputMaybe<Scalars['Boolean']>;
  sourceIsFeaturedPlus?: InputMaybe<Scalars['Boolean']>;
  sourceLocationCity?: InputMaybe<Scalars['String']>;
  sourceLocationCountry?: InputMaybe<Scalars['String']>;
  sourceLocationState?: InputMaybe<Scalars['String']>;
  sourceLocationStreetAddress?: InputMaybe<Scalars['String']>;
  sourceLocationZip?: InputMaybe<Scalars['String']>;
  sourceLogoUrl?: InputMaybe<Scalars['String']>;
  sourceOrganizerId?: InputMaybe<Scalars['String']>;
  sourceOrganizerImageUrl?: InputMaybe<Scalars['String']>;
  sourceOrganizerTitle?: InputMaybe<Scalars['String']>;
  sourceRegistrationCount?: InputMaybe<Scalars['Int']>;
  sourceVenueTitle?: InputMaybe<Scalars['String']>;
  sport?: InputMaybe<SportsEnum>;
  startDate?: InputMaybe<Scalars['date']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<EventStatusesEnum>;
  streetPrimaryString?: InputMaybe<Scalars['String']>;
  streetSecondaryString?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<EventTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
  zipcodeString?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type EventsStddevFields = {
  __typename?: 'EventsStddevFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type EventsStddevPopFields = {
  __typename?: 'EventsStddevPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type EventsStddevSampFields = {
  __typename?: 'EventsStddevSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "events" */
export type EventsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventsStreamCursorValueInput = {
  addressString?: InputMaybe<Scalars['String']>;
  archivedAt?: InputMaybe<Scalars['timestamptz']>;
  ballCustomName?: InputMaybe<Scalars['String']>;
  ballType?: InputMaybe<BallTypesEnum>;
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  cityString?: InputMaybe<Scalars['String']>;
  countryString?: InputMaybe<Scalars['String']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImageFileType?: InputMaybe<Scalars['String']>;
  coverImageHost?: InputMaybe<Scalars['String']>;
  coverImageOriginalFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  /** Fallback for when we don't have a city_id */
  displayLocation?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['date']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  externalUrl?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groupFormat?: InputMaybe<EventGroupFormatsEnum>;
  hasPrizes?: InputMaybe<Scalars['Boolean']>;
  hostUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  isRatingRequired?: InputMaybe<Scalars['Boolean']>;
  isRegisterOffPlatform?: InputMaybe<Scalars['Boolean']>;
  isSanctioned?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  locale?: InputMaybe<Scalars['String']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  organizerImageFileName?: InputMaybe<Scalars['String']>;
  organizerImageFileType?: InputMaybe<Scalars['String']>;
  organizerImageHost?: InputMaybe<Scalars['String']>;
  organizerImageOriginalFileName?: InputMaybe<Scalars['String']>;
  organizerImagePath?: InputMaybe<Scalars['String']>;
  organizerImageProvider?: InputMaybe<Scalars['String']>;
  organizerImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** Note: Use this if it exists, otherwise check the organizer's profile to use their logo */
  organizerImageUrl?: InputMaybe<Scalars['String']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  privacy?: InputMaybe<EventPrivacyEnum>;
  prizeDescription?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  regionString?: InputMaybe<Scalars['String']>;
  registrationClosedAt?: InputMaybe<Scalars['timestamptz']>;
  registrationDeadlineDate?: InputMaybe<Scalars['date']>;
  registrationDeadlineDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationOpenDate?: InputMaybe<Scalars['date']>;
  registrationOpenDateTime?: InputMaybe<Scalars['timestamptz']>;
  registrationPriceUnitAmount?: InputMaybe<Scalars['Int']>;
  scoringFormat?: InputMaybe<ScoringFormatEnum>;
  showInPublicDate?: InputMaybe<Scalars['date']>;
  showInPublicDateTime?: InputMaybe<Scalars['timestamptz']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceEventId?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceIsAdvertiseOnly?: InputMaybe<Scalars['Boolean']>;
  sourceIsFeatured?: InputMaybe<Scalars['Boolean']>;
  sourceIsFeaturedPlus?: InputMaybe<Scalars['Boolean']>;
  sourceLocationCity?: InputMaybe<Scalars['String']>;
  sourceLocationCountry?: InputMaybe<Scalars['String']>;
  sourceLocationState?: InputMaybe<Scalars['String']>;
  sourceLocationStreetAddress?: InputMaybe<Scalars['String']>;
  sourceLocationZip?: InputMaybe<Scalars['String']>;
  sourceLogoUrl?: InputMaybe<Scalars['String']>;
  sourceOrganizerId?: InputMaybe<Scalars['String']>;
  sourceOrganizerImageUrl?: InputMaybe<Scalars['String']>;
  sourceOrganizerTitle?: InputMaybe<Scalars['String']>;
  sourceRegistrationCount?: InputMaybe<Scalars['Int']>;
  sourceVenueTitle?: InputMaybe<Scalars['String']>;
  sport?: InputMaybe<SportsEnum>;
  startDate?: InputMaybe<Scalars['date']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<EventStatusesEnum>;
  streetPrimaryString?: InputMaybe<Scalars['String']>;
  streetSecondaryString?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<EventTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
  zipcodeString?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type EventsSumFields = {
  __typename?: 'EventsSumFields';
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Int']>;
  sourceRegistrationCount?: Maybe<Scalars['Int']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
};

/** update columns of table "events" */
export enum EventsUpdateColumn {
  /** column name */
  AddressString = 'addressString',
  /** column name */
  ArchivedAt = 'archivedAt',
  /** column name */
  BallCustomName = 'ballCustomName',
  /** column name */
  BallType = 'ballType',
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CityId = 'cityId',
  /** column name */
  CityString = 'cityString',
  /** column name */
  CountryString = 'countryString',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImageFileType = 'coverImageFileType',
  /** column name */
  CoverImageHost = 'coverImageHost',
  /** column name */
  CoverImageOriginalFileName = 'coverImageOriginalFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DisplayLocation = 'displayLocation',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExternalUrl = 'externalUrl',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  GroupFormat = 'groupFormat',
  /** column name */
  HasPrizes = 'hasPrizes',
  /** column name */
  HostUserId = 'hostUserId',
  /** column name */
  Id = 'id',
  /** column name */
  IsExternal = 'isExternal',
  /** column name */
  IsRatingRequired = 'isRatingRequired',
  /** column name */
  IsRegisterOffPlatform = 'isRegisterOffPlatform',
  /** column name */
  IsSanctioned = 'isSanctioned',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Locale = 'locale',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  OrganizerImageFileName = 'organizerImageFileName',
  /** column name */
  OrganizerImageFileType = 'organizerImageFileType',
  /** column name */
  OrganizerImageHost = 'organizerImageHost',
  /** column name */
  OrganizerImageOriginalFileName = 'organizerImageOriginalFileName',
  /** column name */
  OrganizerImagePath = 'organizerImagePath',
  /** column name */
  OrganizerImageProvider = 'organizerImageProvider',
  /** column name */
  OrganizerImageProviderUrl = 'organizerImageProviderUrl',
  /** column name */
  OrganizerImageUrl = 'organizerImageUrl',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PrizeDescription = 'prizeDescription',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  RegionString = 'regionString',
  /** column name */
  RegistrationClosedAt = 'registrationClosedAt',
  /** column name */
  RegistrationDeadlineDate = 'registrationDeadlineDate',
  /** column name */
  RegistrationDeadlineDateTime = 'registrationDeadlineDateTime',
  /** column name */
  RegistrationOpenDate = 'registrationOpenDate',
  /** column name */
  RegistrationOpenDateTime = 'registrationOpenDateTime',
  /** column name */
  RegistrationPriceUnitAmount = 'registrationPriceUnitAmount',
  /** column name */
  ScoringFormat = 'scoringFormat',
  /** column name */
  ShowInPublicDate = 'showInPublicDate',
  /** column name */
  ShowInPublicDateTime = 'showInPublicDateTime',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceEventId = 'sourceEventId',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  SourceIsAdvertiseOnly = 'sourceIsAdvertiseOnly',
  /** column name */
  SourceIsFeatured = 'sourceIsFeatured',
  /** column name */
  SourceIsFeaturedPlus = 'sourceIsFeaturedPlus',
  /** column name */
  SourceLocationCity = 'sourceLocationCity',
  /** column name */
  SourceLocationCountry = 'sourceLocationCountry',
  /** column name */
  SourceLocationState = 'sourceLocationState',
  /** column name */
  SourceLocationStreetAddress = 'sourceLocationStreetAddress',
  /** column name */
  SourceLocationZip = 'sourceLocationZip',
  /** column name */
  SourceLogoUrl = 'sourceLogoUrl',
  /** column name */
  SourceOrganizerId = 'sourceOrganizerId',
  /** column name */
  SourceOrganizerImageUrl = 'sourceOrganizerImageUrl',
  /** column name */
  SourceOrganizerTitle = 'sourceOrganizerTitle',
  /** column name */
  SourceRegistrationCount = 'sourceRegistrationCount',
  /** column name */
  SourceVenueTitle = 'sourceVenueTitle',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  StreetPrimaryString = 'streetPrimaryString',
  /** column name */
  StreetSecondaryString = 'streetSecondaryString',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId',
  /** column name */
  ZipcodeString = 'zipcodeString'
}

export type EventsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventsSetInput>;
  /** filter the rows which have to be updated */
  where: EventsBoolExp;
};

/** aggregate varPop on columns */
export type EventsVarPopFields = {
  __typename?: 'EventsVarPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type EventsVarSampFields = {
  __typename?: 'EventsVarSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type EventsVarianceFields = {
  __typename?: 'EventsVarianceFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  registrationPriceUnitAmount?: Maybe<Scalars['Float']>;
  sourceRegistrationCount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "follow_statuses" */
export type FollowStatuses = {
  __typename?: 'FollowStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "follow_statuses" */
export type FollowStatusesAggregate = {
  __typename?: 'FollowStatusesAggregate';
  aggregate?: Maybe<FollowStatusesAggregateFields>;
  nodes: Array<FollowStatuses>;
};

/** aggregate fields of "follow_statuses" */
export type FollowStatusesAggregateFields = {
  __typename?: 'FollowStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<FollowStatusesMaxFields>;
  min?: Maybe<FollowStatusesMinFields>;
};


/** aggregate fields of "follow_statuses" */
export type FollowStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FollowStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "follow_statuses". All fields are combined with a logical 'AND'. */
export type FollowStatusesBoolExp = {
  _and?: InputMaybe<Array<FollowStatusesBoolExp>>;
  _not?: InputMaybe<FollowStatusesBoolExp>;
  _or?: InputMaybe<Array<FollowStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "follow_statuses" */
export enum FollowStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  FollowStatusesPkey = 'follow_statuses_pkey'
}

export enum FollowStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "FollowStatusesEnum". All fields are combined with logical 'AND'. */
export type FollowStatusesEnumComparisonExp = {
  _eq?: InputMaybe<FollowStatusesEnum>;
  _in?: InputMaybe<Array<FollowStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<FollowStatusesEnum>;
  _nin?: InputMaybe<Array<FollowStatusesEnum>>;
};

/** input type for inserting data into table "follow_statuses" */
export type FollowStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type FollowStatusesMaxFields = {
  __typename?: 'FollowStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type FollowStatusesMinFields = {
  __typename?: 'FollowStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "follow_statuses" */
export type FollowStatusesMutationResponse = {
  __typename?: 'FollowStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FollowStatuses>;
};

/** on_conflict condition type for table "follow_statuses" */
export type FollowStatusesOnConflict = {
  constraint: FollowStatusesConstraint;
  updateColumns?: Array<FollowStatusesUpdateColumn>;
  where?: InputMaybe<FollowStatusesBoolExp>;
};

/** Ordering options when selecting data from "follow_statuses". */
export type FollowStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: follow_statuses */
export type FollowStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "follow_statuses" */
export enum FollowStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "follow_statuses" */
export type FollowStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "follow_statuses" */
export type FollowStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: FollowStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FollowStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "follow_statuses" */
export enum FollowStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type FollowStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FollowStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: FollowStatusesBoolExp;
};

/** columns and relationships of "gender" */
export type Gender = {
  __typename?: 'Gender';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "gender" */
export type GenderAggregate = {
  __typename?: 'GenderAggregate';
  aggregate?: Maybe<GenderAggregateFields>;
  nodes: Array<Gender>;
};

/** aggregate fields of "gender" */
export type GenderAggregateFields = {
  __typename?: 'GenderAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GenderMaxFields>;
  min?: Maybe<GenderMinFields>;
};


/** aggregate fields of "gender" */
export type GenderAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GenderSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'. */
export type GenderBoolExp = {
  _and?: InputMaybe<Array<GenderBoolExp>>;
  _not?: InputMaybe<GenderBoolExp>;
  _or?: InputMaybe<Array<GenderBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "gender" */
export enum GenderConstraint {
  /** unique or primary key constraint on columns "value" */
  GenderPkey = 'gender_pkey'
}

export enum GenderEnum {
  Female = 'FEMALE',
  Male = 'MALE',
  /** State your preference in a free text field */
  Preferred = 'PREFERRED',
  /** Choose not to disclose any gender */
  Private = 'PRIVATE'
}

/** Boolean expression to compare columns of type "GenderEnum". All fields are combined with logical 'AND'. */
export type GenderEnumComparisonExp = {
  _eq?: InputMaybe<GenderEnum>;
  _in?: InputMaybe<Array<GenderEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<GenderEnum>;
  _nin?: InputMaybe<Array<GenderEnum>>;
};

/** input type for inserting data into table "gender" */
export type GenderInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type GenderMaxFields = {
  __typename?: 'GenderMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type GenderMinFields = {
  __typename?: 'GenderMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "gender" */
export type GenderMutationResponse = {
  __typename?: 'GenderMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Gender>;
};

/** on_conflict condition type for table "gender" */
export type GenderOnConflict = {
  constraint: GenderConstraint;
  updateColumns?: Array<GenderUpdateColumn>;
  where?: InputMaybe<GenderBoolExp>;
};

/** Ordering options when selecting data from "gender". */
export type GenderOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: gender */
export type GenderPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "gender" */
export enum GenderSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "gender" */
export type GenderSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "gender" */
export type GenderStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GenderStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GenderStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "gender" */
export enum GenderUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type GenderUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GenderSetInput>;
  /** filter the rows which have to be updated */
  where: GenderBoolExp;
};

export type GeographyCastExp = {
  geometry?: InputMaybe<GeometryComparisonExp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type GeographyComparisonExp = {
  _cast?: InputMaybe<GeographyCastExp>;
  _eq?: InputMaybe<Scalars['geography']>;
  _gt?: InputMaybe<Scalars['geography']>;
  _gte?: InputMaybe<Scalars['geography']>;
  _in?: InputMaybe<Array<Scalars['geography']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['geography']>;
  _lte?: InputMaybe<Scalars['geography']>;
  _neq?: InputMaybe<Scalars['geography']>;
  _nin?: InputMaybe<Array<Scalars['geography']>>;
  /** is the column within a given distance from the given geography value */
  _stDWithin?: InputMaybe<St_D_Within_Geography_Input>;
  /** does the column spatially intersect the given geography value */
  _stIntersects?: InputMaybe<Scalars['geography']>;
};

export type GeometryCastExp = {
  geography?: InputMaybe<GeographyComparisonExp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type GeometryComparisonExp = {
  _cast?: InputMaybe<GeometryCastExp>;
  _eq?: InputMaybe<Scalars['geometry']>;
  _gt?: InputMaybe<Scalars['geometry']>;
  _gte?: InputMaybe<Scalars['geometry']>;
  _in?: InputMaybe<Array<Scalars['geometry']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['geometry']>;
  _lte?: InputMaybe<Scalars['geometry']>;
  _neq?: InputMaybe<Scalars['geometry']>;
  _nin?: InputMaybe<Array<Scalars['geometry']>>;
  /** is the column within a given 3D distance from the given geometry value */
  _st3dDWithin?: InputMaybe<St_D_Within_Input>;
  /** does the column spatially intersect the given geometry value in 3D */
  _st3dIntersects?: InputMaybe<Scalars['geometry']>;
  /** does the column contain the given geometry value */
  _stContains?: InputMaybe<Scalars['geometry']>;
  /** does the column cross the given geometry value */
  _stCrosses?: InputMaybe<Scalars['geometry']>;
  /** is the column within a given distance from the given geometry value */
  _stDWithin?: InputMaybe<St_D_Within_Input>;
  /** is the column equal to given geometry value (directionality is ignored) */
  _stEquals?: InputMaybe<Scalars['geometry']>;
  /** does the column spatially intersect the given geometry value */
  _stIntersects?: InputMaybe<Scalars['geometry']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  _stOverlaps?: InputMaybe<Scalars['geometry']>;
  /** does the column have atleast one point in common with the given geometry value */
  _stTouches?: InputMaybe<Scalars['geometry']>;
  /** is the column contained in the given geometry value */
  _stWithin?: InputMaybe<Scalars['geometry']>;
};

/** columns and relationships of "group_comment_votes" */
export type GroupCommentVotes = {
  __typename?: 'GroupCommentVotes';
  /** An object relationship */
  comment: GroupThreadComments;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupThreadCommentId: Scalars['uuid'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  vote: CommentVoteEnum;
};

/** aggregated selection of "group_comment_votes" */
export type GroupCommentVotesAggregate = {
  __typename?: 'GroupCommentVotesAggregate';
  aggregate?: Maybe<GroupCommentVotesAggregateFields>;
  nodes: Array<GroupCommentVotes>;
};

export type GroupCommentVotesAggregateBoolExp = {
  count?: InputMaybe<GroupCommentVotesAggregateBoolExpCount>;
};

/** aggregate fields of "group_comment_votes" */
export type GroupCommentVotesAggregateFields = {
  __typename?: 'GroupCommentVotesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupCommentVotesMaxFields>;
  min?: Maybe<GroupCommentVotesMinFields>;
};


/** aggregate fields of "group_comment_votes" */
export type GroupCommentVotesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_comment_votes" */
export type GroupCommentVotesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupCommentVotesMaxOrderBy>;
  min?: InputMaybe<GroupCommentVotesMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_comment_votes" */
export type GroupCommentVotesArrRelInsertInput = {
  data: Array<GroupCommentVotesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupCommentVotesOnConflict>;
};

/** Boolean expression to filter rows from the table "group_comment_votes". All fields are combined with a logical 'AND'. */
export type GroupCommentVotesBoolExp = {
  _and?: InputMaybe<Array<GroupCommentVotesBoolExp>>;
  _not?: InputMaybe<GroupCommentVotesBoolExp>;
  _or?: InputMaybe<Array<GroupCommentVotesBoolExp>>;
  comment?: InputMaybe<GroupThreadCommentsBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  groupThreadCommentId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  vote?: InputMaybe<CommentVoteEnumComparisonExp>;
};

/** unique or primary key constraints on table "group_comment_votes" */
export enum GroupCommentVotesConstraint {
  /** unique or primary key constraint on columns "user_id", "group_thread_comment_id" */
  GroupCommentVotesGroupThreadCommentIdUserIdKey = 'group_comment_votes_group_thread_comment_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupCommentVotesPkey = 'group_comment_votes_pkey'
}

/** input type for inserting data into table "group_comment_votes" */
export type GroupCommentVotesInsertInput = {
  comment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  vote?: InputMaybe<CommentVoteEnum>;
};

/** aggregate max on columns */
export type GroupCommentVotesMaxFields = {
  __typename?: 'GroupCommentVotesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_comment_votes" */
export type GroupCommentVotesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupCommentVotesMinFields = {
  __typename?: 'GroupCommentVotesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_comment_votes" */
export type GroupCommentVotesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_comment_votes" */
export type GroupCommentVotesMutationResponse = {
  __typename?: 'GroupCommentVotesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupCommentVotes>;
};

/** on_conflict condition type for table "group_comment_votes" */
export type GroupCommentVotesOnConflict = {
  constraint: GroupCommentVotesConstraint;
  updateColumns?: Array<GroupCommentVotesUpdateColumn>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};

/** Ordering options when selecting data from "group_comment_votes". */
export type GroupCommentVotesOrderBy = {
  comment?: InputMaybe<GroupThreadCommentsOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  vote?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_comment_votes */
export type GroupCommentVotesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_comment_votes" */
export enum GroupCommentVotesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Vote = 'vote'
}

/** input type for updating data in table "group_comment_votes" */
export type GroupCommentVotesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  vote?: InputMaybe<CommentVoteEnum>;
};

/** Streaming cursor of the table "group_comment_votes" */
export type GroupCommentVotesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupCommentVotesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupCommentVotesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  vote?: InputMaybe<CommentVoteEnum>;
};

/** update columns of table "group_comment_votes" */
export enum GroupCommentVotesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Vote = 'vote'
}

export type GroupCommentVotesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupCommentVotesSetInput>;
  /** filter the rows which have to be updated */
  where: GroupCommentVotesBoolExp;
};

/** columns and relationships of "group_members" */
export type GroupMembers = {
  __typename?: 'GroupMembers';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  isActive: Scalars['Boolean'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "group_members" */
export type GroupMembersAggregate = {
  __typename?: 'GroupMembersAggregate';
  aggregate?: Maybe<GroupMembersAggregateFields>;
  nodes: Array<GroupMembers>;
};

export type GroupMembersAggregateBoolExp = {
  bool_and?: InputMaybe<GroupMembersAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<GroupMembersAggregateBoolExpBool_Or>;
  count?: InputMaybe<GroupMembersAggregateBoolExpCount>;
};

/** aggregate fields of "group_members" */
export type GroupMembersAggregateFields = {
  __typename?: 'GroupMembersAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupMembersMaxFields>;
  min?: Maybe<GroupMembersMinFields>;
};


/** aggregate fields of "group_members" */
export type GroupMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_members" */
export type GroupMembersAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupMembersMaxOrderBy>;
  min?: InputMaybe<GroupMembersMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_members" */
export type GroupMembersArrRelInsertInput = {
  data: Array<GroupMembersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupMembersOnConflict>;
};

/** Boolean expression to filter rows from the table "group_members". All fields are combined with a logical 'AND'. */
export type GroupMembersBoolExp = {
  _and?: InputMaybe<Array<GroupMembersBoolExp>>;
  _not?: InputMaybe<GroupMembersBoolExp>;
  _or?: InputMaybe<Array<GroupMembersBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "group_members" */
export enum GroupMembersConstraint {
  /** unique or primary key constraint on columns "user_id", "group_id" */
  GroupMembersGroupIdUserIdKey = 'group_members_group_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupMembersPkey = 'group_members_pkey'
}

/** input type for inserting data into table "group_members" */
export type GroupMembersInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<GroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type GroupMembersMaxFields = {
  __typename?: 'GroupMembersMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_members" */
export type GroupMembersMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupMembersMinFields = {
  __typename?: 'GroupMembersMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_members" */
export type GroupMembersMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_members" */
export type GroupMembersMutationResponse = {
  __typename?: 'GroupMembersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupMembers>;
};

/** on_conflict condition type for table "group_members" */
export type GroupMembersOnConflict = {
  constraint: GroupMembersConstraint;
  updateColumns?: Array<GroupMembersUpdateColumn>;
  where?: InputMaybe<GroupMembersBoolExp>;
};

/** Ordering options when selecting data from "group_members". */
export type GroupMembersOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: group_members */
export type GroupMembersPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_members" */
export enum GroupMembersSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "groupMembersAggregateBoolExpBool_andArgumentsColumns" columns of table "group_members" */
export enum GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsActive = 'isActive'
}

/** select "groupMembersAggregateBoolExpBool_orArgumentsColumns" columns of table "group_members" */
export enum GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsActive = 'isActive'
}

/** input type for updating data in table "group_members" */
export type GroupMembersSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "group_members" */
export type GroupMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupMembersStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_members" */
export enum GroupMembersUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type GroupMembersUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupMembersSetInput>;
  /** filter the rows which have to be updated */
  where: GroupMembersBoolExp;
};

/** columns and relationships of "group_thread_comment_files" */
export type GroupThreadCommentFiles = {
  __typename?: 'GroupThreadCommentFiles';
  /** An object relationship */
  comment: GroupThreadComments;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName: Scalars['String'];
  fileType: Scalars['String'];
  groupThreadCommentId: Scalars['uuid'];
  host: Scalars['String'];
  id: Scalars['uuid'];
  isVisible: Scalars['Boolean'];
  originalFileName?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  provider: Scalars['String'];
  providerUrl: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  url: Scalars['String'];
  userId: Scalars['uuid'];
};

/** aggregated selection of "group_thread_comment_files" */
export type GroupThreadCommentFilesAggregate = {
  __typename?: 'GroupThreadCommentFilesAggregate';
  aggregate?: Maybe<GroupThreadCommentFilesAggregateFields>;
  nodes: Array<GroupThreadCommentFiles>;
};

export type GroupThreadCommentFilesAggregateBoolExp = {
  bool_and?: InputMaybe<GroupThreadCommentFilesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<GroupThreadCommentFilesAggregateBoolExpBool_Or>;
  count?: InputMaybe<GroupThreadCommentFilesAggregateBoolExpCount>;
};

/** aggregate fields of "group_thread_comment_files" */
export type GroupThreadCommentFilesAggregateFields = {
  __typename?: 'GroupThreadCommentFilesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupThreadCommentFilesMaxFields>;
  min?: Maybe<GroupThreadCommentFilesMinFields>;
};


/** aggregate fields of "group_thread_comment_files" */
export type GroupThreadCommentFilesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_thread_comment_files" */
export type GroupThreadCommentFilesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupThreadCommentFilesMaxOrderBy>;
  min?: InputMaybe<GroupThreadCommentFilesMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_thread_comment_files" */
export type GroupThreadCommentFilesArrRelInsertInput = {
  data: Array<GroupThreadCommentFilesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadCommentFilesOnConflict>;
};

/** Boolean expression to filter rows from the table "group_thread_comment_files". All fields are combined with a logical 'AND'. */
export type GroupThreadCommentFilesBoolExp = {
  _and?: InputMaybe<Array<GroupThreadCommentFilesBoolExp>>;
  _not?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  _or?: InputMaybe<Array<GroupThreadCommentFilesBoolExp>>;
  comment?: InputMaybe<GroupThreadCommentsBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fileName?: InputMaybe<StringComparisonExp>;
  fileType?: InputMaybe<StringComparisonExp>;
  groupThreadCommentId?: InputMaybe<UuidComparisonExp>;
  host?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isVisible?: InputMaybe<BooleanComparisonExp>;
  originalFileName?: InputMaybe<StringComparisonExp>;
  path?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerUrl?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "group_thread_comment_files" */
export enum GroupThreadCommentFilesConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupThreadCommentFilesPkey = 'group_thread_comment_files_pkey'
}

/** input type for inserting data into table "group_thread_comment_files" */
export type GroupThreadCommentFilesInsertInput = {
  comment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  originalFileName?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type GroupThreadCommentFilesMaxFields = {
  __typename?: 'GroupThreadCommentFilesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName?: Maybe<Scalars['String']>;
  fileType?: Maybe<Scalars['String']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  host?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  originalFileName?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerUrl?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  url?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_thread_comment_files" */
export type GroupThreadCommentFilesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalFileName?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupThreadCommentFilesMinFields = {
  __typename?: 'GroupThreadCommentFilesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName?: Maybe<Scalars['String']>;
  fileType?: Maybe<Scalars['String']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  host?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  originalFileName?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerUrl?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  url?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_thread_comment_files" */
export type GroupThreadCommentFilesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalFileName?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_thread_comment_files" */
export type GroupThreadCommentFilesMutationResponse = {
  __typename?: 'GroupThreadCommentFilesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupThreadCommentFiles>;
};

/** on_conflict condition type for table "group_thread_comment_files" */
export type GroupThreadCommentFilesOnConflict = {
  constraint: GroupThreadCommentFilesConstraint;
  updateColumns?: Array<GroupThreadCommentFilesUpdateColumn>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};

/** Ordering options when selecting data from "group_thread_comment_files". */
export type GroupThreadCommentFilesOrderBy = {
  comment?: InputMaybe<GroupThreadCommentsOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isVisible?: InputMaybe<OrderBy>;
  originalFileName?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_thread_comment_files */
export type GroupThreadCommentFilesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_thread_comment_files" */
export enum GroupThreadCommentFilesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  FileType = 'fileType',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  Host = 'host',
  /** column name */
  Id = 'id',
  /** column name */
  IsVisible = 'isVisible',
  /** column name */
  OriginalFileName = 'originalFileName',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  UserId = 'userId'
}

/** select "groupThreadCommentFilesAggregateBoolExpBool_andArgumentsColumns" columns of table "group_thread_comment_files" */
export enum GroupThreadCommentFilesSelectColumnGroupThreadCommentFilesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsVisible = 'isVisible'
}

/** select "groupThreadCommentFilesAggregateBoolExpBool_orArgumentsColumns" columns of table "group_thread_comment_files" */
export enum GroupThreadCommentFilesSelectColumnGroupThreadCommentFilesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsVisible = 'isVisible'
}

/** input type for updating data in table "group_thread_comment_files" */
export type GroupThreadCommentFilesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  originalFileName?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "group_thread_comment_files" */
export type GroupThreadCommentFilesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupThreadCommentFilesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupThreadCommentFilesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  originalFileName?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_thread_comment_files" */
export enum GroupThreadCommentFilesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  FileType = 'fileType',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  Host = 'host',
  /** column name */
  Id = 'id',
  /** column name */
  IsVisible = 'isVisible',
  /** column name */
  OriginalFileName = 'originalFileName',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  UserId = 'userId'
}

export type GroupThreadCommentFilesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupThreadCommentFilesSetInput>;
  /** filter the rows which have to be updated */
  where: GroupThreadCommentFilesBoolExp;
};

/** columns and relationships of "group_thread_comments" */
export type GroupThreadComments = {
  __typename?: 'GroupThreadComments';
  /** An array relationship */
  allChildComments: Array<GroupThreadComments>;
  /** An aggregate relationship */
  allChildCommentsAggregate: GroupThreadCommentsAggregate;
  content: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  files: Array<GroupThreadCommentFiles>;
  /** An aggregate relationship */
  filesAggregate: GroupThreadCommentFilesAggregate;
  groupCommentId?: Maybe<Scalars['uuid']>;
  groupRootCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId: Scalars['uuid'];
  id: Scalars['uuid'];
  isOriginalThreadComment: Scalars['Boolean'];
  /** An object relationship */
  parentComment?: Maybe<GroupThreadComments>;
  /** An array relationship */
  replies: Array<GroupThreadComments>;
  /** An aggregate relationship */
  repliesAggregate: GroupThreadCommentsAggregate;
  /** An object relationship */
  rootComment?: Maybe<GroupThreadComments>;
  /** An object relationship */
  thread: GroupThreads;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
  /** An array relationship */
  votes: Array<GroupCommentVotes>;
  /** An aggregate relationship */
  votesAggregate: GroupCommentVotesAggregate;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsAllChildCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsAllChildCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsFilesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsRepliesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsRepliesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsVotesArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


/** columns and relationships of "group_thread_comments" */
export type GroupThreadCommentsVotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};

/** aggregated selection of "group_thread_comments" */
export type GroupThreadCommentsAggregate = {
  __typename?: 'GroupThreadCommentsAggregate';
  aggregate?: Maybe<GroupThreadCommentsAggregateFields>;
  nodes: Array<GroupThreadComments>;
};

export type GroupThreadCommentsAggregateBoolExp = {
  bool_and?: InputMaybe<GroupThreadCommentsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<GroupThreadCommentsAggregateBoolExpBool_Or>;
  count?: InputMaybe<GroupThreadCommentsAggregateBoolExpCount>;
};

/** aggregate fields of "group_thread_comments" */
export type GroupThreadCommentsAggregateFields = {
  __typename?: 'GroupThreadCommentsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupThreadCommentsMaxFields>;
  min?: Maybe<GroupThreadCommentsMinFields>;
};


/** aggregate fields of "group_thread_comments" */
export type GroupThreadCommentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_thread_comments" */
export type GroupThreadCommentsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupThreadCommentsMaxOrderBy>;
  min?: InputMaybe<GroupThreadCommentsMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_thread_comments" */
export type GroupThreadCommentsArrRelInsertInput = {
  data: Array<GroupThreadCommentsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};

/** Boolean expression to filter rows from the table "group_thread_comments". All fields are combined with a logical 'AND'. */
export type GroupThreadCommentsBoolExp = {
  _and?: InputMaybe<Array<GroupThreadCommentsBoolExp>>;
  _not?: InputMaybe<GroupThreadCommentsBoolExp>;
  _or?: InputMaybe<Array<GroupThreadCommentsBoolExp>>;
  allChildComments?: InputMaybe<GroupThreadCommentsBoolExp>;
  allChildCommentsAggregate?: InputMaybe<GroupThreadCommentsAggregateBoolExp>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  files?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  filesAggregate?: InputMaybe<GroupThreadCommentFilesAggregateBoolExp>;
  groupCommentId?: InputMaybe<UuidComparisonExp>;
  groupRootCommentId?: InputMaybe<UuidComparisonExp>;
  groupThreadId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isOriginalThreadComment?: InputMaybe<BooleanComparisonExp>;
  parentComment?: InputMaybe<GroupThreadCommentsBoolExp>;
  replies?: InputMaybe<GroupThreadCommentsBoolExp>;
  repliesAggregate?: InputMaybe<GroupThreadCommentsAggregateBoolExp>;
  rootComment?: InputMaybe<GroupThreadCommentsBoolExp>;
  thread?: InputMaybe<GroupThreadsBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
  votes?: InputMaybe<GroupCommentVotesBoolExp>;
  votesAggregate?: InputMaybe<GroupCommentVotesAggregateBoolExp>;
};

/** unique or primary key constraints on table "group_thread_comments" */
export enum GroupThreadCommentsConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupThreadCommentsPkey = 'group_thread_comments_pkey'
}

/** input type for inserting data into table "group_thread_comments" */
export type GroupThreadCommentsInsertInput = {
  allChildComments?: InputMaybe<GroupThreadCommentsArrRelInsertInput>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  files?: InputMaybe<GroupThreadCommentFilesArrRelInsertInput>;
  groupCommentId?: InputMaybe<Scalars['uuid']>;
  groupRootCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isOriginalThreadComment?: InputMaybe<Scalars['Boolean']>;
  parentComment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  replies?: InputMaybe<GroupThreadCommentsArrRelInsertInput>;
  rootComment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  thread?: InputMaybe<GroupThreadsObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  votes?: InputMaybe<GroupCommentVotesArrRelInsertInput>;
};

/** aggregate max on columns */
export type GroupThreadCommentsMaxFields = {
  __typename?: 'GroupThreadCommentsMaxFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupCommentId?: Maybe<Scalars['uuid']>;
  groupRootCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_thread_comments" */
export type GroupThreadCommentsMaxOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupCommentId?: InputMaybe<OrderBy>;
  groupRootCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupThreadCommentsMinFields = {
  __typename?: 'GroupThreadCommentsMinFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupCommentId?: Maybe<Scalars['uuid']>;
  groupRootCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_thread_comments" */
export type GroupThreadCommentsMinOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupCommentId?: InputMaybe<OrderBy>;
  groupRootCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_thread_comments" */
export type GroupThreadCommentsMutationResponse = {
  __typename?: 'GroupThreadCommentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupThreadComments>;
};

/** input type for inserting object relation for remote table "group_thread_comments" */
export type GroupThreadCommentsObjRelInsertInput = {
  data: GroupThreadCommentsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};

/** on_conflict condition type for table "group_thread_comments" */
export type GroupThreadCommentsOnConflict = {
  constraint: GroupThreadCommentsConstraint;
  updateColumns?: Array<GroupThreadCommentsUpdateColumn>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};

/** Ordering options when selecting data from "group_thread_comments". */
export type GroupThreadCommentsOrderBy = {
  allChildCommentsAggregate?: InputMaybe<GroupThreadCommentsAggregateOrderBy>;
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  filesAggregate?: InputMaybe<GroupThreadCommentFilesAggregateOrderBy>;
  groupCommentId?: InputMaybe<OrderBy>;
  groupRootCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isOriginalThreadComment?: InputMaybe<OrderBy>;
  parentComment?: InputMaybe<GroupThreadCommentsOrderBy>;
  repliesAggregate?: InputMaybe<GroupThreadCommentsAggregateOrderBy>;
  rootComment?: InputMaybe<GroupThreadCommentsOrderBy>;
  thread?: InputMaybe<GroupThreadsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
  votesAggregate?: InputMaybe<GroupCommentVotesAggregateOrderBy>;
};

/** primary key columns input for table: group_thread_comments */
export type GroupThreadCommentsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_thread_comments" */
export enum GroupThreadCommentsSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupCommentId = 'groupCommentId',
  /** column name */
  GroupRootCommentId = 'groupRootCommentId',
  /** column name */
  GroupThreadId = 'groupThreadId',
  /** column name */
  Id = 'id',
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "groupThreadCommentsAggregateBoolExpBool_andArgumentsColumns" columns of table "group_thread_comments" */
export enum GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment'
}

/** select "groupThreadCommentsAggregateBoolExpBool_orArgumentsColumns" columns of table "group_thread_comments" */
export enum GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment'
}

/** input type for updating data in table "group_thread_comments" */
export type GroupThreadCommentsSetInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupCommentId?: InputMaybe<Scalars['uuid']>;
  groupRootCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isOriginalThreadComment?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "group_thread_comments" */
export type GroupThreadCommentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupThreadCommentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupThreadCommentsStreamCursorValueInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupCommentId?: InputMaybe<Scalars['uuid']>;
  groupRootCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isOriginalThreadComment?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_thread_comments" */
export enum GroupThreadCommentsUpdateColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupCommentId = 'groupCommentId',
  /** column name */
  GroupRootCommentId = 'groupRootCommentId',
  /** column name */
  GroupThreadId = 'groupThreadId',
  /** column name */
  Id = 'id',
  /** column name */
  IsOriginalThreadComment = 'isOriginalThreadComment',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type GroupThreadCommentsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupThreadCommentsSetInput>;
  /** filter the rows which have to be updated */
  where: GroupThreadCommentsBoolExp;
};

/** columns and relationships of "group_threads" */
export type GroupThreads = {
  __typename?: 'GroupThreads';
  /** An array relationship */
  comments: Array<GroupThreadComments>;
  /** An aggregate relationship */
  commentsAggregate: GroupThreadCommentsAggregate;
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creator: Users;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  userId: Scalars['uuid'];
};


/** columns and relationships of "group_threads" */
export type GroupThreadsCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


/** columns and relationships of "group_threads" */
export type GroupThreadsCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};

/** aggregated selection of "group_threads" */
export type GroupThreadsAggregate = {
  __typename?: 'GroupThreadsAggregate';
  aggregate?: Maybe<GroupThreadsAggregateFields>;
  nodes: Array<GroupThreads>;
};

export type GroupThreadsAggregateBoolExp = {
  count?: InputMaybe<GroupThreadsAggregateBoolExpCount>;
};

/** aggregate fields of "group_threads" */
export type GroupThreadsAggregateFields = {
  __typename?: 'GroupThreadsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupThreadsMaxFields>;
  min?: Maybe<GroupThreadsMinFields>;
};


/** aggregate fields of "group_threads" */
export type GroupThreadsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_threads" */
export type GroupThreadsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupThreadsMaxOrderBy>;
  min?: InputMaybe<GroupThreadsMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_threads" */
export type GroupThreadsArrRelInsertInput = {
  data: Array<GroupThreadsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};

/** Boolean expression to filter rows from the table "group_threads". All fields are combined with a logical 'AND'. */
export type GroupThreadsBoolExp = {
  _and?: InputMaybe<Array<GroupThreadsBoolExp>>;
  _not?: InputMaybe<GroupThreadsBoolExp>;
  _or?: InputMaybe<Array<GroupThreadsBoolExp>>;
  comments?: InputMaybe<GroupThreadCommentsBoolExp>;
  commentsAggregate?: InputMaybe<GroupThreadCommentsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creator?: InputMaybe<UsersBoolExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "group_threads" */
export enum GroupThreadsConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupThreadsPkey = 'group_threads_pkey'
}

/** input type for inserting data into table "group_threads" */
export type GroupThreadsInsertInput = {
  comments?: InputMaybe<GroupThreadCommentsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creator?: InputMaybe<UsersObjRelInsertInput>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<GroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type GroupThreadsMaxFields = {
  __typename?: 'GroupThreadsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_threads" */
export type GroupThreadsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupThreadsMinFields = {
  __typename?: 'GroupThreadsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_threads" */
export type GroupThreadsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_threads" */
export type GroupThreadsMutationResponse = {
  __typename?: 'GroupThreadsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupThreads>;
};

/** input type for inserting object relation for remote table "group_threads" */
export type GroupThreadsObjRelInsertInput = {
  data: GroupThreadsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};

/** on_conflict condition type for table "group_threads" */
export type GroupThreadsOnConflict = {
  constraint: GroupThreadsConstraint;
  updateColumns?: Array<GroupThreadsUpdateColumn>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};

/** Ordering options when selecting data from "group_threads". */
export type GroupThreadsOrderBy = {
  commentsAggregate?: InputMaybe<GroupThreadCommentsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creator?: InputMaybe<UsersOrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_threads */
export type GroupThreadsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_threads" */
export enum GroupThreadsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "group_threads" */
export type GroupThreadsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "group_threads" */
export type GroupThreadsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupThreadsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupThreadsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_threads" */
export enum GroupThreadsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type GroupThreadsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupThreadsSetInput>;
  /** filter the rows which have to be updated */
  where: GroupThreadsBoolExp;
};

/** columns and relationships of "group_venues" */
export type GroupVenues = {
  __typename?: 'GroupVenues';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "group_venues" */
export type GroupVenuesAggregate = {
  __typename?: 'GroupVenuesAggregate';
  aggregate?: Maybe<GroupVenuesAggregateFields>;
  nodes: Array<GroupVenues>;
};

export type GroupVenuesAggregateBoolExp = {
  count?: InputMaybe<GroupVenuesAggregateBoolExpCount>;
};

/** aggregate fields of "group_venues" */
export type GroupVenuesAggregateFields = {
  __typename?: 'GroupVenuesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupVenuesMaxFields>;
  min?: Maybe<GroupVenuesMinFields>;
};


/** aggregate fields of "group_venues" */
export type GroupVenuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_venues" */
export type GroupVenuesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupVenuesMaxOrderBy>;
  min?: InputMaybe<GroupVenuesMinOrderBy>;
};

/** input type for inserting array relation for remote table "group_venues" */
export type GroupVenuesArrRelInsertInput = {
  data: Array<GroupVenuesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupVenuesOnConflict>;
};

/** Boolean expression to filter rows from the table "group_venues". All fields are combined with a logical 'AND'. */
export type GroupVenuesBoolExp = {
  _and?: InputMaybe<Array<GroupVenuesBoolExp>>;
  _not?: InputMaybe<GroupVenuesBoolExp>;
  _or?: InputMaybe<Array<GroupVenuesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "group_venues" */
export enum GroupVenuesConstraint {
  /** unique or primary key constraint on columns "venue_id", "group_id" */
  GroupVenuesGroupIdVenueIdKey = 'group_venues_group_id_venue_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupVenuesPkey = 'group_venues_pkey'
}

/** input type for inserting data into table "group_venues" */
export type GroupVenuesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<GroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type GroupVenuesMaxFields = {
  __typename?: 'GroupVenuesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "group_venues" */
export type GroupVenuesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupVenuesMinFields = {
  __typename?: 'GroupVenuesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "group_venues" */
export type GroupVenuesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_venues" */
export type GroupVenuesMutationResponse = {
  __typename?: 'GroupVenuesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupVenues>;
};

/** on_conflict condition type for table "group_venues" */
export type GroupVenuesOnConflict = {
  constraint: GroupVenuesConstraint;
  updateColumns?: Array<GroupVenuesUpdateColumn>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};

/** Ordering options when selecting data from "group_venues". */
export type GroupVenuesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_venues */
export type GroupVenuesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "group_venues" */
export enum GroupVenuesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

/** input type for updating data in table "group_venues" */
export type GroupVenuesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "group_venues" */
export type GroupVenuesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupVenuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupVenuesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "group_venues" */
export enum GroupVenuesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

export type GroupVenuesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupVenuesSetInput>;
  /** filter the rows which have to be updated */
  where: GroupVenuesBoolExp;
};

/** columns and relationships of "groups" */
export type Groups = {
  __typename?: 'Groups';
  accessCode?: Maybe<Scalars['String']>;
  allowMemberInvites: Scalars['Boolean'];
  allowMemberSessionInvites: Scalars['Boolean'];
  /** An object relationship */
  city: Cities;
  cityId: Scalars['uuid'];
  contactEmail?: Maybe<Scalars['String']>;
  contactMessage?: Maybe<Scalars['String']>;
  contactPhoneNumber?: Maybe<Scalars['String']>;
  contactUrl?: Maybe<Scalars['String']>;
  coverPhotoUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  displayOwnerContactInfo: Scalars['Boolean'];
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  /** An aggregate relationship */
  groupsPlaySessionsAggregate: GroupsPlaySessionsAggregate;
  headline: Scalars['String'];
  id: Scalars['uuid'];
  isPrivate: Scalars['Boolean'];
  /** An array relationship */
  members: Array<GroupMembers>;
  /** An aggregate relationship */
  membersAggregate: GroupMembersAggregate;
  /** An object relationship */
  owner?: Maybe<Users>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  ownerUserProfile?: Maybe<UserProfiles>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  primarySport?: Maybe<SportsEnum>;
  profilePhotoUrl: Scalars['String'];
  skillLevelMaximum?: Maybe<Scalars['numeric']>;
  skillLevelMinimum?: Maybe<Scalars['numeric']>;
  slug: Scalars['String'];
  /** An array relationship */
  threads: Array<GroupThreads>;
  /** An aggregate relationship */
  threadsAggregate: GroupThreadsAggregate;
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  venues: Array<GroupVenues>;
  /** An aggregate relationship */
  venuesAggregate: GroupVenuesAggregate;
};


/** columns and relationships of "groups" */
export type GroupsGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsGroupsPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsMembersArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsThreadsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsThreadsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsVenuesArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


/** columns and relationships of "groups" */
export type GroupsVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};

/** aggregated selection of "groups" */
export type GroupsAggregate = {
  __typename?: 'GroupsAggregate';
  aggregate?: Maybe<GroupsAggregateFields>;
  nodes: Array<Groups>;
};

export type GroupsAggregateBoolExp = {
  bool_and?: InputMaybe<GroupsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<GroupsAggregateBoolExpBool_Or>;
  count?: InputMaybe<GroupsAggregateBoolExpCount>;
};

/** aggregate fields of "groups" */
export type GroupsAggregateFields = {
  __typename?: 'GroupsAggregateFields';
  avg?: Maybe<GroupsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<GroupsMaxFields>;
  min?: Maybe<GroupsMinFields>;
  stddev?: Maybe<GroupsStddevFields>;
  stddevPop?: Maybe<GroupsStddevPopFields>;
  stddevSamp?: Maybe<GroupsStddevSampFields>;
  sum?: Maybe<GroupsSumFields>;
  varPop?: Maybe<GroupsVarPopFields>;
  varSamp?: Maybe<GroupsVarSampFields>;
  variance?: Maybe<GroupsVarianceFields>;
};


/** aggregate fields of "groups" */
export type GroupsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "groups" */
export type GroupsAggregateOrderBy = {
  avg?: InputMaybe<GroupsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupsMaxOrderBy>;
  min?: InputMaybe<GroupsMinOrderBy>;
  stddev?: InputMaybe<GroupsStddevOrderBy>;
  stddevPop?: InputMaybe<GroupsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<GroupsStddevSampOrderBy>;
  sum?: InputMaybe<GroupsSumOrderBy>;
  varPop?: InputMaybe<GroupsVarPopOrderBy>;
  varSamp?: InputMaybe<GroupsVarSampOrderBy>;
  variance?: InputMaybe<GroupsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "groups" */
export type GroupsArrRelInsertInput = {
  data: Array<GroupsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupsOnConflict>;
};

/** aggregate avg on columns */
export type GroupsAvgFields = {
  __typename?: 'GroupsAvgFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "groups" */
export type GroupsAvgOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'. */
export type GroupsBoolExp = {
  _and?: InputMaybe<Array<GroupsBoolExp>>;
  _not?: InputMaybe<GroupsBoolExp>;
  _or?: InputMaybe<Array<GroupsBoolExp>>;
  accessCode?: InputMaybe<StringComparisonExp>;
  allowMemberInvites?: InputMaybe<BooleanComparisonExp>;
  allowMemberSessionInvites?: InputMaybe<BooleanComparisonExp>;
  city?: InputMaybe<CitiesBoolExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  contactEmail?: InputMaybe<StringComparisonExp>;
  contactMessage?: InputMaybe<StringComparisonExp>;
  contactPhoneNumber?: InputMaybe<StringComparisonExp>;
  contactUrl?: InputMaybe<StringComparisonExp>;
  coverPhotoUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  displayOwnerContactInfo?: InputMaybe<BooleanComparisonExp>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsBoolExp>;
  groupsPlaySessionsAggregate?: InputMaybe<GroupsPlaySessionsAggregateBoolExp>;
  headline?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isPrivate?: InputMaybe<BooleanComparisonExp>;
  members?: InputMaybe<GroupMembersBoolExp>;
  membersAggregate?: InputMaybe<GroupMembersAggregateBoolExp>;
  owner?: InputMaybe<UsersBoolExp>;
  ownerUserId?: InputMaybe<UuidComparisonExp>;
  ownerUserProfile?: InputMaybe<UserProfilesBoolExp>;
  playSessions?: InputMaybe<PlaySessionsBoolExp>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateBoolExp>;
  primarySport?: InputMaybe<SportsEnumComparisonExp>;
  profilePhotoUrl?: InputMaybe<StringComparisonExp>;
  skillLevelMaximum?: InputMaybe<NumericComparisonExp>;
  skillLevelMinimum?: InputMaybe<NumericComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  threads?: InputMaybe<GroupThreadsBoolExp>;
  threadsAggregate?: InputMaybe<GroupThreadsAggregateBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venues?: InputMaybe<GroupVenuesBoolExp>;
  venuesAggregate?: InputMaybe<GroupVenuesAggregateBoolExp>;
};

/** unique or primary key constraints on table "groups" */
export enum GroupsConstraint {
  /** unique or primary key constraint on columns "access_code" */
  GroupsAccessCodeKey = 'groups_access_code_key',
  /** unique or primary key constraint on columns "id" */
  GroupsPkey = 'groups_pkey',
  /** unique or primary key constraint on columns "slug" */
  GroupsSlugKey = 'groups_slug_key'
}

/** input type for incrementing numeric columns in table "groups" */
export type GroupsIncInput = {
  skillLevelMaximum?: InputMaybe<Scalars['numeric']>;
  skillLevelMinimum?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "groups" */
export type GroupsInsertInput = {
  accessCode?: InputMaybe<Scalars['String']>;
  allowMemberInvites?: InputMaybe<Scalars['Boolean']>;
  allowMemberSessionInvites?: InputMaybe<Scalars['Boolean']>;
  city?: InputMaybe<CitiesObjRelInsertInput>;
  cityId?: InputMaybe<Scalars['uuid']>;
  contactEmail?: InputMaybe<Scalars['String']>;
  contactMessage?: InputMaybe<Scalars['String']>;
  contactPhoneNumber?: InputMaybe<Scalars['String']>;
  contactUrl?: InputMaybe<Scalars['String']>;
  coverPhotoUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  displayOwnerContactInfo?: InputMaybe<Scalars['Boolean']>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsArrRelInsertInput>;
  headline?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  members?: InputMaybe<GroupMembersArrRelInsertInput>;
  owner?: InputMaybe<UsersObjRelInsertInput>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  ownerUserProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  playSessions?: InputMaybe<PlaySessionsArrRelInsertInput>;
  primarySport?: InputMaybe<SportsEnum>;
  profilePhotoUrl?: InputMaybe<Scalars['String']>;
  skillLevelMaximum?: InputMaybe<Scalars['numeric']>;
  skillLevelMinimum?: InputMaybe<Scalars['numeric']>;
  slug?: InputMaybe<Scalars['String']>;
  threads?: InputMaybe<GroupThreadsArrRelInsertInput>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venues?: InputMaybe<GroupVenuesArrRelInsertInput>;
};

/** aggregate max on columns */
export type GroupsMaxFields = {
  __typename?: 'GroupsMaxFields';
  accessCode?: Maybe<Scalars['String']>;
  cityId?: Maybe<Scalars['uuid']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactMessage?: Maybe<Scalars['String']>;
  contactPhoneNumber?: Maybe<Scalars['String']>;
  contactUrl?: Maybe<Scalars['String']>;
  coverPhotoUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  headline?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  profilePhotoUrl?: Maybe<Scalars['String']>;
  skillLevelMaximum?: Maybe<Scalars['numeric']>;
  skillLevelMinimum?: Maybe<Scalars['numeric']>;
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "groups" */
export type GroupsMaxOrderBy = {
  accessCode?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactMessage?: InputMaybe<OrderBy>;
  contactPhoneNumber?: InputMaybe<OrderBy>;
  contactUrl?: InputMaybe<OrderBy>;
  coverPhotoUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  headline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  profilePhotoUrl?: InputMaybe<OrderBy>;
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupsMinFields = {
  __typename?: 'GroupsMinFields';
  accessCode?: Maybe<Scalars['String']>;
  cityId?: Maybe<Scalars['uuid']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactMessage?: Maybe<Scalars['String']>;
  contactPhoneNumber?: Maybe<Scalars['String']>;
  contactUrl?: Maybe<Scalars['String']>;
  coverPhotoUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  headline?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  profilePhotoUrl?: Maybe<Scalars['String']>;
  skillLevelMaximum?: Maybe<Scalars['numeric']>;
  skillLevelMinimum?: Maybe<Scalars['numeric']>;
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "groups" */
export type GroupsMinOrderBy = {
  accessCode?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactMessage?: InputMaybe<OrderBy>;
  contactPhoneNumber?: InputMaybe<OrderBy>;
  contactUrl?: InputMaybe<OrderBy>;
  coverPhotoUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  headline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  profilePhotoUrl?: InputMaybe<OrderBy>;
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "groups" */
export type GroupsMutationResponse = {
  __typename?: 'GroupsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Groups>;
};

/** input type for inserting object relation for remote table "groups" */
export type GroupsObjRelInsertInput = {
  data: GroupsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<GroupsOnConflict>;
};

/** on_conflict condition type for table "groups" */
export type GroupsOnConflict = {
  constraint: GroupsConstraint;
  updateColumns?: Array<GroupsUpdateColumn>;
  where?: InputMaybe<GroupsBoolExp>;
};

/** Ordering options when selecting data from "groups". */
export type GroupsOrderBy = {
  accessCode?: InputMaybe<OrderBy>;
  allowMemberInvites?: InputMaybe<OrderBy>;
  allowMemberSessionInvites?: InputMaybe<OrderBy>;
  city?: InputMaybe<CitiesOrderBy>;
  cityId?: InputMaybe<OrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactMessage?: InputMaybe<OrderBy>;
  contactPhoneNumber?: InputMaybe<OrderBy>;
  contactUrl?: InputMaybe<OrderBy>;
  coverPhotoUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  displayOwnerContactInfo?: InputMaybe<OrderBy>;
  groupsPlaySessionsAggregate?: InputMaybe<GroupsPlaySessionsAggregateOrderBy>;
  headline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPrivate?: InputMaybe<OrderBy>;
  membersAggregate?: InputMaybe<GroupMembersAggregateOrderBy>;
  owner?: InputMaybe<UsersOrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  ownerUserProfile?: InputMaybe<UserProfilesOrderBy>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateOrderBy>;
  primarySport?: InputMaybe<OrderBy>;
  profilePhotoUrl?: InputMaybe<OrderBy>;
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  threadsAggregate?: InputMaybe<GroupThreadsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venuesAggregate?: InputMaybe<GroupVenuesAggregateOrderBy>;
};

/** primary key columns input for table: groups */
export type GroupsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** columns and relationships of "groups_play_sessions" */
export type GroupsPlaySessions = {
  __typename?: 'GroupsPlaySessions';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group: Groups;
  groupId: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  playSession: PlaySessions;
  playSessionId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "groups_play_sessions" */
export type GroupsPlaySessionsAggregate = {
  __typename?: 'GroupsPlaySessionsAggregate';
  aggregate?: Maybe<GroupsPlaySessionsAggregateFields>;
  nodes: Array<GroupsPlaySessions>;
};

export type GroupsPlaySessionsAggregateBoolExp = {
  count?: InputMaybe<GroupsPlaySessionsAggregateBoolExpCount>;
};

/** aggregate fields of "groups_play_sessions" */
export type GroupsPlaySessionsAggregateFields = {
  __typename?: 'GroupsPlaySessionsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<GroupsPlaySessionsMaxFields>;
  min?: Maybe<GroupsPlaySessionsMinFields>;
};


/** aggregate fields of "groups_play_sessions" */
export type GroupsPlaySessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "groups_play_sessions" */
export type GroupsPlaySessionsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GroupsPlaySessionsMaxOrderBy>;
  min?: InputMaybe<GroupsPlaySessionsMinOrderBy>;
};

/** input type for inserting array relation for remote table "groups_play_sessions" */
export type GroupsPlaySessionsArrRelInsertInput = {
  data: Array<GroupsPlaySessionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<GroupsPlaySessionsOnConflict>;
};

/** Boolean expression to filter rows from the table "groups_play_sessions". All fields are combined with a logical 'AND'. */
export type GroupsPlaySessionsBoolExp = {
  _and?: InputMaybe<Array<GroupsPlaySessionsBoolExp>>;
  _not?: InputMaybe<GroupsPlaySessionsBoolExp>;
  _or?: InputMaybe<Array<GroupsPlaySessionsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "groups_play_sessions" */
export enum GroupsPlaySessionsConstraint {
  /** unique or primary key constraint on columns "play_session_id", "group_id" */
  GroupsPlaySessionsGroupIdPlaySessionIdKey = 'groups_play_sessions_group_id_play_session_id_key',
  /** unique or primary key constraint on columns "id" */
  GroupsPlaySessionsPkey = 'groups_play_sessions_pkey'
}

/** input type for inserting data into table "groups_play_sessions" */
export type GroupsPlaySessionsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<GroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type GroupsPlaySessionsMaxFields = {
  __typename?: 'GroupsPlaySessionsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "groups_play_sessions" */
export type GroupsPlaySessionsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GroupsPlaySessionsMinFields = {
  __typename?: 'GroupsPlaySessionsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "groups_play_sessions" */
export type GroupsPlaySessionsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "groups_play_sessions" */
export type GroupsPlaySessionsMutationResponse = {
  __typename?: 'GroupsPlaySessionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GroupsPlaySessions>;
};

/** on_conflict condition type for table "groups_play_sessions" */
export type GroupsPlaySessionsOnConflict = {
  constraint: GroupsPlaySessionsConstraint;
  updateColumns?: Array<GroupsPlaySessionsUpdateColumn>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};

/** Ordering options when selecting data from "groups_play_sessions". */
export type GroupsPlaySessionsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: groups_play_sessions */
export type GroupsPlaySessionsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "groups_play_sessions" */
export enum GroupsPlaySessionsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "groups_play_sessions" */
export type GroupsPlaySessionsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "groups_play_sessions" */
export type GroupsPlaySessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupsPlaySessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupsPlaySessionsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "groups_play_sessions" */
export enum GroupsPlaySessionsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type GroupsPlaySessionsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupsPlaySessionsSetInput>;
  /** filter the rows which have to be updated */
  where: GroupsPlaySessionsBoolExp;
};

/** select columns of table "groups" */
export enum GroupsSelectColumn {
  /** column name */
  AccessCode = 'accessCode',
  /** column name */
  AllowMemberInvites = 'allowMemberInvites',
  /** column name */
  AllowMemberSessionInvites = 'allowMemberSessionInvites',
  /** column name */
  CityId = 'cityId',
  /** column name */
  ContactEmail = 'contactEmail',
  /** column name */
  ContactMessage = 'contactMessage',
  /** column name */
  ContactPhoneNumber = 'contactPhoneNumber',
  /** column name */
  ContactUrl = 'contactUrl',
  /** column name */
  CoverPhotoUrl = 'coverPhotoUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DisplayOwnerContactInfo = 'displayOwnerContactInfo',
  /** column name */
  Headline = 'headline',
  /** column name */
  Id = 'id',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  OwnerUserId = 'ownerUserId',
  /** column name */
  PrimarySport = 'primarySport',
  /** column name */
  ProfilePhotoUrl = 'profilePhotoUrl',
  /** column name */
  SkillLevelMaximum = 'skillLevelMaximum',
  /** column name */
  SkillLevelMinimum = 'skillLevelMinimum',
  /** column name */
  Slug = 'slug',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "groupsAggregateBoolExpBool_andArgumentsColumns" columns of table "groups" */
export enum GroupsSelectColumnGroupsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  AllowMemberInvites = 'allowMemberInvites',
  /** column name */
  AllowMemberSessionInvites = 'allowMemberSessionInvites',
  /** column name */
  DisplayOwnerContactInfo = 'displayOwnerContactInfo',
  /** column name */
  IsPrivate = 'isPrivate'
}

/** select "groupsAggregateBoolExpBool_orArgumentsColumns" columns of table "groups" */
export enum GroupsSelectColumnGroupsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  AllowMemberInvites = 'allowMemberInvites',
  /** column name */
  AllowMemberSessionInvites = 'allowMemberSessionInvites',
  /** column name */
  DisplayOwnerContactInfo = 'displayOwnerContactInfo',
  /** column name */
  IsPrivate = 'isPrivate'
}

/** input type for updating data in table "groups" */
export type GroupsSetInput = {
  accessCode?: InputMaybe<Scalars['String']>;
  allowMemberInvites?: InputMaybe<Scalars['Boolean']>;
  allowMemberSessionInvites?: InputMaybe<Scalars['Boolean']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  contactEmail?: InputMaybe<Scalars['String']>;
  contactMessage?: InputMaybe<Scalars['String']>;
  contactPhoneNumber?: InputMaybe<Scalars['String']>;
  contactUrl?: InputMaybe<Scalars['String']>;
  coverPhotoUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  displayOwnerContactInfo?: InputMaybe<Scalars['Boolean']>;
  headline?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  primarySport?: InputMaybe<SportsEnum>;
  profilePhotoUrl?: InputMaybe<Scalars['String']>;
  skillLevelMaximum?: InputMaybe<Scalars['numeric']>;
  skillLevelMinimum?: InputMaybe<Scalars['numeric']>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type GroupsStddevFields = {
  __typename?: 'GroupsStddevFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "groups" */
export type GroupsStddevOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type GroupsStddevPopFields = {
  __typename?: 'GroupsStddevPopFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "groups" */
export type GroupsStddevPopOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type GroupsStddevSampFields = {
  __typename?: 'GroupsStddevSampFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "groups" */
export type GroupsStddevSampOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "groups" */
export type GroupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GroupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GroupsStreamCursorValueInput = {
  accessCode?: InputMaybe<Scalars['String']>;
  allowMemberInvites?: InputMaybe<Scalars['Boolean']>;
  allowMemberSessionInvites?: InputMaybe<Scalars['Boolean']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  contactEmail?: InputMaybe<Scalars['String']>;
  contactMessage?: InputMaybe<Scalars['String']>;
  contactPhoneNumber?: InputMaybe<Scalars['String']>;
  contactUrl?: InputMaybe<Scalars['String']>;
  coverPhotoUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  displayOwnerContactInfo?: InputMaybe<Scalars['Boolean']>;
  headline?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  primarySport?: InputMaybe<SportsEnum>;
  profilePhotoUrl?: InputMaybe<Scalars['String']>;
  skillLevelMaximum?: InputMaybe<Scalars['numeric']>;
  skillLevelMinimum?: InputMaybe<Scalars['numeric']>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type GroupsSumFields = {
  __typename?: 'GroupsSumFields';
  skillLevelMaximum?: Maybe<Scalars['numeric']>;
  skillLevelMinimum?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "groups" */
export type GroupsSumOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** update columns of table "groups" */
export enum GroupsUpdateColumn {
  /** column name */
  AccessCode = 'accessCode',
  /** column name */
  AllowMemberInvites = 'allowMemberInvites',
  /** column name */
  AllowMemberSessionInvites = 'allowMemberSessionInvites',
  /** column name */
  CityId = 'cityId',
  /** column name */
  ContactEmail = 'contactEmail',
  /** column name */
  ContactMessage = 'contactMessage',
  /** column name */
  ContactPhoneNumber = 'contactPhoneNumber',
  /** column name */
  ContactUrl = 'contactUrl',
  /** column name */
  CoverPhotoUrl = 'coverPhotoUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DisplayOwnerContactInfo = 'displayOwnerContactInfo',
  /** column name */
  Headline = 'headline',
  /** column name */
  Id = 'id',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  OwnerUserId = 'ownerUserId',
  /** column name */
  PrimarySport = 'primarySport',
  /** column name */
  ProfilePhotoUrl = 'profilePhotoUrl',
  /** column name */
  SkillLevelMaximum = 'skillLevelMaximum',
  /** column name */
  SkillLevelMinimum = 'skillLevelMinimum',
  /** column name */
  Slug = 'slug',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type GroupsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GroupsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GroupsSetInput>;
  /** filter the rows which have to be updated */
  where: GroupsBoolExp;
};

/** aggregate varPop on columns */
export type GroupsVarPopFields = {
  __typename?: 'GroupsVarPopFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "groups" */
export type GroupsVarPopOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type GroupsVarSampFields = {
  __typename?: 'GroupsVarSampFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "groups" */
export type GroupsVarSampOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type GroupsVarianceFields = {
  __typename?: 'GroupsVarianceFields';
  skillLevelMaximum?: Maybe<Scalars['Float']>;
  skillLevelMinimum?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "groups" */
export type GroupsVarianceOrderBy = {
  skillLevelMaximum?: InputMaybe<OrderBy>;
  skillLevelMinimum?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _containedIn?: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']>;
  _eq?: InputMaybe<Scalars['jsonb']>;
  _gt?: InputMaybe<Scalars['jsonb']>;
  _gte?: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _hasKey?: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _hasKeysAll?: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _hasKeysAny?: InputMaybe<Array<Scalars['String']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['jsonb']>;
  _lte?: InputMaybe<Scalars['jsonb']>;
  _neq?: InputMaybe<Scalars['jsonb']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']>>;
};

/** columns and relationships of "lesson_equipment" */
export type LessonEquipment = {
  __typename?: 'LessonEquipment';
  createdAt: Scalars['timestamptz'];
  customName?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  equipmentOptionId: LessonEquipmentOptionsEnum;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "lesson_equipment" */
export type LessonEquipmentAggregate = {
  __typename?: 'LessonEquipmentAggregate';
  aggregate?: Maybe<LessonEquipmentAggregateFields>;
  nodes: Array<LessonEquipment>;
};

export type LessonEquipmentAggregateBoolExp = {
  count?: InputMaybe<LessonEquipmentAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_equipment" */
export type LessonEquipmentAggregateFields = {
  __typename?: 'LessonEquipmentAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonEquipmentMaxFields>;
  min?: Maybe<LessonEquipmentMinFields>;
};


/** aggregate fields of "lesson_equipment" */
export type LessonEquipmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_equipment" */
export type LessonEquipmentAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonEquipmentMaxOrderBy>;
  min?: InputMaybe<LessonEquipmentMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_equipment" */
export type LessonEquipmentArrRelInsertInput = {
  data: Array<LessonEquipmentInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonEquipmentOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_equipment". All fields are combined with a logical 'AND'. */
export type LessonEquipmentBoolExp = {
  _and?: InputMaybe<Array<LessonEquipmentBoolExp>>;
  _not?: InputMaybe<LessonEquipmentBoolExp>;
  _or?: InputMaybe<Array<LessonEquipmentBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  customName?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "lesson_equipment" */
export enum LessonEquipmentConstraint {
  /** unique or primary key constraint on columns "lesson_id", "equipment_option_id" */
  LessonEquipmentLessonIdEquipmentOptionIdKey = 'lesson_equipment_lesson_id_equipment_option_id_key',
  /** unique or primary key constraint on columns "id" */
  LessonEquipmentPkey = 'lesson_equipment_pkey'
}

/** input type for inserting data into table "lesson_equipment" */
export type LessonEquipmentInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customName?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type LessonEquipmentMaxFields = {
  __typename?: 'LessonEquipmentMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  customName?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "lesson_equipment" */
export type LessonEquipmentMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonEquipmentMinFields = {
  __typename?: 'LessonEquipmentMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  customName?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "lesson_equipment" */
export type LessonEquipmentMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_equipment" */
export type LessonEquipmentMutationResponse = {
  __typename?: 'LessonEquipmentMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonEquipment>;
};

/** on_conflict condition type for table "lesson_equipment" */
export type LessonEquipmentOnConflict = {
  constraint: LessonEquipmentConstraint;
  updateColumns?: Array<LessonEquipmentUpdateColumn>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};

/** columns and relationships of "lesson_equipment_options" */
export type LessonEquipmentOptions = {
  __typename?: 'LessonEquipmentOptions';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "lesson_equipment_options" */
export type LessonEquipmentOptionsAggregate = {
  __typename?: 'LessonEquipmentOptionsAggregate';
  aggregate?: Maybe<LessonEquipmentOptionsAggregateFields>;
  nodes: Array<LessonEquipmentOptions>;
};

/** aggregate fields of "lesson_equipment_options" */
export type LessonEquipmentOptionsAggregateFields = {
  __typename?: 'LessonEquipmentOptionsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonEquipmentOptionsMaxFields>;
  min?: Maybe<LessonEquipmentOptionsMinFields>;
};


/** aggregate fields of "lesson_equipment_options" */
export type LessonEquipmentOptionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lesson_equipment_options". All fields are combined with a logical 'AND'. */
export type LessonEquipmentOptionsBoolExp = {
  _and?: InputMaybe<Array<LessonEquipmentOptionsBoolExp>>;
  _not?: InputMaybe<LessonEquipmentOptionsBoolExp>;
  _or?: InputMaybe<Array<LessonEquipmentOptionsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "lesson_equipment_options" */
export enum LessonEquipmentOptionsConstraint {
  /** unique or primary key constraint on columns "value" */
  LessonEquipmentOptionsPkey = 'lesson_equipment_options_pkey'
}

export enum LessonEquipmentOptionsEnum {
  CourtShoes = 'COURT_SHOES',
  HeartRateMonitor = 'HEART_RATE_MONITOR',
  Racket = 'RACKET',
  Towel = 'TOWEL',
  WaterBottle = 'WATER_BOTTLE'
}

/** Boolean expression to compare columns of type "LessonEquipmentOptionsEnum". All fields are combined with logical 'AND'. */
export type LessonEquipmentOptionsEnumComparisonExp = {
  _eq?: InputMaybe<LessonEquipmentOptionsEnum>;
  _in?: InputMaybe<Array<LessonEquipmentOptionsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonEquipmentOptionsEnum>;
  _nin?: InputMaybe<Array<LessonEquipmentOptionsEnum>>;
};

/** input type for inserting data into table "lesson_equipment_options" */
export type LessonEquipmentOptionsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LessonEquipmentOptionsMaxFields = {
  __typename?: 'LessonEquipmentOptionsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LessonEquipmentOptionsMinFields = {
  __typename?: 'LessonEquipmentOptionsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lesson_equipment_options" */
export type LessonEquipmentOptionsMutationResponse = {
  __typename?: 'LessonEquipmentOptionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonEquipmentOptions>;
};

/** on_conflict condition type for table "lesson_equipment_options" */
export type LessonEquipmentOptionsOnConflict = {
  constraint: LessonEquipmentOptionsConstraint;
  updateColumns?: Array<LessonEquipmentOptionsUpdateColumn>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};

/** Ordering options when selecting data from "lesson_equipment_options". */
export type LessonEquipmentOptionsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_equipment_options */
export type LessonEquipmentOptionsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "lesson_equipment_options" */
export enum LessonEquipmentOptionsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "lesson_equipment_options" */
export type LessonEquipmentOptionsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "lesson_equipment_options" */
export type LessonEquipmentOptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonEquipmentOptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonEquipmentOptionsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "lesson_equipment_options" */
export enum LessonEquipmentOptionsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type LessonEquipmentOptionsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonEquipmentOptionsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonEquipmentOptionsBoolExp;
};

/** Ordering options when selecting data from "lesson_equipment". */
export type LessonEquipmentOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  equipmentOptionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_equipment */
export type LessonEquipmentPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_equipment" */
export enum LessonEquipmentSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomName = 'customName',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EquipmentOptionId = 'equipmentOptionId',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "lesson_equipment" */
export type LessonEquipmentSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customName?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "lesson_equipment" */
export type LessonEquipmentStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonEquipmentStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonEquipmentStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customName?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  equipmentOptionId?: InputMaybe<LessonEquipmentOptionsEnum>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "lesson_equipment" */
export enum LessonEquipmentUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomName = 'customName',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EquipmentOptionId = 'equipmentOptionId',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type LessonEquipmentUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonEquipmentSetInput>;
  /** filter the rows which have to be updated */
  where: LessonEquipmentBoolExp;
};

/** columns and relationships of "lesson_order_items" */
export type LessonOrderItems = {
  __typename?: 'LessonOrderItems';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  lessonOrderId: Scalars['uuid'];
  /** An object relationship */
  lessonParticipant: LessonParticipants;
  lessonParticipantId: Scalars['uuid'];
  /** An object relationship */
  order: LessonOrders;
  priceUnitAmount: Scalars['Int'];
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  status: OrderStatusesEnum;
  totalUnitAmount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "lesson_order_items" */
export type LessonOrderItemsAggregate = {
  __typename?: 'LessonOrderItemsAggregate';
  aggregate?: Maybe<LessonOrderItemsAggregateFields>;
  nodes: Array<LessonOrderItems>;
};

export type LessonOrderItemsAggregateBoolExp = {
  count?: InputMaybe<LessonOrderItemsAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_order_items" */
export type LessonOrderItemsAggregateFields = {
  __typename?: 'LessonOrderItemsAggregateFields';
  avg?: Maybe<LessonOrderItemsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LessonOrderItemsMaxFields>;
  min?: Maybe<LessonOrderItemsMinFields>;
  stddev?: Maybe<LessonOrderItemsStddevFields>;
  stddevPop?: Maybe<LessonOrderItemsStddevPopFields>;
  stddevSamp?: Maybe<LessonOrderItemsStddevSampFields>;
  sum?: Maybe<LessonOrderItemsSumFields>;
  varPop?: Maybe<LessonOrderItemsVarPopFields>;
  varSamp?: Maybe<LessonOrderItemsVarSampFields>;
  variance?: Maybe<LessonOrderItemsVarianceFields>;
};


/** aggregate fields of "lesson_order_items" */
export type LessonOrderItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_order_items" */
export type LessonOrderItemsAggregateOrderBy = {
  avg?: InputMaybe<LessonOrderItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonOrderItemsMaxOrderBy>;
  min?: InputMaybe<LessonOrderItemsMinOrderBy>;
  stddev?: InputMaybe<LessonOrderItemsStddevOrderBy>;
  stddevPop?: InputMaybe<LessonOrderItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LessonOrderItemsStddevSampOrderBy>;
  sum?: InputMaybe<LessonOrderItemsSumOrderBy>;
  varPop?: InputMaybe<LessonOrderItemsVarPopOrderBy>;
  varSamp?: InputMaybe<LessonOrderItemsVarSampOrderBy>;
  variance?: InputMaybe<LessonOrderItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_order_items" */
export type LessonOrderItemsArrRelInsertInput = {
  data: Array<LessonOrderItemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonOrderItemsOnConflict>;
};

/** aggregate avg on columns */
export type LessonOrderItemsAvgFields = {
  __typename?: 'LessonOrderItemsAvgFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "lesson_order_items" */
export type LessonOrderItemsAvgOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lesson_order_items". All fields are combined with a logical 'AND'. */
export type LessonOrderItemsBoolExp = {
  _and?: InputMaybe<Array<LessonOrderItemsBoolExp>>;
  _not?: InputMaybe<LessonOrderItemsBoolExp>;
  _or?: InputMaybe<Array<LessonOrderItemsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lessonOrderId?: InputMaybe<UuidComparisonExp>;
  lessonParticipant?: InputMaybe<LessonParticipantsBoolExp>;
  lessonParticipantId?: InputMaybe<UuidComparisonExp>;
  order?: InputMaybe<LessonOrdersBoolExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  totalUnitAmount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "lesson_order_items" */
export enum LessonOrderItemsConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonOrderItemsPkey = 'lesson_order_items_pkey'
}

/** input type for incrementing numeric columns in table "lesson_order_items" */
export type LessonOrderItemsIncInput = {
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lesson_order_items" */
export type LessonOrderItemsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonOrderId?: InputMaybe<Scalars['uuid']>;
  lessonParticipant?: InputMaybe<LessonParticipantsObjRelInsertInput>;
  lessonParticipantId?: InputMaybe<Scalars['uuid']>;
  order?: InputMaybe<LessonOrdersObjRelInsertInput>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type LessonOrderItemsMaxFields = {
  __typename?: 'LessonOrderItemsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonOrderId?: Maybe<Scalars['uuid']>;
  lessonParticipantId?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  totalUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "lesson_order_items" */
export type LessonOrderItemsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonOrderId?: InputMaybe<OrderBy>;
  lessonParticipantId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonOrderItemsMinFields = {
  __typename?: 'LessonOrderItemsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonOrderId?: Maybe<Scalars['uuid']>;
  lessonParticipantId?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  totalUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "lesson_order_items" */
export type LessonOrderItemsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonOrderId?: InputMaybe<OrderBy>;
  lessonParticipantId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_order_items" */
export type LessonOrderItemsMutationResponse = {
  __typename?: 'LessonOrderItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonOrderItems>;
};

/** on_conflict condition type for table "lesson_order_items" */
export type LessonOrderItemsOnConflict = {
  constraint: LessonOrderItemsConstraint;
  updateColumns?: Array<LessonOrderItemsUpdateColumn>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};

/** Ordering options when selecting data from "lesson_order_items". */
export type LessonOrderItemsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonOrderId?: InputMaybe<OrderBy>;
  lessonParticipant?: InputMaybe<LessonParticipantsOrderBy>;
  lessonParticipantId?: InputMaybe<OrderBy>;
  order?: InputMaybe<LessonOrdersOrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_order_items */
export type LessonOrderItemsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_order_items" */
export enum LessonOrderItemsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonOrderId = 'lessonOrderId',
  /** column name */
  LessonParticipantId = 'lessonParticipantId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  TotalUnitAmount = 'totalUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "lesson_order_items" */
export type LessonOrderItemsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonOrderId?: InputMaybe<Scalars['uuid']>;
  lessonParticipantId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type LessonOrderItemsStddevFields = {
  __typename?: 'LessonOrderItemsStddevFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "lesson_order_items" */
export type LessonOrderItemsStddevOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type LessonOrderItemsStddevPopFields = {
  __typename?: 'LessonOrderItemsStddevPopFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "lesson_order_items" */
export type LessonOrderItemsStddevPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type LessonOrderItemsStddevSampFields = {
  __typename?: 'LessonOrderItemsStddevSampFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "lesson_order_items" */
export type LessonOrderItemsStddevSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lesson_order_items" */
export type LessonOrderItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonOrderItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonOrderItemsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonOrderId?: InputMaybe<Scalars['uuid']>;
  lessonParticipantId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<OrderStatusesEnum>;
  totalUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type LessonOrderItemsSumFields = {
  __typename?: 'LessonOrderItemsSumFields';
  priceUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  totalUnitAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "lesson_order_items" */
export type LessonOrderItemsSumOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "lesson_order_items" */
export enum LessonOrderItemsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonOrderId = 'lessonOrderId',
  /** column name */
  LessonParticipantId = 'lessonParticipantId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  TotalUnitAmount = 'totalUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type LessonOrderItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LessonOrderItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonOrderItemsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonOrderItemsBoolExp;
};

/** aggregate varPop on columns */
export type LessonOrderItemsVarPopFields = {
  __typename?: 'LessonOrderItemsVarPopFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "lesson_order_items" */
export type LessonOrderItemsVarPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type LessonOrderItemsVarSampFields = {
  __typename?: 'LessonOrderItemsVarSampFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "lesson_order_items" */
export type LessonOrderItemsVarSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LessonOrderItemsVarianceFields = {
  __typename?: 'LessonOrderItemsVarianceFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  totalUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "lesson_order_items" */
export type LessonOrderItemsVarianceOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  totalUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "lesson_orders" */
export type LessonOrders = {
  __typename?: 'LessonOrders';
  applicationFeeTotalUnitAmount: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creditCard?: Maybe<UserCreditCards>;
  /** An object relationship */
  customer: Users;
  customerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  customerProfile?: Maybe<UserProfiles>;
  customerUserId: Scalars['uuid'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  /** An array relationship */
  items: Array<LessonOrderItems>;
  /** An aggregate relationship */
  itemsAggregate: LessonOrderItemsAggregate;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount: Scalars['Int'];
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount: Scalars['Int'];
  paidUnitAmount: Scalars['Int'];
  /** An object relationship */
  paymentIntentExternal: StripePaymentIntents;
  /** An object relationship */
  paymentIntentInternal: StripePaymentIntents;
  paymentProcessor: PaymentProcessorsEnum;
  refundUnitAmount: Scalars['Int'];
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  /** An object relationship */
  seller: Users;
  sellerApplicationFeeUnitAmount: Scalars['Int'];
  /** An object relationship */
  sellerProfile?: Maybe<UserProfiles>;
  sellerUserId: Scalars['uuid'];
  status: OrderStatusesEnum;
  stripeCustomerId: Scalars['String'];
  stripeMerchantId: Scalars['String'];
  stripePaymentStatus: Scalars['String'];
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  userCreditCardId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "lesson_orders" */
export type LessonOrdersItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


/** columns and relationships of "lesson_orders" */
export type LessonOrdersItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};

/** aggregated selection of "lesson_orders" */
export type LessonOrdersAggregate = {
  __typename?: 'LessonOrdersAggregate';
  aggregate?: Maybe<LessonOrdersAggregateFields>;
  nodes: Array<LessonOrders>;
};

/** aggregate fields of "lesson_orders" */
export type LessonOrdersAggregateFields = {
  __typename?: 'LessonOrdersAggregateFields';
  avg?: Maybe<LessonOrdersAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LessonOrdersMaxFields>;
  min?: Maybe<LessonOrdersMinFields>;
  stddev?: Maybe<LessonOrdersStddevFields>;
  stddevPop?: Maybe<LessonOrdersStddevPopFields>;
  stddevSamp?: Maybe<LessonOrdersStddevSampFields>;
  sum?: Maybe<LessonOrdersSumFields>;
  varPop?: Maybe<LessonOrdersVarPopFields>;
  varSamp?: Maybe<LessonOrdersVarSampFields>;
  variance?: Maybe<LessonOrdersVarianceFields>;
};


/** aggregate fields of "lesson_orders" */
export type LessonOrdersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type LessonOrdersAvgFields = {
  __typename?: 'LessonOrdersAvgFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "lesson_orders". All fields are combined with a logical 'AND'. */
export type LessonOrdersBoolExp = {
  _and?: InputMaybe<Array<LessonOrdersBoolExp>>;
  _not?: InputMaybe<LessonOrdersBoolExp>;
  _or?: InputMaybe<Array<LessonOrdersBoolExp>>;
  applicationFeeTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creditCard?: InputMaybe<UserCreditCardsBoolExp>;
  customer?: InputMaybe<UsersBoolExp>;
  customerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  customerProfile?: InputMaybe<UserProfilesBoolExp>;
  customerUserId?: InputMaybe<UuidComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  items?: InputMaybe<LessonOrderItemsBoolExp>;
  itemsAggregate?: InputMaybe<LessonOrderItemsAggregateBoolExp>;
  orderSubtotalUnitAmount?: InputMaybe<IntComparisonExp>;
  orderTotalUnitAmount?: InputMaybe<IntComparisonExp>;
  paidUnitAmount?: InputMaybe<IntComparisonExp>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnumComparisonExp>;
  refundUnitAmount?: InputMaybe<IntComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  seller?: InputMaybe<UsersBoolExp>;
  sellerApplicationFeeUnitAmount?: InputMaybe<IntComparisonExp>;
  sellerProfile?: InputMaybe<UserProfilesBoolExp>;
  sellerUserId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<OrderStatusesEnumComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripeMerchantId?: InputMaybe<StringComparisonExp>;
  stripePaymentStatus?: InputMaybe<StringComparisonExp>;
  transferUnitAmount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCreditCardId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "lesson_orders" */
export enum LessonOrdersConstraint {
  /** unique or primary key constraint on columns "external_stripe_payment_intent_id" */
  LessonOrdersExternalStripePaymentIntentIdKey = 'lesson_orders_external_stripe_payment_intent_id_key',
  /** unique or primary key constraint on columns "internal_stripe_payment_intent_id" */
  LessonOrdersInternalStripePaymentIntentIdKey = 'lesson_orders_internal_stripe_payment_intent_id_key',
  /** unique or primary key constraint on columns "id" */
  LessonOrdersPkey = 'lesson_orders_pkey'
}

/** input type for incrementing numeric columns in table "lesson_orders" */
export type LessonOrdersIncInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lesson_orders" */
export type LessonOrdersInsertInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creditCard?: InputMaybe<UserCreditCardsObjRelInsertInput>;
  customer?: InputMaybe<UsersObjRelInsertInput>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  customerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  customerUserId?: InputMaybe<Scalars['uuid']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  items?: InputMaybe<LessonOrderItemsArrRelInsertInput>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  seller?: InputMaybe<UsersObjRelInsertInput>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type LessonOrdersMaxFields = {
  __typename?: 'LessonOrdersMaxFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  customerUserId?: Maybe<Scalars['uuid']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  sellerUserId?: Maybe<Scalars['uuid']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type LessonOrdersMinFields = {
  __typename?: 'LessonOrdersMinFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  customerUserId?: Maybe<Scalars['uuid']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  sellerUserId?: Maybe<Scalars['uuid']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripePaymentStatus?: Maybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCreditCardId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "lesson_orders" */
export type LessonOrdersMutationResponse = {
  __typename?: 'LessonOrdersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonOrders>;
};

/** input type for inserting object relation for remote table "lesson_orders" */
export type LessonOrdersObjRelInsertInput = {
  data: LessonOrdersInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LessonOrdersOnConflict>;
};

/** on_conflict condition type for table "lesson_orders" */
export type LessonOrdersOnConflict = {
  constraint: LessonOrdersConstraint;
  updateColumns?: Array<LessonOrdersUpdateColumn>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};

/** Ordering options when selecting data from "lesson_orders". */
export type LessonOrdersOrderBy = {
  applicationFeeTotalUnitAmount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creditCard?: InputMaybe<UserCreditCardsOrderBy>;
  customer?: InputMaybe<UsersOrderBy>;
  customerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  customerProfile?: InputMaybe<UserProfilesOrderBy>;
  customerUserId?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  itemsAggregate?: InputMaybe<LessonOrderItemsAggregateOrderBy>;
  orderSubtotalUnitAmount?: InputMaybe<OrderBy>;
  orderTotalUnitAmount?: InputMaybe<OrderBy>;
  paidUnitAmount?: InputMaybe<OrderBy>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentProcessor?: InputMaybe<OrderBy>;
  refundUnitAmount?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  seller?: InputMaybe<UsersOrderBy>;
  sellerApplicationFeeUnitAmount?: InputMaybe<OrderBy>;
  sellerProfile?: InputMaybe<UserProfilesOrderBy>;
  sellerUserId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripePaymentStatus?: InputMaybe<OrderBy>;
  transferUnitAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCreditCardId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_orders */
export type LessonOrdersPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_orders" */
export enum LessonOrdersSelectColumn {
  /** column name */
  ApplicationFeeTotalUnitAmount = 'applicationFeeTotalUnitAmount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerApplicationFeeUnitAmount = 'customerApplicationFeeUnitAmount',
  /** column name */
  CustomerUserId = 'customerUserId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  SellerApplicationFeeUnitAmount = 'sellerApplicationFeeUnitAmount',
  /** column name */
  SellerUserId = 'sellerUserId',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  TransferUnitAmount = 'transferUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId'
}

/** input type for updating data in table "lesson_orders" */
export type LessonOrdersSetInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  customerUserId?: InputMaybe<Scalars['uuid']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type LessonOrdersStddevFields = {
  __typename?: 'LessonOrdersStddevFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type LessonOrdersStddevPopFields = {
  __typename?: 'LessonOrdersStddevPopFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type LessonOrdersStddevSampFields = {
  __typename?: 'LessonOrdersStddevSampFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "lesson_orders" */
export type LessonOrdersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonOrdersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonOrdersStreamCursorValueInput = {
  applicationFeeTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  customerUserId?: InputMaybe<Scalars['uuid']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: InputMaybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: InputMaybe<Scalars['Int']>;
  paidUnitAmount?: InputMaybe<Scalars['Int']>;
  paymentProcessor?: InputMaybe<PaymentProcessorsEnum>;
  refundUnitAmount?: InputMaybe<Scalars['Int']>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  sellerApplicationFeeUnitAmount?: InputMaybe<Scalars['Int']>;
  sellerUserId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<OrderStatusesEnum>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripePaymentStatus?: InputMaybe<Scalars['String']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCreditCardId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type LessonOrdersSumFields = {
  __typename?: 'LessonOrdersSumFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Int']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Int']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Int']>;
  paidUnitAmount?: Maybe<Scalars['Int']>;
  refundUnitAmount?: Maybe<Scalars['Int']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Int']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Int']>;
};

/** update columns of table "lesson_orders" */
export enum LessonOrdersUpdateColumn {
  /** column name */
  ApplicationFeeTotalUnitAmount = 'applicationFeeTotalUnitAmount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerApplicationFeeUnitAmount = 'customerApplicationFeeUnitAmount',
  /** column name */
  CustomerUserId = 'customerUserId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  OrderSubtotalUnitAmount = 'orderSubtotalUnitAmount',
  /** column name */
  OrderTotalUnitAmount = 'orderTotalUnitAmount',
  /** column name */
  PaidUnitAmount = 'paidUnitAmount',
  /** column name */
  PaymentProcessor = 'paymentProcessor',
  /** column name */
  RefundUnitAmount = 'refundUnitAmount',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  SellerApplicationFeeUnitAmount = 'sellerApplicationFeeUnitAmount',
  /** column name */
  SellerUserId = 'sellerUserId',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripePaymentStatus = 'stripePaymentStatus',
  /** column name */
  TransferUnitAmount = 'transferUnitAmount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCreditCardId = 'userCreditCardId'
}

export type LessonOrdersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LessonOrdersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonOrdersSetInput>;
  /** filter the rows which have to be updated */
  where: LessonOrdersBoolExp;
};

/** aggregate varPop on columns */
export type LessonOrdersVarPopFields = {
  __typename?: 'LessonOrdersVarPopFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type LessonOrdersVarSampFields = {
  __typename?: 'LessonOrdersVarSampFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type LessonOrdersVarianceFields = {
  __typename?: 'LessonOrdersVarianceFields';
  applicationFeeTotalUnitAmount?: Maybe<Scalars['Float']>;
  customerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The sum of the items in the order. This doesn't include any discounts or fees. */
  orderSubtotalUnitAmount?: Maybe<Scalars['Float']>;
  /** The total after fees and discounts. Note that the coaches fee is not added in. This is only what the player pays. The coaches fee is subtracted from their payout. */
  orderTotalUnitAmount?: Maybe<Scalars['Float']>;
  paidUnitAmount?: Maybe<Scalars['Float']>;
  refundUnitAmount?: Maybe<Scalars['Float']>;
  sellerApplicationFeeUnitAmount?: Maybe<Scalars['Float']>;
  /** The amount transferred to the coach as a payout. It is the price of the lesson minus the coaches fee. */
  transferUnitAmount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "lesson_participant_statuses" */
export type LessonParticipantStatuses = {
  __typename?: 'LessonParticipantStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "lesson_participant_statuses" */
export type LessonParticipantStatusesAggregate = {
  __typename?: 'LessonParticipantStatusesAggregate';
  aggregate?: Maybe<LessonParticipantStatusesAggregateFields>;
  nodes: Array<LessonParticipantStatuses>;
};

/** aggregate fields of "lesson_participant_statuses" */
export type LessonParticipantStatusesAggregateFields = {
  __typename?: 'LessonParticipantStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonParticipantStatusesMaxFields>;
  min?: Maybe<LessonParticipantStatusesMinFields>;
};


/** aggregate fields of "lesson_participant_statuses" */
export type LessonParticipantStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lesson_participant_statuses". All fields are combined with a logical 'AND'. */
export type LessonParticipantStatusesBoolExp = {
  _and?: InputMaybe<Array<LessonParticipantStatusesBoolExp>>;
  _not?: InputMaybe<LessonParticipantStatusesBoolExp>;
  _or?: InputMaybe<Array<LessonParticipantStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "lesson_participant_statuses" */
export enum LessonParticipantStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  LessonParticipantStatusesPkey = 'lesson_participant_statuses_pkey'
}

export enum LessonParticipantStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "LessonParticipantStatusesEnum". All fields are combined with logical 'AND'. */
export type LessonParticipantStatusesEnumComparisonExp = {
  _eq?: InputMaybe<LessonParticipantStatusesEnum>;
  _in?: InputMaybe<Array<LessonParticipantStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonParticipantStatusesEnum>;
  _nin?: InputMaybe<Array<LessonParticipantStatusesEnum>>;
};

/** input type for inserting data into table "lesson_participant_statuses" */
export type LessonParticipantStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LessonParticipantStatusesMaxFields = {
  __typename?: 'LessonParticipantStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LessonParticipantStatusesMinFields = {
  __typename?: 'LessonParticipantStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lesson_participant_statuses" */
export type LessonParticipantStatusesMutationResponse = {
  __typename?: 'LessonParticipantStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonParticipantStatuses>;
};

/** on_conflict condition type for table "lesson_participant_statuses" */
export type LessonParticipantStatusesOnConflict = {
  constraint: LessonParticipantStatusesConstraint;
  updateColumns?: Array<LessonParticipantStatusesUpdateColumn>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};

/** Ordering options when selecting data from "lesson_participant_statuses". */
export type LessonParticipantStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_participant_statuses */
export type LessonParticipantStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "lesson_participant_statuses" */
export enum LessonParticipantStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "lesson_participant_statuses" */
export type LessonParticipantStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "lesson_participant_statuses" */
export type LessonParticipantStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonParticipantStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonParticipantStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "lesson_participant_statuses" */
export enum LessonParticipantStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type LessonParticipantStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonParticipantStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonParticipantStatusesBoolExp;
};

/** columns and relationships of "lesson_participants" */
export type LessonParticipants = {
  __typename?: 'LessonParticipants';
  addedAt?: Maybe<Scalars['timestamptz']>;
  addedByPersona?: Maybe<AppPersonasEnum>;
  addedByUserId?: Maybe<Scalars['uuid']>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  /** An array relationship */
  orderItems: Array<LessonOrderItems>;
  /** An aggregate relationship */
  orderItemsAggregate: LessonOrderItemsAggregate;
  paidAt?: Maybe<Scalars['timestamptz']>;
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  refundedByPersona?: Maybe<AppPersonasEnum>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  removedByPersona?: Maybe<AppPersonasEnum>;
  status: LessonParticipantStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "lesson_participants" */
export type LessonParticipantsOrderItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


/** columns and relationships of "lesson_participants" */
export type LessonParticipantsOrderItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};

/** aggregated selection of "lesson_participants" */
export type LessonParticipantsAggregate = {
  __typename?: 'LessonParticipantsAggregate';
  aggregate?: Maybe<LessonParticipantsAggregateFields>;
  nodes: Array<LessonParticipants>;
};

export type LessonParticipantsAggregateBoolExp = {
  count?: InputMaybe<LessonParticipantsAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_participants" */
export type LessonParticipantsAggregateFields = {
  __typename?: 'LessonParticipantsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonParticipantsMaxFields>;
  min?: Maybe<LessonParticipantsMinFields>;
};


/** aggregate fields of "lesson_participants" */
export type LessonParticipantsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_participants" */
export type LessonParticipantsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonParticipantsMaxOrderBy>;
  min?: InputMaybe<LessonParticipantsMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_participants" */
export type LessonParticipantsArrRelInsertInput = {
  data: Array<LessonParticipantsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonParticipantsOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_participants". All fields are combined with a logical 'AND'. */
export type LessonParticipantsBoolExp = {
  _and?: InputMaybe<Array<LessonParticipantsBoolExp>>;
  _not?: InputMaybe<LessonParticipantsBoolExp>;
  _or?: InputMaybe<Array<LessonParticipantsBoolExp>>;
  addedAt?: InputMaybe<TimestamptzComparisonExp>;
  addedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  addedByUserId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  orderItems?: InputMaybe<LessonOrderItemsBoolExp>;
  orderItemsAggregate?: InputMaybe<LessonOrderItemsAggregateBoolExp>;
  paidAt?: InputMaybe<TimestamptzComparisonExp>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnumComparisonExp>;
  refundedAt?: InputMaybe<TimestamptzComparisonExp>;
  refundedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  removedAt?: InputMaybe<TimestamptzComparisonExp>;
  removedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  status?: InputMaybe<LessonParticipantStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "lesson_participants" */
export enum LessonParticipantsConstraint {
  /** unique or primary key constraint on columns "lesson_id", "user_id" */
  LessonParticipantsLessonIdUserIdKey = 'lesson_participants_lesson_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  LessonParticipantsPkey = 'lesson_participants_pkey'
}

/** input type for inserting data into table "lesson_participants" */
export type LessonParticipantsInsertInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  orderItems?: InputMaybe<LessonOrderItemsArrRelInsertInput>;
  paidAt?: InputMaybe<Scalars['timestamptz']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<LessonParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type LessonParticipantsMaxFields = {
  __typename?: 'LessonParticipantsMaxFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  addedByUserId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  paidAt?: Maybe<Scalars['timestamptz']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_participants" */
export type LessonParticipantsMaxOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  addedByUserId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  paidAt?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonParticipantsMinFields = {
  __typename?: 'LessonParticipantsMinFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  addedByUserId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  paidAt?: Maybe<Scalars['timestamptz']>;
  refundedAt?: Maybe<Scalars['timestamptz']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lesson_participants" */
export type LessonParticipantsMinOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  addedByUserId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  paidAt?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_participants" */
export type LessonParticipantsMutationResponse = {
  __typename?: 'LessonParticipantsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonParticipants>;
};

/** input type for inserting object relation for remote table "lesson_participants" */
export type LessonParticipantsObjRelInsertInput = {
  data: LessonParticipantsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LessonParticipantsOnConflict>;
};

/** on_conflict condition type for table "lesson_participants" */
export type LessonParticipantsOnConflict = {
  constraint: LessonParticipantsConstraint;
  updateColumns?: Array<LessonParticipantsUpdateColumn>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};

/** Ordering options when selecting data from "lesson_participants". */
export type LessonParticipantsOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  addedByPersona?: InputMaybe<OrderBy>;
  addedByUserId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  orderItemsAggregate?: InputMaybe<LessonOrderItemsAggregateOrderBy>;
  paidAt?: InputMaybe<OrderBy>;
  paymentFulfillmentChannel?: InputMaybe<OrderBy>;
  refundedAt?: InputMaybe<OrderBy>;
  refundedByPersona?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  removedByPersona?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: lesson_participants */
export type LessonParticipantsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_participants" */
export enum LessonParticipantsSelectColumn {
  /** column name */
  AddedAt = 'addedAt',
  /** column name */
  AddedByPersona = 'addedByPersona',
  /** column name */
  AddedByUserId = 'addedByUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  PaidAt = 'paidAt',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  RemovedAt = 'removedAt',
  /** column name */
  RemovedByPersona = 'removedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "lesson_participants" */
export type LessonParticipantsSetInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  paidAt?: InputMaybe<Scalars['timestamptz']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<LessonParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "lesson_participants" */
export type LessonParticipantsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonParticipantsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonParticipantsStreamCursorValueInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  paidAt?: InputMaybe<Scalars['timestamptz']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  refundedAt?: InputMaybe<Scalars['timestamptz']>;
  refundedByPersona?: InputMaybe<AppPersonasEnum>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<LessonParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "lesson_participants" */
export enum LessonParticipantsUpdateColumn {
  /** column name */
  AddedAt = 'addedAt',
  /** column name */
  AddedByPersona = 'addedByPersona',
  /** column name */
  AddedByUserId = 'addedByUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  PaidAt = 'paidAt',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  RefundedAt = 'refundedAt',
  /** column name */
  RefundedByPersona = 'refundedByPersona',
  /** column name */
  RemovedAt = 'removedAt',
  /** column name */
  RemovedByPersona = 'removedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type LessonParticipantsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonParticipantsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonParticipantsBoolExp;
};

/** columns and relationships of "lesson_privacy" */
export type LessonPrivacy = {
  __typename?: 'LessonPrivacy';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "lesson_privacy" */
export type LessonPrivacyAggregate = {
  __typename?: 'LessonPrivacyAggregate';
  aggregate?: Maybe<LessonPrivacyAggregateFields>;
  nodes: Array<LessonPrivacy>;
};

/** aggregate fields of "lesson_privacy" */
export type LessonPrivacyAggregateFields = {
  __typename?: 'LessonPrivacyAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonPrivacyMaxFields>;
  min?: Maybe<LessonPrivacyMinFields>;
};


/** aggregate fields of "lesson_privacy" */
export type LessonPrivacyAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lesson_privacy". All fields are combined with a logical 'AND'. */
export type LessonPrivacyBoolExp = {
  _and?: InputMaybe<Array<LessonPrivacyBoolExp>>;
  _not?: InputMaybe<LessonPrivacyBoolExp>;
  _or?: InputMaybe<Array<LessonPrivacyBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "lesson_privacy" */
export enum LessonPrivacyConstraint {
  /** unique or primary key constraint on columns "value" */
  LessonPrivacyPkey = 'lesson_privacy_pkey'
}

export enum LessonPrivacyEnum {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** Boolean expression to compare columns of type "LessonPrivacyEnum". All fields are combined with logical 'AND'. */
export type LessonPrivacyEnumComparisonExp = {
  _eq?: InputMaybe<LessonPrivacyEnum>;
  _in?: InputMaybe<Array<LessonPrivacyEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonPrivacyEnum>;
  _nin?: InputMaybe<Array<LessonPrivacyEnum>>;
};

/** input type for inserting data into table "lesson_privacy" */
export type LessonPrivacyInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LessonPrivacyMaxFields = {
  __typename?: 'LessonPrivacyMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LessonPrivacyMinFields = {
  __typename?: 'LessonPrivacyMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lesson_privacy" */
export type LessonPrivacyMutationResponse = {
  __typename?: 'LessonPrivacyMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonPrivacy>;
};

/** on_conflict condition type for table "lesson_privacy" */
export type LessonPrivacyOnConflict = {
  constraint: LessonPrivacyConstraint;
  updateColumns?: Array<LessonPrivacyUpdateColumn>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};

/** Ordering options when selecting data from "lesson_privacy". */
export type LessonPrivacyOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_privacy */
export type LessonPrivacyPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "lesson_privacy" */
export enum LessonPrivacySelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "lesson_privacy" */
export type LessonPrivacySetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "lesson_privacy" */
export type LessonPrivacyStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonPrivacyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonPrivacyStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "lesson_privacy" */
export enum LessonPrivacyUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type LessonPrivacyUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonPrivacySetInput>;
  /** filter the rows which have to be updated */
  where: LessonPrivacyBoolExp;
};

/** columns and relationships of "lesson_statuses" */
export type LessonStatuses = {
  __typename?: 'LessonStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "lesson_statuses" */
export type LessonStatusesAggregate = {
  __typename?: 'LessonStatusesAggregate';
  aggregate?: Maybe<LessonStatusesAggregateFields>;
  nodes: Array<LessonStatuses>;
};

/** aggregate fields of "lesson_statuses" */
export type LessonStatusesAggregateFields = {
  __typename?: 'LessonStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonStatusesMaxFields>;
  min?: Maybe<LessonStatusesMinFields>;
};


/** aggregate fields of "lesson_statuses" */
export type LessonStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lesson_statuses". All fields are combined with a logical 'AND'. */
export type LessonStatusesBoolExp = {
  _and?: InputMaybe<Array<LessonStatusesBoolExp>>;
  _not?: InputMaybe<LessonStatusesBoolExp>;
  _or?: InputMaybe<Array<LessonStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "lesson_statuses" */
export enum LessonStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  LessonStatusesPkey = 'lesson_statuses_pkey'
}

export enum LessonStatusesEnum {
  Active = 'ACTIVE',
  Canceled = 'CANCELED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "LessonStatusesEnum". All fields are combined with logical 'AND'. */
export type LessonStatusesEnumComparisonExp = {
  _eq?: InputMaybe<LessonStatusesEnum>;
  _in?: InputMaybe<Array<LessonStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonStatusesEnum>;
  _nin?: InputMaybe<Array<LessonStatusesEnum>>;
};

/** input type for inserting data into table "lesson_statuses" */
export type LessonStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LessonStatusesMaxFields = {
  __typename?: 'LessonStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LessonStatusesMinFields = {
  __typename?: 'LessonStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lesson_statuses" */
export type LessonStatusesMutationResponse = {
  __typename?: 'LessonStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonStatuses>;
};

/** on_conflict condition type for table "lesson_statuses" */
export type LessonStatusesOnConflict = {
  constraint: LessonStatusesConstraint;
  updateColumns?: Array<LessonStatusesUpdateColumn>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};

/** Ordering options when selecting data from "lesson_statuses". */
export type LessonStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_statuses */
export type LessonStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "lesson_statuses" */
export enum LessonStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "lesson_statuses" */
export type LessonStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "lesson_statuses" */
export type LessonStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "lesson_statuses" */
export enum LessonStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type LessonStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonStatusesBoolExp;
};

/** columns and relationships of "lesson_templates" */
export type LessonTemplates = {
  __typename?: 'LessonTemplates';
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  id: Scalars['uuid'];
  /** An object relationship */
  originalLesson?: Maybe<Lessons>;
  originalLessonId?: Maybe<Scalars['uuid']>;
  participantLimit: Scalars['Int'];
  priceUnitAmount: Scalars['Int'];
  privacy?: Maybe<LessonPrivacyEnum>;
  sport?: Maybe<SportsEnum>;
  templateName: Scalars['String'];
  title: Scalars['String'];
  type: LessonTypesEnum;
  typeCustom: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "lesson_templates" */
export type LessonTemplatesAggregate = {
  __typename?: 'LessonTemplatesAggregate';
  aggregate?: Maybe<LessonTemplatesAggregateFields>;
  nodes: Array<LessonTemplates>;
};

export type LessonTemplatesAggregateBoolExp = {
  count?: InputMaybe<LessonTemplatesAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_templates" */
export type LessonTemplatesAggregateFields = {
  __typename?: 'LessonTemplatesAggregateFields';
  avg?: Maybe<LessonTemplatesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LessonTemplatesMaxFields>;
  min?: Maybe<LessonTemplatesMinFields>;
  stddev?: Maybe<LessonTemplatesStddevFields>;
  stddevPop?: Maybe<LessonTemplatesStddevPopFields>;
  stddevSamp?: Maybe<LessonTemplatesStddevSampFields>;
  sum?: Maybe<LessonTemplatesSumFields>;
  varPop?: Maybe<LessonTemplatesVarPopFields>;
  varSamp?: Maybe<LessonTemplatesVarSampFields>;
  variance?: Maybe<LessonTemplatesVarianceFields>;
};


/** aggregate fields of "lesson_templates" */
export type LessonTemplatesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_templates" */
export type LessonTemplatesAggregateOrderBy = {
  avg?: InputMaybe<LessonTemplatesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonTemplatesMaxOrderBy>;
  min?: InputMaybe<LessonTemplatesMinOrderBy>;
  stddev?: InputMaybe<LessonTemplatesStddevOrderBy>;
  stddevPop?: InputMaybe<LessonTemplatesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LessonTemplatesStddevSampOrderBy>;
  sum?: InputMaybe<LessonTemplatesSumOrderBy>;
  varPop?: InputMaybe<LessonTemplatesVarPopOrderBy>;
  varSamp?: InputMaybe<LessonTemplatesVarSampOrderBy>;
  variance?: InputMaybe<LessonTemplatesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_templates" */
export type LessonTemplatesArrRelInsertInput = {
  data: Array<LessonTemplatesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};

/** aggregate avg on columns */
export type LessonTemplatesAvgFields = {
  __typename?: 'LessonTemplatesAvgFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "lesson_templates" */
export type LessonTemplatesAvgOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lesson_templates". All fields are combined with a logical 'AND'. */
export type LessonTemplatesBoolExp = {
  _and?: InputMaybe<Array<LessonTemplatesBoolExp>>;
  _not?: InputMaybe<LessonTemplatesBoolExp>;
  _or?: InputMaybe<Array<LessonTemplatesBoolExp>>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  originalLesson?: InputMaybe<LessonsBoolExp>;
  originalLessonId?: InputMaybe<UuidComparisonExp>;
  participantLimit?: InputMaybe<IntComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  privacy?: InputMaybe<LessonPrivacyEnumComparisonExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  templateName?: InputMaybe<StringComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<LessonTypesEnumComparisonExp>;
  typeCustom?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userCustomCourtId?: InputMaybe<UuidComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "lesson_templates" */
export enum LessonTemplatesConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonTemplatesPkey = 'lesson_templates_pkey'
}

/** input type for incrementing numeric columns in table "lesson_templates" */
export type LessonTemplatesIncInput = {
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lesson_templates" */
export type LessonTemplatesInsertInput = {
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  originalLesson?: InputMaybe<LessonsObjRelInsertInput>;
  originalLessonId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  sport?: InputMaybe<SportsEnum>;
  templateName?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type LessonTemplatesMaxFields = {
  __typename?: 'LessonTemplatesMaxFields';
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  originalLessonId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  templateName?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  typeCustom?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_templates" */
export type LessonTemplatesMaxOrderBy = {
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalLessonId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  templateName?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonTemplatesMinFields = {
  __typename?: 'LessonTemplatesMinFields';
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  originalLessonId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  templateName?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  typeCustom?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lesson_templates" */
export type LessonTemplatesMinOrderBy = {
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalLessonId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  templateName?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_templates" */
export type LessonTemplatesMutationResponse = {
  __typename?: 'LessonTemplatesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonTemplates>;
};

/** input type for inserting object relation for remote table "lesson_templates" */
export type LessonTemplatesObjRelInsertInput = {
  data: LessonTemplatesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};

/** on_conflict condition type for table "lesson_templates" */
export type LessonTemplatesOnConflict = {
  constraint: LessonTemplatesConstraint;
  updateColumns?: Array<LessonTemplatesUpdateColumn>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};

/** Ordering options when selecting data from "lesson_templates". */
export type LessonTemplatesOrderBy = {
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalLesson?: InputMaybe<LessonsOrderBy>;
  originalLessonId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  sport?: InputMaybe<OrderBy>;
  templateName?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_templates */
export type LessonTemplatesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_templates" */
export enum LessonTemplatesSelectColumn {
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  OriginalLessonId = 'originalLessonId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  Sport = 'sport',
  /** column name */
  TemplateName = 'templateName',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "lesson_templates" */
export type LessonTemplatesSetInput = {
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  originalLessonId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  sport?: InputMaybe<SportsEnum>;
  templateName?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type LessonTemplatesStddevFields = {
  __typename?: 'LessonTemplatesStddevFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "lesson_templates" */
export type LessonTemplatesStddevOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type LessonTemplatesStddevPopFields = {
  __typename?: 'LessonTemplatesStddevPopFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "lesson_templates" */
export type LessonTemplatesStddevPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type LessonTemplatesStddevSampFields = {
  __typename?: 'LessonTemplatesStddevSampFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "lesson_templates" */
export type LessonTemplatesStddevSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lesson_templates" */
export type LessonTemplatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonTemplatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonTemplatesStreamCursorValueInput = {
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  originalLessonId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  sport?: InputMaybe<SportsEnum>;
  templateName?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type LessonTemplatesSumFields = {
  __typename?: 'LessonTemplatesSumFields';
  participantLimit?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "lesson_templates" */
export type LessonTemplatesSumOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "lesson_templates" */
export enum LessonTemplatesUpdateColumn {
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  OriginalLessonId = 'originalLessonId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  Sport = 'sport',
  /** column name */
  TemplateName = 'templateName',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  UserId = 'userId'
}

export type LessonTemplatesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LessonTemplatesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonTemplatesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonTemplatesBoolExp;
};

/** aggregate varPop on columns */
export type LessonTemplatesVarPopFields = {
  __typename?: 'LessonTemplatesVarPopFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "lesson_templates" */
export type LessonTemplatesVarPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type LessonTemplatesVarSampFields = {
  __typename?: 'LessonTemplatesVarSampFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "lesson_templates" */
export type LessonTemplatesVarSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LessonTemplatesVarianceFields = {
  __typename?: 'LessonTemplatesVarianceFields';
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "lesson_templates" */
export type LessonTemplatesVarianceOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** While thinking through how we handle events with multiple dates or times (ie. a camp), this table was made. It will be actively used once that logic has been thought through more. HOWEVER, another option would be to put an FK on lessons that points to a parent lesson that drives it. This would also allow for things like descriptions for each individual lesson. This is a little more complex though. */
export type LessonTimes = {
  __typename?: 'LessonTimes';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endDateTime: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  startDateTime: Scalars['timestamptz'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "lesson_times" */
export type LessonTimesAggregate = {
  __typename?: 'LessonTimesAggregate';
  aggregate?: Maybe<LessonTimesAggregateFields>;
  nodes: Array<LessonTimes>;
};

export type LessonTimesAggregateBoolExp = {
  count?: InputMaybe<LessonTimesAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_times" */
export type LessonTimesAggregateFields = {
  __typename?: 'LessonTimesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonTimesMaxFields>;
  min?: Maybe<LessonTimesMinFields>;
};


/** aggregate fields of "lesson_times" */
export type LessonTimesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonTimesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_times" */
export type LessonTimesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonTimesMaxOrderBy>;
  min?: InputMaybe<LessonTimesMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_times" */
export type LessonTimesArrRelInsertInput = {
  data: Array<LessonTimesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonTimesOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_times". All fields are combined with a logical 'AND'. */
export type LessonTimesBoolExp = {
  _and?: InputMaybe<Array<LessonTimesBoolExp>>;
  _not?: InputMaybe<LessonTimesBoolExp>;
  _or?: InputMaybe<Array<LessonTimesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "lesson_times" */
export enum LessonTimesConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonTimesPkey = 'lesson_times_pkey'
}

/** input type for inserting data into table "lesson_times" */
export type LessonTimesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type LessonTimesMaxFields = {
  __typename?: 'LessonTimesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "lesson_times" */
export type LessonTimesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonTimesMinFields = {
  __typename?: 'LessonTimesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "lesson_times" */
export type LessonTimesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_times" */
export type LessonTimesMutationResponse = {
  __typename?: 'LessonTimesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonTimes>;
};

/** on_conflict condition type for table "lesson_times" */
export type LessonTimesOnConflict = {
  constraint: LessonTimesConstraint;
  updateColumns?: Array<LessonTimesUpdateColumn>;
  where?: InputMaybe<LessonTimesBoolExp>;
};

/** Ordering options when selecting data from "lesson_times". */
export type LessonTimesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_times */
export type LessonTimesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_times" */
export enum LessonTimesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "lesson_times" */
export type LessonTimesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "lesson_times" */
export type LessonTimesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonTimesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonTimesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "lesson_times" */
export enum LessonTimesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type LessonTimesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonTimesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonTimesBoolExp;
};

/** columns and relationships of "lesson_types" */
export type LessonTypes = {
  __typename?: 'LessonTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "lesson_types" */
export type LessonTypesAggregate = {
  __typename?: 'LessonTypesAggregate';
  aggregate?: Maybe<LessonTypesAggregateFields>;
  nodes: Array<LessonTypes>;
};

/** aggregate fields of "lesson_types" */
export type LessonTypesAggregateFields = {
  __typename?: 'LessonTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonTypesMaxFields>;
  min?: Maybe<LessonTypesMinFields>;
};


/** aggregate fields of "lesson_types" */
export type LessonTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lesson_types". All fields are combined with a logical 'AND'. */
export type LessonTypesBoolExp = {
  _and?: InputMaybe<Array<LessonTypesBoolExp>>;
  _not?: InputMaybe<LessonTypesBoolExp>;
  _or?: InputMaybe<Array<LessonTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "lesson_types" */
export enum LessonTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  LessonTypesPkey = 'lesson_types_pkey'
}

export enum LessonTypesEnum {
  Camp = 'CAMP',
  Cardio = 'CARDIO',
  Clinic = 'CLINIC',
  Custom = 'CUSTOM',
  Individual = 'INDIVIDUAL'
}

/** Boolean expression to compare columns of type "LessonTypesEnum". All fields are combined with logical 'AND'. */
export type LessonTypesEnumComparisonExp = {
  _eq?: InputMaybe<LessonTypesEnum>;
  _in?: InputMaybe<Array<LessonTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonTypesEnum>;
  _nin?: InputMaybe<Array<LessonTypesEnum>>;
};

/** input type for inserting data into table "lesson_types" */
export type LessonTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LessonTypesMaxFields = {
  __typename?: 'LessonTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LessonTypesMinFields = {
  __typename?: 'LessonTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lesson_types" */
export type LessonTypesMutationResponse = {
  __typename?: 'LessonTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonTypes>;
};

/** on_conflict condition type for table "lesson_types" */
export type LessonTypesOnConflict = {
  constraint: LessonTypesConstraint;
  updateColumns?: Array<LessonTypesUpdateColumn>;
  where?: InputMaybe<LessonTypesBoolExp>;
};

/** Ordering options when selecting data from "lesson_types". */
export type LessonTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_types */
export type LessonTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "lesson_types" */
export enum LessonTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "lesson_types" */
export type LessonTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "lesson_types" */
export type LessonTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "lesson_types" */
export enum LessonTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type LessonTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonTypesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonTypesBoolExp;
};

/** columns and relationships of "lesson_waitlist_statuses" */
export type LessonWaitlistStatuses = {
  __typename?: 'LessonWaitlistStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesAggregate = {
  __typename?: 'LessonWaitlistStatusesAggregate';
  aggregate?: Maybe<LessonWaitlistStatusesAggregateFields>;
  nodes: Array<LessonWaitlistStatuses>;
};

/** aggregate fields of "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesAggregateFields = {
  __typename?: 'LessonWaitlistStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonWaitlistStatusesMaxFields>;
  min?: Maybe<LessonWaitlistStatusesMinFields>;
};


/** aggregate fields of "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lesson_waitlist_statuses". All fields are combined with a logical 'AND'. */
export type LessonWaitlistStatusesBoolExp = {
  _and?: InputMaybe<Array<LessonWaitlistStatusesBoolExp>>;
  _not?: InputMaybe<LessonWaitlistStatusesBoolExp>;
  _or?: InputMaybe<Array<LessonWaitlistStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "lesson_waitlist_statuses" */
export enum LessonWaitlistStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  LessonWaitlistStatusesPkey = 'lesson_waitlist_statuses_pkey'
}

export enum LessonWaitlistStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

/** Boolean expression to compare columns of type "LessonWaitlistStatusesEnum". All fields are combined with logical 'AND'. */
export type LessonWaitlistStatusesEnumComparisonExp = {
  _eq?: InputMaybe<LessonWaitlistStatusesEnum>;
  _in?: InputMaybe<Array<LessonWaitlistStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<LessonWaitlistStatusesEnum>;
  _nin?: InputMaybe<Array<LessonWaitlistStatusesEnum>>;
};

/** input type for inserting data into table "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type LessonWaitlistStatusesMaxFields = {
  __typename?: 'LessonWaitlistStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type LessonWaitlistStatusesMinFields = {
  __typename?: 'LessonWaitlistStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesMutationResponse = {
  __typename?: 'LessonWaitlistStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonWaitlistStatuses>;
};

/** on_conflict condition type for table "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesOnConflict = {
  constraint: LessonWaitlistStatusesConstraint;
  updateColumns?: Array<LessonWaitlistStatusesUpdateColumn>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};

/** Ordering options when selecting data from "lesson_waitlist_statuses". */
export type LessonWaitlistStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lesson_waitlist_statuses */
export type LessonWaitlistStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "lesson_waitlist_statuses" */
export enum LessonWaitlistStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "lesson_waitlist_statuses" */
export type LessonWaitlistStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonWaitlistStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonWaitlistStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "lesson_waitlist_statuses" */
export enum LessonWaitlistStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type LessonWaitlistStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonWaitlistStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: LessonWaitlistStatusesBoolExp;
};

/** columns and relationships of "lesson_waitlists" */
export type LessonWaitlists = {
  __typename?: 'LessonWaitlists';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson: Lessons;
  lessonId: Scalars['uuid'];
  status: LessonWaitlistStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "lesson_waitlists" */
export type LessonWaitlistsAggregate = {
  __typename?: 'LessonWaitlistsAggregate';
  aggregate?: Maybe<LessonWaitlistsAggregateFields>;
  nodes: Array<LessonWaitlists>;
};

export type LessonWaitlistsAggregateBoolExp = {
  count?: InputMaybe<LessonWaitlistsAggregateBoolExpCount>;
};

/** aggregate fields of "lesson_waitlists" */
export type LessonWaitlistsAggregateFields = {
  __typename?: 'LessonWaitlistsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<LessonWaitlistsMaxFields>;
  min?: Maybe<LessonWaitlistsMinFields>;
};


/** aggregate fields of "lesson_waitlists" */
export type LessonWaitlistsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lesson_waitlists" */
export type LessonWaitlistsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonWaitlistsMaxOrderBy>;
  min?: InputMaybe<LessonWaitlistsMinOrderBy>;
};

/** input type for inserting array relation for remote table "lesson_waitlists" */
export type LessonWaitlistsArrRelInsertInput = {
  data: Array<LessonWaitlistsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonWaitlistsOnConflict>;
};

/** Boolean expression to filter rows from the table "lesson_waitlists". All fields are combined with a logical 'AND'. */
export type LessonWaitlistsBoolExp = {
  _and?: InputMaybe<Array<LessonWaitlistsBoolExp>>;
  _not?: InputMaybe<LessonWaitlistsBoolExp>;
  _or?: InputMaybe<Array<LessonWaitlistsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<LessonWaitlistStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "lesson_waitlists" */
export enum LessonWaitlistsConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonWaitlistsPkey = 'lesson_waitlists_pkey',
  /** unique or primary key constraint on columns "lesson_id", "user_id" */
  LessonWaitlistsUserIdLessonIdKey = 'lesson_waitlists_user_id_lesson_id_key'
}

/** input type for inserting data into table "lesson_waitlists" */
export type LessonWaitlistsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<LessonWaitlistStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type LessonWaitlistsMaxFields = {
  __typename?: 'LessonWaitlistsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lesson_waitlists" */
export type LessonWaitlistsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonWaitlistsMinFields = {
  __typename?: 'LessonWaitlistsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lesson_waitlists" */
export type LessonWaitlistsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lesson_waitlists" */
export type LessonWaitlistsMutationResponse = {
  __typename?: 'LessonWaitlistsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<LessonWaitlists>;
};

/** on_conflict condition type for table "lesson_waitlists" */
export type LessonWaitlistsOnConflict = {
  constraint: LessonWaitlistsConstraint;
  updateColumns?: Array<LessonWaitlistsUpdateColumn>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};

/** Ordering options when selecting data from "lesson_waitlists". */
export type LessonWaitlistsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: lesson_waitlists */
export type LessonWaitlistsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lesson_waitlists" */
export enum LessonWaitlistsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "lesson_waitlists" */
export type LessonWaitlistsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<LessonWaitlistStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "lesson_waitlists" */
export type LessonWaitlistsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonWaitlistsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonWaitlistsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<LessonWaitlistStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "lesson_waitlists" */
export enum LessonWaitlistsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type LessonWaitlistsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonWaitlistsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonWaitlistsBoolExp;
};

/** columns and relationships of "lessons" */
export type Lessons = {
  __typename?: 'Lessons';
  cancelReason: Scalars['String'];
  canceledAt?: Maybe<Scalars['timestamptz']>;
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  endDateTime?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  equipment: Array<LessonEquipment>;
  /** An aggregate relationship */
  equipmentAggregate: LessonEquipmentAggregate;
  id: Scalars['uuid'];
  locale: Scalars['String'];
  /** An object relationship */
  owner?: Maybe<Users>;
  /** An object relationship */
  ownerProfile?: Maybe<UserProfiles>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** An array relationship */
  participants: Array<LessonParticipants>;
  /** An aggregate relationship */
  participantsAggregate: LessonParticipantsAggregate;
  paymentFulfillmentChannel: PaymentFulfillmentChannelsEnum;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount: Scalars['Int'];
  privacy: LessonPrivacyEnum;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  sport: SportsEnum;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  status: LessonStatusesEnum;
  /** An array relationship */
  times: Array<LessonTimes>;
  /** An aggregate relationship */
  timesAggregate: LessonTimesAggregate;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title: Scalars['String'];
  type: LessonTypesEnum;
  typeCustom: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  usedTemplate?: Maybe<LessonTemplates>;
  usedTemplateId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  userCustomCourt?: Maybe<UserCustomCourts>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  waitlist: Array<LessonWaitlists>;
  /** An aggregate relationship */
  waitlistAggregate: LessonWaitlistsAggregate;
};


/** columns and relationships of "lessons" */
export type LessonsEquipmentArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsEquipmentAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsParticipantsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsTimesArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsTimesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsWaitlistArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


/** columns and relationships of "lessons" */
export type LessonsWaitlistAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};

/** aggregated selection of "lessons" */
export type LessonsAggregate = {
  __typename?: 'LessonsAggregate';
  aggregate?: Maybe<LessonsAggregateFields>;
  nodes: Array<Lessons>;
};

export type LessonsAggregateBoolExp = {
  count?: InputMaybe<LessonsAggregateBoolExpCount>;
};

/** aggregate fields of "lessons" */
export type LessonsAggregateFields = {
  __typename?: 'LessonsAggregateFields';
  avg?: Maybe<LessonsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<LessonsMaxFields>;
  min?: Maybe<LessonsMinFields>;
  stddev?: Maybe<LessonsStddevFields>;
  stddevPop?: Maybe<LessonsStddevPopFields>;
  stddevSamp?: Maybe<LessonsStddevSampFields>;
  sum?: Maybe<LessonsSumFields>;
  varPop?: Maybe<LessonsVarPopFields>;
  varSamp?: Maybe<LessonsVarSampFields>;
  variance?: Maybe<LessonsVarianceFields>;
};


/** aggregate fields of "lessons" */
export type LessonsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LessonsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lessons" */
export type LessonsAggregateOrderBy = {
  avg?: InputMaybe<LessonsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LessonsMaxOrderBy>;
  min?: InputMaybe<LessonsMinOrderBy>;
  stddev?: InputMaybe<LessonsStddevOrderBy>;
  stddevPop?: InputMaybe<LessonsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LessonsStddevSampOrderBy>;
  sum?: InputMaybe<LessonsSumOrderBy>;
  varPop?: InputMaybe<LessonsVarPopOrderBy>;
  varSamp?: InputMaybe<LessonsVarSampOrderBy>;
  variance?: InputMaybe<LessonsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "lessons" */
export type LessonsArrRelInsertInput = {
  data: Array<LessonsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LessonsOnConflict>;
};

/** aggregate avg on columns */
export type LessonsAvgFields = {
  __typename?: 'LessonsAvgFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "lessons" */
export type LessonsAvgOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lessons". All fields are combined with a logical 'AND'. */
export type LessonsBoolExp = {
  _and?: InputMaybe<Array<LessonsBoolExp>>;
  _not?: InputMaybe<LessonsBoolExp>;
  _or?: InputMaybe<Array<LessonsBoolExp>>;
  cancelReason?: InputMaybe<StringComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderId?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  equipment?: InputMaybe<LessonEquipmentBoolExp>;
  equipmentAggregate?: InputMaybe<LessonEquipmentAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  locale?: InputMaybe<StringComparisonExp>;
  owner?: InputMaybe<UsersBoolExp>;
  ownerProfile?: InputMaybe<UserProfilesBoolExp>;
  ownerUserId?: InputMaybe<UuidComparisonExp>;
  participantLimit?: InputMaybe<IntComparisonExp>;
  participants?: InputMaybe<LessonParticipantsBoolExp>;
  participantsAggregate?: InputMaybe<LessonParticipantsAggregateBoolExp>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnumComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  privacy?: InputMaybe<LessonPrivacyEnumComparisonExp>;
  publishedAt?: InputMaybe<TimestamptzComparisonExp>;
  reminderEventId?: InputMaybe<UuidComparisonExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<LessonStatusesEnumComparisonExp>;
  times?: InputMaybe<LessonTimesBoolExp>;
  timesAggregate?: InputMaybe<LessonTimesAggregateBoolExp>;
  timezoneAbbreviation?: InputMaybe<StringComparisonExp>;
  timezoneName?: InputMaybe<StringComparisonExp>;
  timezoneOffsetMinutes?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<LessonTypesEnumComparisonExp>;
  typeCustom?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  usedTemplate?: InputMaybe<LessonTemplatesBoolExp>;
  usedTemplateId?: InputMaybe<UuidComparisonExp>;
  userCustomCourt?: InputMaybe<UserCustomCourtsBoolExp>;
  userCustomCourtId?: InputMaybe<UuidComparisonExp>;
  waitlist?: InputMaybe<LessonWaitlistsBoolExp>;
  waitlistAggregate?: InputMaybe<LessonWaitlistsAggregateBoolExp>;
};

/** unique or primary key constraints on table "lessons" */
export enum LessonsConstraint {
  /** unique or primary key constraint on columns "id" */
  LessonsPkey = 'lessons_pkey'
}

/** input type for incrementing numeric columns in table "lessons" */
export type LessonsIncInput = {
  participantLimit?: InputMaybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lessons" */
export type LessonsInsertInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  equipment?: InputMaybe<LessonEquipmentArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  locale?: InputMaybe<Scalars['String']>;
  owner?: InputMaybe<UsersObjRelInsertInput>;
  ownerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  participants?: InputMaybe<LessonParticipantsArrRelInsertInput>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonStatusesEnum>;
  times?: InputMaybe<LessonTimesArrRelInsertInput>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  usedTemplate?: InputMaybe<LessonTemplatesObjRelInsertInput>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourt?: InputMaybe<UserCustomCourtsObjRelInsertInput>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  waitlist?: InputMaybe<LessonWaitlistsArrRelInsertInput>;
};

/** aggregate max on columns */
export type LessonsMaxFields = {
  __typename?: 'LessonsMaxFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  typeCustom?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  usedTemplateId?: Maybe<Scalars['uuid']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "lessons" */
export type LessonsMaxOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  usedTemplateId?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LessonsMinFields = {
  __typename?: 'LessonsMinFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  ownerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  typeCustom?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  usedTemplateId?: Maybe<Scalars['uuid']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "lessons" */
export type LessonsMinOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  usedTemplateId?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lessons" */
export type LessonsMutationResponse = {
  __typename?: 'LessonsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Lessons>;
};

/** input type for inserting object relation for remote table "lessons" */
export type LessonsObjRelInsertInput = {
  data: LessonsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LessonsOnConflict>;
};

/** on_conflict condition type for table "lessons" */
export type LessonsOnConflict = {
  constraint: LessonsConstraint;
  updateColumns?: Array<LessonsUpdateColumn>;
  where?: InputMaybe<LessonsBoolExp>;
};

/** Ordering options when selecting data from "lessons". */
export type LessonsOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  equipmentAggregate?: InputMaybe<LessonEquipmentAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  owner?: InputMaybe<UsersOrderBy>;
  ownerProfile?: InputMaybe<UserProfilesOrderBy>;
  ownerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  participantsAggregate?: InputMaybe<LessonParticipantsAggregateOrderBy>;
  paymentFulfillmentChannel?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  sport?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timesAggregate?: InputMaybe<LessonTimesAggregateOrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  typeCustom?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  usedTemplate?: InputMaybe<LessonTemplatesOrderBy>;
  usedTemplateId?: InputMaybe<OrderBy>;
  userCustomCourt?: InputMaybe<UserCustomCourtsOrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  waitlistAggregate?: InputMaybe<LessonWaitlistsAggregateOrderBy>;
};

/** primary key columns input for table: lessons */
export type LessonsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "lessons" */
export enum LessonsSelectColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  OwnerUserId = 'ownerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  ReminderEventId = 'reminderEventId',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedTemplateId = 'usedTemplateId',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId'
}

/** input type for updating data in table "lessons" */
export type LessonsSetInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  locale?: InputMaybe<Scalars['String']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonStatusesEnum>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type LessonsStddevFields = {
  __typename?: 'LessonsStddevFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "lessons" */
export type LessonsStddevOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type LessonsStddevPopFields = {
  __typename?: 'LessonsStddevPopFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "lessons" */
export type LessonsStddevPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type LessonsStddevSampFields = {
  __typename?: 'LessonsStddevSampFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "lessons" */
export type LessonsStddevSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lessons" */
export type LessonsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LessonsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LessonsStreamCursorValueInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  locale?: InputMaybe<Scalars['String']>;
  ownerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  paymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<LessonPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<LessonStatusesEnum>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  typeCustom?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  usedTemplateId?: InputMaybe<Scalars['uuid']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type LessonsSumFields = {
  __typename?: 'LessonsSumFields';
  participantLimit?: Maybe<Scalars['Int']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Int']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "lessons" */
export type LessonsSumOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** update columns of table "lessons" */
export enum LessonsUpdateColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  OwnerUserId = 'ownerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PaymentFulfillmentChannel = 'paymentFulfillmentChannel',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  ReminderEventId = 'reminderEventId',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  TypeCustom = 'typeCustom',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedTemplateId = 'usedTemplateId',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId'
}

export type LessonsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LessonsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LessonsSetInput>;
  /** filter the rows which have to be updated */
  where: LessonsBoolExp;
};

/** aggregate varPop on columns */
export type LessonsVarPopFields = {
  __typename?: 'LessonsVarPopFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "lessons" */
export type LessonsVarPopOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type LessonsVarSampFields = {
  __typename?: 'LessonsVarSampFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "lessons" */
export type LessonsVarSampOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LessonsVarianceFields = {
  __typename?: 'LessonsVarianceFields';
  participantLimit?: Maybe<Scalars['Float']>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "lessons" */
export type LessonsVarianceOrderBy = {
  participantLimit?: InputMaybe<OrderBy>;
  /** This follows the standard from Stripe where a price is stored in its smallest denomination as an integer. In USD, this would be cents. For example, $42.23 is stored as 4223. */
  priceUnitAmount?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** columns and relationships of "match_selection_criteria" */
export type MatchSelectionCriteria = {
  __typename?: 'MatchSelectionCriteria';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "match_selection_criteria" */
export type MatchSelectionCriteriaAggregate = {
  __typename?: 'MatchSelectionCriteriaAggregate';
  aggregate?: Maybe<MatchSelectionCriteriaAggregateFields>;
  nodes: Array<MatchSelectionCriteria>;
};

/** aggregate fields of "match_selection_criteria" */
export type MatchSelectionCriteriaAggregateFields = {
  __typename?: 'MatchSelectionCriteriaAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<MatchSelectionCriteriaMaxFields>;
  min?: Maybe<MatchSelectionCriteriaMinFields>;
};


/** aggregate fields of "match_selection_criteria" */
export type MatchSelectionCriteriaAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "match_selection_criteria". All fields are combined with a logical 'AND'. */
export type MatchSelectionCriteriaBoolExp = {
  _and?: InputMaybe<Array<MatchSelectionCriteriaBoolExp>>;
  _not?: InputMaybe<MatchSelectionCriteriaBoolExp>;
  _or?: InputMaybe<Array<MatchSelectionCriteriaBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "match_selection_criteria" */
export enum MatchSelectionCriteriaConstraint {
  /** unique or primary key constraint on columns "value" */
  MatchSelectionCriteriaPkey = 'match_selection_criteria_pkey'
}

export enum MatchSelectionCriteriaEnum {
  Loser = 'LOSER',
  Winner = 'WINNER'
}

/** Boolean expression to compare columns of type "MatchSelectionCriteriaEnum". All fields are combined with logical 'AND'. */
export type MatchSelectionCriteriaEnumComparisonExp = {
  _eq?: InputMaybe<MatchSelectionCriteriaEnum>;
  _in?: InputMaybe<Array<MatchSelectionCriteriaEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<MatchSelectionCriteriaEnum>;
  _nin?: InputMaybe<Array<MatchSelectionCriteriaEnum>>;
};

/** input type for inserting data into table "match_selection_criteria" */
export type MatchSelectionCriteriaInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type MatchSelectionCriteriaMaxFields = {
  __typename?: 'MatchSelectionCriteriaMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type MatchSelectionCriteriaMinFields = {
  __typename?: 'MatchSelectionCriteriaMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "match_selection_criteria" */
export type MatchSelectionCriteriaMutationResponse = {
  __typename?: 'MatchSelectionCriteriaMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<MatchSelectionCriteria>;
};

/** on_conflict condition type for table "match_selection_criteria" */
export type MatchSelectionCriteriaOnConflict = {
  constraint: MatchSelectionCriteriaConstraint;
  updateColumns?: Array<MatchSelectionCriteriaUpdateColumn>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};

/** Ordering options when selecting data from "match_selection_criteria". */
export type MatchSelectionCriteriaOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: match_selection_criteria */
export type MatchSelectionCriteriaPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "match_selection_criteria" */
export enum MatchSelectionCriteriaSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "match_selection_criteria" */
export type MatchSelectionCriteriaSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "match_selection_criteria" */
export type MatchSelectionCriteriaStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MatchSelectionCriteriaStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MatchSelectionCriteriaStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "match_selection_criteria" */
export enum MatchSelectionCriteriaUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type MatchSelectionCriteriaUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MatchSelectionCriteriaSetInput>;
  /** filter the rows which have to be updated */
  where: MatchSelectionCriteriaBoolExp;
};

/** columns and relationships of "notification_action_types" */
export type NotificationActionTypes = {
  __typename?: 'NotificationActionTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "notification_action_types" */
export type NotificationActionTypesAggregate = {
  __typename?: 'NotificationActionTypesAggregate';
  aggregate?: Maybe<NotificationActionTypesAggregateFields>;
  nodes: Array<NotificationActionTypes>;
};

/** aggregate fields of "notification_action_types" */
export type NotificationActionTypesAggregateFields = {
  __typename?: 'NotificationActionTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<NotificationActionTypesMaxFields>;
  min?: Maybe<NotificationActionTypesMinFields>;
};


/** aggregate fields of "notification_action_types" */
export type NotificationActionTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NotificationActionTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "notification_action_types". All fields are combined with a logical 'AND'. */
export type NotificationActionTypesBoolExp = {
  _and?: InputMaybe<Array<NotificationActionTypesBoolExp>>;
  _not?: InputMaybe<NotificationActionTypesBoolExp>;
  _or?: InputMaybe<Array<NotificationActionTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "notification_action_types" */
export enum NotificationActionTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  NotificationActionTypesPkey = 'notification_action_types_pkey'
}

export enum NotificationActionTypesEnum {
  FollowerUserNew = 'FOLLOWER_USER_NEW',
  GroupCommentReply = 'GROUP_COMMENT_REPLY',
  GroupCommentUpvote = 'GROUP_COMMENT_UPVOTE',
  LessonCoachCancel = 'LESSON_COACH_CANCEL',
  LessonParticipantJoin = 'LESSON_PARTICIPANT_JOIN',
  LessonParticipantLeave = 'LESSON_PARTICIPANT_LEAVE',
  LessonStartReminder = 'LESSON_START_REMINDER',
  PlaySessionCommentSubmit = 'PLAY_SESSION_COMMENT_SUBMIT',
  PlaySessionDetailsUpdate = 'PLAY_SESSION_DETAILS_UPDATE',
  PlaySessionOrganizerCancel = 'PLAY_SESSION_ORGANIZER_CANCEL',
  PlaySessionParticipantJoin = 'PLAY_SESSION_PARTICIPANT_JOIN',
  PlaySessionParticipantLeave = 'PLAY_SESSION_PARTICIPANT_LEAVE',
  PlaySessionStartReminder = 'PLAY_SESSION_START_REMINDER'
}

/** Boolean expression to compare columns of type "NotificationActionTypesEnum". All fields are combined with logical 'AND'. */
export type NotificationActionTypesEnumComparisonExp = {
  _eq?: InputMaybe<NotificationActionTypesEnum>;
  _in?: InputMaybe<Array<NotificationActionTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<NotificationActionTypesEnum>;
  _nin?: InputMaybe<Array<NotificationActionTypesEnum>>;
};

/** input type for inserting data into table "notification_action_types" */
export type NotificationActionTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type NotificationActionTypesMaxFields = {
  __typename?: 'NotificationActionTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type NotificationActionTypesMinFields = {
  __typename?: 'NotificationActionTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "notification_action_types" */
export type NotificationActionTypesMutationResponse = {
  __typename?: 'NotificationActionTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<NotificationActionTypes>;
};

/** on_conflict condition type for table "notification_action_types" */
export type NotificationActionTypesOnConflict = {
  constraint: NotificationActionTypesConstraint;
  updateColumns?: Array<NotificationActionTypesUpdateColumn>;
  where?: InputMaybe<NotificationActionTypesBoolExp>;
};

/** Ordering options when selecting data from "notification_action_types". */
export type NotificationActionTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: notification_action_types */
export type NotificationActionTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "notification_action_types" */
export enum NotificationActionTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "notification_action_types" */
export type NotificationActionTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "notification_action_types" */
export type NotificationActionTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: NotificationActionTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NotificationActionTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "notification_action_types" */
export enum NotificationActionTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type NotificationActionTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<NotificationActionTypesSetInput>;
  /** filter the rows which have to be updated */
  where: NotificationActionTypesBoolExp;
};

/** columns and relationships of "notification_statuses" */
export type NotificationStatuses = {
  __typename?: 'NotificationStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "notification_statuses" */
export type NotificationStatusesAggregate = {
  __typename?: 'NotificationStatusesAggregate';
  aggregate?: Maybe<NotificationStatusesAggregateFields>;
  nodes: Array<NotificationStatuses>;
};

/** aggregate fields of "notification_statuses" */
export type NotificationStatusesAggregateFields = {
  __typename?: 'NotificationStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<NotificationStatusesMaxFields>;
  min?: Maybe<NotificationStatusesMinFields>;
};


/** aggregate fields of "notification_statuses" */
export type NotificationStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NotificationStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "notification_statuses". All fields are combined with a logical 'AND'. */
export type NotificationStatusesBoolExp = {
  _and?: InputMaybe<Array<NotificationStatusesBoolExp>>;
  _not?: InputMaybe<NotificationStatusesBoolExp>;
  _or?: InputMaybe<Array<NotificationStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "notification_statuses" */
export enum NotificationStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  NotificationStatusesPkey = 'notification_statuses_pkey'
}

export enum NotificationStatusesEnum {
  Read = 'READ',
  Unread = 'UNREAD'
}

/** Boolean expression to compare columns of type "NotificationStatusesEnum". All fields are combined with logical 'AND'. */
export type NotificationStatusesEnumComparisonExp = {
  _eq?: InputMaybe<NotificationStatusesEnum>;
  _in?: InputMaybe<Array<NotificationStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<NotificationStatusesEnum>;
  _nin?: InputMaybe<Array<NotificationStatusesEnum>>;
};

/** input type for inserting data into table "notification_statuses" */
export type NotificationStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type NotificationStatusesMaxFields = {
  __typename?: 'NotificationStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type NotificationStatusesMinFields = {
  __typename?: 'NotificationStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "notification_statuses" */
export type NotificationStatusesMutationResponse = {
  __typename?: 'NotificationStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<NotificationStatuses>;
};

/** on_conflict condition type for table "notification_statuses" */
export type NotificationStatusesOnConflict = {
  constraint: NotificationStatusesConstraint;
  updateColumns?: Array<NotificationStatusesUpdateColumn>;
  where?: InputMaybe<NotificationStatusesBoolExp>;
};

/** Ordering options when selecting data from "notification_statuses". */
export type NotificationStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: notification_statuses */
export type NotificationStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "notification_statuses" */
export enum NotificationStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "notification_statuses" */
export type NotificationStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "notification_statuses" */
export type NotificationStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: NotificationStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NotificationStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "notification_statuses" */
export enum NotificationStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type NotificationStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<NotificationStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: NotificationStatusesBoolExp;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']>;
  _gt?: InputMaybe<Scalars['numeric']>;
  _gte?: InputMaybe<Scalars['numeric']>;
  _in?: InputMaybe<Array<Scalars['numeric']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['numeric']>;
  _lte?: InputMaybe<Scalars['numeric']>;
  _neq?: InputMaybe<Scalars['numeric']>;
  _nin?: InputMaybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'ASC',
  /** in ascending order, nulls first */
  AscNullsFirst = 'ASC_NULLS_FIRST',
  /** in ascending order, nulls last */
  AscNullsLast = 'ASC_NULLS_LAST',
  /** in descending order, nulls first */
  Desc = 'DESC',
  /** in descending order, nulls first */
  DescNullsFirst = 'DESC_NULLS_FIRST',
  /** in descending order, nulls last */
  DescNullsLast = 'DESC_NULLS_LAST'
}

/** columns and relationships of "order_statuses" */
export type OrderStatuses = {
  __typename?: 'OrderStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "order_statuses" */
export type OrderStatusesAggregate = {
  __typename?: 'OrderStatusesAggregate';
  aggregate?: Maybe<OrderStatusesAggregateFields>;
  nodes: Array<OrderStatuses>;
};

/** aggregate fields of "order_statuses" */
export type OrderStatusesAggregateFields = {
  __typename?: 'OrderStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<OrderStatusesMaxFields>;
  min?: Maybe<OrderStatusesMinFields>;
};


/** aggregate fields of "order_statuses" */
export type OrderStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<OrderStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "order_statuses". All fields are combined with a logical 'AND'. */
export type OrderStatusesBoolExp = {
  _and?: InputMaybe<Array<OrderStatusesBoolExp>>;
  _not?: InputMaybe<OrderStatusesBoolExp>;
  _or?: InputMaybe<Array<OrderStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "order_statuses" */
export enum OrderStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  OrderStatusesPkey = 'order_statuses_pkey'
}

export enum OrderStatusesEnum {
  Canceled = 'CANCELED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Refunded = 'REFUNDED',
  Succeeded = 'SUCCEEDED'
}

/** Boolean expression to compare columns of type "OrderStatusesEnum". All fields are combined with logical 'AND'. */
export type OrderStatusesEnumComparisonExp = {
  _eq?: InputMaybe<OrderStatusesEnum>;
  _in?: InputMaybe<Array<OrderStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<OrderStatusesEnum>;
  _nin?: InputMaybe<Array<OrderStatusesEnum>>;
};

/** input type for inserting data into table "order_statuses" */
export type OrderStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type OrderStatusesMaxFields = {
  __typename?: 'OrderStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type OrderStatusesMinFields = {
  __typename?: 'OrderStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "order_statuses" */
export type OrderStatusesMutationResponse = {
  __typename?: 'OrderStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<OrderStatuses>;
};

/** on_conflict condition type for table "order_statuses" */
export type OrderStatusesOnConflict = {
  constraint: OrderStatusesConstraint;
  updateColumns?: Array<OrderStatusesUpdateColumn>;
  where?: InputMaybe<OrderStatusesBoolExp>;
};

/** Ordering options when selecting data from "order_statuses". */
export type OrderStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: order_statuses */
export type OrderStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "order_statuses" */
export enum OrderStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "order_statuses" */
export type OrderStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "order_statuses" */
export type OrderStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: OrderStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type OrderStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "order_statuses" */
export enum OrderStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type OrderStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<OrderStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: OrderStatusesBoolExp;
};

/** columns and relationships of "payment_fulfillment_channels" */
export type PaymentFulfillmentChannels = {
  __typename?: 'PaymentFulfillmentChannels';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsAggregate = {
  __typename?: 'PaymentFulfillmentChannelsAggregate';
  aggregate?: Maybe<PaymentFulfillmentChannelsAggregateFields>;
  nodes: Array<PaymentFulfillmentChannels>;
};

/** aggregate fields of "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsAggregateFields = {
  __typename?: 'PaymentFulfillmentChannelsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PaymentFulfillmentChannelsMaxFields>;
  min?: Maybe<PaymentFulfillmentChannelsMinFields>;
};


/** aggregate fields of "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "payment_fulfillment_channels". All fields are combined with a logical 'AND'. */
export type PaymentFulfillmentChannelsBoolExp = {
  _and?: InputMaybe<Array<PaymentFulfillmentChannelsBoolExp>>;
  _not?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
  _or?: InputMaybe<Array<PaymentFulfillmentChannelsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "payment_fulfillment_channels" */
export enum PaymentFulfillmentChannelsConstraint {
  /** unique or primary key constraint on columns "value" */
  PaymentFulfillmentChannelsPkey = 'payment_fulfillment_channels_pkey'
}

export enum PaymentFulfillmentChannelsEnum {
  OffPlatform = 'OFF_PLATFORM',
  OnPlatform = 'ON_PLATFORM',
  ParticipantsChoice = 'PARTICIPANTS_CHOICE'
}

/** Boolean expression to compare columns of type "PaymentFulfillmentChannelsEnum". All fields are combined with logical 'AND'. */
export type PaymentFulfillmentChannelsEnumComparisonExp = {
  _eq?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  _in?: InputMaybe<Array<PaymentFulfillmentChannelsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  _nin?: InputMaybe<Array<PaymentFulfillmentChannelsEnum>>;
};

/** input type for inserting data into table "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PaymentFulfillmentChannelsMaxFields = {
  __typename?: 'PaymentFulfillmentChannelsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PaymentFulfillmentChannelsMinFields = {
  __typename?: 'PaymentFulfillmentChannelsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsMutationResponse = {
  __typename?: 'PaymentFulfillmentChannelsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PaymentFulfillmentChannels>;
};

/** on_conflict condition type for table "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsOnConflict = {
  constraint: PaymentFulfillmentChannelsConstraint;
  updateColumns?: Array<PaymentFulfillmentChannelsUpdateColumn>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};

/** Ordering options when selecting data from "payment_fulfillment_channels". */
export type PaymentFulfillmentChannelsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payment_fulfillment_channels */
export type PaymentFulfillmentChannelsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "payment_fulfillment_channels" */
export enum PaymentFulfillmentChannelsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "payment_fulfillment_channels" */
export type PaymentFulfillmentChannelsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PaymentFulfillmentChannelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PaymentFulfillmentChannelsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "payment_fulfillment_channels" */
export enum PaymentFulfillmentChannelsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PaymentFulfillmentChannelsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PaymentFulfillmentChannelsSetInput>;
  /** filter the rows which have to be updated */
  where: PaymentFulfillmentChannelsBoolExp;
};

/** columns and relationships of "payment_processors" */
export type PaymentProcessors = {
  __typename?: 'PaymentProcessors';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "payment_processors" */
export type PaymentProcessorsAggregate = {
  __typename?: 'PaymentProcessorsAggregate';
  aggregate?: Maybe<PaymentProcessorsAggregateFields>;
  nodes: Array<PaymentProcessors>;
};

/** aggregate fields of "payment_processors" */
export type PaymentProcessorsAggregateFields = {
  __typename?: 'PaymentProcessorsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PaymentProcessorsMaxFields>;
  min?: Maybe<PaymentProcessorsMinFields>;
};


/** aggregate fields of "payment_processors" */
export type PaymentProcessorsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PaymentProcessorsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "payment_processors". All fields are combined with a logical 'AND'. */
export type PaymentProcessorsBoolExp = {
  _and?: InputMaybe<Array<PaymentProcessorsBoolExp>>;
  _not?: InputMaybe<PaymentProcessorsBoolExp>;
  _or?: InputMaybe<Array<PaymentProcessorsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "payment_processors" */
export enum PaymentProcessorsConstraint {
  /** unique or primary key constraint on columns "value" */
  PaymentProcessorsPkey = 'payment_processors_pkey'
}

export enum PaymentProcessorsEnum {
  Stripe = 'STRIPE'
}

/** Boolean expression to compare columns of type "PaymentProcessorsEnum". All fields are combined with logical 'AND'. */
export type PaymentProcessorsEnumComparisonExp = {
  _eq?: InputMaybe<PaymentProcessorsEnum>;
  _in?: InputMaybe<Array<PaymentProcessorsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PaymentProcessorsEnum>;
  _nin?: InputMaybe<Array<PaymentProcessorsEnum>>;
};

/** input type for inserting data into table "payment_processors" */
export type PaymentProcessorsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PaymentProcessorsMaxFields = {
  __typename?: 'PaymentProcessorsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PaymentProcessorsMinFields = {
  __typename?: 'PaymentProcessorsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "payment_processors" */
export type PaymentProcessorsMutationResponse = {
  __typename?: 'PaymentProcessorsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PaymentProcessors>;
};

/** on_conflict condition type for table "payment_processors" */
export type PaymentProcessorsOnConflict = {
  constraint: PaymentProcessorsConstraint;
  updateColumns?: Array<PaymentProcessorsUpdateColumn>;
  where?: InputMaybe<PaymentProcessorsBoolExp>;
};

/** Ordering options when selecting data from "payment_processors". */
export type PaymentProcessorsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payment_processors */
export type PaymentProcessorsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "payment_processors" */
export enum PaymentProcessorsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "payment_processors" */
export type PaymentProcessorsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "payment_processors" */
export type PaymentProcessorsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PaymentProcessorsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PaymentProcessorsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "payment_processors" */
export enum PaymentProcessorsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PaymentProcessorsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PaymentProcessorsSetInput>;
  /** filter the rows which have to be updated */
  where: PaymentProcessorsBoolExp;
};

/** columns and relationships of "pickleball_rating_scales" */
export type PickleballRatingScales = {
  __typename?: 'PickleballRatingScales';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  maximum: Scalars['numeric'];
  minimum: Scalars['numeric'];
  name: Scalars['String'];
  order: Scalars['Int'];
  shortName: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "pickleball_rating_scales" */
export type PickleballRatingScalesAggregate = {
  __typename?: 'PickleballRatingScalesAggregate';
  aggregate?: Maybe<PickleballRatingScalesAggregateFields>;
  nodes: Array<PickleballRatingScales>;
};

/** aggregate fields of "pickleball_rating_scales" */
export type PickleballRatingScalesAggregateFields = {
  __typename?: 'PickleballRatingScalesAggregateFields';
  avg?: Maybe<PickleballRatingScalesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PickleballRatingScalesMaxFields>;
  min?: Maybe<PickleballRatingScalesMinFields>;
  stddev?: Maybe<PickleballRatingScalesStddevFields>;
  stddevPop?: Maybe<PickleballRatingScalesStddevPopFields>;
  stddevSamp?: Maybe<PickleballRatingScalesStddevSampFields>;
  sum?: Maybe<PickleballRatingScalesSumFields>;
  varPop?: Maybe<PickleballRatingScalesVarPopFields>;
  varSamp?: Maybe<PickleballRatingScalesVarSampFields>;
  variance?: Maybe<PickleballRatingScalesVarianceFields>;
};


/** aggregate fields of "pickleball_rating_scales" */
export type PickleballRatingScalesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PickleballRatingScalesAvgFields = {
  __typename?: 'PickleballRatingScalesAvgFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "pickleball_rating_scales". All fields are combined with a logical 'AND'. */
export type PickleballRatingScalesBoolExp = {
  _and?: InputMaybe<Array<PickleballRatingScalesBoolExp>>;
  _not?: InputMaybe<PickleballRatingScalesBoolExp>;
  _or?: InputMaybe<Array<PickleballRatingScalesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  minimum?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  shortName?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "pickleball_rating_scales" */
export enum PickleballRatingScalesConstraint {
  /** unique or primary key constraint on columns "id" */
  PickleballRatingScalesPkey = 'pickleball_rating_scales_pkey'
}

/** input type for incrementing numeric columns in table "pickleball_rating_scales" */
export type PickleballRatingScalesIncInput = {
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  order?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "pickleball_rating_scales" */
export type PickleballRatingScalesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type PickleballRatingScalesMaxFields = {
  __typename?: 'PickleballRatingScalesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  maximum?: Maybe<Scalars['numeric']>;
  minimum?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  shortName?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type PickleballRatingScalesMinFields = {
  __typename?: 'PickleballRatingScalesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  maximum?: Maybe<Scalars['numeric']>;
  minimum?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  shortName?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "pickleball_rating_scales" */
export type PickleballRatingScalesMutationResponse = {
  __typename?: 'PickleballRatingScalesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PickleballRatingScales>;
};

/** input type for inserting object relation for remote table "pickleball_rating_scales" */
export type PickleballRatingScalesObjRelInsertInput = {
  data: PickleballRatingScalesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PickleballRatingScalesOnConflict>;
};

/** on_conflict condition type for table "pickleball_rating_scales" */
export type PickleballRatingScalesOnConflict = {
  constraint: PickleballRatingScalesConstraint;
  updateColumns?: Array<PickleballRatingScalesUpdateColumn>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};

/** Ordering options when selecting data from "pickleball_rating_scales". */
export type PickleballRatingScalesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  minimum?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  shortName?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: pickleball_rating_scales */
export type PickleballRatingScalesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "pickleball_rating_scales" */
export enum PickleballRatingScalesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Maximum = 'maximum',
  /** column name */
  Minimum = 'minimum',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "pickleball_rating_scales" */
export type PickleballRatingScalesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type PickleballRatingScalesStddevFields = {
  __typename?: 'PickleballRatingScalesStddevFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type PickleballRatingScalesStddevPopFields = {
  __typename?: 'PickleballRatingScalesStddevPopFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type PickleballRatingScalesStddevSampFields = {
  __typename?: 'PickleballRatingScalesStddevSampFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "pickleball_rating_scales" */
export type PickleballRatingScalesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PickleballRatingScalesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PickleballRatingScalesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type PickleballRatingScalesSumFields = {
  __typename?: 'PickleballRatingScalesSumFields';
  maximum?: Maybe<Scalars['numeric']>;
  minimum?: Maybe<Scalars['numeric']>;
  order?: Maybe<Scalars['Int']>;
};

/** update columns of table "pickleball_rating_scales" */
export enum PickleballRatingScalesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Maximum = 'maximum',
  /** column name */
  Minimum = 'minimum',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type PickleballRatingScalesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PickleballRatingScalesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PickleballRatingScalesSetInput>;
  /** filter the rows which have to be updated */
  where: PickleballRatingScalesBoolExp;
};

/** aggregate varPop on columns */
export type PickleballRatingScalesVarPopFields = {
  __typename?: 'PickleballRatingScalesVarPopFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type PickleballRatingScalesVarSampFields = {
  __typename?: 'PickleballRatingScalesVarSampFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PickleballRatingScalesVarianceFields = {
  __typename?: 'PickleballRatingScalesVarianceFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "play_session_comments" */
export type PlaySessionComments = {
  __typename?: 'PlaySessionComments';
  /** An array relationship */
  allChildComments: Array<PlaySessionComments>;
  /** An aggregate relationship */
  allChildCommentsAggregate: PlaySessionCommentsAggregate;
  content: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  playSession: PlaySessions;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId: Scalars['uuid'];
  playSessionRootCommentId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  replies: Array<PlaySessionComments>;
  /** An aggregate relationship */
  repliesAggregate: PlaySessionCommentsAggregate;
  updatedAt: Scalars['timestamptz'];
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsAllChildCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsAllChildCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsRepliesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_session_comments" */
export type PlaySessionCommentsRepliesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};

/** aggregated selection of "play_session_comments" */
export type PlaySessionCommentsAggregate = {
  __typename?: 'PlaySessionCommentsAggregate';
  aggregate?: Maybe<PlaySessionCommentsAggregateFields>;
  nodes: Array<PlaySessionComments>;
};

export type PlaySessionCommentsAggregateBoolExp = {
  count?: InputMaybe<PlaySessionCommentsAggregateBoolExpCount>;
};

/** aggregate fields of "play_session_comments" */
export type PlaySessionCommentsAggregateFields = {
  __typename?: 'PlaySessionCommentsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionCommentsMaxFields>;
  min?: Maybe<PlaySessionCommentsMinFields>;
};


/** aggregate fields of "play_session_comments" */
export type PlaySessionCommentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "play_session_comments" */
export type PlaySessionCommentsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PlaySessionCommentsMaxOrderBy>;
  min?: InputMaybe<PlaySessionCommentsMinOrderBy>;
};

/** input type for inserting array relation for remote table "play_session_comments" */
export type PlaySessionCommentsArrRelInsertInput = {
  data: Array<PlaySessionCommentsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};

/** Boolean expression to filter rows from the table "play_session_comments". All fields are combined with a logical 'AND'. */
export type PlaySessionCommentsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionCommentsBoolExp>>;
  _not?: InputMaybe<PlaySessionCommentsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionCommentsBoolExp>>;
  allChildComments?: InputMaybe<PlaySessionCommentsBoolExp>;
  allChildCommentsAggregate?: InputMaybe<PlaySessionCommentsAggregateBoolExp>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionCommentId?: InputMaybe<UuidComparisonExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  playSessionRootCommentId?: InputMaybe<UuidComparisonExp>;
  replies?: InputMaybe<PlaySessionCommentsBoolExp>;
  repliesAggregate?: InputMaybe<PlaySessionCommentsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "play_session_comments" */
export enum PlaySessionCommentsConstraint {
  /** unique or primary key constraint on columns "id" */
  PlaySessionCommentsPkey = 'play_session_comments_pkey'
}

/** input type for inserting data into table "play_session_comments" */
export type PlaySessionCommentsInsertInput = {
  allChildComments?: InputMaybe<PlaySessionCommentsArrRelInsertInput>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  playSessionRootCommentId?: InputMaybe<Scalars['uuid']>;
  replies?: InputMaybe<PlaySessionCommentsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type PlaySessionCommentsMaxFields = {
  __typename?: 'PlaySessionCommentsMaxFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  playSessionRootCommentId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "play_session_comments" */
export type PlaySessionCommentsMaxOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  playSessionRootCommentId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PlaySessionCommentsMinFields = {
  __typename?: 'PlaySessionCommentsMinFields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  playSessionRootCommentId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "play_session_comments" */
export type PlaySessionCommentsMinOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  playSessionRootCommentId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "play_session_comments" */
export type PlaySessionCommentsMutationResponse = {
  __typename?: 'PlaySessionCommentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionComments>;
};

/** input type for inserting object relation for remote table "play_session_comments" */
export type PlaySessionCommentsObjRelInsertInput = {
  data: PlaySessionCommentsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};

/** on_conflict condition type for table "play_session_comments" */
export type PlaySessionCommentsOnConflict = {
  constraint: PlaySessionCommentsConstraint;
  updateColumns?: Array<PlaySessionCommentsUpdateColumn>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};

/** Ordering options when selecting data from "play_session_comments". */
export type PlaySessionCommentsOrderBy = {
  allChildCommentsAggregate?: InputMaybe<PlaySessionCommentsAggregateOrderBy>;
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  playSessionRootCommentId?: InputMaybe<OrderBy>;
  repliesAggregate?: InputMaybe<PlaySessionCommentsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: play_session_comments */
export type PlaySessionCommentsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "play_session_comments" */
export enum PlaySessionCommentsSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionCommentId = 'playSessionCommentId',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  PlaySessionRootCommentId = 'playSessionRootCommentId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "play_session_comments" */
export type PlaySessionCommentsSetInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  playSessionRootCommentId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "play_session_comments" */
export type PlaySessionCommentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionCommentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionCommentsStreamCursorValueInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  playSessionRootCommentId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "play_session_comments" */
export enum PlaySessionCommentsUpdateColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionCommentId = 'playSessionCommentId',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  PlaySessionRootCommentId = 'playSessionRootCommentId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type PlaySessionCommentsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionCommentsSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionCommentsBoolExp;
};

/** columns and relationships of "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatuses = {
  __typename?: 'PlaySessionCourtBookingStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesAggregate = {
  __typename?: 'PlaySessionCourtBookingStatusesAggregate';
  aggregate?: Maybe<PlaySessionCourtBookingStatusesAggregateFields>;
  nodes: Array<PlaySessionCourtBookingStatuses>;
};

/** aggregate fields of "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesAggregateFields = {
  __typename?: 'PlaySessionCourtBookingStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionCourtBookingStatusesMaxFields>;
  min?: Maybe<PlaySessionCourtBookingStatusesMinFields>;
};


/** aggregate fields of "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "play_session_court_booking_statuses". All fields are combined with a logical 'AND'. */
export type PlaySessionCourtBookingStatusesBoolExp = {
  _and?: InputMaybe<Array<PlaySessionCourtBookingStatusesBoolExp>>;
  _not?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
  _or?: InputMaybe<Array<PlaySessionCourtBookingStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "play_session_court_booking_statuses" */
export enum PlaySessionCourtBookingStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  PlaySessionCourtBookingStatusesPkey = 'play_session_court_booking_statuses_pkey'
}

export enum PlaySessionCourtBookingStatusesEnum {
  Booked = 'BOOKED',
  NotBooked = 'NOT_BOOKED'
}

/** Boolean expression to compare columns of type "PlaySessionCourtBookingStatusesEnum". All fields are combined with logical 'AND'. */
export type PlaySessionCourtBookingStatusesEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  _in?: InputMaybe<Array<PlaySessionCourtBookingStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  _nin?: InputMaybe<Array<PlaySessionCourtBookingStatusesEnum>>;
};

/** input type for inserting data into table "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PlaySessionCourtBookingStatusesMaxFields = {
  __typename?: 'PlaySessionCourtBookingStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PlaySessionCourtBookingStatusesMinFields = {
  __typename?: 'PlaySessionCourtBookingStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesMutationResponse = {
  __typename?: 'PlaySessionCourtBookingStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionCourtBookingStatuses>;
};

/** on_conflict condition type for table "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesOnConflict = {
  constraint: PlaySessionCourtBookingStatusesConstraint;
  updateColumns?: Array<PlaySessionCourtBookingStatusesUpdateColumn>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};

/** Ordering options when selecting data from "play_session_court_booking_statuses". */
export type PlaySessionCourtBookingStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_session_court_booking_statuses */
export type PlaySessionCourtBookingStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "play_session_court_booking_statuses" */
export enum PlaySessionCourtBookingStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "play_session_court_booking_statuses" */
export type PlaySessionCourtBookingStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionCourtBookingStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionCourtBookingStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "play_session_court_booking_statuses" */
export enum PlaySessionCourtBookingStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PlaySessionCourtBookingStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionCourtBookingStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionCourtBookingStatusesBoolExp;
};

/** columns and relationships of "play_session_formats" */
export type PlaySessionFormats = {
  __typename?: 'PlaySessionFormats';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "play_session_formats" */
export type PlaySessionFormatsAggregate = {
  __typename?: 'PlaySessionFormatsAggregate';
  aggregate?: Maybe<PlaySessionFormatsAggregateFields>;
  nodes: Array<PlaySessionFormats>;
};

/** aggregate fields of "play_session_formats" */
export type PlaySessionFormatsAggregateFields = {
  __typename?: 'PlaySessionFormatsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionFormatsMaxFields>;
  min?: Maybe<PlaySessionFormatsMinFields>;
};


/** aggregate fields of "play_session_formats" */
export type PlaySessionFormatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "play_session_formats". All fields are combined with a logical 'AND'. */
export type PlaySessionFormatsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionFormatsBoolExp>>;
  _not?: InputMaybe<PlaySessionFormatsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionFormatsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "play_session_formats" */
export enum PlaySessionFormatsConstraint {
  /** unique or primary key constraint on columns "value" */
  PlaySessionFormatsPkey = 'play_session_formats_pkey'
}

export enum PlaySessionFormatsEnum {
  Doubles = 'DOUBLES',
  OpenPlay = 'OPEN_PLAY',
  Singles = 'SINGLES'
}

/** Boolean expression to compare columns of type "PlaySessionFormatsEnum". All fields are combined with logical 'AND'. */
export type PlaySessionFormatsEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionFormatsEnum>;
  _in?: InputMaybe<Array<PlaySessionFormatsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionFormatsEnum>;
  _nin?: InputMaybe<Array<PlaySessionFormatsEnum>>;
};

/** input type for inserting data into table "play_session_formats" */
export type PlaySessionFormatsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PlaySessionFormatsMaxFields = {
  __typename?: 'PlaySessionFormatsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PlaySessionFormatsMinFields = {
  __typename?: 'PlaySessionFormatsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "play_session_formats" */
export type PlaySessionFormatsMutationResponse = {
  __typename?: 'PlaySessionFormatsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionFormats>;
};

/** on_conflict condition type for table "play_session_formats" */
export type PlaySessionFormatsOnConflict = {
  constraint: PlaySessionFormatsConstraint;
  updateColumns?: Array<PlaySessionFormatsUpdateColumn>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};

/** Ordering options when selecting data from "play_session_formats". */
export type PlaySessionFormatsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_session_formats */
export type PlaySessionFormatsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "play_session_formats" */
export enum PlaySessionFormatsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "play_session_formats" */
export type PlaySessionFormatsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "play_session_formats" */
export type PlaySessionFormatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionFormatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionFormatsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "play_session_formats" */
export enum PlaySessionFormatsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PlaySessionFormatsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionFormatsSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionFormatsBoolExp;
};

/** columns and relationships of "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitiveness = {
  __typename?: 'PlaySessionMatchCompetitiveness';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessAggregate = {
  __typename?: 'PlaySessionMatchCompetitivenessAggregate';
  aggregate?: Maybe<PlaySessionMatchCompetitivenessAggregateFields>;
  nodes: Array<PlaySessionMatchCompetitiveness>;
};

/** aggregate fields of "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessAggregateFields = {
  __typename?: 'PlaySessionMatchCompetitivenessAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionMatchCompetitivenessMaxFields>;
  min?: Maybe<PlaySessionMatchCompetitivenessMinFields>;
};


/** aggregate fields of "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "play_session_match_competitiveness". All fields are combined with a logical 'AND'. */
export type PlaySessionMatchCompetitivenessBoolExp = {
  _and?: InputMaybe<Array<PlaySessionMatchCompetitivenessBoolExp>>;
  _not?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
  _or?: InputMaybe<Array<PlaySessionMatchCompetitivenessBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "play_session_match_competitiveness" */
export enum PlaySessionMatchCompetitivenessConstraint {
  /** unique or primary key constraint on columns "value" */
  PlaySessionMatchCompetitivenessPkey = 'play_session_match_competitiveness_pkey'
}

export enum PlaySessionMatchCompetitivenessEnum {
  Casual = 'CASUAL',
  Match = 'MATCH',
  Practice = 'PRACTICE'
}

/** Boolean expression to compare columns of type "PlaySessionMatchCompetitivenessEnum". All fields are combined with logical 'AND'. */
export type PlaySessionMatchCompetitivenessEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  _in?: InputMaybe<Array<PlaySessionMatchCompetitivenessEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  _nin?: InputMaybe<Array<PlaySessionMatchCompetitivenessEnum>>;
};

/** input type for inserting data into table "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PlaySessionMatchCompetitivenessMaxFields = {
  __typename?: 'PlaySessionMatchCompetitivenessMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PlaySessionMatchCompetitivenessMinFields = {
  __typename?: 'PlaySessionMatchCompetitivenessMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessMutationResponse = {
  __typename?: 'PlaySessionMatchCompetitivenessMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionMatchCompetitiveness>;
};

/** on_conflict condition type for table "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessOnConflict = {
  constraint: PlaySessionMatchCompetitivenessConstraint;
  updateColumns?: Array<PlaySessionMatchCompetitivenessUpdateColumn>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};

/** Ordering options when selecting data from "play_session_match_competitiveness". */
export type PlaySessionMatchCompetitivenessOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_session_match_competitiveness */
export type PlaySessionMatchCompetitivenessPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "play_session_match_competitiveness" */
export enum PlaySessionMatchCompetitivenessSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "play_session_match_competitiveness" */
export type PlaySessionMatchCompetitivenessStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionMatchCompetitivenessStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionMatchCompetitivenessStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "play_session_match_competitiveness" */
export enum PlaySessionMatchCompetitivenessUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PlaySessionMatchCompetitivenessUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionMatchCompetitivenessSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionMatchCompetitivenessBoolExp;
};

/** columns and relationships of "play_session_participant_statuses" */
export type PlaySessionParticipantStatuses = {
  __typename?: 'PlaySessionParticipantStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesAggregate = {
  __typename?: 'PlaySessionParticipantStatusesAggregate';
  aggregate?: Maybe<PlaySessionParticipantStatusesAggregateFields>;
  nodes: Array<PlaySessionParticipantStatuses>;
};

/** aggregate fields of "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesAggregateFields = {
  __typename?: 'PlaySessionParticipantStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionParticipantStatusesMaxFields>;
  min?: Maybe<PlaySessionParticipantStatusesMinFields>;
};


/** aggregate fields of "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "play_session_participant_statuses". All fields are combined with a logical 'AND'. */
export type PlaySessionParticipantStatusesBoolExp = {
  _and?: InputMaybe<Array<PlaySessionParticipantStatusesBoolExp>>;
  _not?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
  _or?: InputMaybe<Array<PlaySessionParticipantStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "play_session_participant_statuses" */
export enum PlaySessionParticipantStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  PlaySessionParticipantStatusesPkey = 'play_session_participant_statuses_pkey'
}

export enum PlaySessionParticipantStatusesEnum {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "PlaySessionParticipantStatusesEnum". All fields are combined with logical 'AND'. */
export type PlaySessionParticipantStatusesEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  _in?: InputMaybe<Array<PlaySessionParticipantStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  _nin?: InputMaybe<Array<PlaySessionParticipantStatusesEnum>>;
};

/** input type for inserting data into table "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PlaySessionParticipantStatusesMaxFields = {
  __typename?: 'PlaySessionParticipantStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PlaySessionParticipantStatusesMinFields = {
  __typename?: 'PlaySessionParticipantStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesMutationResponse = {
  __typename?: 'PlaySessionParticipantStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionParticipantStatuses>;
};

/** on_conflict condition type for table "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesOnConflict = {
  constraint: PlaySessionParticipantStatusesConstraint;
  updateColumns?: Array<PlaySessionParticipantStatusesUpdateColumn>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};

/** Ordering options when selecting data from "play_session_participant_statuses". */
export type PlaySessionParticipantStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_session_participant_statuses */
export type PlaySessionParticipantStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "play_session_participant_statuses" */
export enum PlaySessionParticipantStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "play_session_participant_statuses" */
export type PlaySessionParticipantStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionParticipantStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionParticipantStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "play_session_participant_statuses" */
export enum PlaySessionParticipantStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PlaySessionParticipantStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionParticipantStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionParticipantStatusesBoolExp;
};

/** columns and relationships of "play_session_participants" */
export type PlaySessionParticipants = {
  __typename?: 'PlaySessionParticipants';
  addedAt?: Maybe<Scalars['timestamptz']>;
  addedByPersona?: Maybe<AppPersonasEnum>;
  addedByUserId?: Maybe<Scalars['uuid']>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  playSession: PlaySessions;
  playSessionId: Scalars['uuid'];
  removedAt?: Maybe<Scalars['timestamptz']>;
  removedByPersona?: Maybe<AppPersonasEnum>;
  status: PlaySessionParticipantStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "play_session_participants" */
export type PlaySessionParticipantsAggregate = {
  __typename?: 'PlaySessionParticipantsAggregate';
  aggregate?: Maybe<PlaySessionParticipantsAggregateFields>;
  nodes: Array<PlaySessionParticipants>;
};

export type PlaySessionParticipantsAggregateBoolExp = {
  count?: InputMaybe<PlaySessionParticipantsAggregateBoolExpCount>;
};

/** aggregate fields of "play_session_participants" */
export type PlaySessionParticipantsAggregateFields = {
  __typename?: 'PlaySessionParticipantsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionParticipantsMaxFields>;
  min?: Maybe<PlaySessionParticipantsMinFields>;
};


/** aggregate fields of "play_session_participants" */
export type PlaySessionParticipantsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "play_session_participants" */
export type PlaySessionParticipantsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PlaySessionParticipantsMaxOrderBy>;
  min?: InputMaybe<PlaySessionParticipantsMinOrderBy>;
};

/** input type for inserting array relation for remote table "play_session_participants" */
export type PlaySessionParticipantsArrRelInsertInput = {
  data: Array<PlaySessionParticipantsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionParticipantsOnConflict>;
};

/** Boolean expression to filter rows from the table "play_session_participants". All fields are combined with a logical 'AND'. */
export type PlaySessionParticipantsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionParticipantsBoolExp>>;
  _not?: InputMaybe<PlaySessionParticipantsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionParticipantsBoolExp>>;
  addedAt?: InputMaybe<TimestamptzComparisonExp>;
  addedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  addedByUserId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  removedAt?: InputMaybe<TimestamptzComparisonExp>;
  removedByPersona?: InputMaybe<AppPersonasEnumComparisonExp>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "play_session_participants" */
export enum PlaySessionParticipantsConstraint {
  /** unique or primary key constraint on columns "id" */
  PlaySessionParticipantsPkey = 'play_session_participants_pkey',
  /** unique or primary key constraint on columns "user_id", "play_session_id" */
  PlaySessionParticipantsPlaySessionIdUserIdKey = 'play_session_participants_play_session_id_user_id_key'
}

/** input type for inserting data into table "play_session_participants" */
export type PlaySessionParticipantsInsertInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type PlaySessionParticipantsMaxFields = {
  __typename?: 'PlaySessionParticipantsMaxFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  addedByUserId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "play_session_participants" */
export type PlaySessionParticipantsMaxOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  addedByUserId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PlaySessionParticipantsMinFields = {
  __typename?: 'PlaySessionParticipantsMinFields';
  addedAt?: Maybe<Scalars['timestamptz']>;
  addedByUserId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  removedAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "play_session_participants" */
export type PlaySessionParticipantsMinOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  addedByUserId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "play_session_participants" */
export type PlaySessionParticipantsMutationResponse = {
  __typename?: 'PlaySessionParticipantsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionParticipants>;
};

/** on_conflict condition type for table "play_session_participants" */
export type PlaySessionParticipantsOnConflict = {
  constraint: PlaySessionParticipantsConstraint;
  updateColumns?: Array<PlaySessionParticipantsUpdateColumn>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};

/** Ordering options when selecting data from "play_session_participants". */
export type PlaySessionParticipantsOrderBy = {
  addedAt?: InputMaybe<OrderBy>;
  addedByPersona?: InputMaybe<OrderBy>;
  addedByUserId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  removedAt?: InputMaybe<OrderBy>;
  removedByPersona?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: play_session_participants */
export type PlaySessionParticipantsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "play_session_participants" */
export enum PlaySessionParticipantsSelectColumn {
  /** column name */
  AddedAt = 'addedAt',
  /** column name */
  AddedByPersona = 'addedByPersona',
  /** column name */
  AddedByUserId = 'addedByUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  RemovedAt = 'removedAt',
  /** column name */
  RemovedByPersona = 'removedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "play_session_participants" */
export type PlaySessionParticipantsSetInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "play_session_participants" */
export type PlaySessionParticipantsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionParticipantsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionParticipantsStreamCursorValueInput = {
  addedAt?: InputMaybe<Scalars['timestamptz']>;
  addedByPersona?: InputMaybe<AppPersonasEnum>;
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  removedAt?: InputMaybe<Scalars['timestamptz']>;
  removedByPersona?: InputMaybe<AppPersonasEnum>;
  status?: InputMaybe<PlaySessionParticipantStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "play_session_participants" */
export enum PlaySessionParticipantsUpdateColumn {
  /** column name */
  AddedAt = 'addedAt',
  /** column name */
  AddedByPersona = 'addedByPersona',
  /** column name */
  AddedByUserId = 'addedByUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  RemovedAt = 'removedAt',
  /** column name */
  RemovedByPersona = 'removedByPersona',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type PlaySessionParticipantsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionParticipantsSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionParticipantsBoolExp;
};

/** columns and relationships of "play_session_privacy" */
export type PlaySessionPrivacy = {
  __typename?: 'PlaySessionPrivacy';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "play_session_privacy" */
export type PlaySessionPrivacyAggregate = {
  __typename?: 'PlaySessionPrivacyAggregate';
  aggregate?: Maybe<PlaySessionPrivacyAggregateFields>;
  nodes: Array<PlaySessionPrivacy>;
};

/** aggregate fields of "play_session_privacy" */
export type PlaySessionPrivacyAggregateFields = {
  __typename?: 'PlaySessionPrivacyAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionPrivacyMaxFields>;
  min?: Maybe<PlaySessionPrivacyMinFields>;
};


/** aggregate fields of "play_session_privacy" */
export type PlaySessionPrivacyAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "play_session_privacy". All fields are combined with a logical 'AND'. */
export type PlaySessionPrivacyBoolExp = {
  _and?: InputMaybe<Array<PlaySessionPrivacyBoolExp>>;
  _not?: InputMaybe<PlaySessionPrivacyBoolExp>;
  _or?: InputMaybe<Array<PlaySessionPrivacyBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "play_session_privacy" */
export enum PlaySessionPrivacyConstraint {
  /** unique or primary key constraint on columns "value" */
  PlaySessionPrivacyPkey = 'play_session_privacy_pkey'
}

export enum PlaySessionPrivacyEnum {
  Private = 'PRIVATE',
  Public = 'PUBLIC'
}

/** Boolean expression to compare columns of type "PlaySessionPrivacyEnum". All fields are combined with logical 'AND'. */
export type PlaySessionPrivacyEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionPrivacyEnum>;
  _in?: InputMaybe<Array<PlaySessionPrivacyEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionPrivacyEnum>;
  _nin?: InputMaybe<Array<PlaySessionPrivacyEnum>>;
};

/** input type for inserting data into table "play_session_privacy" */
export type PlaySessionPrivacyInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PlaySessionPrivacyMaxFields = {
  __typename?: 'PlaySessionPrivacyMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PlaySessionPrivacyMinFields = {
  __typename?: 'PlaySessionPrivacyMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "play_session_privacy" */
export type PlaySessionPrivacyMutationResponse = {
  __typename?: 'PlaySessionPrivacyMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionPrivacy>;
};

/** on_conflict condition type for table "play_session_privacy" */
export type PlaySessionPrivacyOnConflict = {
  constraint: PlaySessionPrivacyConstraint;
  updateColumns?: Array<PlaySessionPrivacyUpdateColumn>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};

/** Ordering options when selecting data from "play_session_privacy". */
export type PlaySessionPrivacyOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_session_privacy */
export type PlaySessionPrivacyPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "play_session_privacy" */
export enum PlaySessionPrivacySelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "play_session_privacy" */
export type PlaySessionPrivacySetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "play_session_privacy" */
export type PlaySessionPrivacyStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionPrivacyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionPrivacyStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "play_session_privacy" */
export enum PlaySessionPrivacyUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PlaySessionPrivacyUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionPrivacySetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionPrivacyBoolExp;
};

/** columns and relationships of "play_session_statuses" */
export type PlaySessionStatuses = {
  __typename?: 'PlaySessionStatuses';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "play_session_statuses" */
export type PlaySessionStatusesAggregate = {
  __typename?: 'PlaySessionStatusesAggregate';
  aggregate?: Maybe<PlaySessionStatusesAggregateFields>;
  nodes: Array<PlaySessionStatuses>;
};

/** aggregate fields of "play_session_statuses" */
export type PlaySessionStatusesAggregateFields = {
  __typename?: 'PlaySessionStatusesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<PlaySessionStatusesMaxFields>;
  min?: Maybe<PlaySessionStatusesMinFields>;
};


/** aggregate fields of "play_session_statuses" */
export type PlaySessionStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "play_session_statuses". All fields are combined with a logical 'AND'. */
export type PlaySessionStatusesBoolExp = {
  _and?: InputMaybe<Array<PlaySessionStatusesBoolExp>>;
  _not?: InputMaybe<PlaySessionStatusesBoolExp>;
  _or?: InputMaybe<Array<PlaySessionStatusesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "play_session_statuses" */
export enum PlaySessionStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  PlaySessionStatusesPkey = 'play_session_statuses_pkey'
}

export enum PlaySessionStatusesEnum {
  Active = 'ACTIVE',
  Canceled = 'CANCELED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "PlaySessionStatusesEnum". All fields are combined with logical 'AND'. */
export type PlaySessionStatusesEnumComparisonExp = {
  _eq?: InputMaybe<PlaySessionStatusesEnum>;
  _in?: InputMaybe<Array<PlaySessionStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<PlaySessionStatusesEnum>;
  _nin?: InputMaybe<Array<PlaySessionStatusesEnum>>;
};

/** input type for inserting data into table "play_session_statuses" */
export type PlaySessionStatusesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PlaySessionStatusesMaxFields = {
  __typename?: 'PlaySessionStatusesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type PlaySessionStatusesMinFields = {
  __typename?: 'PlaySessionStatusesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "play_session_statuses" */
export type PlaySessionStatusesMutationResponse = {
  __typename?: 'PlaySessionStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessionStatuses>;
};

/** on_conflict condition type for table "play_session_statuses" */
export type PlaySessionStatusesOnConflict = {
  constraint: PlaySessionStatusesConstraint;
  updateColumns?: Array<PlaySessionStatusesUpdateColumn>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};

/** Ordering options when selecting data from "play_session_statuses". */
export type PlaySessionStatusesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_session_statuses */
export type PlaySessionStatusesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "play_session_statuses" */
export enum PlaySessionStatusesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "play_session_statuses" */
export type PlaySessionStatusesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "play_session_statuses" */
export type PlaySessionStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionStatusesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "play_session_statuses" */
export enum PlaySessionStatusesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type PlaySessionStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionStatusesBoolExp;
};

/** columns and relationships of "play_sessions" */
export type PlaySessions = {
  __typename?: 'PlaySessions';
  cancelReason: Scalars['String'];
  canceledAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  comments: Array<PlaySessionComments>;
  /** An aggregate relationship */
  commentsAggregate: PlaySessionCommentsAggregate;
  competitiveness?: Maybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus: PlaySessionCourtBookingStatusesEnum;
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  endDateTime?: Maybe<Scalars['timestamptz']>;
  extraRacketCount?: Maybe<Scalars['Int']>;
  format: PlaySessionFormatsEnum;
  /** An object relationship */
  group?: Maybe<Groups>;
  groupId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  /** An aggregate relationship */
  groupsPlaySessionsAggregate: GroupsPlaySessionsAggregate;
  id: Scalars['uuid'];
  isBringingNet: Scalars['Boolean'];
  locale: Scalars['String'];
  /** An object relationship */
  organizer?: Maybe<Users>;
  /** An object relationship */
  organizerProfile?: Maybe<UserProfiles>;
  organizerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  /** An array relationship */
  participants: Array<PlaySessionParticipants>;
  /** An aggregate relationship */
  participantsAggregate: PlaySessionParticipantsAggregate;
  /** An object relationship */
  pickleballRatingScale?: Maybe<PickleballRatingScales>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  priceUnitAmount: Scalars['Int'];
  privacy: PlaySessionPrivacyEnum;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  sport: SportsEnum;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  status: PlaySessionStatusesEnum;
  targetSkillLevel?: Maybe<Scalars['String']>;
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation: Scalars['String'];
  timezoneName: Scalars['String'];
  timezoneOffsetMinutes: Scalars['Int'];
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  userCustomCourt?: Maybe<UserCustomCourts>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  venue?: Maybe<Venues>;
  venueId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsGroupsPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsParticipantsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


/** columns and relationships of "play_sessions" */
export type PlaySessionsParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};

/** aggregated selection of "play_sessions" */
export type PlaySessionsAggregate = {
  __typename?: 'PlaySessionsAggregate';
  aggregate?: Maybe<PlaySessionsAggregateFields>;
  nodes: Array<PlaySessions>;
};

export type PlaySessionsAggregateBoolExp = {
  bool_and?: InputMaybe<PlaySessionsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<PlaySessionsAggregateBoolExpBool_Or>;
  count?: InputMaybe<PlaySessionsAggregateBoolExpCount>;
};

/** aggregate fields of "play_sessions" */
export type PlaySessionsAggregateFields = {
  __typename?: 'PlaySessionsAggregateFields';
  avg?: Maybe<PlaySessionsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<PlaySessionsMaxFields>;
  min?: Maybe<PlaySessionsMinFields>;
  stddev?: Maybe<PlaySessionsStddevFields>;
  stddevPop?: Maybe<PlaySessionsStddevPopFields>;
  stddevSamp?: Maybe<PlaySessionsStddevSampFields>;
  sum?: Maybe<PlaySessionsSumFields>;
  varPop?: Maybe<PlaySessionsVarPopFields>;
  varSamp?: Maybe<PlaySessionsVarSampFields>;
  variance?: Maybe<PlaySessionsVarianceFields>;
};


/** aggregate fields of "play_sessions" */
export type PlaySessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "play_sessions" */
export type PlaySessionsAggregateOrderBy = {
  avg?: InputMaybe<PlaySessionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PlaySessionsMaxOrderBy>;
  min?: InputMaybe<PlaySessionsMinOrderBy>;
  stddev?: InputMaybe<PlaySessionsStddevOrderBy>;
  stddevPop?: InputMaybe<PlaySessionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<PlaySessionsStddevSampOrderBy>;
  sum?: InputMaybe<PlaySessionsSumOrderBy>;
  varPop?: InputMaybe<PlaySessionsVarPopOrderBy>;
  varSamp?: InputMaybe<PlaySessionsVarSampOrderBy>;
  variance?: InputMaybe<PlaySessionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "play_sessions" */
export type PlaySessionsArrRelInsertInput = {
  data: Array<PlaySessionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};

/** aggregate avg on columns */
export type PlaySessionsAvgFields = {
  __typename?: 'PlaySessionsAvgFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "play_sessions" */
export type PlaySessionsAvgOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "play_sessions". All fields are combined with a logical 'AND'. */
export type PlaySessionsBoolExp = {
  _and?: InputMaybe<Array<PlaySessionsBoolExp>>;
  _not?: InputMaybe<PlaySessionsBoolExp>;
  _or?: InputMaybe<Array<PlaySessionsBoolExp>>;
  cancelReason?: InputMaybe<StringComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  comments?: InputMaybe<PlaySessionCommentsBoolExp>;
  commentsAggregate?: InputMaybe<PlaySessionCommentsAggregateBoolExp>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnumComparisonExp>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  endDateTime?: InputMaybe<TimestamptzComparisonExp>;
  extraRacketCount?: InputMaybe<IntComparisonExp>;
  format?: InputMaybe<PlaySessionFormatsEnumComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsBoolExp>;
  groupsPlaySessionsAggregate?: InputMaybe<GroupsPlaySessionsAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBringingNet?: InputMaybe<BooleanComparisonExp>;
  locale?: InputMaybe<StringComparisonExp>;
  organizer?: InputMaybe<UsersBoolExp>;
  organizerProfile?: InputMaybe<UserProfilesBoolExp>;
  organizerUserId?: InputMaybe<UuidComparisonExp>;
  participantLimit?: InputMaybe<IntComparisonExp>;
  participants?: InputMaybe<PlaySessionParticipantsBoolExp>;
  participantsAggregate?: InputMaybe<PlaySessionParticipantsAggregateBoolExp>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesBoolExp>;
  pickleballRatingScaleId?: InputMaybe<UuidComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  privacy?: InputMaybe<PlaySessionPrivacyEnumComparisonExp>;
  publishedAt?: InputMaybe<TimestamptzComparisonExp>;
  reminderEventId?: InputMaybe<UuidComparisonExp>;
  skillRatingMaximum?: InputMaybe<NumericComparisonExp>;
  skillRatingMinimum?: InputMaybe<NumericComparisonExp>;
  sport?: InputMaybe<SportsEnumComparisonExp>;
  startDateTime?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<PlaySessionStatusesEnumComparisonExp>;
  targetSkillLevel?: InputMaybe<StringComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  timezoneAbbreviation?: InputMaybe<StringComparisonExp>;
  timezoneName?: InputMaybe<StringComparisonExp>;
  timezoneOffsetMinutes?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userCustomCourt?: InputMaybe<UserCustomCourtsBoolExp>;
  userCustomCourtId?: InputMaybe<UuidComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "play_sessions" */
export enum PlaySessionsConstraint {
  /** unique or primary key constraint on columns "id" */
  PlaySessionsPkey = 'play_sessions_pkey'
}

/** input type for incrementing numeric columns in table "play_sessions" */
export type PlaySessionsIncInput = {
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "play_sessions" */
export type PlaySessionsInsertInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  comments?: InputMaybe<PlaySessionCommentsArrRelInsertInput>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<PlaySessionFormatsEnum>;
  group?: InputMaybe<GroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupsPlaySessions?: InputMaybe<GroupsPlaySessionsArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale?: InputMaybe<Scalars['String']>;
  organizer?: InputMaybe<UsersObjRelInsertInput>;
  organizerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  organizerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  participants?: InputMaybe<PlaySessionParticipantsArrRelInsertInput>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesObjRelInsertInput>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesObjRelInsertInput>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourt?: InputMaybe<UserCustomCourtsObjRelInsertInput>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type PlaySessionsMaxFields = {
  __typename?: 'PlaySessionsMaxFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  extraRacketCount?: Maybe<Scalars['Int']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  organizerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  targetSkillLevel?: Maybe<Scalars['String']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "play_sessions" */
export type PlaySessionsMaxOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  extraRacketCount?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  organizerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  targetSkillLevel?: InputMaybe<OrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PlaySessionsMinFields = {
  __typename?: 'PlaySessionsMinFields';
  cancelReason?: Maybe<Scalars['String']>;
  canceledAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  endDateTime?: Maybe<Scalars['timestamptz']>;
  extraRacketCount?: Maybe<Scalars['Int']>;
  groupId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  locale?: Maybe<Scalars['String']>;
  organizerUserId?: Maybe<Scalars['uuid']>;
  participantLimit?: Maybe<Scalars['Int']>;
  pickleballRatingScaleId?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  publishedAt?: Maybe<Scalars['timestamptz']>;
  reminderEventId?: Maybe<Scalars['uuid']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  startDateTime?: Maybe<Scalars['timestamptz']>;
  targetSkillLevel?: Maybe<Scalars['String']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  timezoneAbbreviation?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userCustomCourtId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "play_sessions" */
export type PlaySessionsMinOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  extraRacketCount?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  organizerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  targetSkillLevel?: InputMaybe<OrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "play_sessions" */
export type PlaySessionsMutationResponse = {
  __typename?: 'PlaySessionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PlaySessions>;
};

/** input type for inserting object relation for remote table "play_sessions" */
export type PlaySessionsObjRelInsertInput = {
  data: PlaySessionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};

/** on_conflict condition type for table "play_sessions" */
export type PlaySessionsOnConflict = {
  constraint: PlaySessionsConstraint;
  updateColumns?: Array<PlaySessionsUpdateColumn>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};

/** Ordering options when selecting data from "play_sessions". */
export type PlaySessionsOrderBy = {
  cancelReason?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  commentsAggregate?: InputMaybe<PlaySessionCommentsAggregateOrderBy>;
  competitiveness?: InputMaybe<OrderBy>;
  courtBookingStatus?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  endDateTime?: InputMaybe<OrderBy>;
  extraRacketCount?: InputMaybe<OrderBy>;
  format?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupsPlaySessionsAggregate?: InputMaybe<GroupsPlaySessionsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isBringingNet?: InputMaybe<OrderBy>;
  locale?: InputMaybe<OrderBy>;
  organizer?: InputMaybe<UsersOrderBy>;
  organizerProfile?: InputMaybe<UserProfilesOrderBy>;
  organizerUserId?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  participantsAggregate?: InputMaybe<PlaySessionParticipantsAggregateOrderBy>;
  pickleballRatingScale?: InputMaybe<PickleballRatingScalesOrderBy>;
  pickleballRatingScaleId?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  privacy?: InputMaybe<OrderBy>;
  publishedAt?: InputMaybe<OrderBy>;
  reminderEventId?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  sport?: InputMaybe<OrderBy>;
  startDateTime?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  targetSkillLevel?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  timezoneAbbreviation?: InputMaybe<OrderBy>;
  timezoneName?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userCustomCourt?: InputMaybe<UserCustomCourtsOrderBy>;
  userCustomCourtId?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: play_sessions */
export type PlaySessionsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "play_sessions" */
export enum PlaySessionsSelectColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  Competitiveness = 'competitiveness',
  /** column name */
  CourtBookingStatus = 'courtBookingStatus',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExtraRacketCount = 'extraRacketCount',
  /** column name */
  Format = 'format',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsBringingNet = 'isBringingNet',
  /** column name */
  Locale = 'locale',
  /** column name */
  OrganizerUserId = 'organizerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  ReminderEventId = 'reminderEventId',
  /** column name */
  SkillRatingMaximum = 'skillRatingMaximum',
  /** column name */
  SkillRatingMinimum = 'skillRatingMinimum',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TargetSkillLevel = 'targetSkillLevel',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  VenueId = 'venueId'
}

/** select "playSessionsAggregateBoolExpBool_andArgumentsColumns" columns of table "play_sessions" */
export enum PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsBringingNet = 'isBringingNet'
}

/** select "playSessionsAggregateBoolExpBool_orArgumentsColumns" columns of table "play_sessions" */
export enum PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsBringingNet = 'isBringingNet'
}

/** input type for updating data in table "play_sessions" */
export type PlaySessionsSetInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<PlaySessionFormatsEnum>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale?: InputMaybe<Scalars['String']>;
  organizerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type PlaySessionsStddevFields = {
  __typename?: 'PlaySessionsStddevFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "play_sessions" */
export type PlaySessionsStddevOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type PlaySessionsStddevPopFields = {
  __typename?: 'PlaySessionsStddevPopFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "play_sessions" */
export type PlaySessionsStddevPopOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type PlaySessionsStddevSampFields = {
  __typename?: 'PlaySessionsStddevSampFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "play_sessions" */
export type PlaySessionsStddevSampOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "play_sessions" */
export type PlaySessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PlaySessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PlaySessionsStreamCursorValueInput = {
  cancelReason?: InputMaybe<Scalars['String']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']>;
  competitiveness?: InputMaybe<PlaySessionMatchCompetitivenessEnum>;
  courtBookingStatus?: InputMaybe<PlaySessionCourtBookingStatusesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  endDateTime?: InputMaybe<Scalars['timestamptz']>;
  extraRacketCount?: InputMaybe<Scalars['Int']>;
  format?: InputMaybe<PlaySessionFormatsEnum>;
  groupId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isBringingNet?: InputMaybe<Scalars['Boolean']>;
  locale?: InputMaybe<Scalars['String']>;
  organizerUserId?: InputMaybe<Scalars['uuid']>;
  participantLimit?: InputMaybe<Scalars['Int']>;
  pickleballRatingScaleId?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  privacy?: InputMaybe<PlaySessionPrivacyEnum>;
  publishedAt?: InputMaybe<Scalars['timestamptz']>;
  reminderEventId?: InputMaybe<Scalars['uuid']>;
  skillRatingMaximum?: InputMaybe<Scalars['numeric']>;
  skillRatingMinimum?: InputMaybe<Scalars['numeric']>;
  sport?: InputMaybe<SportsEnum>;
  startDateTime?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<PlaySessionStatusesEnum>;
  targetSkillLevel?: InputMaybe<Scalars['String']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  timezoneAbbreviation?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffsetMinutes?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userCustomCourtId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type PlaySessionsSumFields = {
  __typename?: 'PlaySessionsSumFields';
  extraRacketCount?: Maybe<Scalars['Int']>;
  participantLimit?: Maybe<Scalars['Int']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  skillRatingMaximum?: Maybe<Scalars['numeric']>;
  skillRatingMinimum?: Maybe<Scalars['numeric']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "play_sessions" */
export type PlaySessionsSumOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** update columns of table "play_sessions" */
export enum PlaySessionsUpdateColumn {
  /** column name */
  CancelReason = 'cancelReason',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  Competitiveness = 'competitiveness',
  /** column name */
  CourtBookingStatus = 'courtBookingStatus',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  EndDateTime = 'endDateTime',
  /** column name */
  ExtraRacketCount = 'extraRacketCount',
  /** column name */
  Format = 'format',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  IsBringingNet = 'isBringingNet',
  /** column name */
  Locale = 'locale',
  /** column name */
  OrganizerUserId = 'organizerUserId',
  /** column name */
  ParticipantLimit = 'participantLimit',
  /** column name */
  PickleballRatingScaleId = 'pickleballRatingScaleId',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Privacy = 'privacy',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  ReminderEventId = 'reminderEventId',
  /** column name */
  SkillRatingMaximum = 'skillRatingMaximum',
  /** column name */
  SkillRatingMinimum = 'skillRatingMinimum',
  /** column name */
  Sport = 'sport',
  /** column name */
  StartDateTime = 'startDateTime',
  /** column name */
  Status = 'status',
  /** column name */
  TargetSkillLevel = 'targetSkillLevel',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TimezoneAbbreviation = 'timezoneAbbreviation',
  /** column name */
  TimezoneName = 'timezoneName',
  /** column name */
  TimezoneOffsetMinutes = 'timezoneOffsetMinutes',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserCustomCourtId = 'userCustomCourtId',
  /** column name */
  VenueId = 'venueId'
}

export type PlaySessionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PlaySessionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PlaySessionsSetInput>;
  /** filter the rows which have to be updated */
  where: PlaySessionsBoolExp;
};

/** aggregate varPop on columns */
export type PlaySessionsVarPopFields = {
  __typename?: 'PlaySessionsVarPopFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "play_sessions" */
export type PlaySessionsVarPopOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type PlaySessionsVarSampFields = {
  __typename?: 'PlaySessionsVarSampFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "play_sessions" */
export type PlaySessionsVarSampOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PlaySessionsVarianceFields = {
  __typename?: 'PlaySessionsVarianceFields';
  extraRacketCount?: Maybe<Scalars['Float']>;
  participantLimit?: Maybe<Scalars['Float']>;
  priceUnitAmount?: Maybe<Scalars['Float']>;
  skillRatingMaximum?: Maybe<Scalars['Float']>;
  skillRatingMinimum?: Maybe<Scalars['Float']>;
  timezoneOffsetMinutes?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "play_sessions" */
export type PlaySessionsVarianceOrderBy = {
  extraRacketCount?: InputMaybe<OrderBy>;
  participantLimit?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  skillRatingMaximum?: InputMaybe<OrderBy>;
  skillRatingMinimum?: InputMaybe<OrderBy>;
  timezoneOffsetMinutes?: InputMaybe<OrderBy>;
};

/** columns and relationships of "scoring_format" */
export type ScoringFormat = {
  __typename?: 'ScoringFormat';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "scoring_format" */
export type ScoringFormatAggregate = {
  __typename?: 'ScoringFormatAggregate';
  aggregate?: Maybe<ScoringFormatAggregateFields>;
  nodes: Array<ScoringFormat>;
};

/** aggregate fields of "scoring_format" */
export type ScoringFormatAggregateFields = {
  __typename?: 'ScoringFormatAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<ScoringFormatMaxFields>;
  min?: Maybe<ScoringFormatMinFields>;
};


/** aggregate fields of "scoring_format" */
export type ScoringFormatAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "scoring_format". All fields are combined with a logical 'AND'. */
export type ScoringFormatBoolExp = {
  _and?: InputMaybe<Array<ScoringFormatBoolExp>>;
  _not?: InputMaybe<ScoringFormatBoolExp>;
  _or?: InputMaybe<Array<ScoringFormatBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "scoring_format" */
export enum ScoringFormatConstraint {
  /** unique or primary key constraint on columns "value" */
  ScoringFormatPkey = 'scoring_format_pkey'
}

export enum ScoringFormatEnum {
  Rally = 'RALLY',
  Traditional = 'TRADITIONAL'
}

/** Boolean expression to compare columns of type "ScoringFormatEnum". All fields are combined with logical 'AND'. */
export type ScoringFormatEnumComparisonExp = {
  _eq?: InputMaybe<ScoringFormatEnum>;
  _in?: InputMaybe<Array<ScoringFormatEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<ScoringFormatEnum>;
  _nin?: InputMaybe<Array<ScoringFormatEnum>>;
};

/** input type for inserting data into table "scoring_format" */
export type ScoringFormatInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ScoringFormatMaxFields = {
  __typename?: 'ScoringFormatMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type ScoringFormatMinFields = {
  __typename?: 'ScoringFormatMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "scoring_format" */
export type ScoringFormatMutationResponse = {
  __typename?: 'ScoringFormatMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ScoringFormat>;
};

/** on_conflict condition type for table "scoring_format" */
export type ScoringFormatOnConflict = {
  constraint: ScoringFormatConstraint;
  updateColumns?: Array<ScoringFormatUpdateColumn>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};

/** Ordering options when selecting data from "scoring_format". */
export type ScoringFormatOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: scoring_format */
export type ScoringFormatPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "scoring_format" */
export enum ScoringFormatSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "scoring_format" */
export type ScoringFormatSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "scoring_format" */
export type ScoringFormatStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ScoringFormatStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ScoringFormatStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "scoring_format" */
export enum ScoringFormatUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type ScoringFormatUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ScoringFormatSetInput>;
  /** filter the rows which have to be updated */
  where: ScoringFormatBoolExp;
};

/** columns and relationships of "signup_requests" */
export type SignupRequests = {
  __typename?: 'SignupRequests';
  accountType: Scalars['String'];
  city: Scalars['String'];
  cityId?: Maybe<Scalars['uuid']>;
  country: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email: Scalars['String'];
  eventOrganizerAccountType?: Maybe<EventOrganizerAccountTypesEnum>;
  fullDetails?: Maybe<Scalars['jsonb']>;
  fullName: Scalars['String'];
  id: Scalars['uuid'];
  ip: Scalars['String'];
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  phoneNumber?: Maybe<Scalars['String']>;
  platform: Scalars['String'];
  preferredName: Scalars['String'];
  region: Scalars['String'];
  timezone: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  username: Scalars['String'];
  zip: Scalars['String'];
};


/** columns and relationships of "signup_requests" */
export type SignupRequestsFullDetailsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "signup_requests" */
export type SignupRequestsAggregate = {
  __typename?: 'SignupRequestsAggregate';
  aggregate?: Maybe<SignupRequestsAggregateFields>;
  nodes: Array<SignupRequests>;
};

/** aggregate fields of "signup_requests" */
export type SignupRequestsAggregateFields = {
  __typename?: 'SignupRequestsAggregateFields';
  avg?: Maybe<SignupRequestsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<SignupRequestsMaxFields>;
  min?: Maybe<SignupRequestsMinFields>;
  stddev?: Maybe<SignupRequestsStddevFields>;
  stddevPop?: Maybe<SignupRequestsStddevPopFields>;
  stddevSamp?: Maybe<SignupRequestsStddevSampFields>;
  sum?: Maybe<SignupRequestsSumFields>;
  varPop?: Maybe<SignupRequestsVarPopFields>;
  varSamp?: Maybe<SignupRequestsVarSampFields>;
  variance?: Maybe<SignupRequestsVarianceFields>;
};


/** aggregate fields of "signup_requests" */
export type SignupRequestsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SignupRequestsAppendInput = {
  fullDetails?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type SignupRequestsAvgFields = {
  __typename?: 'SignupRequestsAvgFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "signup_requests". All fields are combined with a logical 'AND'. */
export type SignupRequestsBoolExp = {
  _and?: InputMaybe<Array<SignupRequestsBoolExp>>;
  _not?: InputMaybe<SignupRequestsBoolExp>;
  _or?: InputMaybe<Array<SignupRequestsBoolExp>>;
  accountType?: InputMaybe<StringComparisonExp>;
  city?: InputMaybe<StringComparisonExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  country?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnumComparisonExp>;
  fullDetails?: InputMaybe<JsonbComparisonExp>;
  fullName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ip?: InputMaybe<StringComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  platform?: InputMaybe<StringComparisonExp>;
  preferredName?: InputMaybe<StringComparisonExp>;
  region?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
  zip?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "signup_requests" */
export enum SignupRequestsConstraint {
  /** unique or primary key constraint on columns "id" */
  SignupRequestsPkey = 'signup_requests_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SignupRequestsDeleteAtPathInput = {
  fullDetails?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SignupRequestsDeleteElemInput = {
  fullDetails?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SignupRequestsDeleteKeyInput = {
  fullDetails?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "signup_requests" */
export type SignupRequestsIncInput = {
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "signup_requests" */
export type SignupRequestsInsertInput = {
  accountType?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  fullName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type SignupRequestsMaxFields = {
  __typename?: 'SignupRequestsMaxFields';
  accountType?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  cityId?: Maybe<Scalars['uuid']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  phoneNumber?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
  zip?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type SignupRequestsMinFields = {
  __typename?: 'SignupRequestsMinFields';
  accountType?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  cityId?: Maybe<Scalars['uuid']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  phoneNumber?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
  zip?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "signup_requests" */
export type SignupRequestsMutationResponse = {
  __typename?: 'SignupRequestsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<SignupRequests>;
};

/** on_conflict condition type for table "signup_requests" */
export type SignupRequestsOnConflict = {
  constraint: SignupRequestsConstraint;
  updateColumns?: Array<SignupRequestsUpdateColumn>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};

/** Ordering options when selecting data from "signup_requests". */
export type SignupRequestsOrderBy = {
  accountType?: InputMaybe<OrderBy>;
  city?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  eventOrganizerAccountType?: InputMaybe<OrderBy>;
  fullDetails?: InputMaybe<OrderBy>;
  fullName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  platform?: InputMaybe<OrderBy>;
  preferredName?: InputMaybe<OrderBy>;
  region?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
  zip?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: signup_requests */
export type SignupRequestsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SignupRequestsPrependInput = {
  fullDetails?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "signup_requests" */
export enum SignupRequestsSelectColumn {
  /** column name */
  AccountType = 'accountType',
  /** column name */
  City = 'city',
  /** column name */
  CityId = 'cityId',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FullDetails = 'fullDetails',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  Platform = 'platform',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  Region = 'region',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username',
  /** column name */
  Zip = 'zip'
}

/** input type for updating data in table "signup_requests" */
export type SignupRequestsSetInput = {
  accountType?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  fullName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type SignupRequestsStddevFields = {
  __typename?: 'SignupRequestsStddevFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type SignupRequestsStddevPopFields = {
  __typename?: 'SignupRequestsStddevPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type SignupRequestsStddevSampFields = {
  __typename?: 'SignupRequestsStddevSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "signup_requests" */
export type SignupRequestsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SignupRequestsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SignupRequestsStreamCursorValueInput = {
  accountType?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  fullName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type SignupRequestsSumFields = {
  __typename?: 'SignupRequestsSumFields';
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
};

/** update columns of table "signup_requests" */
export enum SignupRequestsUpdateColumn {
  /** column name */
  AccountType = 'accountType',
  /** column name */
  City = 'city',
  /** column name */
  CityId = 'cityId',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FullDetails = 'fullDetails',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  Platform = 'platform',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  Region = 'region',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username',
  /** column name */
  Zip = 'zip'
}

export type SignupRequestsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SignupRequestsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<SignupRequestsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<SignupRequestsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<SignupRequestsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SignupRequestsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SignupRequestsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SignupRequestsSetInput>;
  /** filter the rows which have to be updated */
  where: SignupRequestsBoolExp;
};

/** aggregate varPop on columns */
export type SignupRequestsVarPopFields = {
  __typename?: 'SignupRequestsVarPopFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type SignupRequestsVarSampFields = {
  __typename?: 'SignupRequestsVarSampFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type SignupRequestsVarianceFields = {
  __typename?: 'SignupRequestsVarianceFields';
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "skill_levels" */
export type SkillLevels = {
  __typename?: 'SkillLevels';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName: Scalars['String'];
  id: Scalars['String'];
  isDisplayed: Scalars['Boolean'];
  rank: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "skill_levels" */
export type SkillLevelsAggregate = {
  __typename?: 'SkillLevelsAggregate';
  aggregate?: Maybe<SkillLevelsAggregateFields>;
  nodes: Array<SkillLevels>;
};

/** aggregate fields of "skill_levels" */
export type SkillLevelsAggregateFields = {
  __typename?: 'SkillLevelsAggregateFields';
  avg?: Maybe<SkillLevelsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<SkillLevelsMaxFields>;
  min?: Maybe<SkillLevelsMinFields>;
  stddev?: Maybe<SkillLevelsStddevFields>;
  stddevPop?: Maybe<SkillLevelsStddevPopFields>;
  stddevSamp?: Maybe<SkillLevelsStddevSampFields>;
  sum?: Maybe<SkillLevelsSumFields>;
  varPop?: Maybe<SkillLevelsVarPopFields>;
  varSamp?: Maybe<SkillLevelsVarSampFields>;
  variance?: Maybe<SkillLevelsVarianceFields>;
};


/** aggregate fields of "skill_levels" */
export type SkillLevelsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type SkillLevelsAvgFields = {
  __typename?: 'SkillLevelsAvgFields';
  rank?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "skill_levels". All fields are combined with a logical 'AND'. */
export type SkillLevelsBoolExp = {
  _and?: InputMaybe<Array<SkillLevelsBoolExp>>;
  _not?: InputMaybe<SkillLevelsBoolExp>;
  _or?: InputMaybe<Array<SkillLevelsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  displayName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  isDisplayed?: InputMaybe<BooleanComparisonExp>;
  rank?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "skill_levels" */
export enum SkillLevelsConstraint {
  /** unique or primary key constraint on columns "id" */
  SkillLevelsPkey = 'skill_levels_pkey',
  /** unique or primary key constraint on columns "rank" */
  SkillLevelsRankKey = 'skill_levels_rank_key'
}

/** input type for incrementing numeric columns in table "skill_levels" */
export type SkillLevelsIncInput = {
  rank?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "skill_levels" */
export type SkillLevelsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  isDisplayed?: InputMaybe<Scalars['Boolean']>;
  rank?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type SkillLevelsMaxFields = {
  __typename?: 'SkillLevelsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  rank?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type SkillLevelsMinFields = {
  __typename?: 'SkillLevelsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  rank?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "skill_levels" */
export type SkillLevelsMutationResponse = {
  __typename?: 'SkillLevelsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<SkillLevels>;
};

/** input type for inserting object relation for remote table "skill_levels" */
export type SkillLevelsObjRelInsertInput = {
  data: SkillLevelsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<SkillLevelsOnConflict>;
};

/** on_conflict condition type for table "skill_levels" */
export type SkillLevelsOnConflict = {
  constraint: SkillLevelsConstraint;
  updateColumns?: Array<SkillLevelsUpdateColumn>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};

/** Ordering options when selecting data from "skill_levels". */
export type SkillLevelsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isDisplayed?: InputMaybe<OrderBy>;
  rank?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: skill_levels */
export type SkillLevelsPkColumnsInput = {
  id: Scalars['String'];
};

/** select columns of table "skill_levels" */
export enum SkillLevelsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  IsDisplayed = 'isDisplayed',
  /** column name */
  Rank = 'rank',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "skill_levels" */
export type SkillLevelsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  isDisplayed?: InputMaybe<Scalars['Boolean']>;
  rank?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type SkillLevelsStddevFields = {
  __typename?: 'SkillLevelsStddevFields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type SkillLevelsStddevPopFields = {
  __typename?: 'SkillLevelsStddevPopFields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type SkillLevelsStddevSampFields = {
  __typename?: 'SkillLevelsStddevSampFields';
  rank?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "skill_levels" */
export type SkillLevelsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SkillLevelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SkillLevelsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  isDisplayed?: InputMaybe<Scalars['Boolean']>;
  rank?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type SkillLevelsSumFields = {
  __typename?: 'SkillLevelsSumFields';
  rank?: Maybe<Scalars['Int']>;
};

/** update columns of table "skill_levels" */
export enum SkillLevelsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  IsDisplayed = 'isDisplayed',
  /** column name */
  Rank = 'rank',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type SkillLevelsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SkillLevelsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SkillLevelsSetInput>;
  /** filter the rows which have to be updated */
  where: SkillLevelsBoolExp;
};

/** aggregate varPop on columns */
export type SkillLevelsVarPopFields = {
  __typename?: 'SkillLevelsVarPopFields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type SkillLevelsVarSampFields = {
  __typename?: 'SkillLevelsVarSampFields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type SkillLevelsVarianceFields = {
  __typename?: 'SkillLevelsVarianceFields';
  rank?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "sports" */
export type Sports = {
  __typename?: 'Sports';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "sports" */
export type SportsAggregate = {
  __typename?: 'SportsAggregate';
  aggregate?: Maybe<SportsAggregateFields>;
  nodes: Array<Sports>;
};

/** aggregate fields of "sports" */
export type SportsAggregateFields = {
  __typename?: 'SportsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<SportsMaxFields>;
  min?: Maybe<SportsMinFields>;
};


/** aggregate fields of "sports" */
export type SportsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SportsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "sports". All fields are combined with a logical 'AND'. */
export type SportsBoolExp = {
  _and?: InputMaybe<Array<SportsBoolExp>>;
  _not?: InputMaybe<SportsBoolExp>;
  _or?: InputMaybe<Array<SportsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "sports" */
export enum SportsConstraint {
  /** unique or primary key constraint on columns "value" */
  SportsPkey = 'sports_pkey'
}

export enum SportsEnum {
  Pickleball = 'PICKLEBALL',
  Tennis = 'TENNIS'
}

/** Boolean expression to compare columns of type "SportsEnum". All fields are combined with logical 'AND'. */
export type SportsEnumComparisonExp = {
  _eq?: InputMaybe<SportsEnum>;
  _in?: InputMaybe<Array<SportsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<SportsEnum>;
  _nin?: InputMaybe<Array<SportsEnum>>;
};

/** input type for inserting data into table "sports" */
export type SportsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type SportsMaxFields = {
  __typename?: 'SportsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type SportsMinFields = {
  __typename?: 'SportsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "sports" */
export type SportsMutationResponse = {
  __typename?: 'SportsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Sports>;
};

/** on_conflict condition type for table "sports" */
export type SportsOnConflict = {
  constraint: SportsConstraint;
  updateColumns?: Array<SportsUpdateColumn>;
  where?: InputMaybe<SportsBoolExp>;
};

/** Ordering options when selecting data from "sports". */
export type SportsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: sports */
export type SportsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "sports" */
export enum SportsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "sports" */
export type SportsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "sports" */
export type SportsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SportsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SportsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "sports" */
export enum SportsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type SportsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SportsSetInput>;
  /** filter the rows which have to be updated */
  where: SportsBoolExp;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "stripe_charges" */
export type StripeCharges = {
  __typename?: 'StripeCharges';
  amount: Scalars['Int'];
  amountCaptured: Scalars['Int'];
  amountRefunded: Scalars['Int'];
  application?: Maybe<Scalars['String']>;
  applicationFee?: Maybe<Scalars['String']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  calculatedStatementDescriptor?: Maybe<Scalars['String']>;
  captured: Scalars['Boolean'];
  chargeId: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  disputed: Scalars['Boolean'];
  externalStripePaymentIntentId: Scalars['String'];
  id: Scalars['uuid'];
  internalStripePaymentIntentId: Scalars['uuid'];
  paid: Scalars['Boolean'];
  /** An object relationship */
  paymentIntentExternal: StripePaymentIntents;
  /** An object relationship */
  paymentIntentInternal: StripePaymentIntents;
  paymentMethod?: Maybe<Scalars['String']>;
  /** An object relationship */
  paymentMethodUsed?: Maybe<UserCreditCards>;
  refunded: Scalars['Boolean'];
  sourceTransfer?: Maybe<Scalars['String']>;
  stripeCustomerId: Scalars['String'];
  transferDataAmount?: Maybe<Scalars['Int']>;
  transferDataDestination?: Maybe<Scalars['String']>;
  transferId?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "stripe_charges" */
export type StripeChargesAggregate = {
  __typename?: 'StripeChargesAggregate';
  aggregate?: Maybe<StripeChargesAggregateFields>;
  nodes: Array<StripeCharges>;
};

export type StripeChargesAggregateBoolExp = {
  bool_and?: InputMaybe<StripeChargesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<StripeChargesAggregateBoolExpBool_Or>;
  count?: InputMaybe<StripeChargesAggregateBoolExpCount>;
};

/** aggregate fields of "stripe_charges" */
export type StripeChargesAggregateFields = {
  __typename?: 'StripeChargesAggregateFields';
  avg?: Maybe<StripeChargesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StripeChargesMaxFields>;
  min?: Maybe<StripeChargesMinFields>;
  stddev?: Maybe<StripeChargesStddevFields>;
  stddevPop?: Maybe<StripeChargesStddevPopFields>;
  stddevSamp?: Maybe<StripeChargesStddevSampFields>;
  sum?: Maybe<StripeChargesSumFields>;
  varPop?: Maybe<StripeChargesVarPopFields>;
  varSamp?: Maybe<StripeChargesVarSampFields>;
  variance?: Maybe<StripeChargesVarianceFields>;
};


/** aggregate fields of "stripe_charges" */
export type StripeChargesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StripeChargesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stripe_charges" */
export type StripeChargesAggregateOrderBy = {
  avg?: InputMaybe<StripeChargesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StripeChargesMaxOrderBy>;
  min?: InputMaybe<StripeChargesMinOrderBy>;
  stddev?: InputMaybe<StripeChargesStddevOrderBy>;
  stddevPop?: InputMaybe<StripeChargesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<StripeChargesStddevSampOrderBy>;
  sum?: InputMaybe<StripeChargesSumOrderBy>;
  varPop?: InputMaybe<StripeChargesVarPopOrderBy>;
  varSamp?: InputMaybe<StripeChargesVarSampOrderBy>;
  variance?: InputMaybe<StripeChargesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stripe_charges" */
export type StripeChargesArrRelInsertInput = {
  data: Array<StripeChargesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<StripeChargesOnConflict>;
};

/** aggregate avg on columns */
export type StripeChargesAvgFields = {
  __typename?: 'StripeChargesAvgFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stripe_charges" */
export type StripeChargesAvgOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stripe_charges". All fields are combined with a logical 'AND'. */
export type StripeChargesBoolExp = {
  _and?: InputMaybe<Array<StripeChargesBoolExp>>;
  _not?: InputMaybe<StripeChargesBoolExp>;
  _or?: InputMaybe<Array<StripeChargesBoolExp>>;
  amount?: InputMaybe<IntComparisonExp>;
  amountCaptured?: InputMaybe<IntComparisonExp>;
  amountRefunded?: InputMaybe<IntComparisonExp>;
  application?: InputMaybe<StringComparisonExp>;
  applicationFee?: InputMaybe<StringComparisonExp>;
  applicationFeeAmount?: InputMaybe<IntComparisonExp>;
  calculatedStatementDescriptor?: InputMaybe<StringComparisonExp>;
  captured?: InputMaybe<BooleanComparisonExp>;
  chargeId?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  disputed?: InputMaybe<BooleanComparisonExp>;
  externalStripePaymentIntentId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  internalStripePaymentIntentId?: InputMaybe<UuidComparisonExp>;
  paid?: InputMaybe<BooleanComparisonExp>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsBoolExp>;
  paymentMethod?: InputMaybe<StringComparisonExp>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsBoolExp>;
  refunded?: InputMaybe<BooleanComparisonExp>;
  sourceTransfer?: InputMaybe<StringComparisonExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  transferDataAmount?: InputMaybe<IntComparisonExp>;
  transferDataDestination?: InputMaybe<StringComparisonExp>;
  transferId?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "stripe_charges" */
export enum StripeChargesConstraint {
  /** unique or primary key constraint on columns "charge_id" */
  StripeChargesChargeIdKey = 'stripe_charges_charge_id_key',
  /** unique or primary key constraint on columns "id" */
  StripeChargesPkey = 'stripe_charges_pkey'
}

/** input type for incrementing numeric columns in table "stripe_charges" */
export type StripeChargesIncInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCaptured?: InputMaybe<Scalars['Int']>;
  amountRefunded?: InputMaybe<Scalars['Int']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "stripe_charges" */
export type StripeChargesInsertInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCaptured?: InputMaybe<Scalars['Int']>;
  amountRefunded?: InputMaybe<Scalars['Int']>;
  application?: InputMaybe<Scalars['String']>;
  applicationFee?: InputMaybe<Scalars['String']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  calculatedStatementDescriptor?: InputMaybe<Scalars['String']>;
  captured?: InputMaybe<Scalars['Boolean']>;
  chargeId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  disputed?: InputMaybe<Scalars['Boolean']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  paid?: InputMaybe<Scalars['Boolean']>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsObjRelInsertInput>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsObjRelInsertInput>;
  refunded?: InputMaybe<Scalars['Boolean']>;
  sourceTransfer?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
  transferDataDestination?: InputMaybe<Scalars['String']>;
  transferId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type StripeChargesMaxFields = {
  __typename?: 'StripeChargesMaxFields';
  amount?: Maybe<Scalars['Int']>;
  amountCaptured?: Maybe<Scalars['Int']>;
  amountRefunded?: Maybe<Scalars['Int']>;
  application?: Maybe<Scalars['String']>;
  applicationFee?: Maybe<Scalars['String']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  calculatedStatementDescriptor?: Maybe<Scalars['String']>;
  chargeId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  paymentMethod?: Maybe<Scalars['String']>;
  sourceTransfer?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  transferDataAmount?: Maybe<Scalars['Int']>;
  transferDataDestination?: Maybe<Scalars['String']>;
  transferId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "stripe_charges" */
export type StripeChargesMaxOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  application?: InputMaybe<OrderBy>;
  applicationFee?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  calculatedStatementDescriptor?: InputMaybe<OrderBy>;
  chargeId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  paymentMethod?: InputMaybe<OrderBy>;
  sourceTransfer?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
  transferDataDestination?: InputMaybe<OrderBy>;
  transferId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StripeChargesMinFields = {
  __typename?: 'StripeChargesMinFields';
  amount?: Maybe<Scalars['Int']>;
  amountCaptured?: Maybe<Scalars['Int']>;
  amountRefunded?: Maybe<Scalars['Int']>;
  application?: Maybe<Scalars['String']>;
  applicationFee?: Maybe<Scalars['String']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  calculatedStatementDescriptor?: Maybe<Scalars['String']>;
  chargeId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  externalStripePaymentIntentId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: Maybe<Scalars['uuid']>;
  paymentMethod?: Maybe<Scalars['String']>;
  sourceTransfer?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  transferDataAmount?: Maybe<Scalars['Int']>;
  transferDataDestination?: Maybe<Scalars['String']>;
  transferId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "stripe_charges" */
export type StripeChargesMinOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  application?: InputMaybe<OrderBy>;
  applicationFee?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  calculatedStatementDescriptor?: InputMaybe<OrderBy>;
  chargeId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  paymentMethod?: InputMaybe<OrderBy>;
  sourceTransfer?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
  transferDataDestination?: InputMaybe<OrderBy>;
  transferId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stripe_charges" */
export type StripeChargesMutationResponse = {
  __typename?: 'StripeChargesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StripeCharges>;
};

/** on_conflict condition type for table "stripe_charges" */
export type StripeChargesOnConflict = {
  constraint: StripeChargesConstraint;
  updateColumns?: Array<StripeChargesUpdateColumn>;
  where?: InputMaybe<StripeChargesBoolExp>;
};

/** Ordering options when selecting data from "stripe_charges". */
export type StripeChargesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  application?: InputMaybe<OrderBy>;
  applicationFee?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  calculatedStatementDescriptor?: InputMaybe<OrderBy>;
  captured?: InputMaybe<OrderBy>;
  chargeId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  disputed?: InputMaybe<OrderBy>;
  externalStripePaymentIntentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  internalStripePaymentIntentId?: InputMaybe<OrderBy>;
  paid?: InputMaybe<OrderBy>;
  paymentIntentExternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentIntentInternal?: InputMaybe<StripePaymentIntentsOrderBy>;
  paymentMethod?: InputMaybe<OrderBy>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsOrderBy>;
  refunded?: InputMaybe<OrderBy>;
  sourceTransfer?: InputMaybe<OrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
  transferDataDestination?: InputMaybe<OrderBy>;
  transferId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stripe_charges */
export type StripeChargesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "stripe_charges" */
export enum StripeChargesSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AmountCaptured = 'amountCaptured',
  /** column name */
  AmountRefunded = 'amountRefunded',
  /** column name */
  Application = 'application',
  /** column name */
  ApplicationFee = 'applicationFee',
  /** column name */
  ApplicationFeeAmount = 'applicationFeeAmount',
  /** column name */
  CalculatedStatementDescriptor = 'calculatedStatementDescriptor',
  /** column name */
  Captured = 'captured',
  /** column name */
  ChargeId = 'chargeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  Paid = 'paid',
  /** column name */
  PaymentMethod = 'paymentMethod',
  /** column name */
  Refunded = 'refunded',
  /** column name */
  SourceTransfer = 'sourceTransfer',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  TransferDataAmount = 'transferDataAmount',
  /** column name */
  TransferDataDestination = 'transferDataDestination',
  /** column name */
  TransferId = 'transferId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "stripeChargesAggregateBoolExpBool_andArgumentsColumns" columns of table "stripe_charges" */
export enum StripeChargesSelectColumnStripeChargesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  Captured = 'captured',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  Paid = 'paid',
  /** column name */
  Refunded = 'refunded'
}

/** select "stripeChargesAggregateBoolExpBool_orArgumentsColumns" columns of table "stripe_charges" */
export enum StripeChargesSelectColumnStripeChargesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  Captured = 'captured',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  Paid = 'paid',
  /** column name */
  Refunded = 'refunded'
}

/** input type for updating data in table "stripe_charges" */
export type StripeChargesSetInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCaptured?: InputMaybe<Scalars['Int']>;
  amountRefunded?: InputMaybe<Scalars['Int']>;
  application?: InputMaybe<Scalars['String']>;
  applicationFee?: InputMaybe<Scalars['String']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  calculatedStatementDescriptor?: InputMaybe<Scalars['String']>;
  captured?: InputMaybe<Scalars['Boolean']>;
  chargeId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  disputed?: InputMaybe<Scalars['Boolean']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  paid?: InputMaybe<Scalars['Boolean']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  refunded?: InputMaybe<Scalars['Boolean']>;
  sourceTransfer?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
  transferDataDestination?: InputMaybe<Scalars['String']>;
  transferId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type StripeChargesStddevFields = {
  __typename?: 'StripeChargesStddevFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stripe_charges" */
export type StripeChargesStddevOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type StripeChargesStddevPopFields = {
  __typename?: 'StripeChargesStddevPopFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "stripe_charges" */
export type StripeChargesStddevPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type StripeChargesStddevSampFields = {
  __typename?: 'StripeChargesStddevSampFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "stripe_charges" */
export type StripeChargesStddevSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stripe_charges" */
export type StripeChargesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: StripeChargesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StripeChargesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCaptured?: InputMaybe<Scalars['Int']>;
  amountRefunded?: InputMaybe<Scalars['Int']>;
  application?: InputMaybe<Scalars['String']>;
  applicationFee?: InputMaybe<Scalars['String']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  calculatedStatementDescriptor?: InputMaybe<Scalars['String']>;
  captured?: InputMaybe<Scalars['Boolean']>;
  chargeId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  disputed?: InputMaybe<Scalars['Boolean']>;
  externalStripePaymentIntentId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  internalStripePaymentIntentId?: InputMaybe<Scalars['uuid']>;
  paid?: InputMaybe<Scalars['Boolean']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  refunded?: InputMaybe<Scalars['Boolean']>;
  sourceTransfer?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
  transferDataDestination?: InputMaybe<Scalars['String']>;
  transferId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type StripeChargesSumFields = {
  __typename?: 'StripeChargesSumFields';
  amount?: Maybe<Scalars['Int']>;
  amountCaptured?: Maybe<Scalars['Int']>;
  amountRefunded?: Maybe<Scalars['Int']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  transferDataAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "stripe_charges" */
export type StripeChargesSumOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "stripe_charges" */
export enum StripeChargesUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AmountCaptured = 'amountCaptured',
  /** column name */
  AmountRefunded = 'amountRefunded',
  /** column name */
  Application = 'application',
  /** column name */
  ApplicationFee = 'applicationFee',
  /** column name */
  ApplicationFeeAmount = 'applicationFeeAmount',
  /** column name */
  CalculatedStatementDescriptor = 'calculatedStatementDescriptor',
  /** column name */
  Captured = 'captured',
  /** column name */
  ChargeId = 'chargeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  ExternalStripePaymentIntentId = 'externalStripePaymentIntentId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalStripePaymentIntentId = 'internalStripePaymentIntentId',
  /** column name */
  Paid = 'paid',
  /** column name */
  PaymentMethod = 'paymentMethod',
  /** column name */
  Refunded = 'refunded',
  /** column name */
  SourceTransfer = 'sourceTransfer',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  TransferDataAmount = 'transferDataAmount',
  /** column name */
  TransferDataDestination = 'transferDataDestination',
  /** column name */
  TransferId = 'transferId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type StripeChargesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StripeChargesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StripeChargesSetInput>;
  /** filter the rows which have to be updated */
  where: StripeChargesBoolExp;
};

/** aggregate varPop on columns */
export type StripeChargesVarPopFields = {
  __typename?: 'StripeChargesVarPopFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "stripe_charges" */
export type StripeChargesVarPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type StripeChargesVarSampFields = {
  __typename?: 'StripeChargesVarSampFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "stripe_charges" */
export type StripeChargesVarSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StripeChargesVarianceFields = {
  __typename?: 'StripeChargesVarianceFields';
  amount?: Maybe<Scalars['Float']>;
  amountCaptured?: Maybe<Scalars['Float']>;
  amountRefunded?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stripe_charges" */
export type StripeChargesVarianceOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCaptured?: InputMaybe<OrderBy>;
  amountRefunded?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "stripe_payment_intents" */
export type StripePaymentIntents = {
  __typename?: 'StripePaymentIntents';
  amount: Scalars['Int'];
  amountCapturable: Scalars['Int'];
  amountReceived: Scalars['Int'];
  application?: Maybe<Scalars['String']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  cancellationReason?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  onBehalfOf?: Maybe<Scalars['String']>;
  paymentIntentId: Scalars['String'];
  paymentMethod?: Maybe<Scalars['String']>;
  /** An object relationship */
  paymentMethodUsed?: Maybe<UserCreditCards>;
  statementDescriptor?: Maybe<Scalars['String']>;
  status: Scalars['String'];
  /** An array relationship */
  stripeCharges: Array<StripeCharges>;
  /** An aggregate relationship */
  stripeChargesAggregate: StripeChargesAggregate;
  stripeCustomerId: Scalars['String'];
  transferDataAmount?: Maybe<Scalars['Int']>;
  transferDataDestination?: Maybe<Scalars['String']>;
  transferGroup?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "stripe_payment_intents" */
export type StripePaymentIntentsStripeChargesArgs = {
  distinctOn?: InputMaybe<Array<StripeChargesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripeChargesOrderBy>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};


/** columns and relationships of "stripe_payment_intents" */
export type StripePaymentIntentsStripeChargesAggregateArgs = {
  distinctOn?: InputMaybe<Array<StripeChargesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripeChargesOrderBy>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};

/** aggregated selection of "stripe_payment_intents" */
export type StripePaymentIntentsAggregate = {
  __typename?: 'StripePaymentIntentsAggregate';
  aggregate?: Maybe<StripePaymentIntentsAggregateFields>;
  nodes: Array<StripePaymentIntents>;
};

/** aggregate fields of "stripe_payment_intents" */
export type StripePaymentIntentsAggregateFields = {
  __typename?: 'StripePaymentIntentsAggregateFields';
  avg?: Maybe<StripePaymentIntentsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StripePaymentIntentsMaxFields>;
  min?: Maybe<StripePaymentIntentsMinFields>;
  stddev?: Maybe<StripePaymentIntentsStddevFields>;
  stddevPop?: Maybe<StripePaymentIntentsStddevPopFields>;
  stddevSamp?: Maybe<StripePaymentIntentsStddevSampFields>;
  sum?: Maybe<StripePaymentIntentsSumFields>;
  varPop?: Maybe<StripePaymentIntentsVarPopFields>;
  varSamp?: Maybe<StripePaymentIntentsVarSampFields>;
  variance?: Maybe<StripePaymentIntentsVarianceFields>;
};


/** aggregate fields of "stripe_payment_intents" */
export type StripePaymentIntentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StripePaymentIntentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StripePaymentIntentsAvgFields = {
  __typename?: 'StripePaymentIntentsAvgFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "stripe_payment_intents". All fields are combined with a logical 'AND'. */
export type StripePaymentIntentsBoolExp = {
  _and?: InputMaybe<Array<StripePaymentIntentsBoolExp>>;
  _not?: InputMaybe<StripePaymentIntentsBoolExp>;
  _or?: InputMaybe<Array<StripePaymentIntentsBoolExp>>;
  amount?: InputMaybe<IntComparisonExp>;
  amountCapturable?: InputMaybe<IntComparisonExp>;
  amountReceived?: InputMaybe<IntComparisonExp>;
  application?: InputMaybe<StringComparisonExp>;
  applicationFeeAmount?: InputMaybe<IntComparisonExp>;
  cancellationReason?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  onBehalfOf?: InputMaybe<StringComparisonExp>;
  paymentIntentId?: InputMaybe<StringComparisonExp>;
  paymentMethod?: InputMaybe<StringComparisonExp>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsBoolExp>;
  statementDescriptor?: InputMaybe<StringComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  stripeCharges?: InputMaybe<StripeChargesBoolExp>;
  stripeChargesAggregate?: InputMaybe<StripeChargesAggregateBoolExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  transferDataAmount?: InputMaybe<IntComparisonExp>;
  transferDataDestination?: InputMaybe<StringComparisonExp>;
  transferGroup?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "stripe_payment_intents" */
export enum StripePaymentIntentsConstraint {
  /** unique or primary key constraint on columns "payment_intent_id" */
  StripePaymentIntentsPaymentIntentIdKey = 'stripe_payment_intents_payment_intent_id_key',
  /** unique or primary key constraint on columns "id" */
  StripePaymentIntentsPkey = 'stripe_payment_intents_pkey'
}

/** input type for incrementing numeric columns in table "stripe_payment_intents" */
export type StripePaymentIntentsIncInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCapturable?: InputMaybe<Scalars['Int']>;
  amountReceived?: InputMaybe<Scalars['Int']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "stripe_payment_intents" */
export type StripePaymentIntentsInsertInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCapturable?: InputMaybe<Scalars['Int']>;
  amountReceived?: InputMaybe<Scalars['Int']>;
  application?: InputMaybe<Scalars['String']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  cancellationReason?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  onBehalfOf?: InputMaybe<Scalars['String']>;
  paymentIntentId?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsObjRelInsertInput>;
  statementDescriptor?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  stripeCharges?: InputMaybe<StripeChargesArrRelInsertInput>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
  transferDataDestination?: InputMaybe<Scalars['String']>;
  transferGroup?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type StripePaymentIntentsMaxFields = {
  __typename?: 'StripePaymentIntentsMaxFields';
  amount?: Maybe<Scalars['Int']>;
  amountCapturable?: Maybe<Scalars['Int']>;
  amountReceived?: Maybe<Scalars['Int']>;
  application?: Maybe<Scalars['String']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  cancellationReason?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  onBehalfOf?: Maybe<Scalars['String']>;
  paymentIntentId?: Maybe<Scalars['String']>;
  paymentMethod?: Maybe<Scalars['String']>;
  statementDescriptor?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  transferDataAmount?: Maybe<Scalars['Int']>;
  transferDataDestination?: Maybe<Scalars['String']>;
  transferGroup?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type StripePaymentIntentsMinFields = {
  __typename?: 'StripePaymentIntentsMinFields';
  amount?: Maybe<Scalars['Int']>;
  amountCapturable?: Maybe<Scalars['Int']>;
  amountReceived?: Maybe<Scalars['Int']>;
  application?: Maybe<Scalars['String']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  cancellationReason?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  onBehalfOf?: Maybe<Scalars['String']>;
  paymentIntentId?: Maybe<Scalars['String']>;
  paymentMethod?: Maybe<Scalars['String']>;
  statementDescriptor?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  transferDataAmount?: Maybe<Scalars['Int']>;
  transferDataDestination?: Maybe<Scalars['String']>;
  transferGroup?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "stripe_payment_intents" */
export type StripePaymentIntentsMutationResponse = {
  __typename?: 'StripePaymentIntentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StripePaymentIntents>;
};

/** input type for inserting object relation for remote table "stripe_payment_intents" */
export type StripePaymentIntentsObjRelInsertInput = {
  data: StripePaymentIntentsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<StripePaymentIntentsOnConflict>;
};

/** on_conflict condition type for table "stripe_payment_intents" */
export type StripePaymentIntentsOnConflict = {
  constraint: StripePaymentIntentsConstraint;
  updateColumns?: Array<StripePaymentIntentsUpdateColumn>;
  where?: InputMaybe<StripePaymentIntentsBoolExp>;
};

/** Ordering options when selecting data from "stripe_payment_intents". */
export type StripePaymentIntentsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amountCapturable?: InputMaybe<OrderBy>;
  amountReceived?: InputMaybe<OrderBy>;
  application?: InputMaybe<OrderBy>;
  applicationFeeAmount?: InputMaybe<OrderBy>;
  cancellationReason?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  onBehalfOf?: InputMaybe<OrderBy>;
  paymentIntentId?: InputMaybe<OrderBy>;
  paymentMethod?: InputMaybe<OrderBy>;
  paymentMethodUsed?: InputMaybe<UserCreditCardsOrderBy>;
  statementDescriptor?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  stripeChargesAggregate?: InputMaybe<StripeChargesAggregateOrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  transferDataAmount?: InputMaybe<OrderBy>;
  transferDataDestination?: InputMaybe<OrderBy>;
  transferGroup?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stripe_payment_intents */
export type StripePaymentIntentsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "stripe_payment_intents" */
export enum StripePaymentIntentsSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AmountCapturable = 'amountCapturable',
  /** column name */
  AmountReceived = 'amountReceived',
  /** column name */
  Application = 'application',
  /** column name */
  ApplicationFeeAmount = 'applicationFeeAmount',
  /** column name */
  CancellationReason = 'cancellationReason',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  OnBehalfOf = 'onBehalfOf',
  /** column name */
  PaymentIntentId = 'paymentIntentId',
  /** column name */
  PaymentMethod = 'paymentMethod',
  /** column name */
  StatementDescriptor = 'statementDescriptor',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  TransferDataAmount = 'transferDataAmount',
  /** column name */
  TransferDataDestination = 'transferDataDestination',
  /** column name */
  TransferGroup = 'transferGroup',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "stripe_payment_intents" */
export type StripePaymentIntentsSetInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCapturable?: InputMaybe<Scalars['Int']>;
  amountReceived?: InputMaybe<Scalars['Int']>;
  application?: InputMaybe<Scalars['String']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  cancellationReason?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  onBehalfOf?: InputMaybe<Scalars['String']>;
  paymentIntentId?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  statementDescriptor?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
  transferDataDestination?: InputMaybe<Scalars['String']>;
  transferGroup?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type StripePaymentIntentsStddevFields = {
  __typename?: 'StripePaymentIntentsStddevFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type StripePaymentIntentsStddevPopFields = {
  __typename?: 'StripePaymentIntentsStddevPopFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type StripePaymentIntentsStddevSampFields = {
  __typename?: 'StripePaymentIntentsStddevSampFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "stripe_payment_intents" */
export type StripePaymentIntentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: StripePaymentIntentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StripePaymentIntentsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['Int']>;
  amountCapturable?: InputMaybe<Scalars['Int']>;
  amountReceived?: InputMaybe<Scalars['Int']>;
  application?: InputMaybe<Scalars['String']>;
  applicationFeeAmount?: InputMaybe<Scalars['Int']>;
  cancellationReason?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  onBehalfOf?: InputMaybe<Scalars['String']>;
  paymentIntentId?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  statementDescriptor?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  transferDataAmount?: InputMaybe<Scalars['Int']>;
  transferDataDestination?: InputMaybe<Scalars['String']>;
  transferGroup?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type StripePaymentIntentsSumFields = {
  __typename?: 'StripePaymentIntentsSumFields';
  amount?: Maybe<Scalars['Int']>;
  amountCapturable?: Maybe<Scalars['Int']>;
  amountReceived?: Maybe<Scalars['Int']>;
  applicationFeeAmount?: Maybe<Scalars['Int']>;
  transferDataAmount?: Maybe<Scalars['Int']>;
};

/** update columns of table "stripe_payment_intents" */
export enum StripePaymentIntentsUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  AmountCapturable = 'amountCapturable',
  /** column name */
  AmountReceived = 'amountReceived',
  /** column name */
  Application = 'application',
  /** column name */
  ApplicationFeeAmount = 'applicationFeeAmount',
  /** column name */
  CancellationReason = 'cancellationReason',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  OnBehalfOf = 'onBehalfOf',
  /** column name */
  PaymentIntentId = 'paymentIntentId',
  /** column name */
  PaymentMethod = 'paymentMethod',
  /** column name */
  StatementDescriptor = 'statementDescriptor',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  TransferDataAmount = 'transferDataAmount',
  /** column name */
  TransferDataDestination = 'transferDataDestination',
  /** column name */
  TransferGroup = 'transferGroup',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type StripePaymentIntentsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StripePaymentIntentsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StripePaymentIntentsSetInput>;
  /** filter the rows which have to be updated */
  where: StripePaymentIntentsBoolExp;
};

/** aggregate varPop on columns */
export type StripePaymentIntentsVarPopFields = {
  __typename?: 'StripePaymentIntentsVarPopFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type StripePaymentIntentsVarSampFields = {
  __typename?: 'StripePaymentIntentsVarSampFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StripePaymentIntentsVarianceFields = {
  __typename?: 'StripePaymentIntentsVarianceFields';
  amount?: Maybe<Scalars['Float']>;
  amountCapturable?: Maybe<Scalars['Float']>;
  amountReceived?: Maybe<Scalars['Float']>;
  applicationFeeAmount?: Maybe<Scalars['Float']>;
  transferDataAmount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "team_types" */
export type TeamTypes = {
  __typename?: 'TeamTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "team_types" */
export type TeamTypesAggregate = {
  __typename?: 'TeamTypesAggregate';
  aggregate?: Maybe<TeamTypesAggregateFields>;
  nodes: Array<TeamTypes>;
};

/** aggregate fields of "team_types" */
export type TeamTypesAggregateFields = {
  __typename?: 'TeamTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<TeamTypesMaxFields>;
  min?: Maybe<TeamTypesMinFields>;
};


/** aggregate fields of "team_types" */
export type TeamTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeamTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "team_types". All fields are combined with a logical 'AND'. */
export type TeamTypesBoolExp = {
  _and?: InputMaybe<Array<TeamTypesBoolExp>>;
  _not?: InputMaybe<TeamTypesBoolExp>;
  _or?: InputMaybe<Array<TeamTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "team_types" */
export enum TeamTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  TeamTypesPkey = 'team_types_pkey'
}

export enum TeamTypesEnum {
  Doubles = 'DOUBLES',
  Singles = 'SINGLES'
}

/** Boolean expression to compare columns of type "TeamTypesEnum". All fields are combined with logical 'AND'. */
export type TeamTypesEnumComparisonExp = {
  _eq?: InputMaybe<TeamTypesEnum>;
  _in?: InputMaybe<Array<TeamTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<TeamTypesEnum>;
  _nin?: InputMaybe<Array<TeamTypesEnum>>;
};

/** input type for inserting data into table "team_types" */
export type TeamTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type TeamTypesMaxFields = {
  __typename?: 'TeamTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type TeamTypesMinFields = {
  __typename?: 'TeamTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "team_types" */
export type TeamTypesMutationResponse = {
  __typename?: 'TeamTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TeamTypes>;
};

/** on_conflict condition type for table "team_types" */
export type TeamTypesOnConflict = {
  constraint: TeamTypesConstraint;
  updateColumns?: Array<TeamTypesUpdateColumn>;
  where?: InputMaybe<TeamTypesBoolExp>;
};

/** Ordering options when selecting data from "team_types". */
export type TeamTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: team_types */
export type TeamTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "team_types" */
export enum TeamTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "team_types" */
export type TeamTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "team_types" */
export type TeamTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TeamTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeamTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "team_types" */
export enum TeamTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type TeamTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeamTypesSetInput>;
  /** filter the rows which have to be updated */
  where: TeamTypesBoolExp;
};

/** columns and relationships of "tennis_rating_scales" */
export type TennisRatingScales = {
  __typename?: 'TennisRatingScales';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  maximum: Scalars['numeric'];
  minimum: Scalars['numeric'];
  name: Scalars['String'];
  order: Scalars['Int'];
  shortName: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "tennis_rating_scales" */
export type TennisRatingScalesAggregate = {
  __typename?: 'TennisRatingScalesAggregate';
  aggregate?: Maybe<TennisRatingScalesAggregateFields>;
  nodes: Array<TennisRatingScales>;
};

/** aggregate fields of "tennis_rating_scales" */
export type TennisRatingScalesAggregateFields = {
  __typename?: 'TennisRatingScalesAggregateFields';
  avg?: Maybe<TennisRatingScalesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TennisRatingScalesMaxFields>;
  min?: Maybe<TennisRatingScalesMinFields>;
  stddev?: Maybe<TennisRatingScalesStddevFields>;
  stddevPop?: Maybe<TennisRatingScalesStddevPopFields>;
  stddevSamp?: Maybe<TennisRatingScalesStddevSampFields>;
  sum?: Maybe<TennisRatingScalesSumFields>;
  varPop?: Maybe<TennisRatingScalesVarPopFields>;
  varSamp?: Maybe<TennisRatingScalesVarSampFields>;
  variance?: Maybe<TennisRatingScalesVarianceFields>;
};


/** aggregate fields of "tennis_rating_scales" */
export type TennisRatingScalesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type TennisRatingScalesAvgFields = {
  __typename?: 'TennisRatingScalesAvgFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "tennis_rating_scales". All fields are combined with a logical 'AND'. */
export type TennisRatingScalesBoolExp = {
  _and?: InputMaybe<Array<TennisRatingScalesBoolExp>>;
  _not?: InputMaybe<TennisRatingScalesBoolExp>;
  _or?: InputMaybe<Array<TennisRatingScalesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  minimum?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  shortName?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "tennis_rating_scales" */
export enum TennisRatingScalesConstraint {
  /** unique or primary key constraint on columns "id" */
  TennisRatingScalesPkey = 'tennis_rating_scales_pkey'
}

/** input type for incrementing numeric columns in table "tennis_rating_scales" */
export type TennisRatingScalesIncInput = {
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  order?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "tennis_rating_scales" */
export type TennisRatingScalesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type TennisRatingScalesMaxFields = {
  __typename?: 'TennisRatingScalesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  maximum?: Maybe<Scalars['numeric']>;
  minimum?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  shortName?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type TennisRatingScalesMinFields = {
  __typename?: 'TennisRatingScalesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  maximum?: Maybe<Scalars['numeric']>;
  minimum?: Maybe<Scalars['numeric']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  shortName?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "tennis_rating_scales" */
export type TennisRatingScalesMutationResponse = {
  __typename?: 'TennisRatingScalesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TennisRatingScales>;
};

/** input type for inserting object relation for remote table "tennis_rating_scales" */
export type TennisRatingScalesObjRelInsertInput = {
  data: TennisRatingScalesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<TennisRatingScalesOnConflict>;
};

/** on_conflict condition type for table "tennis_rating_scales" */
export type TennisRatingScalesOnConflict = {
  constraint: TennisRatingScalesConstraint;
  updateColumns?: Array<TennisRatingScalesUpdateColumn>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};

/** Ordering options when selecting data from "tennis_rating_scales". */
export type TennisRatingScalesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  minimum?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  shortName?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: tennis_rating_scales */
export type TennisRatingScalesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "tennis_rating_scales" */
export enum TennisRatingScalesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Maximum = 'maximum',
  /** column name */
  Minimum = 'minimum',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "tennis_rating_scales" */
export type TennisRatingScalesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type TennisRatingScalesStddevFields = {
  __typename?: 'TennisRatingScalesStddevFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type TennisRatingScalesStddevPopFields = {
  __typename?: 'TennisRatingScalesStddevPopFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type TennisRatingScalesStddevSampFields = {
  __typename?: 'TennisRatingScalesStddevSampFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "tennis_rating_scales" */
export type TennisRatingScalesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TennisRatingScalesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TennisRatingScalesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  maximum?: InputMaybe<Scalars['numeric']>;
  minimum?: InputMaybe<Scalars['numeric']>;
  name?: InputMaybe<Scalars['String']>;
  order?: InputMaybe<Scalars['Int']>;
  shortName?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type TennisRatingScalesSumFields = {
  __typename?: 'TennisRatingScalesSumFields';
  maximum?: Maybe<Scalars['numeric']>;
  minimum?: Maybe<Scalars['numeric']>;
  order?: Maybe<Scalars['Int']>;
};

/** update columns of table "tennis_rating_scales" */
export enum TennisRatingScalesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Maximum = 'maximum',
  /** column name */
  Minimum = 'minimum',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type TennisRatingScalesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TennisRatingScalesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TennisRatingScalesSetInput>;
  /** filter the rows which have to be updated */
  where: TennisRatingScalesBoolExp;
};

/** aggregate varPop on columns */
export type TennisRatingScalesVarPopFields = {
  __typename?: 'TennisRatingScalesVarPopFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type TennisRatingScalesVarSampFields = {
  __typename?: 'TennisRatingScalesVarSampFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type TennisRatingScalesVarianceFields = {
  __typename?: 'TennisRatingScalesVarianceFields';
  maximum?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']>;
  _gt?: InputMaybe<Scalars['timestamptz']>;
  _gte?: InputMaybe<Scalars['timestamptz']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamptz']>;
  _lte?: InputMaybe<Scalars['timestamptz']>;
  _neq?: InputMaybe<Scalars['timestamptz']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** columns and relationships of "user_auth_identities" */
export type UserAuthIdentities = {
  __typename?: 'UserAuthIdentities';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  id: Scalars['uuid'];
  phoneNumber?: Maybe<Scalars['String']>;
  provider: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  userId: Scalars['uuid'];
};

/** aggregated selection of "user_auth_identities" */
export type UserAuthIdentitiesAggregate = {
  __typename?: 'UserAuthIdentitiesAggregate';
  aggregate?: Maybe<UserAuthIdentitiesAggregateFields>;
  nodes: Array<UserAuthIdentities>;
};

export type UserAuthIdentitiesAggregateBoolExp = {
  count?: InputMaybe<UserAuthIdentitiesAggregateBoolExpCount>;
};

/** aggregate fields of "user_auth_identities" */
export type UserAuthIdentitiesAggregateFields = {
  __typename?: 'UserAuthIdentitiesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserAuthIdentitiesMaxFields>;
  min?: Maybe<UserAuthIdentitiesMinFields>;
};


/** aggregate fields of "user_auth_identities" */
export type UserAuthIdentitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_auth_identities" */
export type UserAuthIdentitiesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserAuthIdentitiesMaxOrderBy>;
  min?: InputMaybe<UserAuthIdentitiesMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_auth_identities" */
export type UserAuthIdentitiesArrRelInsertInput = {
  data: Array<UserAuthIdentitiesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserAuthIdentitiesOnConflict>;
};

/** Boolean expression to filter rows from the table "user_auth_identities". All fields are combined with a logical 'AND'. */
export type UserAuthIdentitiesBoolExp = {
  _and?: InputMaybe<Array<UserAuthIdentitiesBoolExp>>;
  _not?: InputMaybe<UserAuthIdentitiesBoolExp>;
  _or?: InputMaybe<Array<UserAuthIdentitiesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  displayName?: InputMaybe<StringComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_auth_identities" */
export enum UserAuthIdentitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserAuthIdentitiesPkey = 'user_auth_identities_pkey',
  /** unique or primary key constraint on columns "provider", "user_id", "email" */
  UserAuthIdentitiesProviderEmailUserIdKey = 'user_auth_identities_provider_email_user_id_key'
}

/** input type for inserting data into table "user_auth_identities" */
export type UserAuthIdentitiesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UserAuthIdentitiesMaxFields = {
  __typename?: 'UserAuthIdentitiesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  phoneNumber?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_auth_identities" */
export type UserAuthIdentitiesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserAuthIdentitiesMinFields = {
  __typename?: 'UserAuthIdentitiesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  displayName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  phoneNumber?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_auth_identities" */
export type UserAuthIdentitiesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_auth_identities" */
export type UserAuthIdentitiesMutationResponse = {
  __typename?: 'UserAuthIdentitiesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserAuthIdentities>;
};

/** on_conflict condition type for table "user_auth_identities" */
export type UserAuthIdentitiesOnConflict = {
  constraint: UserAuthIdentitiesConstraint;
  updateColumns?: Array<UserAuthIdentitiesUpdateColumn>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};

/** Ordering options when selecting data from "user_auth_identities". */
export type UserAuthIdentitiesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_auth_identities */
export type UserAuthIdentitiesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_auth_identities" */
export enum UserAuthIdentitiesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  Provider = 'provider',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_auth_identities" */
export type UserAuthIdentitiesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_auth_identities" */
export type UserAuthIdentitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserAuthIdentitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserAuthIdentitiesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_auth_identities" */
export enum UserAuthIdentitiesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  Provider = 'provider',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UserAuthIdentitiesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserAuthIdentitiesSetInput>;
  /** filter the rows which have to be updated */
  where: UserAuthIdentitiesBoolExp;
};

/** columns and relationships of "user_coach_services" */
export type UserCoachServices = {
  __typename?: 'UserCoachServices';
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currency: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  id: Scalars['uuid'];
  priceUnitAmount: Scalars['Int'];
  title: Scalars['String'];
  type?: Maybe<LessonTypesEnum>;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
};

/** aggregated selection of "user_coach_services" */
export type UserCoachServicesAggregate = {
  __typename?: 'UserCoachServicesAggregate';
  aggregate?: Maybe<UserCoachServicesAggregateFields>;
  nodes: Array<UserCoachServices>;
};

export type UserCoachServicesAggregateBoolExp = {
  count?: InputMaybe<UserCoachServicesAggregateBoolExpCount>;
};

/** aggregate fields of "user_coach_services" */
export type UserCoachServicesAggregateFields = {
  __typename?: 'UserCoachServicesAggregateFields';
  avg?: Maybe<UserCoachServicesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<UserCoachServicesMaxFields>;
  min?: Maybe<UserCoachServicesMinFields>;
  stddev?: Maybe<UserCoachServicesStddevFields>;
  stddevPop?: Maybe<UserCoachServicesStddevPopFields>;
  stddevSamp?: Maybe<UserCoachServicesStddevSampFields>;
  sum?: Maybe<UserCoachServicesSumFields>;
  varPop?: Maybe<UserCoachServicesVarPopFields>;
  varSamp?: Maybe<UserCoachServicesVarSampFields>;
  variance?: Maybe<UserCoachServicesVarianceFields>;
};


/** aggregate fields of "user_coach_services" */
export type UserCoachServicesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_coach_services" */
export type UserCoachServicesAggregateOrderBy = {
  avg?: InputMaybe<UserCoachServicesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCoachServicesMaxOrderBy>;
  min?: InputMaybe<UserCoachServicesMinOrderBy>;
  stddev?: InputMaybe<UserCoachServicesStddevOrderBy>;
  stddevPop?: InputMaybe<UserCoachServicesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<UserCoachServicesStddevSampOrderBy>;
  sum?: InputMaybe<UserCoachServicesSumOrderBy>;
  varPop?: InputMaybe<UserCoachServicesVarPopOrderBy>;
  varSamp?: InputMaybe<UserCoachServicesVarSampOrderBy>;
  variance?: InputMaybe<UserCoachServicesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "user_coach_services" */
export type UserCoachServicesArrRelInsertInput = {
  data: Array<UserCoachServicesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserCoachServicesOnConflict>;
};

/** aggregate avg on columns */
export type UserCoachServicesAvgFields = {
  __typename?: 'UserCoachServicesAvgFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "user_coach_services" */
export type UserCoachServicesAvgOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_coach_services". All fields are combined with a logical 'AND'. */
export type UserCoachServicesBoolExp = {
  _and?: InputMaybe<Array<UserCoachServicesBoolExp>>;
  _not?: InputMaybe<UserCoachServicesBoolExp>;
  _or?: InputMaybe<Array<UserCoachServicesBoolExp>>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderId?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  priceUnitAmount?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<LessonTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
};

/** unique or primary key constraints on table "user_coach_services" */
export enum UserCoachServicesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserCoachServicesPkey = 'user_coach_services_pkey'
}

/** input type for incrementing numeric columns in table "user_coach_services" */
export type UserCoachServicesIncInput = {
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_coach_services" */
export type UserCoachServicesInsertInput = {
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
};

/** aggregate max on columns */
export type UserCoachServicesMaxFields = {
  __typename?: 'UserCoachServicesMaxFields';
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_coach_services" */
export type UserCoachServicesMaxOrderBy = {
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserCoachServicesMinFields = {
  __typename?: 'UserCoachServicesMinFields';
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  priceUnitAmount?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_coach_services" */
export type UserCoachServicesMinOrderBy = {
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_coach_services" */
export type UserCoachServicesMutationResponse = {
  __typename?: 'UserCoachServicesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCoachServices>;
};

/** on_conflict condition type for table "user_coach_services" */
export type UserCoachServicesOnConflict = {
  constraint: UserCoachServicesConstraint;
  updateColumns?: Array<UserCoachServicesUpdateColumn>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};

/** Ordering options when selecting data from "user_coach_services". */
export type UserCoachServicesOrderBy = {
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceUnitAmount?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
};

/** primary key columns input for table: user_coach_services */
export type UserCoachServicesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_coach_services" */
export enum UserCoachServicesSelectColumn {
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_coach_services" */
export type UserCoachServicesSetInput = {
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type UserCoachServicesStddevFields = {
  __typename?: 'UserCoachServicesStddevFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "user_coach_services" */
export type UserCoachServicesStddevOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type UserCoachServicesStddevPopFields = {
  __typename?: 'UserCoachServicesStddevPopFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "user_coach_services" */
export type UserCoachServicesStddevPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type UserCoachServicesStddevSampFields = {
  __typename?: 'UserCoachServicesStddevSampFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "user_coach_services" */
export type UserCoachServicesStddevSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_coach_services" */
export type UserCoachServicesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCoachServicesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCoachServicesStreamCursorValueInput = {
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  priceUnitAmount?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<LessonTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type UserCoachServicesSumFields = {
  __typename?: 'UserCoachServicesSumFields';
  priceUnitAmount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "user_coach_services" */
export type UserCoachServicesSumOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "user_coach_services" */
export enum UserCoachServicesUpdateColumn {
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  PriceUnitAmount = 'priceUnitAmount',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UserCoachServicesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserCoachServicesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCoachServicesSetInput>;
  /** filter the rows which have to be updated */
  where: UserCoachServicesBoolExp;
};

/** aggregate varPop on columns */
export type UserCoachServicesVarPopFields = {
  __typename?: 'UserCoachServicesVarPopFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "user_coach_services" */
export type UserCoachServicesVarPopOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type UserCoachServicesVarSampFields = {
  __typename?: 'UserCoachServicesVarSampFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "user_coach_services" */
export type UserCoachServicesVarSampOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UserCoachServicesVarianceFields = {
  __typename?: 'UserCoachServicesVarianceFields';
  priceUnitAmount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "user_coach_services" */
export type UserCoachServicesVarianceOrderBy = {
  priceUnitAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "user_communication_preferences" */
export type UserCommunicationPreferences = {
  __typename?: 'UserCommunicationPreferences';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id: Scalars['uuid'];
  lessonBookedEmail: CommunicationPreferenceStatusesEnum;
  lessonBookedPush: CommunicationPreferenceStatusesEnum;
  lessonCanceledEmail: CommunicationPreferenceStatusesEnum;
  lessonCanceledPushed: CommunicationPreferenceStatusesEnum;
  lessonReminderEmail: CommunicationPreferenceStatusesEnum;
  lessonReminderPush: CommunicationPreferenceStatusesEnum;
  marketingEmail: CommunicationPreferenceStatusesEnum;
  marketingPush: CommunicationPreferenceStatusesEnum;
  newFollowerEmail: CommunicationPreferenceStatusesEnum;
  newFollowerPush: CommunicationPreferenceStatusesEnum;
  newLessonPublishedEmail: CommunicationPreferenceStatusesEnum;
  newLessonPublishedPush: CommunicationPreferenceStatusesEnum;
  participantLeftLessonEmail: CommunicationPreferenceStatusesEnum;
  participantLeftLessonPush: CommunicationPreferenceStatusesEnum;
  payoutEmail: CommunicationPreferenceStatusesEnum;
  payoutPush: CommunicationPreferenceStatusesEnum;
  playSessionCanceledEmail: CommunicationPreferenceStatusesEnum;
  playSessionCanceledPush: CommunicationPreferenceStatusesEnum;
  playSessionParticipantJoinedEmail: CommunicationPreferenceStatusesEnum;
  playSessionParticipantJoinedPush: CommunicationPreferenceStatusesEnum;
  playSessionParticipantLeftEmail: CommunicationPreferenceStatusesEnum;
  playSessionParticipantLeftPush: CommunicationPreferenceStatusesEnum;
  playSessionReminderEmail: CommunicationPreferenceStatusesEnum;
  playSessionReminderPush: CommunicationPreferenceStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "user_communication_preferences" */
export type UserCommunicationPreferencesAggregate = {
  __typename?: 'UserCommunicationPreferencesAggregate';
  aggregate?: Maybe<UserCommunicationPreferencesAggregateFields>;
  nodes: Array<UserCommunicationPreferences>;
};

/** aggregate fields of "user_communication_preferences" */
export type UserCommunicationPreferencesAggregateFields = {
  __typename?: 'UserCommunicationPreferencesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserCommunicationPreferencesMaxFields>;
  min?: Maybe<UserCommunicationPreferencesMinFields>;
};


/** aggregate fields of "user_communication_preferences" */
export type UserCommunicationPreferencesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_communication_preferences". All fields are combined with a logical 'AND'. */
export type UserCommunicationPreferencesBoolExp = {
  _and?: InputMaybe<Array<UserCommunicationPreferencesBoolExp>>;
  _not?: InputMaybe<UserCommunicationPreferencesBoolExp>;
  _or?: InputMaybe<Array<UserCommunicationPreferencesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "user_communication_preferences" */
export enum UserCommunicationPreferencesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserCommunicationPreferencesPkey = 'user_communication_preferences_pkey'
}

/** input type for inserting data into table "user_communication_preferences" */
export type UserCommunicationPreferencesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id?: InputMaybe<Scalars['uuid']>;
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type UserCommunicationPreferencesMaxFields = {
  __typename?: 'UserCommunicationPreferencesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type UserCommunicationPreferencesMinFields = {
  __typename?: 'UserCommunicationPreferencesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "user_communication_preferences" */
export type UserCommunicationPreferencesMutationResponse = {
  __typename?: 'UserCommunicationPreferencesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCommunicationPreferences>;
};

/** input type for inserting object relation for remote table "user_communication_preferences" */
export type UserCommunicationPreferencesObjRelInsertInput = {
  data: UserCommunicationPreferencesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserCommunicationPreferencesOnConflict>;
};

/** on_conflict condition type for table "user_communication_preferences" */
export type UserCommunicationPreferencesOnConflict = {
  constraint: UserCommunicationPreferencesConstraint;
  updateColumns?: Array<UserCommunicationPreferencesUpdateColumn>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};

/** Ordering options when selecting data from "user_communication_preferences". */
export type UserCommunicationPreferencesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonBookedEmail?: InputMaybe<OrderBy>;
  lessonBookedPush?: InputMaybe<OrderBy>;
  lessonCanceledEmail?: InputMaybe<OrderBy>;
  lessonCanceledPushed?: InputMaybe<OrderBy>;
  lessonReminderEmail?: InputMaybe<OrderBy>;
  lessonReminderPush?: InputMaybe<OrderBy>;
  marketingEmail?: InputMaybe<OrderBy>;
  marketingPush?: InputMaybe<OrderBy>;
  newFollowerEmail?: InputMaybe<OrderBy>;
  newFollowerPush?: InputMaybe<OrderBy>;
  newLessonPublishedEmail?: InputMaybe<OrderBy>;
  newLessonPublishedPush?: InputMaybe<OrderBy>;
  participantLeftLessonEmail?: InputMaybe<OrderBy>;
  participantLeftLessonPush?: InputMaybe<OrderBy>;
  payoutEmail?: InputMaybe<OrderBy>;
  payoutPush?: InputMaybe<OrderBy>;
  playSessionCanceledEmail?: InputMaybe<OrderBy>;
  playSessionCanceledPush?: InputMaybe<OrderBy>;
  playSessionParticipantJoinedEmail?: InputMaybe<OrderBy>;
  playSessionParticipantJoinedPush?: InputMaybe<OrderBy>;
  playSessionParticipantLeftEmail?: InputMaybe<OrderBy>;
  playSessionParticipantLeftPush?: InputMaybe<OrderBy>;
  playSessionReminderEmail?: InputMaybe<OrderBy>;
  playSessionReminderPush?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: user_communication_preferences */
export type UserCommunicationPreferencesPkColumnsInput = {
  /** This will match the users UUID since it's 1-1 relationship */
  id: Scalars['uuid'];
};

/** select columns of table "user_communication_preferences" */
export enum UserCommunicationPreferencesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonBookedEmail = 'lessonBookedEmail',
  /** column name */
  LessonBookedPush = 'lessonBookedPush',
  /** column name */
  LessonCanceledEmail = 'lessonCanceledEmail',
  /** column name */
  LessonCanceledPushed = 'lessonCanceledPushed',
  /** column name */
  LessonReminderEmail = 'lessonReminderEmail',
  /** column name */
  LessonReminderPush = 'lessonReminderPush',
  /** column name */
  MarketingEmail = 'marketingEmail',
  /** column name */
  MarketingPush = 'marketingPush',
  /** column name */
  NewFollowerEmail = 'newFollowerEmail',
  /** column name */
  NewFollowerPush = 'newFollowerPush',
  /** column name */
  NewLessonPublishedEmail = 'newLessonPublishedEmail',
  /** column name */
  NewLessonPublishedPush = 'newLessonPublishedPush',
  /** column name */
  ParticipantLeftLessonEmail = 'participantLeftLessonEmail',
  /** column name */
  ParticipantLeftLessonPush = 'participantLeftLessonPush',
  /** column name */
  PayoutEmail = 'payoutEmail',
  /** column name */
  PayoutPush = 'payoutPush',
  /** column name */
  PlaySessionCanceledEmail = 'playSessionCanceledEmail',
  /** column name */
  PlaySessionCanceledPush = 'playSessionCanceledPush',
  /** column name */
  PlaySessionParticipantJoinedEmail = 'playSessionParticipantJoinedEmail',
  /** column name */
  PlaySessionParticipantJoinedPush = 'playSessionParticipantJoinedPush',
  /** column name */
  PlaySessionParticipantLeftEmail = 'playSessionParticipantLeftEmail',
  /** column name */
  PlaySessionParticipantLeftPush = 'playSessionParticipantLeftPush',
  /** column name */
  PlaySessionReminderEmail = 'playSessionReminderEmail',
  /** column name */
  PlaySessionReminderPush = 'playSessionReminderPush',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "user_communication_preferences" */
export type UserCommunicationPreferencesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id?: InputMaybe<Scalars['uuid']>;
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "user_communication_preferences" */
export type UserCommunicationPreferencesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCommunicationPreferencesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCommunicationPreferencesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  /** This will match the users UUID since it's 1-1 relationship */
  id?: InputMaybe<Scalars['uuid']>;
  lessonBookedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonBookedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonCanceledPushed?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  lessonReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  marketingPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newFollowerPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  newLessonPublishedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  participantLeftLessonPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  payoutPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionCanceledPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantJoinedPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionParticipantLeftPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderEmail?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  playSessionReminderPush?: InputMaybe<CommunicationPreferenceStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "user_communication_preferences" */
export enum UserCommunicationPreferencesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  LessonBookedEmail = 'lessonBookedEmail',
  /** column name */
  LessonBookedPush = 'lessonBookedPush',
  /** column name */
  LessonCanceledEmail = 'lessonCanceledEmail',
  /** column name */
  LessonCanceledPushed = 'lessonCanceledPushed',
  /** column name */
  LessonReminderEmail = 'lessonReminderEmail',
  /** column name */
  LessonReminderPush = 'lessonReminderPush',
  /** column name */
  MarketingEmail = 'marketingEmail',
  /** column name */
  MarketingPush = 'marketingPush',
  /** column name */
  NewFollowerEmail = 'newFollowerEmail',
  /** column name */
  NewFollowerPush = 'newFollowerPush',
  /** column name */
  NewLessonPublishedEmail = 'newLessonPublishedEmail',
  /** column name */
  NewLessonPublishedPush = 'newLessonPublishedPush',
  /** column name */
  ParticipantLeftLessonEmail = 'participantLeftLessonEmail',
  /** column name */
  ParticipantLeftLessonPush = 'participantLeftLessonPush',
  /** column name */
  PayoutEmail = 'payoutEmail',
  /** column name */
  PayoutPush = 'payoutPush',
  /** column name */
  PlaySessionCanceledEmail = 'playSessionCanceledEmail',
  /** column name */
  PlaySessionCanceledPush = 'playSessionCanceledPush',
  /** column name */
  PlaySessionParticipantJoinedEmail = 'playSessionParticipantJoinedEmail',
  /** column name */
  PlaySessionParticipantJoinedPush = 'playSessionParticipantJoinedPush',
  /** column name */
  PlaySessionParticipantLeftEmail = 'playSessionParticipantLeftEmail',
  /** column name */
  PlaySessionParticipantLeftPush = 'playSessionParticipantLeftPush',
  /** column name */
  PlaySessionReminderEmail = 'playSessionReminderEmail',
  /** column name */
  PlaySessionReminderPush = 'playSessionReminderPush',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type UserCommunicationPreferencesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCommunicationPreferencesSetInput>;
  /** filter the rows which have to be updated */
  where: UserCommunicationPreferencesBoolExp;
};

/** columns and relationships of "user_credit_cards" */
export type UserCreditCards = {
  __typename?: 'UserCreditCards';
  billingCity?: Maybe<Scalars['String']>;
  billingCountry?: Maybe<Scalars['String']>;
  billingEmail?: Maybe<Scalars['String']>;
  billingLine1?: Maybe<Scalars['String']>;
  billingLine2?: Maybe<Scalars['String']>;
  billingName?: Maybe<Scalars['String']>;
  billingPhone?: Maybe<Scalars['String']>;
  billingPostalCode?: Maybe<Scalars['String']>;
  billingState?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  country: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  expireMonth: Scalars['Int'];
  expireYear: Scalars['Int'];
  fingerprint: Scalars['String'];
  funding: Scalars['String'];
  id: Scalars['uuid'];
  last4: Scalars['String'];
  provider: Scalars['String'];
  providerCardId: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "user_credit_cards" */
export type UserCreditCardsAggregate = {
  __typename?: 'UserCreditCardsAggregate';
  aggregate?: Maybe<UserCreditCardsAggregateFields>;
  nodes: Array<UserCreditCards>;
};

export type UserCreditCardsAggregateBoolExp = {
  count?: InputMaybe<UserCreditCardsAggregateBoolExpCount>;
};

/** aggregate fields of "user_credit_cards" */
export type UserCreditCardsAggregateFields = {
  __typename?: 'UserCreditCardsAggregateFields';
  avg?: Maybe<UserCreditCardsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<UserCreditCardsMaxFields>;
  min?: Maybe<UserCreditCardsMinFields>;
  stddev?: Maybe<UserCreditCardsStddevFields>;
  stddevPop?: Maybe<UserCreditCardsStddevPopFields>;
  stddevSamp?: Maybe<UserCreditCardsStddevSampFields>;
  sum?: Maybe<UserCreditCardsSumFields>;
  varPop?: Maybe<UserCreditCardsVarPopFields>;
  varSamp?: Maybe<UserCreditCardsVarSampFields>;
  variance?: Maybe<UserCreditCardsVarianceFields>;
};


/** aggregate fields of "user_credit_cards" */
export type UserCreditCardsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_credit_cards" */
export type UserCreditCardsAggregateOrderBy = {
  avg?: InputMaybe<UserCreditCardsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCreditCardsMaxOrderBy>;
  min?: InputMaybe<UserCreditCardsMinOrderBy>;
  stddev?: InputMaybe<UserCreditCardsStddevOrderBy>;
  stddevPop?: InputMaybe<UserCreditCardsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<UserCreditCardsStddevSampOrderBy>;
  sum?: InputMaybe<UserCreditCardsSumOrderBy>;
  varPop?: InputMaybe<UserCreditCardsVarPopOrderBy>;
  varSamp?: InputMaybe<UserCreditCardsVarSampOrderBy>;
  variance?: InputMaybe<UserCreditCardsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "user_credit_cards" */
export type UserCreditCardsArrRelInsertInput = {
  data: Array<UserCreditCardsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserCreditCardsOnConflict>;
};

/** aggregate avg on columns */
export type UserCreditCardsAvgFields = {
  __typename?: 'UserCreditCardsAvgFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "user_credit_cards" */
export type UserCreditCardsAvgOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_credit_cards". All fields are combined with a logical 'AND'. */
export type UserCreditCardsBoolExp = {
  _and?: InputMaybe<Array<UserCreditCardsBoolExp>>;
  _not?: InputMaybe<UserCreditCardsBoolExp>;
  _or?: InputMaybe<Array<UserCreditCardsBoolExp>>;
  billingCity?: InputMaybe<StringComparisonExp>;
  billingCountry?: InputMaybe<StringComparisonExp>;
  billingEmail?: InputMaybe<StringComparisonExp>;
  billingLine1?: InputMaybe<StringComparisonExp>;
  billingLine2?: InputMaybe<StringComparisonExp>;
  billingName?: InputMaybe<StringComparisonExp>;
  billingPhone?: InputMaybe<StringComparisonExp>;
  billingPostalCode?: InputMaybe<StringComparisonExp>;
  billingState?: InputMaybe<StringComparisonExp>;
  brand?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  expireMonth?: InputMaybe<IntComparisonExp>;
  expireYear?: InputMaybe<IntComparisonExp>;
  fingerprint?: InputMaybe<StringComparisonExp>;
  funding?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  last4?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerCardId?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_credit_cards" */
export enum UserCreditCardsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserCreditCardsPkey = 'user_credit_cards_pkey',
  /** unique or primary key constraint on columns "provider_card_id" */
  UserCreditCardsProviderCardIdKey = 'user_credit_cards_provider_card_id_key'
}

/** input type for incrementing numeric columns in table "user_credit_cards" */
export type UserCreditCardsIncInput = {
  expireMonth?: InputMaybe<Scalars['Int']>;
  expireYear?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_credit_cards" */
export type UserCreditCardsInsertInput = {
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingEmail?: InputMaybe<Scalars['String']>;
  billingLine1?: InputMaybe<Scalars['String']>;
  billingLine2?: InputMaybe<Scalars['String']>;
  billingName?: InputMaybe<Scalars['String']>;
  billingPhone?: InputMaybe<Scalars['String']>;
  billingPostalCode?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expireMonth?: InputMaybe<Scalars['Int']>;
  expireYear?: InputMaybe<Scalars['Int']>;
  fingerprint?: InputMaybe<Scalars['String']>;
  funding?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  last4?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerCardId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UserCreditCardsMaxFields = {
  __typename?: 'UserCreditCardsMaxFields';
  billingCity?: Maybe<Scalars['String']>;
  billingCountry?: Maybe<Scalars['String']>;
  billingEmail?: Maybe<Scalars['String']>;
  billingLine1?: Maybe<Scalars['String']>;
  billingLine2?: Maybe<Scalars['String']>;
  billingName?: Maybe<Scalars['String']>;
  billingPhone?: Maybe<Scalars['String']>;
  billingPostalCode?: Maybe<Scalars['String']>;
  billingState?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expireMonth?: Maybe<Scalars['Int']>;
  expireYear?: Maybe<Scalars['Int']>;
  fingerprint?: Maybe<Scalars['String']>;
  funding?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last4?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerCardId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_credit_cards" */
export type UserCreditCardsMaxOrderBy = {
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingLine1?: InputMaybe<OrderBy>;
  billingLine2?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPhone?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  brand?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
  fingerprint?: InputMaybe<OrderBy>;
  funding?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  last4?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerCardId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserCreditCardsMinFields = {
  __typename?: 'UserCreditCardsMinFields';
  billingCity?: Maybe<Scalars['String']>;
  billingCountry?: Maybe<Scalars['String']>;
  billingEmail?: Maybe<Scalars['String']>;
  billingLine1?: Maybe<Scalars['String']>;
  billingLine2?: Maybe<Scalars['String']>;
  billingName?: Maybe<Scalars['String']>;
  billingPhone?: Maybe<Scalars['String']>;
  billingPostalCode?: Maybe<Scalars['String']>;
  billingState?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expireMonth?: Maybe<Scalars['Int']>;
  expireYear?: Maybe<Scalars['Int']>;
  fingerprint?: Maybe<Scalars['String']>;
  funding?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last4?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerCardId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_credit_cards" */
export type UserCreditCardsMinOrderBy = {
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingLine1?: InputMaybe<OrderBy>;
  billingLine2?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPhone?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  brand?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
  fingerprint?: InputMaybe<OrderBy>;
  funding?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  last4?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerCardId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_credit_cards" */
export type UserCreditCardsMutationResponse = {
  __typename?: 'UserCreditCardsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCreditCards>;
};

/** input type for inserting object relation for remote table "user_credit_cards" */
export type UserCreditCardsObjRelInsertInput = {
  data: UserCreditCardsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserCreditCardsOnConflict>;
};

/** on_conflict condition type for table "user_credit_cards" */
export type UserCreditCardsOnConflict = {
  constraint: UserCreditCardsConstraint;
  updateColumns?: Array<UserCreditCardsUpdateColumn>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};

/** Ordering options when selecting data from "user_credit_cards". */
export type UserCreditCardsOrderBy = {
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingLine1?: InputMaybe<OrderBy>;
  billingLine2?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPhone?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  brand?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
  fingerprint?: InputMaybe<OrderBy>;
  funding?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  last4?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerCardId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_credit_cards */
export type UserCreditCardsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_credit_cards" */
export enum UserCreditCardsSelectColumn {
  /** column name */
  BillingCity = 'billingCity',
  /** column name */
  BillingCountry = 'billingCountry',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingLine1 = 'billingLine1',
  /** column name */
  BillingLine2 = 'billingLine2',
  /** column name */
  BillingName = 'billingName',
  /** column name */
  BillingPhone = 'billingPhone',
  /** column name */
  BillingPostalCode = 'billingPostalCode',
  /** column name */
  BillingState = 'billingState',
  /** column name */
  Brand = 'brand',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpireMonth = 'expireMonth',
  /** column name */
  ExpireYear = 'expireYear',
  /** column name */
  Fingerprint = 'fingerprint',
  /** column name */
  Funding = 'funding',
  /** column name */
  Id = 'id',
  /** column name */
  Last4 = 'last4',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderCardId = 'providerCardId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_credit_cards" */
export type UserCreditCardsSetInput = {
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingEmail?: InputMaybe<Scalars['String']>;
  billingLine1?: InputMaybe<Scalars['String']>;
  billingLine2?: InputMaybe<Scalars['String']>;
  billingName?: InputMaybe<Scalars['String']>;
  billingPhone?: InputMaybe<Scalars['String']>;
  billingPostalCode?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expireMonth?: InputMaybe<Scalars['Int']>;
  expireYear?: InputMaybe<Scalars['Int']>;
  fingerprint?: InputMaybe<Scalars['String']>;
  funding?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  last4?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerCardId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type UserCreditCardsStddevFields = {
  __typename?: 'UserCreditCardsStddevFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "user_credit_cards" */
export type UserCreditCardsStddevOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type UserCreditCardsStddevPopFields = {
  __typename?: 'UserCreditCardsStddevPopFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "user_credit_cards" */
export type UserCreditCardsStddevPopOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type UserCreditCardsStddevSampFields = {
  __typename?: 'UserCreditCardsStddevSampFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "user_credit_cards" */
export type UserCreditCardsStddevSampOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_credit_cards" */
export type UserCreditCardsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCreditCardsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCreditCardsStreamCursorValueInput = {
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingEmail?: InputMaybe<Scalars['String']>;
  billingLine1?: InputMaybe<Scalars['String']>;
  billingLine2?: InputMaybe<Scalars['String']>;
  billingName?: InputMaybe<Scalars['String']>;
  billingPhone?: InputMaybe<Scalars['String']>;
  billingPostalCode?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expireMonth?: InputMaybe<Scalars['Int']>;
  expireYear?: InputMaybe<Scalars['Int']>;
  fingerprint?: InputMaybe<Scalars['String']>;
  funding?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  last4?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerCardId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type UserCreditCardsSumFields = {
  __typename?: 'UserCreditCardsSumFields';
  expireMonth?: Maybe<Scalars['Int']>;
  expireYear?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "user_credit_cards" */
export type UserCreditCardsSumOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** update columns of table "user_credit_cards" */
export enum UserCreditCardsUpdateColumn {
  /** column name */
  BillingCity = 'billingCity',
  /** column name */
  BillingCountry = 'billingCountry',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingLine1 = 'billingLine1',
  /** column name */
  BillingLine2 = 'billingLine2',
  /** column name */
  BillingName = 'billingName',
  /** column name */
  BillingPhone = 'billingPhone',
  /** column name */
  BillingPostalCode = 'billingPostalCode',
  /** column name */
  BillingState = 'billingState',
  /** column name */
  Brand = 'brand',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpireMonth = 'expireMonth',
  /** column name */
  ExpireYear = 'expireYear',
  /** column name */
  Fingerprint = 'fingerprint',
  /** column name */
  Funding = 'funding',
  /** column name */
  Id = 'id',
  /** column name */
  Last4 = 'last4',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderCardId = 'providerCardId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UserCreditCardsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserCreditCardsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCreditCardsSetInput>;
  /** filter the rows which have to be updated */
  where: UserCreditCardsBoolExp;
};

/** aggregate varPop on columns */
export type UserCreditCardsVarPopFields = {
  __typename?: 'UserCreditCardsVarPopFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "user_credit_cards" */
export type UserCreditCardsVarPopOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type UserCreditCardsVarSampFields = {
  __typename?: 'UserCreditCardsVarSampFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "user_credit_cards" */
export type UserCreditCardsVarSampOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UserCreditCardsVarianceFields = {
  __typename?: 'UserCreditCardsVarianceFields';
  expireMonth?: Maybe<Scalars['Float']>;
  expireYear?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "user_credit_cards" */
export type UserCreditCardsVarianceOrderBy = {
  expireMonth?: InputMaybe<OrderBy>;
  expireYear?: InputMaybe<OrderBy>;
};

/** columns and relationships of "user_custom_courts" */
export type UserCustomCourts = {
  __typename?: 'UserCustomCourts';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fullAddress: Scalars['String'];
  id: Scalars['uuid'];
  /** An array relationship */
  lessons: Array<Lessons>;
  /** An aggregate relationship */
  lessonsAggregate: LessonsAggregate;
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};


/** columns and relationships of "user_custom_courts" */
export type UserCustomCourtsLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "user_custom_courts" */
export type UserCustomCourtsLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};

/** aggregated selection of "user_custom_courts" */
export type UserCustomCourtsAggregate = {
  __typename?: 'UserCustomCourtsAggregate';
  aggregate?: Maybe<UserCustomCourtsAggregateFields>;
  nodes: Array<UserCustomCourts>;
};

export type UserCustomCourtsAggregateBoolExp = {
  count?: InputMaybe<UserCustomCourtsAggregateBoolExpCount>;
};

/** aggregate fields of "user_custom_courts" */
export type UserCustomCourtsAggregateFields = {
  __typename?: 'UserCustomCourtsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserCustomCourtsMaxFields>;
  min?: Maybe<UserCustomCourtsMinFields>;
};


/** aggregate fields of "user_custom_courts" */
export type UserCustomCourtsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_custom_courts" */
export type UserCustomCourtsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCustomCourtsMaxOrderBy>;
  min?: InputMaybe<UserCustomCourtsMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_custom_courts" */
export type UserCustomCourtsArrRelInsertInput = {
  data: Array<UserCustomCourtsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};

/** Boolean expression to filter rows from the table "user_custom_courts". All fields are combined with a logical 'AND'. */
export type UserCustomCourtsBoolExp = {
  _and?: InputMaybe<Array<UserCustomCourtsBoolExp>>;
  _not?: InputMaybe<UserCustomCourtsBoolExp>;
  _or?: InputMaybe<Array<UserCustomCourtsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fullAddress?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lessons?: InputMaybe<LessonsBoolExp>;
  lessonsAggregate?: InputMaybe<LessonsAggregateBoolExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_custom_courts" */
export enum UserCustomCourtsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserCustomCourtsPkey = 'user_custom_courts_pkey'
}

/** input type for inserting data into table "user_custom_courts" */
export type UserCustomCourtsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullAddress?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessons?: InputMaybe<LessonsArrRelInsertInput>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UserCustomCourtsMaxFields = {
  __typename?: 'UserCustomCourtsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fullAddress?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_custom_courts" */
export type UserCustomCourtsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullAddress?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserCustomCourtsMinFields = {
  __typename?: 'UserCustomCourtsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fullAddress?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_custom_courts" */
export type UserCustomCourtsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullAddress?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_custom_courts" */
export type UserCustomCourtsMutationResponse = {
  __typename?: 'UserCustomCourtsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCustomCourts>;
};

/** input type for inserting object relation for remote table "user_custom_courts" */
export type UserCustomCourtsObjRelInsertInput = {
  data: UserCustomCourtsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};

/** on_conflict condition type for table "user_custom_courts" */
export type UserCustomCourtsOnConflict = {
  constraint: UserCustomCourtsConstraint;
  updateColumns?: Array<UserCustomCourtsUpdateColumn>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};

/** Ordering options when selecting data from "user_custom_courts". */
export type UserCustomCourtsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullAddress?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lessonsAggregate?: InputMaybe<LessonsAggregateOrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_custom_courts */
export type UserCustomCourtsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_custom_courts" */
export enum UserCustomCourtsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FullAddress = 'fullAddress',
  /** column name */
  Id = 'id',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_custom_courts" */
export type UserCustomCourtsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullAddress?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_custom_courts" */
export type UserCustomCourtsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserCustomCourtsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCustomCourtsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullAddress?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_custom_courts" */
export enum UserCustomCourtsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FullAddress = 'fullAddress',
  /** column name */
  Id = 'id',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UserCustomCourtsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCustomCourtsSetInput>;
  /** filter the rows which have to be updated */
  where: UserCustomCourtsBoolExp;
};

/** columns and relationships of "user_follows" */
export type UserFollows = {
  __typename?: 'UserFollows';
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  followedProfile?: Maybe<UserProfiles>;
  followedUserId: Scalars['uuid'];
  /** An object relationship */
  followerProfile?: Maybe<UserProfiles>;
  followerUserId: Scalars['uuid'];
  id: Scalars['uuid'];
  status: FollowStatusesEnum;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "user_follows" */
export type UserFollowsAggregate = {
  __typename?: 'UserFollowsAggregate';
  aggregate?: Maybe<UserFollowsAggregateFields>;
  nodes: Array<UserFollows>;
};

export type UserFollowsAggregateBoolExp = {
  count?: InputMaybe<UserFollowsAggregateBoolExpCount>;
};

/** aggregate fields of "user_follows" */
export type UserFollowsAggregateFields = {
  __typename?: 'UserFollowsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserFollowsMaxFields>;
  min?: Maybe<UserFollowsMinFields>;
};


/** aggregate fields of "user_follows" */
export type UserFollowsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserFollowsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_follows" */
export type UserFollowsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserFollowsMaxOrderBy>;
  min?: InputMaybe<UserFollowsMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_follows" */
export type UserFollowsArrRelInsertInput = {
  data: Array<UserFollowsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserFollowsOnConflict>;
};

/** Boolean expression to filter rows from the table "user_follows". All fields are combined with a logical 'AND'. */
export type UserFollowsBoolExp = {
  _and?: InputMaybe<Array<UserFollowsBoolExp>>;
  _not?: InputMaybe<UserFollowsBoolExp>;
  _or?: InputMaybe<Array<UserFollowsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  followedProfile?: InputMaybe<UserProfilesBoolExp>;
  followedUserId?: InputMaybe<UuidComparisonExp>;
  followerProfile?: InputMaybe<UserProfilesBoolExp>;
  followerUserId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<FollowStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "user_follows" */
export enum UserFollowsConstraint {
  /** unique or primary key constraint on columns "followed_user_id", "follower_user_id" */
  UserFollowsFollowedUserIdFollowerUserIdKey = 'user_follows_followed_user_id_follower_user_id_key',
  /** unique or primary key constraint on columns "id" */
  UserFollowsPkey = 'user_follows_pkey'
}

/** input type for inserting data into table "user_follows" */
export type UserFollowsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  followedProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  followedUserId?: InputMaybe<Scalars['uuid']>;
  followerProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  followerUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type UserFollowsMaxFields = {
  __typename?: 'UserFollowsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  followedUserId?: Maybe<Scalars['uuid']>;
  followerUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "user_follows" */
export type UserFollowsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  followedUserId?: InputMaybe<OrderBy>;
  followerUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserFollowsMinFields = {
  __typename?: 'UserFollowsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  followedUserId?: Maybe<Scalars['uuid']>;
  followerUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "user_follows" */
export type UserFollowsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  followedUserId?: InputMaybe<OrderBy>;
  followerUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_follows" */
export type UserFollowsMutationResponse = {
  __typename?: 'UserFollowsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserFollows>;
};

/** on_conflict condition type for table "user_follows" */
export type UserFollowsOnConflict = {
  constraint: UserFollowsConstraint;
  updateColumns?: Array<UserFollowsUpdateColumn>;
  where?: InputMaybe<UserFollowsBoolExp>;
};

/** Ordering options when selecting data from "user_follows". */
export type UserFollowsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  followedProfile?: InputMaybe<UserProfilesOrderBy>;
  followedUserId?: InputMaybe<OrderBy>;
  followerProfile?: InputMaybe<UserProfilesOrderBy>;
  followerUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_follows */
export type UserFollowsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_follows" */
export enum UserFollowsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FollowedUserId = 'followedUserId',
  /** column name */
  FollowerUserId = 'followerUserId',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "user_follows" */
export type UserFollowsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  followedUserId?: InputMaybe<Scalars['uuid']>;
  followerUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "user_follows" */
export type UserFollowsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserFollowsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserFollowsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  followedUserId?: InputMaybe<Scalars['uuid']>;
  followerUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "user_follows" */
export enum UserFollowsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FollowedUserId = 'followedUserId',
  /** column name */
  FollowerUserId = 'followerUserId',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type UserFollowsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserFollowsSetInput>;
  /** filter the rows which have to be updated */
  where: UserFollowsBoolExp;
};

/** columns and relationships of "user_image_log" */
export type UserImageLog = {
  __typename?: 'UserImageLog';
  createdAt: Scalars['timestamptz'];
  fileName: Scalars['String'];
  id: Scalars['uuid'];
  path: Scalars['String'];
  provider: Scalars['String'];
  providerId: Scalars['String'];
  providerUrl: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  userId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "user_image_log" */
export type UserImageLogAggregate = {
  __typename?: 'UserImageLogAggregate';
  aggregate?: Maybe<UserImageLogAggregateFields>;
  nodes: Array<UserImageLog>;
};

/** aggregate fields of "user_image_log" */
export type UserImageLogAggregateFields = {
  __typename?: 'UserImageLogAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserImageLogMaxFields>;
  min?: Maybe<UserImageLogMinFields>;
};


/** aggregate fields of "user_image_log" */
export type UserImageLogAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserImageLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_image_log". All fields are combined with a logical 'AND'. */
export type UserImageLogBoolExp = {
  _and?: InputMaybe<Array<UserImageLogBoolExp>>;
  _not?: InputMaybe<UserImageLogBoolExp>;
  _or?: InputMaybe<Array<UserImageLogBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  fileName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  path?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerId?: InputMaybe<StringComparisonExp>;
  providerUrl?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_image_log" */
export enum UserImageLogConstraint {
  /** unique or primary key constraint on columns "id" */
  UserImageLogPkey = 'user_image_log_pkey'
}

/** input type for inserting data into table "user_image_log" */
export type UserImageLogInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UserImageLogMaxFields = {
  __typename?: 'UserImageLogMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  fileName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  path?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerId?: Maybe<Scalars['String']>;
  providerUrl?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type UserImageLogMinFields = {
  __typename?: 'UserImageLogMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  fileName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  path?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerId?: Maybe<Scalars['String']>;
  providerUrl?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "user_image_log" */
export type UserImageLogMutationResponse = {
  __typename?: 'UserImageLogMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserImageLog>;
};

/** on_conflict condition type for table "user_image_log" */
export type UserImageLogOnConflict = {
  constraint: UserImageLogConstraint;
  updateColumns?: Array<UserImageLogUpdateColumn>;
  where?: InputMaybe<UserImageLogBoolExp>;
};

/** Ordering options when selecting data from "user_image_log". */
export type UserImageLogOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_image_log */
export type UserImageLogPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_image_log" */
export enum UserImageLogSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  Id = 'id',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_image_log" */
export type UserImageLogSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_image_log" */
export type UserImageLogStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserImageLogStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserImageLogStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_image_log" */
export enum UserImageLogUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  Id = 'id',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UserImageLogUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserImageLogSetInput>;
  /** filter the rows which have to be updated */
  where: UserImageLogBoolExp;
};

/** columns and relationships of "user_notification_details" */
export type UserNotificationDetails = {
  __typename?: 'UserNotificationDetails';
  actionType: NotificationActionTypesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  primaryEntity: UserNotificationEntities;
  updatedAt: Scalars['timestamptz'];
  userNotificationEntityId: Scalars['uuid'];
  /** An array relationship */
  userNotifications: Array<UserNotifications>;
  /** An aggregate relationship */
  userNotificationsAggregate: UserNotificationsAggregate;
};


/** columns and relationships of "user_notification_details" */
export type UserNotificationDetailsUserNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


/** columns and relationships of "user_notification_details" */
export type UserNotificationDetailsUserNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};

/** aggregated selection of "user_notification_details" */
export type UserNotificationDetailsAggregate = {
  __typename?: 'UserNotificationDetailsAggregate';
  aggregate?: Maybe<UserNotificationDetailsAggregateFields>;
  nodes: Array<UserNotificationDetails>;
};

/** aggregate fields of "user_notification_details" */
export type UserNotificationDetailsAggregateFields = {
  __typename?: 'UserNotificationDetailsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserNotificationDetailsMaxFields>;
  min?: Maybe<UserNotificationDetailsMinFields>;
};


/** aggregate fields of "user_notification_details" */
export type UserNotificationDetailsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_notification_details". All fields are combined with a logical 'AND'. */
export type UserNotificationDetailsBoolExp = {
  _and?: InputMaybe<Array<UserNotificationDetailsBoolExp>>;
  _not?: InputMaybe<UserNotificationDetailsBoolExp>;
  _or?: InputMaybe<Array<UserNotificationDetailsBoolExp>>;
  actionType?: InputMaybe<NotificationActionTypesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  primaryEntity?: InputMaybe<UserNotificationEntitiesBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userNotificationEntityId?: InputMaybe<UuidComparisonExp>;
  userNotifications?: InputMaybe<UserNotificationsBoolExp>;
  userNotificationsAggregate?: InputMaybe<UserNotificationsAggregateBoolExp>;
};

/** unique or primary key constraints on table "user_notification_details" */
export enum UserNotificationDetailsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserNotificationDetailsPkey = 'user_notification_details_pkey',
  /** unique or primary key constraint on columns "user_notification_entity_id" */
  UserNotificationDetailsUserNotificationEntityIdKey = 'user_notification_details_user_notification_entity_id_key'
}

/** input type for inserting data into table "user_notification_details" */
export type UserNotificationDetailsInsertInput = {
  actionType?: InputMaybe<NotificationActionTypesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  primaryEntity?: InputMaybe<UserNotificationEntitiesObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userNotificationEntityId?: InputMaybe<Scalars['uuid']>;
  userNotifications?: InputMaybe<UserNotificationsArrRelInsertInput>;
};

/** aggregate max on columns */
export type UserNotificationDetailsMaxFields = {
  __typename?: 'UserNotificationDetailsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userNotificationEntityId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type UserNotificationDetailsMinFields = {
  __typename?: 'UserNotificationDetailsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userNotificationEntityId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "user_notification_details" */
export type UserNotificationDetailsMutationResponse = {
  __typename?: 'UserNotificationDetailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserNotificationDetails>;
};

/** input type for inserting object relation for remote table "user_notification_details" */
export type UserNotificationDetailsObjRelInsertInput = {
  data: UserNotificationDetailsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserNotificationDetailsOnConflict>;
};

/** on_conflict condition type for table "user_notification_details" */
export type UserNotificationDetailsOnConflict = {
  constraint: UserNotificationDetailsConstraint;
  updateColumns?: Array<UserNotificationDetailsUpdateColumn>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};

/** Ordering options when selecting data from "user_notification_details". */
export type UserNotificationDetailsOrderBy = {
  actionType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  primaryEntity?: InputMaybe<UserNotificationEntitiesOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userNotificationEntityId?: InputMaybe<OrderBy>;
  userNotificationsAggregate?: InputMaybe<UserNotificationsAggregateOrderBy>;
};

/** primary key columns input for table: user_notification_details */
export type UserNotificationDetailsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_notification_details" */
export enum UserNotificationDetailsSelectColumn {
  /** column name */
  ActionType = 'actionType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserNotificationEntityId = 'userNotificationEntityId'
}

/** input type for updating data in table "user_notification_details" */
export type UserNotificationDetailsSetInput = {
  actionType?: InputMaybe<NotificationActionTypesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userNotificationEntityId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_notification_details" */
export type UserNotificationDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserNotificationDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserNotificationDetailsStreamCursorValueInput = {
  actionType?: InputMaybe<NotificationActionTypesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userNotificationEntityId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_notification_details" */
export enum UserNotificationDetailsUpdateColumn {
  /** column name */
  ActionType = 'actionType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserNotificationEntityId = 'userNotificationEntityId'
}

export type UserNotificationDetailsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserNotificationDetailsSetInput>;
  /** filter the rows which have to be updated */
  where: UserNotificationDetailsBoolExp;
};

/** columns and relationships of "user_notification_entities" */
export type UserNotificationEntities = {
  __typename?: 'UserNotificationEntities';
  /** An object relationship */
  actingUser?: Maybe<Users>;
  actingUserId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  actingUserProfile?: Maybe<UserProfiles>;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  group?: Maybe<Groups>;
  groupId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  groupThread?: Maybe<GroupThreads>;
  /** An object relationship */
  groupThreadComment?: Maybe<GroupThreadComments>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  /** An object relationship */
  lesson?: Maybe<Lessons>;
  lessonId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  notificationDetails?: Maybe<UserNotificationDetails>;
  /** An object relationship */
  playSession?: Maybe<PlaySessions>;
  /** An object relationship */
  playSessionComment?: Maybe<PlaySessionComments>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "user_notification_entities" */
export type UserNotificationEntitiesAggregate = {
  __typename?: 'UserNotificationEntitiesAggregate';
  aggregate?: Maybe<UserNotificationEntitiesAggregateFields>;
  nodes: Array<UserNotificationEntities>;
};

/** aggregate fields of "user_notification_entities" */
export type UserNotificationEntitiesAggregateFields = {
  __typename?: 'UserNotificationEntitiesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserNotificationEntitiesMaxFields>;
  min?: Maybe<UserNotificationEntitiesMinFields>;
};


/** aggregate fields of "user_notification_entities" */
export type UserNotificationEntitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_notification_entities". All fields are combined with a logical 'AND'. */
export type UserNotificationEntitiesBoolExp = {
  _and?: InputMaybe<Array<UserNotificationEntitiesBoolExp>>;
  _not?: InputMaybe<UserNotificationEntitiesBoolExp>;
  _or?: InputMaybe<Array<UserNotificationEntitiesBoolExp>>;
  actingUser?: InputMaybe<UsersBoolExp>;
  actingUserId?: InputMaybe<UuidComparisonExp>;
  actingUserProfile?: InputMaybe<UserProfilesBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  group?: InputMaybe<GroupsBoolExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupThread?: InputMaybe<GroupThreadsBoolExp>;
  groupThreadComment?: InputMaybe<GroupThreadCommentsBoolExp>;
  groupThreadCommentId?: InputMaybe<UuidComparisonExp>;
  groupThreadId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lesson?: InputMaybe<LessonsBoolExp>;
  lessonId?: InputMaybe<UuidComparisonExp>;
  notificationDetails?: InputMaybe<UserNotificationDetailsBoolExp>;
  playSession?: InputMaybe<PlaySessionsBoolExp>;
  playSessionComment?: InputMaybe<PlaySessionCommentsBoolExp>;
  playSessionCommentId?: InputMaybe<UuidComparisonExp>;
  playSessionId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "user_notification_entities" */
export enum UserNotificationEntitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserNotificationEntitiesPkey = 'user_notification_entities_pkey'
}

/** input type for inserting data into table "user_notification_entities" */
export type UserNotificationEntitiesInsertInput = {
  actingUser?: InputMaybe<UsersObjRelInsertInput>;
  actingUserId?: InputMaybe<Scalars['uuid']>;
  actingUserProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  group?: InputMaybe<GroupsObjRelInsertInput>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupThread?: InputMaybe<GroupThreadsObjRelInsertInput>;
  groupThreadComment?: InputMaybe<GroupThreadCommentsObjRelInsertInput>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  lesson?: InputMaybe<LessonsObjRelInsertInput>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  notificationDetails?: InputMaybe<UserNotificationDetailsObjRelInsertInput>;
  playSession?: InputMaybe<PlaySessionsObjRelInsertInput>;
  playSessionComment?: InputMaybe<PlaySessionCommentsObjRelInsertInput>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type UserNotificationEntitiesMaxFields = {
  __typename?: 'UserNotificationEntitiesMaxFields';
  actingUserId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type UserNotificationEntitiesMinFields = {
  __typename?: 'UserNotificationEntitiesMinFields';
  actingUserId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  groupId?: Maybe<Scalars['uuid']>;
  groupThreadCommentId?: Maybe<Scalars['uuid']>;
  groupThreadId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  lessonId?: Maybe<Scalars['uuid']>;
  playSessionCommentId?: Maybe<Scalars['uuid']>;
  playSessionId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "user_notification_entities" */
export type UserNotificationEntitiesMutationResponse = {
  __typename?: 'UserNotificationEntitiesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserNotificationEntities>;
};

/** input type for inserting object relation for remote table "user_notification_entities" */
export type UserNotificationEntitiesObjRelInsertInput = {
  data: UserNotificationEntitiesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserNotificationEntitiesOnConflict>;
};

/** on_conflict condition type for table "user_notification_entities" */
export type UserNotificationEntitiesOnConflict = {
  constraint: UserNotificationEntitiesConstraint;
  updateColumns?: Array<UserNotificationEntitiesUpdateColumn>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};

/** Ordering options when selecting data from "user_notification_entities". */
export type UserNotificationEntitiesOrderBy = {
  actingUser?: InputMaybe<UsersOrderBy>;
  actingUserId?: InputMaybe<OrderBy>;
  actingUserProfile?: InputMaybe<UserProfilesOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  group?: InputMaybe<GroupsOrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupThread?: InputMaybe<GroupThreadsOrderBy>;
  groupThreadComment?: InputMaybe<GroupThreadCommentsOrderBy>;
  groupThreadCommentId?: InputMaybe<OrderBy>;
  groupThreadId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lesson?: InputMaybe<LessonsOrderBy>;
  lessonId?: InputMaybe<OrderBy>;
  notificationDetails?: InputMaybe<UserNotificationDetailsOrderBy>;
  playSession?: InputMaybe<PlaySessionsOrderBy>;
  playSessionComment?: InputMaybe<PlaySessionCommentsOrderBy>;
  playSessionCommentId?: InputMaybe<OrderBy>;
  playSessionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_notification_entities */
export type UserNotificationEntitiesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_notification_entities" */
export enum UserNotificationEntitiesSelectColumn {
  /** column name */
  ActingUserId = 'actingUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  GroupThreadId = 'groupThreadId',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  PlaySessionCommentId = 'playSessionCommentId',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "user_notification_entities" */
export type UserNotificationEntitiesSetInput = {
  actingUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "user_notification_entities" */
export type UserNotificationEntitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserNotificationEntitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserNotificationEntitiesStreamCursorValueInput = {
  actingUserId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  groupId?: InputMaybe<Scalars['uuid']>;
  groupThreadCommentId?: InputMaybe<Scalars['uuid']>;
  groupThreadId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  lessonId?: InputMaybe<Scalars['uuid']>;
  playSessionCommentId?: InputMaybe<Scalars['uuid']>;
  playSessionId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "user_notification_entities" */
export enum UserNotificationEntitiesUpdateColumn {
  /** column name */
  ActingUserId = 'actingUserId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupThreadCommentId = 'groupThreadCommentId',
  /** column name */
  GroupThreadId = 'groupThreadId',
  /** column name */
  Id = 'id',
  /** column name */
  LessonId = 'lessonId',
  /** column name */
  PlaySessionCommentId = 'playSessionCommentId',
  /** column name */
  PlaySessionId = 'playSessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type UserNotificationEntitiesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserNotificationEntitiesSetInput>;
  /** filter the rows which have to be updated */
  where: UserNotificationEntitiesBoolExp;
};

/** columns and relationships of "user_notifications" */
export type UserNotifications = {
  __typename?: 'UserNotifications';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  notificationDetails: UserNotificationDetails;
  readAt?: Maybe<Scalars['timestamptz']>;
  status: NotificationStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  userNotificationDetailId: Scalars['uuid'];
};

/** aggregated selection of "user_notifications" */
export type UserNotificationsAggregate = {
  __typename?: 'UserNotificationsAggregate';
  aggregate?: Maybe<UserNotificationsAggregateFields>;
  nodes: Array<UserNotifications>;
};

export type UserNotificationsAggregateBoolExp = {
  count?: InputMaybe<UserNotificationsAggregateBoolExpCount>;
};

/** aggregate fields of "user_notifications" */
export type UserNotificationsAggregateFields = {
  __typename?: 'UserNotificationsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserNotificationsMaxFields>;
  min?: Maybe<UserNotificationsMinFields>;
};


/** aggregate fields of "user_notifications" */
export type UserNotificationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_notifications" */
export type UserNotificationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserNotificationsMaxOrderBy>;
  min?: InputMaybe<UserNotificationsMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_notifications" */
export type UserNotificationsArrRelInsertInput = {
  data: Array<UserNotificationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserNotificationsOnConflict>;
};

/** Boolean expression to filter rows from the table "user_notifications". All fields are combined with a logical 'AND'. */
export type UserNotificationsBoolExp = {
  _and?: InputMaybe<Array<UserNotificationsBoolExp>>;
  _not?: InputMaybe<UserNotificationsBoolExp>;
  _or?: InputMaybe<Array<UserNotificationsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  notificationDetails?: InputMaybe<UserNotificationDetailsBoolExp>;
  readAt?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<NotificationStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userNotificationDetailId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_notifications" */
export enum UserNotificationsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserNotificationsPkey = 'user_notifications_pkey'
}

/** input type for inserting data into table "user_notifications" */
export type UserNotificationsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  notificationDetails?: InputMaybe<UserNotificationDetailsObjRelInsertInput>;
  readAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<NotificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userNotificationDetailId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UserNotificationsMaxFields = {
  __typename?: 'UserNotificationsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  readAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  userNotificationDetailId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_notifications" */
export type UserNotificationsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  readAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userNotificationDetailId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserNotificationsMinFields = {
  __typename?: 'UserNotificationsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  readAt?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  userNotificationDetailId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_notifications" */
export type UserNotificationsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  readAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userNotificationDetailId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_notifications" */
export type UserNotificationsMutationResponse = {
  __typename?: 'UserNotificationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserNotifications>;
};

/** on_conflict condition type for table "user_notifications" */
export type UserNotificationsOnConflict = {
  constraint: UserNotificationsConstraint;
  updateColumns?: Array<UserNotificationsUpdateColumn>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};

/** Ordering options when selecting data from "user_notifications". */
export type UserNotificationsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notificationDetails?: InputMaybe<UserNotificationDetailsOrderBy>;
  readAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userNotificationDetailId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_notifications */
export type UserNotificationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_notifications" */
export enum UserNotificationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  ReadAt = 'readAt',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserNotificationDetailId = 'userNotificationDetailId'
}

/** input type for updating data in table "user_notifications" */
export type UserNotificationsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  readAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<NotificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  userNotificationDetailId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_notifications" */
export type UserNotificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserNotificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserNotificationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  readAt?: InputMaybe<Scalars['timestamptz']>;
  status?: InputMaybe<NotificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  userNotificationDetailId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_notifications" */
export enum UserNotificationsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  ReadAt = 'readAt',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserNotificationDetailId = 'userNotificationDetailId'
}

export type UserNotificationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserNotificationsSetInput>;
  /** filter the rows which have to be updated */
  where: UserNotificationsBoolExp;
};

/** columns and relationships of "user_profiles" */
export type UserProfiles = {
  __typename?: 'UserProfiles';
  aboutMe?: Maybe<Scalars['String']>;
  aboutMeVideoUrl?: Maybe<Scalars['String']>;
  /** An object relationship */
  activeCity?: Maybe<Cities>;
  activeCityId?: Maybe<Scalars['uuid']>;
  cityName?: Maybe<Scalars['String']>;
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  coachLessons: Array<Lessons>;
  /** An aggregate relationship */
  coachLessonsAggregate: LessonsAggregate;
  /** An array relationship */
  coachQualifications: Array<UsersCoachQualifications>;
  /** An aggregate relationship */
  coachQualificationsAggregate: UsersCoachQualificationsAggregate;
  /** An array relationship */
  coachServices: Array<UserCoachServices>;
  /** An aggregate relationship */
  coachServicesAggregate: UserCoachServicesAggregate;
  coachStatus?: Maybe<Scalars['String']>;
  /** An object relationship */
  country?: Maybe<Countries>;
  countryId?: Maybe<Scalars['String']>;
  /** An object relationship */
  countrySubdivision?: Maybe<CountrySubdivisions>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  defaultSport?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventOrganizerAccountType?: Maybe<Scalars['String']>;
  /** An array relationship */
  followers: Array<UserFollows>;
  /** An aggregate relationship */
  followersAggregate: UserFollowsAggregate;
  /** An array relationship */
  following: Array<UserFollows>;
  /** An aggregate relationship */
  followingAggregate: UserFollowsAggregate;
  fullName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  genderPreference?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  normalizedTennisRatingScale?: Maybe<TennisRatingScales>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  pickleballSkillLevel?: Maybe<SkillLevels>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  profileImageFileName?: Maybe<Scalars['String']>;
  profileImagePath?: Maybe<Scalars['String']>;
  profileImageProvider?: Maybe<Scalars['String']>;
  profileImageProviderUrl?: Maybe<Scalars['String']>;
  tennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  tennisSkillLevel?: Maybe<SkillLevels>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachQualificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesCoachServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowersArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowingArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "user_profiles" */
export type UserProfilesFollowingAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};

/** aggregated selection of "user_profiles" */
export type UserProfilesAggregate = {
  __typename?: 'UserProfilesAggregate';
  aggregate?: Maybe<UserProfilesAggregateFields>;
  nodes: Array<UserProfiles>;
};

/** aggregate fields of "user_profiles" */
export type UserProfilesAggregateFields = {
  __typename?: 'UserProfilesAggregateFields';
  avg?: Maybe<UserProfilesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<UserProfilesMaxFields>;
  min?: Maybe<UserProfilesMinFields>;
  stddev?: Maybe<UserProfilesStddevFields>;
  stddevPop?: Maybe<UserProfilesStddevPopFields>;
  stddevSamp?: Maybe<UserProfilesStddevSampFields>;
  sum?: Maybe<UserProfilesSumFields>;
  varPop?: Maybe<UserProfilesVarPopFields>;
  varSamp?: Maybe<UserProfilesVarSampFields>;
  variance?: Maybe<UserProfilesVarianceFields>;
};


/** aggregate fields of "user_profiles" */
export type UserProfilesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserProfilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type UserProfilesAvgFields = {
  __typename?: 'UserProfilesAvgFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_profiles". All fields are combined with a logical 'AND'. */
export type UserProfilesBoolExp = {
  _and?: InputMaybe<Array<UserProfilesBoolExp>>;
  _not?: InputMaybe<UserProfilesBoolExp>;
  _or?: InputMaybe<Array<UserProfilesBoolExp>>;
  aboutMe?: InputMaybe<StringComparisonExp>;
  aboutMeVideoUrl?: InputMaybe<StringComparisonExp>;
  activeCity?: InputMaybe<CitiesBoolExp>;
  activeCityId?: InputMaybe<UuidComparisonExp>;
  cityName?: InputMaybe<StringComparisonExp>;
  coachExperienceSetAt?: InputMaybe<TimestamptzComparisonExp>;
  coachExperienceYears?: InputMaybe<NumericComparisonExp>;
  coachLessons?: InputMaybe<LessonsBoolExp>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateBoolExp>;
  coachQualifications?: InputMaybe<UsersCoachQualificationsBoolExp>;
  coachQualificationsAggregate?: InputMaybe<UsersCoachQualificationsAggregateBoolExp>;
  coachServices?: InputMaybe<UserCoachServicesBoolExp>;
  coachServicesAggregate?: InputMaybe<UserCoachServicesAggregateBoolExp>;
  coachStatus?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<CountriesBoolExp>;
  countryId?: InputMaybe<StringComparisonExp>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsBoolExp>;
  countrySubdivisionId?: InputMaybe<UuidComparisonExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  defaultSport?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  duprId?: InputMaybe<StringComparisonExp>;
  eventOrganizerAccountType?: InputMaybe<StringComparisonExp>;
  followers?: InputMaybe<UserFollowsBoolExp>;
  followersAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  following?: InputMaybe<UserFollowsBoolExp>;
  followingAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  fullName?: InputMaybe<StringComparisonExp>;
  gender?: InputMaybe<StringComparisonExp>;
  genderPreference?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  normalizedTennisRating?: InputMaybe<NumericComparisonExp>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  normalizedTennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  pickleballSkillLevelId?: InputMaybe<StringComparisonExp>;
  preferredName?: InputMaybe<StringComparisonExp>;
  profileImageFileName?: InputMaybe<StringComparisonExp>;
  profileImagePath?: InputMaybe<StringComparisonExp>;
  profileImageProvider?: InputMaybe<StringComparisonExp>;
  profileImageProviderUrl?: InputMaybe<StringComparisonExp>;
  tennisRating?: InputMaybe<NumericComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  tennisSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  tennisSkillLevelId?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "user_profiles" */
export type UserProfilesIncInput = {
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "user_profiles" */
export type UserProfilesInsertInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCity?: InputMaybe<CitiesObjRelInsertInput>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachLessons?: InputMaybe<LessonsArrRelInsertInput>;
  coachQualifications?: InputMaybe<UsersCoachQualificationsArrRelInsertInput>;
  coachServices?: InputMaybe<UserCoachServicesArrRelInsertInput>;
  coachStatus?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<CountriesObjRelInsertInput>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsObjRelInsertInput>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultSport?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<Scalars['String']>;
  followers?: InputMaybe<UserFollowsArrRelInsertInput>;
  following?: InputMaybe<UserFollowsArrRelInsertInput>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  genderPreference?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesObjRelInsertInput>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsObjRelInsertInput>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesObjRelInsertInput>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevel?: InputMaybe<SkillLevelsObjRelInsertInput>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type UserProfilesMaxFields = {
  __typename?: 'UserProfilesMaxFields';
  aboutMe?: Maybe<Scalars['String']>;
  aboutMeVideoUrl?: Maybe<Scalars['String']>;
  activeCityId?: Maybe<Scalars['uuid']>;
  cityName?: Maybe<Scalars['String']>;
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  coachStatus?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  defaultSport?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventOrganizerAccountType?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  genderPreference?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  profileImageFileName?: Maybe<Scalars['String']>;
  profileImagePath?: Maybe<Scalars['String']>;
  profileImageProvider?: Maybe<Scalars['String']>;
  profileImageProviderUrl?: Maybe<Scalars['String']>;
  tennisRating?: Maybe<Scalars['numeric']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type UserProfilesMinFields = {
  __typename?: 'UserProfilesMinFields';
  aboutMe?: Maybe<Scalars['String']>;
  aboutMeVideoUrl?: Maybe<Scalars['String']>;
  activeCityId?: Maybe<Scalars['uuid']>;
  cityName?: Maybe<Scalars['String']>;
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  coachStatus?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  defaultSport?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  eventOrganizerAccountType?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  genderPreference?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  profileImageFileName?: Maybe<Scalars['String']>;
  profileImagePath?: Maybe<Scalars['String']>;
  profileImageProvider?: Maybe<Scalars['String']>;
  profileImageProviderUrl?: Maybe<Scalars['String']>;
  tennisRating?: Maybe<Scalars['numeric']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "user_profiles" */
export type UserProfilesMutationResponse = {
  __typename?: 'UserProfilesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserProfiles>;
};

/** input type for inserting object relation for remote table "user_profiles" */
export type UserProfilesObjRelInsertInput = {
  data: UserProfilesInsertInput;
};

/** Ordering options when selecting data from "user_profiles". */
export type UserProfilesOrderBy = {
  aboutMe?: InputMaybe<OrderBy>;
  aboutMeVideoUrl?: InputMaybe<OrderBy>;
  activeCity?: InputMaybe<CitiesOrderBy>;
  activeCityId?: InputMaybe<OrderBy>;
  cityName?: InputMaybe<OrderBy>;
  coachExperienceSetAt?: InputMaybe<OrderBy>;
  coachExperienceYears?: InputMaybe<OrderBy>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateOrderBy>;
  coachQualificationsAggregate?: InputMaybe<UsersCoachQualificationsAggregateOrderBy>;
  coachServicesAggregate?: InputMaybe<UserCoachServicesAggregateOrderBy>;
  coachStatus?: InputMaybe<OrderBy>;
  country?: InputMaybe<CountriesOrderBy>;
  countryId?: InputMaybe<OrderBy>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsOrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  defaultSport?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  duprId?: InputMaybe<OrderBy>;
  eventOrganizerAccountType?: InputMaybe<OrderBy>;
  followersAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  followingAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  fullName?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  genderPreference?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  normalizedTennisRating?: InputMaybe<OrderBy>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  normalizedTennisRatingScaleId?: InputMaybe<OrderBy>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  pickleballSkillLevelId?: InputMaybe<OrderBy>;
  preferredName?: InputMaybe<OrderBy>;
  profileImageFileName?: InputMaybe<OrderBy>;
  profileImagePath?: InputMaybe<OrderBy>;
  profileImageProvider?: InputMaybe<OrderBy>;
  profileImageProviderUrl?: InputMaybe<OrderBy>;
  tennisRating?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  tennisSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  tennisSkillLevelId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** select columns of table "user_profiles" */
export enum UserProfilesSelectColumn {
  /** column name */
  AboutMe = 'aboutMe',
  /** column name */
  AboutMeVideoUrl = 'aboutMeVideoUrl',
  /** column name */
  ActiveCityId = 'activeCityId',
  /** column name */
  CityName = 'cityName',
  /** column name */
  CoachExperienceSetAt = 'coachExperienceSetAt',
  /** column name */
  CoachExperienceYears = 'coachExperienceYears',
  /** column name */
  CoachStatus = 'coachStatus',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DefaultSport = 'defaultSport',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Gender = 'gender',
  /** column name */
  GenderPreference = 'genderPreference',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedTennisRating = 'normalizedTennisRating',
  /** column name */
  NormalizedTennisRatingScaleId = 'normalizedTennisRatingScaleId',
  /** column name */
  PickleballSkillLevelId = 'pickleballSkillLevelId',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  ProfileImageFileName = 'profileImageFileName',
  /** column name */
  ProfileImagePath = 'profileImagePath',
  /** column name */
  ProfileImageProvider = 'profileImageProvider',
  /** column name */
  ProfileImageProviderUrl = 'profileImageProviderUrl',
  /** column name */
  TennisRating = 'tennisRating',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TennisSkillLevelId = 'tennisSkillLevelId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username'
}

/** input type for updating data in table "user_profiles" */
export type UserProfilesSetInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<Scalars['String']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultSport?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  genderPreference?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type UserProfilesStddevFields = {
  __typename?: 'UserProfilesStddevFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type UserProfilesStddevPopFields = {
  __typename?: 'UserProfilesStddevPopFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type UserProfilesStddevSampFields = {
  __typename?: 'UserProfilesStddevSampFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_profiles" */
export type UserProfilesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserProfilesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserProfilesStreamCursorValueInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<Scalars['String']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultSport?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  genderPreference?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type UserProfilesSumFields = {
  __typename?: 'UserProfilesSumFields';
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  tennisRating?: Maybe<Scalars['numeric']>;
};

export type UserProfilesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserProfilesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserProfilesSetInput>;
  /** filter the rows which have to be updated */
  where: UserProfilesBoolExp;
};

/** aggregate varPop on columns */
export type UserProfilesVarPopFields = {
  __typename?: 'UserProfilesVarPopFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type UserProfilesVarSampFields = {
  __typename?: 'UserProfilesVarSampFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type UserProfilesVarianceFields = {
  __typename?: 'UserProfilesVarianceFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "user_registration_details" */
export type UserRegistrationDetails = {
  __typename?: 'UserRegistrationDetails';
  city: Scalars['String'];
  country: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fullDetails?: Maybe<Scalars['jsonb']>;
  id: Scalars['uuid'];
  ip: Scalars['String'];
  platform: Scalars['String'];
  region: Scalars['String'];
  timezone: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']>;
  zip: Scalars['String'];
};


/** columns and relationships of "user_registration_details" */
export type UserRegistrationDetailsFullDetailsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "user_registration_details" */
export type UserRegistrationDetailsAggregate = {
  __typename?: 'UserRegistrationDetailsAggregate';
  aggregate?: Maybe<UserRegistrationDetailsAggregateFields>;
  nodes: Array<UserRegistrationDetails>;
};

/** aggregate fields of "user_registration_details" */
export type UserRegistrationDetailsAggregateFields = {
  __typename?: 'UserRegistrationDetailsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserRegistrationDetailsMaxFields>;
  min?: Maybe<UserRegistrationDetailsMinFields>;
};


/** aggregate fields of "user_registration_details" */
export type UserRegistrationDetailsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserRegistrationDetailsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type UserRegistrationDetailsAppendInput = {
  fullDetails?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "user_registration_details". All fields are combined with a logical 'AND'. */
export type UserRegistrationDetailsBoolExp = {
  _and?: InputMaybe<Array<UserRegistrationDetailsBoolExp>>;
  _not?: InputMaybe<UserRegistrationDetailsBoolExp>;
  _or?: InputMaybe<Array<UserRegistrationDetailsBoolExp>>;
  city?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fullDetails?: InputMaybe<JsonbComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ip?: InputMaybe<StringComparisonExp>;
  platform?: InputMaybe<StringComparisonExp>;
  region?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  zip?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "user_registration_details" */
export enum UserRegistrationDetailsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserRegistrationDetailsPkey = 'user_registration_details_pkey',
  /** unique or primary key constraint on columns "user_id" */
  UserRegistrationDetailsUserIdKey = 'user_registration_details_user_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type UserRegistrationDetailsDeleteAtPathInput = {
  fullDetails?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type UserRegistrationDetailsDeleteElemInput = {
  fullDetails?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type UserRegistrationDetailsDeleteKeyInput = {
  fullDetails?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "user_registration_details" */
export type UserRegistrationDetailsInsertInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type UserRegistrationDetailsMaxFields = {
  __typename?: 'UserRegistrationDetailsMaxFields';
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  zip?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type UserRegistrationDetailsMinFields = {
  __typename?: 'UserRegistrationDetailsMinFields';
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  zip?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "user_registration_details" */
export type UserRegistrationDetailsMutationResponse = {
  __typename?: 'UserRegistrationDetailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserRegistrationDetails>;
};

/** input type for inserting object relation for remote table "user_registration_details" */
export type UserRegistrationDetailsObjRelInsertInput = {
  data: UserRegistrationDetailsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UserRegistrationDetailsOnConflict>;
};

/** on_conflict condition type for table "user_registration_details" */
export type UserRegistrationDetailsOnConflict = {
  constraint: UserRegistrationDetailsConstraint;
  updateColumns?: Array<UserRegistrationDetailsUpdateColumn>;
  where?: InputMaybe<UserRegistrationDetailsBoolExp>;
};

/** Ordering options when selecting data from "user_registration_details". */
export type UserRegistrationDetailsOrderBy = {
  city?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fullDetails?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  platform?: InputMaybe<OrderBy>;
  region?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  zip?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_registration_details */
export type UserRegistrationDetailsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type UserRegistrationDetailsPrependInput = {
  fullDetails?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "user_registration_details" */
export enum UserRegistrationDetailsSelectColumn {
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FullDetails = 'fullDetails',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Platform = 'platform',
  /** column name */
  Region = 'region',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Zip = 'zip'
}

/** input type for updating data in table "user_registration_details" */
export type UserRegistrationDetailsSetInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "user_registration_details" */
export type UserRegistrationDetailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserRegistrationDetailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserRegistrationDetailsStreamCursorValueInput = {
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  zip?: InputMaybe<Scalars['String']>;
};

/** update columns of table "user_registration_details" */
export enum UserRegistrationDetailsUpdateColumn {
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FullDetails = 'fullDetails',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Platform = 'platform',
  /** column name */
  Region = 'region',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Zip = 'zip'
}

export type UserRegistrationDetailsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<UserRegistrationDetailsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<UserRegistrationDetailsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<UserRegistrationDetailsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<UserRegistrationDetailsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<UserRegistrationDetailsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserRegistrationDetailsSetInput>;
  /** filter the rows which have to be updated */
  where: UserRegistrationDetailsBoolExp;
};

/** columns and relationships of "user_terms_of_service" */
export type UserTermsOfService = {
  __typename?: 'UserTermsOfService';
  acceptedAt: Scalars['timestamptz'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  ip: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userAgent: Scalars['String'];
  userId: Scalars['uuid'];
};

/** aggregated selection of "user_terms_of_service" */
export type UserTermsOfServiceAggregate = {
  __typename?: 'UserTermsOfServiceAggregate';
  aggregate?: Maybe<UserTermsOfServiceAggregateFields>;
  nodes: Array<UserTermsOfService>;
};

export type UserTermsOfServiceAggregateBoolExp = {
  count?: InputMaybe<UserTermsOfServiceAggregateBoolExpCount>;
};

/** aggregate fields of "user_terms_of_service" */
export type UserTermsOfServiceAggregateFields = {
  __typename?: 'UserTermsOfServiceAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UserTermsOfServiceMaxFields>;
  min?: Maybe<UserTermsOfServiceMinFields>;
};


/** aggregate fields of "user_terms_of_service" */
export type UserTermsOfServiceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_terms_of_service" */
export type UserTermsOfServiceAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserTermsOfServiceMaxOrderBy>;
  min?: InputMaybe<UserTermsOfServiceMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_terms_of_service" */
export type UserTermsOfServiceArrRelInsertInput = {
  data: Array<UserTermsOfServiceInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserTermsOfServiceOnConflict>;
};

/** Boolean expression to filter rows from the table "user_terms_of_service". All fields are combined with a logical 'AND'. */
export type UserTermsOfServiceBoolExp = {
  _and?: InputMaybe<Array<UserTermsOfServiceBoolExp>>;
  _not?: InputMaybe<UserTermsOfServiceBoolExp>;
  _or?: InputMaybe<Array<UserTermsOfServiceBoolExp>>;
  acceptedAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ip?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userAgent?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_terms_of_service" */
export enum UserTermsOfServiceConstraint {
  /** unique or primary key constraint on columns "id" */
  UserTermsOfServicePkey = 'user_terms_of_service_pkey'
}

/** input type for inserting data into table "user_terms_of_service" */
export type UserTermsOfServiceInsertInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userAgent?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UserTermsOfServiceMaxFields = {
  __typename?: 'UserTermsOfServiceMaxFields';
  acceptedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userAgent?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_terms_of_service" */
export type UserTermsOfServiceMaxOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserTermsOfServiceMinFields = {
  __typename?: 'UserTermsOfServiceMinFields';
  acceptedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userAgent?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_terms_of_service" */
export type UserTermsOfServiceMinOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_terms_of_service" */
export type UserTermsOfServiceMutationResponse = {
  __typename?: 'UserTermsOfServiceMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UserTermsOfService>;
};

/** on_conflict condition type for table "user_terms_of_service" */
export type UserTermsOfServiceOnConflict = {
  constraint: UserTermsOfServiceConstraint;
  updateColumns?: Array<UserTermsOfServiceUpdateColumn>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};

/** Ordering options when selecting data from "user_terms_of_service". */
export type UserTermsOfServiceOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ip?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_terms_of_service */
export type UserTermsOfServicePkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "user_terms_of_service" */
export enum UserTermsOfServiceSelectColumn {
  /** column name */
  AcceptedAt = 'acceptedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserAgent = 'userAgent',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_terms_of_service" */
export type UserTermsOfServiceSetInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userAgent?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_terms_of_service" */
export type UserTermsOfServiceStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserTermsOfServiceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserTermsOfServiceStreamCursorValueInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  ip?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userAgent?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "user_terms_of_service" */
export enum UserTermsOfServiceUpdateColumn {
  /** column name */
  AcceptedAt = 'acceptedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserAgent = 'userAgent',
  /** column name */
  UserId = 'userId'
}

export type UserTermsOfServiceUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserTermsOfServiceSetInput>;
  /** filter the rows which have to be updated */
  where: UserTermsOfServiceBoolExp;
};

/** columns and relationships of "username_logs" */
export type UsernameLogs = {
  __typename?: 'UsernameLogs';
  /** ADD or UPDATE to determine what occurred */
  action: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currentUsername: Scalars['String'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  previousUsername?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  userId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "username_logs" */
export type UsernameLogsAggregate = {
  __typename?: 'UsernameLogsAggregate';
  aggregate?: Maybe<UsernameLogsAggregateFields>;
  nodes: Array<UsernameLogs>;
};

export type UsernameLogsAggregateBoolExp = {
  count?: InputMaybe<UsernameLogsAggregateBoolExpCount>;
};

/** aggregate fields of "username_logs" */
export type UsernameLogsAggregateFields = {
  __typename?: 'UsernameLogsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UsernameLogsMaxFields>;
  min?: Maybe<UsernameLogsMinFields>;
};


/** aggregate fields of "username_logs" */
export type UsernameLogsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "username_logs" */
export type UsernameLogsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UsernameLogsMaxOrderBy>;
  min?: InputMaybe<UsernameLogsMinOrderBy>;
};

/** input type for inserting array relation for remote table "username_logs" */
export type UsernameLogsArrRelInsertInput = {
  data: Array<UsernameLogsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UsernameLogsOnConflict>;
};

/** Boolean expression to filter rows from the table "username_logs". All fields are combined with a logical 'AND'. */
export type UsernameLogsBoolExp = {
  _and?: InputMaybe<Array<UsernameLogsBoolExp>>;
  _not?: InputMaybe<UsernameLogsBoolExp>;
  _or?: InputMaybe<Array<UsernameLogsBoolExp>>;
  action?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currentUsername?: InputMaybe<StringComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  previousUsername?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "username_logs" */
export enum UsernameLogsConstraint {
  /** unique or primary key constraint on columns "id" */
  UsernameLogsPkey = 'username_logs_pkey'
}

/** input type for inserting data into table "username_logs" */
export type UsernameLogsInsertInput = {
  /** ADD or UPDATE to determine what occurred */
  action?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currentUsername?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  previousUsername?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UsernameLogsMaxFields = {
  __typename?: 'UsernameLogsMaxFields';
  /** ADD or UPDATE to determine what occurred */
  action?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currentUsername?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  previousUsername?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "username_logs" */
export type UsernameLogsMaxOrderBy = {
  /** ADD or UPDATE to determine what occurred */
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currentUsername?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  previousUsername?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UsernameLogsMinFields = {
  __typename?: 'UsernameLogsMinFields';
  /** ADD or UPDATE to determine what occurred */
  action?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currentUsername?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  previousUsername?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "username_logs" */
export type UsernameLogsMinOrderBy = {
  /** ADD or UPDATE to determine what occurred */
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currentUsername?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  previousUsername?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "username_logs" */
export type UsernameLogsMutationResponse = {
  __typename?: 'UsernameLogsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UsernameLogs>;
};

/** on_conflict condition type for table "username_logs" */
export type UsernameLogsOnConflict = {
  constraint: UsernameLogsConstraint;
  updateColumns?: Array<UsernameLogsUpdateColumn>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};

/** Ordering options when selecting data from "username_logs". */
export type UsernameLogsOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currentUsername?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  previousUsername?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: username_logs */
export type UsernameLogsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "username_logs" */
export enum UsernameLogsSelectColumn {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentUsername = 'currentUsername',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PreviousUsername = 'previousUsername',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "username_logs" */
export type UsernameLogsSetInput = {
  /** ADD or UPDATE to determine what occurred */
  action?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currentUsername?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  previousUsername?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "username_logs" */
export type UsernameLogsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsernameLogsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsernameLogsStreamCursorValueInput = {
  /** ADD or UPDATE to determine what occurred */
  action?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currentUsername?: InputMaybe<Scalars['String']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  previousUsername?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "username_logs" */
export enum UsernameLogsUpdateColumn {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentUsername = 'currentUsername',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  PreviousUsername = 'previousUsername',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UsernameLogsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsernameLogsSetInput>;
  /** filter the rows which have to be updated */
  where: UsernameLogsBoolExp;
};

/** columns and relationships of "usernames_active" */
export type UsernamesActive = {
  __typename?: 'UsernamesActive';
  username?: Maybe<Scalars['String']>;
};

/** aggregated selection of "usernames_active" */
export type UsernamesActiveAggregate = {
  __typename?: 'UsernamesActiveAggregate';
  aggregate?: Maybe<UsernamesActiveAggregateFields>;
  nodes: Array<UsernamesActive>;
};

/** aggregate fields of "usernames_active" */
export type UsernamesActiveAggregateFields = {
  __typename?: 'UsernamesActiveAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UsernamesActiveMaxFields>;
  min?: Maybe<UsernamesActiveMinFields>;
};


/** aggregate fields of "usernames_active" */
export type UsernamesActiveAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "usernames_active". All fields are combined with a logical 'AND'. */
export type UsernamesActiveBoolExp = {
  _and?: InputMaybe<Array<UsernamesActiveBoolExp>>;
  _not?: InputMaybe<UsernamesActiveBoolExp>;
  _or?: InputMaybe<Array<UsernamesActiveBoolExp>>;
  username?: InputMaybe<StringComparisonExp>;
};

/** input type for inserting data into table "usernames_active" */
export type UsernamesActiveInsertInput = {
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type UsernamesActiveMaxFields = {
  __typename?: 'UsernamesActiveMaxFields';
  username?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type UsernamesActiveMinFields = {
  __typename?: 'UsernamesActiveMinFields';
  username?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "usernames_active" */
export type UsernamesActiveMutationResponse = {
  __typename?: 'UsernamesActiveMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UsernamesActive>;
};

/** Ordering options when selecting data from "usernames_active". */
export type UsernamesActiveOrderBy = {
  username?: InputMaybe<OrderBy>;
};

/** select columns of table "usernames_active" */
export enum UsernamesActiveSelectColumn {
  /** column name */
  Username = 'username'
}

/** input type for updating data in table "usernames_active" */
export type UsernamesActiveSetInput = {
  username?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "usernames_active" */
export type UsernamesActiveStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsernamesActiveStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsernamesActiveStreamCursorValueInput = {
  username?: InputMaybe<Scalars['String']>;
};

export type UsernamesActiveUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsernamesActiveSetInput>;
  /** filter the rows which have to be updated */
  where: UsernamesActiveBoolExp;
};

/** This table prevents reserved words from being used or old usernames being claimed for where identity takeover can happen */
export type UsernamesClaimed = {
  __typename?: 'UsernamesClaimed';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  userId?: Maybe<Scalars['uuid']>;
  username: Scalars['String'];
};

/** aggregated selection of "usernames_claimed" */
export type UsernamesClaimedAggregate = {
  __typename?: 'UsernamesClaimedAggregate';
  aggregate?: Maybe<UsernamesClaimedAggregateFields>;
  nodes: Array<UsernamesClaimed>;
};

export type UsernamesClaimedAggregateBoolExp = {
  count?: InputMaybe<UsernamesClaimedAggregateBoolExpCount>;
};

/** aggregate fields of "usernames_claimed" */
export type UsernamesClaimedAggregateFields = {
  __typename?: 'UsernamesClaimedAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UsernamesClaimedMaxFields>;
  min?: Maybe<UsernamesClaimedMinFields>;
};


/** aggregate fields of "usernames_claimed" */
export type UsernamesClaimedAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "usernames_claimed" */
export type UsernamesClaimedAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UsernamesClaimedMaxOrderBy>;
  min?: InputMaybe<UsernamesClaimedMinOrderBy>;
};

/** input type for inserting array relation for remote table "usernames_claimed" */
export type UsernamesClaimedArrRelInsertInput = {
  data: Array<UsernamesClaimedInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UsernamesClaimedOnConflict>;
};

/** Boolean expression to filter rows from the table "usernames_claimed". All fields are combined with a logical 'AND'. */
export type UsernamesClaimedBoolExp = {
  _and?: InputMaybe<Array<UsernamesClaimedBoolExp>>;
  _not?: InputMaybe<UsernamesClaimedBoolExp>;
  _or?: InputMaybe<Array<UsernamesClaimedBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  reason?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "usernames_claimed" */
export enum UsernamesClaimedConstraint {
  /** unique or primary key constraint on columns "id" */
  UsernamesClaimedPkey = 'usernames_claimed_pkey',
  /** unique or primary key constraint on columns "username" */
  UsernamesClaimedUsernameKey = 'usernames_claimed_username_key'
}

/** input type for inserting data into table "usernames_claimed" */
export type UsernamesClaimedInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type UsernamesClaimedMaxFields = {
  __typename?: 'UsernamesClaimedMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  username?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "usernames_claimed" */
export type UsernamesClaimedMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UsernamesClaimedMinFields = {
  __typename?: 'UsernamesClaimedMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  username?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "usernames_claimed" */
export type UsernamesClaimedMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "usernames_claimed" */
export type UsernamesClaimedMutationResponse = {
  __typename?: 'UsernamesClaimedMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UsernamesClaimed>;
};

/** on_conflict condition type for table "usernames_claimed" */
export type UsernamesClaimedOnConflict = {
  constraint: UsernamesClaimedConstraint;
  updateColumns?: Array<UsernamesClaimedUpdateColumn>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};

/** Ordering options when selecting data from "usernames_claimed". */
export type UsernamesClaimedOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: usernames_claimed */
export type UsernamesClaimedPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "usernames_claimed" */
export enum UsernamesClaimedSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Reason = 'reason',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Username = 'username'
}

/** input type for updating data in table "usernames_claimed" */
export type UsernamesClaimedSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  username?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "usernames_claimed" */
export type UsernamesClaimedStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsernamesClaimedStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsernamesClaimedStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  /** KEYWORD or USER or FORBIDDEN (more options may be needed) */
  reason?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  username?: InputMaybe<Scalars['String']>;
};

/** update columns of table "usernames_claimed" */
export enum UsernamesClaimedUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Reason = 'reason',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  Username = 'username'
}

export type UsernamesClaimedUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsernamesClaimedSetInput>;
  /** filter the rows which have to be updated */
  where: UsernamesClaimedBoolExp;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'Users';
  aboutMe: Scalars['String'];
  aboutMeVideoUrl: Scalars['String'];
  /** An object relationship */
  activeCity?: Maybe<Cities>;
  activeCityId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  authIdentities: Array<UserAuthIdentities>;
  /** An aggregate relationship */
  authIdentitiesAggregate: UserAuthIdentitiesAggregate;
  birthday?: Maybe<Scalars['date']>;
  cityName: Scalars['String'];
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears: Scalars['numeric'];
  /** An array relationship */
  coachLessons: Array<Lessons>;
  /** An aggregate relationship */
  coachLessonsAggregate: LessonsAggregate;
  /** An array relationship */
  coachQualifications: Array<UsersCoachQualifications>;
  /** An aggregate relationship */
  coachQualificationsAggregate: UsersCoachQualificationsAggregate;
  /** An array relationship */
  coachServices: Array<UserCoachServices>;
  /** An aggregate relationship */
  coachServicesAggregate: UserCoachServicesAggregate;
  coachStatus?: Maybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  communicationPreferences?: Maybe<UserCommunicationPreferences>;
  /** An object relationship */
  country?: Maybe<Countries>;
  countryId?: Maybe<Scalars['String']>;
  /** An object relationship */
  countrySubdivision?: Maybe<CountrySubdivisions>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName: Scalars['String'];
  coverImagePath: Scalars['String'];
  coverImageProvider: Scalars['String'];
  coverImageProviderId: Scalars['String'];
  coverImageProviderUrl: Scalars['String'];
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  /** An array relationship */
  creditCards: Array<UserCreditCards>;
  /** An aggregate relationship */
  creditCardsAggregate: UserCreditCardsAggregate;
  /** An array relationship */
  customCourts: Array<UserCustomCourts>;
  /** An aggregate relationship */
  customCourtsAggregate: UserCustomCourtsAggregate;
  defaultCoachPaymentFulfillmentChannel?: Maybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: Maybe<Scalars['uuid']>;
  defaultSport?: Maybe<SportsEnum>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  derfaultCreditCard?: Maybe<UserCreditCards>;
  duprId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  eventOrganizerAccountType: EventOrganizerAccountTypesEnum;
  firebaseId: Scalars['String'];
  /** An array relationship */
  followers: Array<UserFollows>;
  /** An aggregate relationship */
  followersAggregate: UserFollowsAggregate;
  /** An array relationship */
  following: Array<UserFollows>;
  /** An aggregate relationship */
  followingAggregate: UserFollowsAggregate;
  fullName: Scalars['String'];
  gender?: Maybe<GenderEnum>;
  genderPreference: Scalars['String'];
  geometry?: Maybe<Scalars['geography']>;
  /** An array relationship */
  groups: Array<GroupMembers>;
  /** An aggregate relationship */
  groupsAggregate: GroupMembersAggregate;
  id: Scalars['uuid'];
  isMarketingRegistered?: Maybe<Scalars['Boolean']>;
  isOnboardComplete: Scalars['Boolean'];
  latestAuthProvider: Scalars['String'];
  latitude?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  lessonTemplates: Array<LessonTemplates>;
  /** An aggregate relationship */
  lessonTemplatesAggregate: LessonTemplatesAggregate;
  longitude?: Maybe<Scalars['numeric']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  normalizedTennisRatingScale?: Maybe<TennisRatingScales>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  notifications: Array<UserNotifications>;
  /** An aggregate relationship */
  notificationsAggregate: UserNotificationsAggregate;
  originalAuthProvider: Scalars['String'];
  /** An array relationship */
  participantLessons: Array<LessonParticipants>;
  /** An aggregate relationship */
  participantLessonsAggregate: LessonParticipantsAggregate;
  phoneNumber?: Maybe<Scalars['String']>;
  /** An object relationship */
  pickleballSkillLevel?: Maybe<SkillLevels>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName: Scalars['String'];
  /** An object relationship */
  profile?: Maybe<UserProfiles>;
  profileImageFileName: Scalars['String'];
  profileImagePath: Scalars['String'];
  profileImageProvider: Scalars['String'];
  profileImageProviderId: Scalars['String'];
  profileImageProviderUrl: Scalars['String'];
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl: Scalars['String'];
  /** An object relationship */
  registrationDetails?: Maybe<UserRegistrationDetails>;
  stripeCustomerId: Scalars['String'];
  stripeMerchantBusinessType?: Maybe<Scalars['String']>;
  stripeMerchantChargesEnabled: Scalars['Boolean'];
  stripeMerchantCountry?: Maybe<Scalars['String']>;
  stripeMerchantCurrency?: Maybe<Scalars['String']>;
  stripeMerchantCurrentlyDue?: Maybe<Scalars['jsonb']>;
  stripeMerchantDetailsSubmitted: Scalars['Boolean'];
  stripeMerchantEventuallyDue?: Maybe<Scalars['jsonb']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  stripeMerchantPastDue?: Maybe<Scalars['jsonb']>;
  stripeMerchantPayoutsEnabled: Scalars['Boolean'];
  tennisRating?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  tennisRatingScale?: Maybe<TennisRatingScales>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  tennisSkillLevel?: Maybe<SkillLevels>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  /** An array relationship */
  termsOfService: Array<UserTermsOfService>;
  /** An aggregate relationship */
  termsOfServiceAggregate: UserTermsOfServiceAggregate;
  updatedAt: Scalars['timestamptz'];
  username?: Maybe<Scalars['String']>;
  /** An array relationship */
  usernameLogs: Array<UsernameLogs>;
  /** An aggregate relationship */
  usernameLogsAggregate: UsernameLogsAggregate;
  /** An array relationship */
  usernamesClaimed: Array<UsernamesClaimed>;
  /** An aggregate relationship */
  usernamesClaimedAggregate: UsernamesClaimedAggregate;
};


/** columns and relationships of "users" */
export type UsersAuthIdentitiesArgs = {
  distinctOn?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserAuthIdentitiesOrderBy>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAuthIdentitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserAuthIdentitiesOrderBy>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachQualificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCoachServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreditCardsArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreditCardsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCustomCourtsArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCustomCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowersArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowingArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFollowingAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersLessonTemplatesArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersLessonTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersParticipantLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersParticipantLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersStripeMerchantCurrentlyDueArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersStripeMerchantEventuallyDueArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersStripeMerchantPastDueArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersTermsOfServiceArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


/** columns and relationships of "users" */
export type UsersTermsOfServiceAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsernameLogsArgs = {
  distinctOn?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernameLogsOrderBy>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsernameLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernameLogsOrderBy>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsernamesClaimedArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsernamesClaimedAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};

/** aggregated selection of "users" */
export type UsersAggregate = {
  __typename?: 'UsersAggregate';
  aggregate?: Maybe<UsersAggregateFields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type UsersAggregateFields = {
  __typename?: 'UsersAggregateFields';
  avg?: Maybe<UsersAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<UsersMaxFields>;
  min?: Maybe<UsersMinFields>;
  stddev?: Maybe<UsersStddevFields>;
  stddevPop?: Maybe<UsersStddevPopFields>;
  stddevSamp?: Maybe<UsersStddevSampFields>;
  sum?: Maybe<UsersSumFields>;
  varPop?: Maybe<UsersVarPopFields>;
  varSamp?: Maybe<UsersVarSampFields>;
  variance?: Maybe<UsersVarianceFields>;
};


/** aggregate fields of "users" */
export type UsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type UsersAppendInput = {
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type UsersAvgFields = {
  __typename?: 'UsersAvgFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type UsersBoolExp = {
  _and?: InputMaybe<Array<UsersBoolExp>>;
  _not?: InputMaybe<UsersBoolExp>;
  _or?: InputMaybe<Array<UsersBoolExp>>;
  aboutMe?: InputMaybe<StringComparisonExp>;
  aboutMeVideoUrl?: InputMaybe<StringComparisonExp>;
  activeCity?: InputMaybe<CitiesBoolExp>;
  activeCityId?: InputMaybe<UuidComparisonExp>;
  authIdentities?: InputMaybe<UserAuthIdentitiesBoolExp>;
  authIdentitiesAggregate?: InputMaybe<UserAuthIdentitiesAggregateBoolExp>;
  birthday?: InputMaybe<DateComparisonExp>;
  cityName?: InputMaybe<StringComparisonExp>;
  coachExperienceSetAt?: InputMaybe<TimestamptzComparisonExp>;
  coachExperienceYears?: InputMaybe<NumericComparisonExp>;
  coachLessons?: InputMaybe<LessonsBoolExp>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateBoolExp>;
  coachQualifications?: InputMaybe<UsersCoachQualificationsBoolExp>;
  coachQualificationsAggregate?: InputMaybe<UsersCoachQualificationsAggregateBoolExp>;
  coachServices?: InputMaybe<UserCoachServicesBoolExp>;
  coachServicesAggregate?: InputMaybe<UserCoachServicesAggregateBoolExp>;
  coachStatus?: InputMaybe<CoachStatusEnumComparisonExp>;
  coachStatusUpdatedAt?: InputMaybe<TimestamptzComparisonExp>;
  communicationPreferences?: InputMaybe<UserCommunicationPreferencesBoolExp>;
  country?: InputMaybe<CountriesBoolExp>;
  countryId?: InputMaybe<StringComparisonExp>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsBoolExp>;
  countrySubdivisionId?: InputMaybe<UuidComparisonExp>;
  coverImageFileName?: InputMaybe<StringComparisonExp>;
  coverImagePath?: InputMaybe<StringComparisonExp>;
  coverImageProvider?: InputMaybe<StringComparisonExp>;
  coverImageProviderId?: InputMaybe<StringComparisonExp>;
  coverImageProviderUrl?: InputMaybe<StringComparisonExp>;
  coverImageUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  creditCards?: InputMaybe<UserCreditCardsBoolExp>;
  creditCardsAggregate?: InputMaybe<UserCreditCardsAggregateBoolExp>;
  customCourts?: InputMaybe<UserCustomCourtsBoolExp>;
  customCourtsAggregate?: InputMaybe<UserCustomCourtsAggregateBoolExp>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnumComparisonExp>;
  defaultCreditCardId?: InputMaybe<UuidComparisonExp>;
  defaultSport?: InputMaybe<SportsEnumComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  derfaultCreditCard?: InputMaybe<UserCreditCardsBoolExp>;
  duprId?: InputMaybe<StringComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnumComparisonExp>;
  firebaseId?: InputMaybe<StringComparisonExp>;
  followers?: InputMaybe<UserFollowsBoolExp>;
  followersAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  following?: InputMaybe<UserFollowsBoolExp>;
  followingAggregate?: InputMaybe<UserFollowsAggregateBoolExp>;
  fullName?: InputMaybe<StringComparisonExp>;
  gender?: InputMaybe<GenderEnumComparisonExp>;
  genderPreference?: InputMaybe<StringComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groups?: InputMaybe<GroupMembersBoolExp>;
  groupsAggregate?: InputMaybe<GroupMembersAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isMarketingRegistered?: InputMaybe<BooleanComparisonExp>;
  isOnboardComplete?: InputMaybe<BooleanComparisonExp>;
  latestAuthProvider?: InputMaybe<StringComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  lessonTemplates?: InputMaybe<LessonTemplatesBoolExp>;
  lessonTemplatesAggregate?: InputMaybe<LessonTemplatesAggregateBoolExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  normalizedTennisRating?: InputMaybe<NumericComparisonExp>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  normalizedTennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  notifications?: InputMaybe<UserNotificationsBoolExp>;
  notificationsAggregate?: InputMaybe<UserNotificationsAggregateBoolExp>;
  originalAuthProvider?: InputMaybe<StringComparisonExp>;
  participantLessons?: InputMaybe<LessonParticipantsBoolExp>;
  participantLessonsAggregate?: InputMaybe<LessonParticipantsAggregateBoolExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  pickleballSkillLevelId?: InputMaybe<StringComparisonExp>;
  preferredName?: InputMaybe<StringComparisonExp>;
  profile?: InputMaybe<UserProfilesBoolExp>;
  profileImageFileName?: InputMaybe<StringComparisonExp>;
  profileImagePath?: InputMaybe<StringComparisonExp>;
  profileImageProvider?: InputMaybe<StringComparisonExp>;
  profileImageProviderId?: InputMaybe<StringComparisonExp>;
  profileImageProviderUrl?: InputMaybe<StringComparisonExp>;
  profileImageUrl?: InputMaybe<StringComparisonExp>;
  registrationDetails?: InputMaybe<UserRegistrationDetailsBoolExp>;
  stripeCustomerId?: InputMaybe<StringComparisonExp>;
  stripeMerchantBusinessType?: InputMaybe<StringComparisonExp>;
  stripeMerchantChargesEnabled?: InputMaybe<BooleanComparisonExp>;
  stripeMerchantCountry?: InputMaybe<StringComparisonExp>;
  stripeMerchantCurrency?: InputMaybe<StringComparisonExp>;
  stripeMerchantCurrentlyDue?: InputMaybe<JsonbComparisonExp>;
  stripeMerchantDetailsSubmitted?: InputMaybe<BooleanComparisonExp>;
  stripeMerchantEventuallyDue?: InputMaybe<JsonbComparisonExp>;
  stripeMerchantId?: InputMaybe<StringComparisonExp>;
  stripeMerchantPastDue?: InputMaybe<JsonbComparisonExp>;
  stripeMerchantPayoutsEnabled?: InputMaybe<BooleanComparisonExp>;
  tennisRating?: InputMaybe<NumericComparisonExp>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesBoolExp>;
  tennisRatingScaleId?: InputMaybe<UuidComparisonExp>;
  tennisSkillLevel?: InputMaybe<SkillLevelsBoolExp>;
  tennisSkillLevelId?: InputMaybe<StringComparisonExp>;
  termsOfService?: InputMaybe<UserTermsOfServiceBoolExp>;
  termsOfServiceAggregate?: InputMaybe<UserTermsOfServiceAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  username?: InputMaybe<StringComparisonExp>;
  usernameLogs?: InputMaybe<UsernameLogsBoolExp>;
  usernameLogsAggregate?: InputMaybe<UsernameLogsAggregateBoolExp>;
  usernamesClaimed?: InputMaybe<UsernamesClaimedBoolExp>;
  usernamesClaimedAggregate?: InputMaybe<UsernamesClaimedAggregateBoolExp>;
};

/** columns and relationships of "users_coach_qualifications" */
export type UsersCoachQualifications = {
  __typename?: 'UsersCoachQualifications';
  coachQualificationId: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  qualification: CoachQualifications;
  status: CoachQualificationStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "users_coach_qualifications" */
export type UsersCoachQualificationsAggregate = {
  __typename?: 'UsersCoachQualificationsAggregate';
  aggregate?: Maybe<UsersCoachQualificationsAggregateFields>;
  nodes: Array<UsersCoachQualifications>;
};

export type UsersCoachQualificationsAggregateBoolExp = {
  count?: InputMaybe<UsersCoachQualificationsAggregateBoolExpCount>;
};

/** aggregate fields of "users_coach_qualifications" */
export type UsersCoachQualificationsAggregateFields = {
  __typename?: 'UsersCoachQualificationsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<UsersCoachQualificationsMaxFields>;
  min?: Maybe<UsersCoachQualificationsMinFields>;
};


/** aggregate fields of "users_coach_qualifications" */
export type UsersCoachQualificationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "users_coach_qualifications" */
export type UsersCoachQualificationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UsersCoachQualificationsMaxOrderBy>;
  min?: InputMaybe<UsersCoachQualificationsMinOrderBy>;
};

/** input type for inserting array relation for remote table "users_coach_qualifications" */
export type UsersCoachQualificationsArrRelInsertInput = {
  data: Array<UsersCoachQualificationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UsersCoachQualificationsOnConflict>;
};

/** Boolean expression to filter rows from the table "users_coach_qualifications". All fields are combined with a logical 'AND'. */
export type UsersCoachQualificationsBoolExp = {
  _and?: InputMaybe<Array<UsersCoachQualificationsBoolExp>>;
  _not?: InputMaybe<UsersCoachQualificationsBoolExp>;
  _or?: InputMaybe<Array<UsersCoachQualificationsBoolExp>>;
  coachQualificationId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  qualification?: InputMaybe<CoachQualificationsBoolExp>;
  status?: InputMaybe<CoachQualificationStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "users_coach_qualifications" */
export enum UsersCoachQualificationsConstraint {
  /** unique or primary key constraint on columns "id" */
  UsersCoachQualificationsPkey = 'users_coach_qualifications_pkey',
  /** unique or primary key constraint on columns "user_id", "coach_qualification_id" */
  UsersCoachQualificationsUserIdCoachQualificationIdKey = 'users_coach_qualifications_user_id_coach_qualification_id_key'
}

/** input type for inserting data into table "users_coach_qualifications" */
export type UsersCoachQualificationsInsertInput = {
  coachQualificationId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  qualification?: InputMaybe<CoachQualificationsObjRelInsertInput>;
  status?: InputMaybe<CoachQualificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type UsersCoachQualificationsMaxFields = {
  __typename?: 'UsersCoachQualificationsMaxFields';
  coachQualificationId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "users_coach_qualifications" */
export type UsersCoachQualificationsMaxOrderBy = {
  coachQualificationId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UsersCoachQualificationsMinFields = {
  __typename?: 'UsersCoachQualificationsMinFields';
  coachQualificationId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "users_coach_qualifications" */
export type UsersCoachQualificationsMinOrderBy = {
  coachQualificationId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "users_coach_qualifications" */
export type UsersCoachQualificationsMutationResponse = {
  __typename?: 'UsersCoachQualificationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<UsersCoachQualifications>;
};

/** on_conflict condition type for table "users_coach_qualifications" */
export type UsersCoachQualificationsOnConflict = {
  constraint: UsersCoachQualificationsConstraint;
  updateColumns?: Array<UsersCoachQualificationsUpdateColumn>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};

/** Ordering options when selecting data from "users_coach_qualifications". */
export type UsersCoachQualificationsOrderBy = {
  coachQualificationId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  qualification?: InputMaybe<CoachQualificationsOrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: users_coach_qualifications */
export type UsersCoachQualificationsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "users_coach_qualifications" */
export enum UsersCoachQualificationsSelectColumn {
  /** column name */
  CoachQualificationId = 'coachQualificationId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "users_coach_qualifications" */
export type UsersCoachQualificationsSetInput = {
  coachQualificationId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<CoachQualificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "users_coach_qualifications" */
export type UsersCoachQualificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersCoachQualificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersCoachQualificationsStreamCursorValueInput = {
  coachQualificationId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<CoachQualificationStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "users_coach_qualifications" */
export enum UsersCoachQualificationsUpdateColumn {
  /** column name */
  CoachQualificationId = 'coachQualificationId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type UsersCoachQualificationsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersCoachQualificationsSetInput>;
  /** filter the rows which have to be updated */
  where: UsersCoachQualificationsBoolExp;
};

/** unique or primary key constraints on table "users" */
export enum UsersConstraint {
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "firebase_id" */
  UsersFirebaseIdKey = 'users_firebase_id_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey',
  /** unique or primary key constraint on columns "stripe_customer_id" */
  UsersStripeCustomerIdKey = 'users_stripe_customer_id_key',
  /** unique or primary key constraint on columns "stripe_merchant_id" */
  UsersStripeMerchantIdKey = 'users_stripe_merchant_id_key',
  /** unique or primary key constraint on columns "username" */
  UsersUsernameKey = 'users_username_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type UsersDeleteAtPathInput = {
  stripeMerchantCurrentlyDue?: InputMaybe<Array<Scalars['String']>>;
  stripeMerchantEventuallyDue?: InputMaybe<Array<Scalars['String']>>;
  stripeMerchantPastDue?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type UsersDeleteElemInput = {
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['Int']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['Int']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type UsersDeleteKeyInput = {
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['String']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['String']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "users" */
export type UsersIncInput = {
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "users" */
export type UsersInsertInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCity?: InputMaybe<CitiesObjRelInsertInput>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  authIdentities?: InputMaybe<UserAuthIdentitiesArrRelInsertInput>;
  birthday?: InputMaybe<Scalars['date']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachLessons?: InputMaybe<LessonsArrRelInsertInput>;
  coachQualifications?: InputMaybe<UsersCoachQualificationsArrRelInsertInput>;
  coachServices?: InputMaybe<UserCoachServicesArrRelInsertInput>;
  coachStatus?: InputMaybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  communicationPreferences?: InputMaybe<UserCommunicationPreferencesObjRelInsertInput>;
  country?: InputMaybe<CountriesObjRelInsertInput>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsObjRelInsertInput>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creditCards?: InputMaybe<UserCreditCardsArrRelInsertInput>;
  customCourts?: InputMaybe<UserCustomCourtsArrRelInsertInput>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: InputMaybe<Scalars['uuid']>;
  defaultSport?: InputMaybe<SportsEnum>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  derfaultCreditCard?: InputMaybe<UserCreditCardsObjRelInsertInput>;
  duprId?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  firebaseId?: InputMaybe<Scalars['String']>;
  followers?: InputMaybe<UserFollowsArrRelInsertInput>;
  following?: InputMaybe<UserFollowsArrRelInsertInput>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderEnum>;
  genderPreference?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groups?: InputMaybe<GroupMembersArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']>;
  isMarketingRegistered?: InputMaybe<Scalars['Boolean']>;
  isOnboardComplete?: InputMaybe<Scalars['Boolean']>;
  latestAuthProvider?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  lessonTemplates?: InputMaybe<LessonTemplatesArrRelInsertInput>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesObjRelInsertInput>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  notifications?: InputMaybe<UserNotificationsArrRelInsertInput>;
  originalAuthProvider?: InputMaybe<Scalars['String']>;
  participantLessons?: InputMaybe<LessonParticipantsArrRelInsertInput>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsObjRelInsertInput>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<UserProfilesObjRelInsertInput>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderId?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: InputMaybe<Scalars['String']>;
  registrationDetails?: InputMaybe<UserRegistrationDetailsObjRelInsertInput>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantBusinessType?: InputMaybe<Scalars['String']>;
  stripeMerchantChargesEnabled?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantCountry?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrency?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantDetailsSubmitted?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantPayoutsEnabled?: InputMaybe<Scalars['Boolean']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesObjRelInsertInput>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevel?: InputMaybe<SkillLevelsObjRelInsertInput>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  termsOfService?: InputMaybe<UserTermsOfServiceArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
  usernameLogs?: InputMaybe<UsernameLogsArrRelInsertInput>;
  usernamesClaimed?: InputMaybe<UsernamesClaimedArrRelInsertInput>;
};

/** aggregate max on columns */
export type UsersMaxFields = {
  __typename?: 'UsersMaxFields';
  aboutMe?: Maybe<Scalars['String']>;
  aboutMeVideoUrl?: Maybe<Scalars['String']>;
  activeCityId?: Maybe<Scalars['uuid']>;
  birthday?: Maybe<Scalars['date']>;
  cityName?: Maybe<Scalars['String']>;
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  coachStatusUpdatedAt?: Maybe<Scalars['timestamptz']>;
  countryId?: Maybe<Scalars['String']>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  defaultCreditCardId?: Maybe<Scalars['uuid']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firebaseId?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  genderPreference?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  latestAuthProvider?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  originalAuthProvider?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  profileImageFileName?: Maybe<Scalars['String']>;
  profileImagePath?: Maybe<Scalars['String']>;
  profileImageProvider?: Maybe<Scalars['String']>;
  profileImageProviderId?: Maybe<Scalars['String']>;
  profileImageProviderUrl?: Maybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantBusinessType?: Maybe<Scalars['String']>;
  stripeMerchantCountry?: Maybe<Scalars['String']>;
  stripeMerchantCurrency?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  tennisRating?: Maybe<Scalars['numeric']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type UsersMinFields = {
  __typename?: 'UsersMinFields';
  aboutMe?: Maybe<Scalars['String']>;
  aboutMeVideoUrl?: Maybe<Scalars['String']>;
  activeCityId?: Maybe<Scalars['uuid']>;
  birthday?: Maybe<Scalars['date']>;
  cityName?: Maybe<Scalars['String']>;
  coachExperienceSetAt?: Maybe<Scalars['timestamptz']>;
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  coachStatusUpdatedAt?: Maybe<Scalars['timestamptz']>;
  countryId?: Maybe<Scalars['String']>;
  countrySubdivisionId?: Maybe<Scalars['uuid']>;
  coverImageFileName?: Maybe<Scalars['String']>;
  coverImagePath?: Maybe<Scalars['String']>;
  coverImageProvider?: Maybe<Scalars['String']>;
  coverImageProviderId?: Maybe<Scalars['String']>;
  coverImageProviderUrl?: Maybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  defaultCreditCardId?: Maybe<Scalars['uuid']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  duprId?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firebaseId?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  genderPreference?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  latestAuthProvider?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: Maybe<Scalars['uuid']>;
  originalAuthProvider?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  pickleballSkillLevelId?: Maybe<Scalars['String']>;
  preferredName?: Maybe<Scalars['String']>;
  profileImageFileName?: Maybe<Scalars['String']>;
  profileImagePath?: Maybe<Scalars['String']>;
  profileImageProvider?: Maybe<Scalars['String']>;
  profileImageProviderId?: Maybe<Scalars['String']>;
  profileImageProviderUrl?: Maybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  stripeMerchantBusinessType?: Maybe<Scalars['String']>;
  stripeMerchantCountry?: Maybe<Scalars['String']>;
  stripeMerchantCurrency?: Maybe<Scalars['String']>;
  stripeMerchantId?: Maybe<Scalars['String']>;
  tennisRating?: Maybe<Scalars['numeric']>;
  tennisRatingScaleId?: Maybe<Scalars['uuid']>;
  tennisSkillLevelId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  username?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "users" */
export type UsersMutationResponse = {
  __typename?: 'UsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type UsersObjRelInsertInput = {
  data: UsersInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UsersOnConflict>;
};

/** on_conflict condition type for table "users" */
export type UsersOnConflict = {
  constraint: UsersConstraint;
  updateColumns?: Array<UsersUpdateColumn>;
  where?: InputMaybe<UsersBoolExp>;
};

/** Ordering options when selecting data from "users". */
export type UsersOrderBy = {
  aboutMe?: InputMaybe<OrderBy>;
  aboutMeVideoUrl?: InputMaybe<OrderBy>;
  activeCity?: InputMaybe<CitiesOrderBy>;
  activeCityId?: InputMaybe<OrderBy>;
  authIdentitiesAggregate?: InputMaybe<UserAuthIdentitiesAggregateOrderBy>;
  birthday?: InputMaybe<OrderBy>;
  cityName?: InputMaybe<OrderBy>;
  coachExperienceSetAt?: InputMaybe<OrderBy>;
  coachExperienceYears?: InputMaybe<OrderBy>;
  coachLessonsAggregate?: InputMaybe<LessonsAggregateOrderBy>;
  coachQualificationsAggregate?: InputMaybe<UsersCoachQualificationsAggregateOrderBy>;
  coachServicesAggregate?: InputMaybe<UserCoachServicesAggregateOrderBy>;
  coachStatus?: InputMaybe<OrderBy>;
  coachStatusUpdatedAt?: InputMaybe<OrderBy>;
  communicationPreferences?: InputMaybe<UserCommunicationPreferencesOrderBy>;
  country?: InputMaybe<CountriesOrderBy>;
  countryId?: InputMaybe<OrderBy>;
  countrySubdivision?: InputMaybe<CountrySubdivisionsOrderBy>;
  countrySubdivisionId?: InputMaybe<OrderBy>;
  coverImageFileName?: InputMaybe<OrderBy>;
  coverImagePath?: InputMaybe<OrderBy>;
  coverImageProvider?: InputMaybe<OrderBy>;
  coverImageProviderId?: InputMaybe<OrderBy>;
  coverImageProviderUrl?: InputMaybe<OrderBy>;
  coverImageUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creditCardsAggregate?: InputMaybe<UserCreditCardsAggregateOrderBy>;
  customCourtsAggregate?: InputMaybe<UserCustomCourtsAggregateOrderBy>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<OrderBy>;
  defaultCreditCardId?: InputMaybe<OrderBy>;
  defaultSport?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  derfaultCreditCard?: InputMaybe<UserCreditCardsOrderBy>;
  duprId?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  eventOrganizerAccountType?: InputMaybe<OrderBy>;
  firebaseId?: InputMaybe<OrderBy>;
  followersAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  followingAggregate?: InputMaybe<UserFollowsAggregateOrderBy>;
  fullName?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  genderPreference?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<GroupMembersAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  isMarketingRegistered?: InputMaybe<OrderBy>;
  isOnboardComplete?: InputMaybe<OrderBy>;
  latestAuthProvider?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  lessonTemplatesAggregate?: InputMaybe<LessonTemplatesAggregateOrderBy>;
  longitude?: InputMaybe<OrderBy>;
  normalizedTennisRating?: InputMaybe<OrderBy>;
  normalizedTennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  normalizedTennisRatingScaleId?: InputMaybe<OrderBy>;
  notificationsAggregate?: InputMaybe<UserNotificationsAggregateOrderBy>;
  originalAuthProvider?: InputMaybe<OrderBy>;
  participantLessonsAggregate?: InputMaybe<LessonParticipantsAggregateOrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  pickleballSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  pickleballSkillLevelId?: InputMaybe<OrderBy>;
  preferredName?: InputMaybe<OrderBy>;
  profile?: InputMaybe<UserProfilesOrderBy>;
  profileImageFileName?: InputMaybe<OrderBy>;
  profileImagePath?: InputMaybe<OrderBy>;
  profileImageProvider?: InputMaybe<OrderBy>;
  profileImageProviderId?: InputMaybe<OrderBy>;
  profileImageProviderUrl?: InputMaybe<OrderBy>;
  profileImageUrl?: InputMaybe<OrderBy>;
  registrationDetails?: InputMaybe<UserRegistrationDetailsOrderBy>;
  stripeCustomerId?: InputMaybe<OrderBy>;
  stripeMerchantBusinessType?: InputMaybe<OrderBy>;
  stripeMerchantChargesEnabled?: InputMaybe<OrderBy>;
  stripeMerchantCountry?: InputMaybe<OrderBy>;
  stripeMerchantCurrency?: InputMaybe<OrderBy>;
  stripeMerchantCurrentlyDue?: InputMaybe<OrderBy>;
  stripeMerchantDetailsSubmitted?: InputMaybe<OrderBy>;
  stripeMerchantEventuallyDue?: InputMaybe<OrderBy>;
  stripeMerchantId?: InputMaybe<OrderBy>;
  stripeMerchantPastDue?: InputMaybe<OrderBy>;
  stripeMerchantPayoutsEnabled?: InputMaybe<OrderBy>;
  tennisRating?: InputMaybe<OrderBy>;
  tennisRatingScale?: InputMaybe<TennisRatingScalesOrderBy>;
  tennisRatingScaleId?: InputMaybe<OrderBy>;
  tennisSkillLevel?: InputMaybe<SkillLevelsOrderBy>;
  tennisSkillLevelId?: InputMaybe<OrderBy>;
  termsOfServiceAggregate?: InputMaybe<UserTermsOfServiceAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  username?: InputMaybe<OrderBy>;
  usernameLogsAggregate?: InputMaybe<UsernameLogsAggregateOrderBy>;
  usernamesClaimedAggregate?: InputMaybe<UsernamesClaimedAggregateOrderBy>;
};

/** primary key columns input for table: users */
export type UsersPkColumnsInput = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type UsersPrependInput = {
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "users" */
export enum UsersSelectColumn {
  /** column name */
  AboutMe = 'aboutMe',
  /** column name */
  AboutMeVideoUrl = 'aboutMeVideoUrl',
  /** column name */
  ActiveCityId = 'activeCityId',
  /** column name */
  Birthday = 'birthday',
  /** column name */
  CityName = 'cityName',
  /** column name */
  CoachExperienceSetAt = 'coachExperienceSetAt',
  /** column name */
  CoachExperienceYears = 'coachExperienceYears',
  /** column name */
  CoachStatus = 'coachStatus',
  /** column name */
  CoachStatusUpdatedAt = 'coachStatusUpdatedAt',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DefaultCoachPaymentFulfillmentChannel = 'defaultCoachPaymentFulfillmentChannel',
  /** column name */
  DefaultCreditCardId = 'defaultCreditCardId',
  /** column name */
  DefaultSport = 'defaultSport',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  Email = 'email',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FirebaseId = 'firebaseId',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Gender = 'gender',
  /** column name */
  GenderPreference = 'genderPreference',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  IsMarketingRegistered = 'isMarketingRegistered',
  /** column name */
  IsOnboardComplete = 'isOnboardComplete',
  /** column name */
  LatestAuthProvider = 'latestAuthProvider',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  NormalizedTennisRating = 'normalizedTennisRating',
  /** column name */
  NormalizedTennisRatingScaleId = 'normalizedTennisRatingScaleId',
  /** column name */
  OriginalAuthProvider = 'originalAuthProvider',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PickleballSkillLevelId = 'pickleballSkillLevelId',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  ProfileImageFileName = 'profileImageFileName',
  /** column name */
  ProfileImagePath = 'profileImagePath',
  /** column name */
  ProfileImageProvider = 'profileImageProvider',
  /** column name */
  ProfileImageProviderId = 'profileImageProviderId',
  /** column name */
  ProfileImageProviderUrl = 'profileImageProviderUrl',
  /** column name */
  ProfileImageUrl = 'profileImageUrl',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantBusinessType = 'stripeMerchantBusinessType',
  /** column name */
  StripeMerchantChargesEnabled = 'stripeMerchantChargesEnabled',
  /** column name */
  StripeMerchantCountry = 'stripeMerchantCountry',
  /** column name */
  StripeMerchantCurrency = 'stripeMerchantCurrency',
  /** column name */
  StripeMerchantCurrentlyDue = 'stripeMerchantCurrentlyDue',
  /** column name */
  StripeMerchantDetailsSubmitted = 'stripeMerchantDetailsSubmitted',
  /** column name */
  StripeMerchantEventuallyDue = 'stripeMerchantEventuallyDue',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripeMerchantPastDue = 'stripeMerchantPastDue',
  /** column name */
  StripeMerchantPayoutsEnabled = 'stripeMerchantPayoutsEnabled',
  /** column name */
  TennisRating = 'tennisRating',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TennisSkillLevelId = 'tennisSkillLevelId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username'
}

/** input type for updating data in table "users" */
export type UsersSetInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  birthday?: InputMaybe<Scalars['date']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: InputMaybe<Scalars['uuid']>;
  defaultSport?: InputMaybe<SportsEnum>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  firebaseId?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderEnum>;
  genderPreference?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  isMarketingRegistered?: InputMaybe<Scalars['Boolean']>;
  isOnboardComplete?: InputMaybe<Scalars['Boolean']>;
  latestAuthProvider?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  originalAuthProvider?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderId?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantBusinessType?: InputMaybe<Scalars['String']>;
  stripeMerchantChargesEnabled?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantCountry?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrency?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantDetailsSubmitted?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantPayoutsEnabled?: InputMaybe<Scalars['Boolean']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type UsersStddevFields = {
  __typename?: 'UsersStddevFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate stddevPop on columns */
export type UsersStddevPopFields = {
  __typename?: 'UsersStddevPopFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate stddevSamp on columns */
export type UsersStddevSampFields = {
  __typename?: 'UsersStddevSampFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "users" */
export type UsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersStreamCursorValueInput = {
  aboutMe?: InputMaybe<Scalars['String']>;
  aboutMeVideoUrl?: InputMaybe<Scalars['String']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  birthday?: InputMaybe<Scalars['date']>;
  cityName?: InputMaybe<Scalars['String']>;
  coachExperienceSetAt?: InputMaybe<Scalars['timestamptz']>;
  coachExperienceYears?: InputMaybe<Scalars['numeric']>;
  coachStatus?: InputMaybe<CoachStatusEnum>;
  coachStatusUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  countryId?: InputMaybe<Scalars['String']>;
  countrySubdivisionId?: InputMaybe<Scalars['uuid']>;
  coverImageFileName?: InputMaybe<Scalars['String']>;
  coverImagePath?: InputMaybe<Scalars['String']>;
  coverImageProvider?: InputMaybe<Scalars['String']>;
  coverImageProviderId?: InputMaybe<Scalars['String']>;
  coverImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  coverImageUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  defaultCoachPaymentFulfillmentChannel?: InputMaybe<PaymentFulfillmentChannelsEnum>;
  defaultCreditCardId?: InputMaybe<Scalars['uuid']>;
  defaultSport?: InputMaybe<SportsEnum>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  duprId?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
  firebaseId?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<GenderEnum>;
  genderPreference?: InputMaybe<Scalars['String']>;
  geometry?: InputMaybe<Scalars['geography']>;
  id?: InputMaybe<Scalars['uuid']>;
  isMarketingRegistered?: InputMaybe<Scalars['Boolean']>;
  isOnboardComplete?: InputMaybe<Scalars['Boolean']>;
  latestAuthProvider?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRating?: InputMaybe<Scalars['numeric']>;
  normalizedTennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  originalAuthProvider?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballSkillLevelId?: InputMaybe<Scalars['String']>;
  preferredName?: InputMaybe<Scalars['String']>;
  profileImageFileName?: InputMaybe<Scalars['String']>;
  profileImagePath?: InputMaybe<Scalars['String']>;
  profileImageProvider?: InputMaybe<Scalars['String']>;
  profileImageProviderId?: InputMaybe<Scalars['String']>;
  profileImageProviderUrl?: InputMaybe<Scalars['String']>;
  /** NOTE: Keeping this field empty for now until we serve from our own custom domain */
  profileImageUrl?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  stripeMerchantBusinessType?: InputMaybe<Scalars['String']>;
  stripeMerchantChargesEnabled?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantCountry?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrency?: InputMaybe<Scalars['String']>;
  stripeMerchantCurrentlyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantDetailsSubmitted?: InputMaybe<Scalars['Boolean']>;
  stripeMerchantEventuallyDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantId?: InputMaybe<Scalars['String']>;
  stripeMerchantPastDue?: InputMaybe<Scalars['jsonb']>;
  stripeMerchantPayoutsEnabled?: InputMaybe<Scalars['Boolean']>;
  tennisRating?: InputMaybe<Scalars['numeric']>;
  tennisRatingScaleId?: InputMaybe<Scalars['uuid']>;
  tennisSkillLevelId?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  username?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type UsersSumFields = {
  __typename?: 'UsersSumFields';
  coachExperienceYears?: Maybe<Scalars['numeric']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  normalizedTennisRating?: Maybe<Scalars['numeric']>;
  tennisRating?: Maybe<Scalars['numeric']>;
};

/** update columns of table "users" */
export enum UsersUpdateColumn {
  /** column name */
  AboutMe = 'aboutMe',
  /** column name */
  AboutMeVideoUrl = 'aboutMeVideoUrl',
  /** column name */
  ActiveCityId = 'activeCityId',
  /** column name */
  Birthday = 'birthday',
  /** column name */
  CityName = 'cityName',
  /** column name */
  CoachExperienceSetAt = 'coachExperienceSetAt',
  /** column name */
  CoachExperienceYears = 'coachExperienceYears',
  /** column name */
  CoachStatus = 'coachStatus',
  /** column name */
  CoachStatusUpdatedAt = 'coachStatusUpdatedAt',
  /** column name */
  CountryId = 'countryId',
  /** column name */
  CountrySubdivisionId = 'countrySubdivisionId',
  /** column name */
  CoverImageFileName = 'coverImageFileName',
  /** column name */
  CoverImagePath = 'coverImagePath',
  /** column name */
  CoverImageProvider = 'coverImageProvider',
  /** column name */
  CoverImageProviderId = 'coverImageProviderId',
  /** column name */
  CoverImageProviderUrl = 'coverImageProviderUrl',
  /** column name */
  CoverImageUrl = 'coverImageUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DefaultCoachPaymentFulfillmentChannel = 'defaultCoachPaymentFulfillmentChannel',
  /** column name */
  DefaultCreditCardId = 'defaultCreditCardId',
  /** column name */
  DefaultSport = 'defaultSport',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DuprId = 'duprId',
  /** column name */
  Email = 'email',
  /** column name */
  EventOrganizerAccountType = 'eventOrganizerAccountType',
  /** column name */
  FirebaseId = 'firebaseId',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Gender = 'gender',
  /** column name */
  GenderPreference = 'genderPreference',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  Id = 'id',
  /** column name */
  IsMarketingRegistered = 'isMarketingRegistered',
  /** column name */
  IsOnboardComplete = 'isOnboardComplete',
  /** column name */
  LatestAuthProvider = 'latestAuthProvider',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  NormalizedTennisRating = 'normalizedTennisRating',
  /** column name */
  NormalizedTennisRatingScaleId = 'normalizedTennisRatingScaleId',
  /** column name */
  OriginalAuthProvider = 'originalAuthProvider',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PickleballSkillLevelId = 'pickleballSkillLevelId',
  /** column name */
  PreferredName = 'preferredName',
  /** column name */
  ProfileImageFileName = 'profileImageFileName',
  /** column name */
  ProfileImagePath = 'profileImagePath',
  /** column name */
  ProfileImageProvider = 'profileImageProvider',
  /** column name */
  ProfileImageProviderId = 'profileImageProviderId',
  /** column name */
  ProfileImageProviderUrl = 'profileImageProviderUrl',
  /** column name */
  ProfileImageUrl = 'profileImageUrl',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  StripeMerchantBusinessType = 'stripeMerchantBusinessType',
  /** column name */
  StripeMerchantChargesEnabled = 'stripeMerchantChargesEnabled',
  /** column name */
  StripeMerchantCountry = 'stripeMerchantCountry',
  /** column name */
  StripeMerchantCurrency = 'stripeMerchantCurrency',
  /** column name */
  StripeMerchantCurrentlyDue = 'stripeMerchantCurrentlyDue',
  /** column name */
  StripeMerchantDetailsSubmitted = 'stripeMerchantDetailsSubmitted',
  /** column name */
  StripeMerchantEventuallyDue = 'stripeMerchantEventuallyDue',
  /** column name */
  StripeMerchantId = 'stripeMerchantId',
  /** column name */
  StripeMerchantPastDue = 'stripeMerchantPastDue',
  /** column name */
  StripeMerchantPayoutsEnabled = 'stripeMerchantPayoutsEnabled',
  /** column name */
  TennisRating = 'tennisRating',
  /** column name */
  TennisRatingScaleId = 'tennisRatingScaleId',
  /** column name */
  TennisSkillLevelId = 'tennisSkillLevelId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Username = 'username'
}

export type UsersUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<UsersAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<UsersDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<UsersDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<UsersDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UsersIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<UsersPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersSetInput>;
  /** filter the rows which have to be updated */
  where: UsersBoolExp;
};

/** aggregate varPop on columns */
export type UsersVarPopFields = {
  __typename?: 'UsersVarPopFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate varSamp on columns */
export type UsersVarSampFields = {
  __typename?: 'UsersVarSampFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type UsersVarianceFields = {
  __typename?: 'UsersVarianceFields';
  coachExperienceYears?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  normalizedTennisRating?: Maybe<Scalars['Float']>;
  tennisRating?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidComparisonExp = {
  _eq?: InputMaybe<Scalars['uuid']>;
  _gt?: InputMaybe<Scalars['uuid']>;
  _gte?: InputMaybe<Scalars['uuid']>;
  _in?: InputMaybe<Array<Scalars['uuid']>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['uuid']>;
  _lte?: InputMaybe<Scalars['uuid']>;
  _neq?: InputMaybe<Scalars['uuid']>;
  _nin?: InputMaybe<Array<Scalars['uuid']>>;
};

/** columns and relationships of "venue_access_types" */
export type VenueAccessTypes = {
  __typename?: 'VenueAccessTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "venue_access_types" */
export type VenueAccessTypesAggregate = {
  __typename?: 'VenueAccessTypesAggregate';
  aggregate?: Maybe<VenueAccessTypesAggregateFields>;
  nodes: Array<VenueAccessTypes>;
};

/** aggregate fields of "venue_access_types" */
export type VenueAccessTypesAggregateFields = {
  __typename?: 'VenueAccessTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueAccessTypesMaxFields>;
  min?: Maybe<VenueAccessTypesMinFields>;
};


/** aggregate fields of "venue_access_types" */
export type VenueAccessTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue_access_types". All fields are combined with a logical 'AND'. */
export type VenueAccessTypesBoolExp = {
  _and?: InputMaybe<Array<VenueAccessTypesBoolExp>>;
  _not?: InputMaybe<VenueAccessTypesBoolExp>;
  _or?: InputMaybe<Array<VenueAccessTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "venue_access_types" */
export enum VenueAccessTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  VenueAccessTypesPkey = 'venue_access_types_pkey'
}

export enum VenueAccessTypesEnum {
  Free = 'FREE',
  Membership = 'MEMBERSHIP',
  NeedsAudit = 'NEEDS_AUDIT',
  OneTime = 'ONE_TIME',
  Private = 'PRIVATE'
}

/** Boolean expression to compare columns of type "VenueAccessTypesEnum". All fields are combined with logical 'AND'. */
export type VenueAccessTypesEnumComparisonExp = {
  _eq?: InputMaybe<VenueAccessTypesEnum>;
  _in?: InputMaybe<Array<VenueAccessTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueAccessTypesEnum>;
  _nin?: InputMaybe<Array<VenueAccessTypesEnum>>;
};

/** input type for inserting data into table "venue_access_types" */
export type VenueAccessTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type VenueAccessTypesMaxFields = {
  __typename?: 'VenueAccessTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type VenueAccessTypesMinFields = {
  __typename?: 'VenueAccessTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "venue_access_types" */
export type VenueAccessTypesMutationResponse = {
  __typename?: 'VenueAccessTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueAccessTypes>;
};

/** on_conflict condition type for table "venue_access_types" */
export type VenueAccessTypesOnConflict = {
  constraint: VenueAccessTypesConstraint;
  updateColumns?: Array<VenueAccessTypesUpdateColumn>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};

/** Ordering options when selecting data from "venue_access_types". */
export type VenueAccessTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_access_types */
export type VenueAccessTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "venue_access_types" */
export enum VenueAccessTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "venue_access_types" */
export type VenueAccessTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "venue_access_types" */
export type VenueAccessTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueAccessTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueAccessTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "venue_access_types" */
export enum VenueAccessTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type VenueAccessTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueAccessTypesSetInput>;
  /** filter the rows which have to be updated */
  where: VenueAccessTypesBoolExp;
};

/** columns and relationships of "venue_amenities" */
export type VenueAmenities = {
  __typename?: 'VenueAmenities';
  amenity: AmenitiesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "venue_amenities" */
export type VenueAmenitiesAggregate = {
  __typename?: 'VenueAmenitiesAggregate';
  aggregate?: Maybe<VenueAmenitiesAggregateFields>;
  nodes: Array<VenueAmenities>;
};

export type VenueAmenitiesAggregateBoolExp = {
  count?: InputMaybe<VenueAmenitiesAggregateBoolExpCount>;
};

/** aggregate fields of "venue_amenities" */
export type VenueAmenitiesAggregateFields = {
  __typename?: 'VenueAmenitiesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueAmenitiesMaxFields>;
  min?: Maybe<VenueAmenitiesMinFields>;
};


/** aggregate fields of "venue_amenities" */
export type VenueAmenitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "venue_amenities" */
export type VenueAmenitiesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenueAmenitiesMaxOrderBy>;
  min?: InputMaybe<VenueAmenitiesMinOrderBy>;
};

/** input type for inserting array relation for remote table "venue_amenities" */
export type VenueAmenitiesArrRelInsertInput = {
  data: Array<VenueAmenitiesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<VenueAmenitiesOnConflict>;
};

/** Boolean expression to filter rows from the table "venue_amenities". All fields are combined with a logical 'AND'. */
export type VenueAmenitiesBoolExp = {
  _and?: InputMaybe<Array<VenueAmenitiesBoolExp>>;
  _not?: InputMaybe<VenueAmenitiesBoolExp>;
  _or?: InputMaybe<Array<VenueAmenitiesBoolExp>>;
  amenity?: InputMaybe<AmenitiesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "venue_amenities" */
export enum VenueAmenitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  VenueAmenitiesPkey = 'venue_amenities_pkey',
  /** unique or primary key constraint on columns "venue_id", "amenity" */
  VenueAmenitiesVenueIdAmenityKey = 'venue_amenities_venue_id_amenity_key'
}

/** input type for inserting data into table "venue_amenities" */
export type VenueAmenitiesInsertInput = {
  amenity?: InputMaybe<AmenitiesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type VenueAmenitiesMaxFields = {
  __typename?: 'VenueAmenitiesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "venue_amenities" */
export type VenueAmenitiesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type VenueAmenitiesMinFields = {
  __typename?: 'VenueAmenitiesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "venue_amenities" */
export type VenueAmenitiesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "venue_amenities" */
export type VenueAmenitiesMutationResponse = {
  __typename?: 'VenueAmenitiesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueAmenities>;
};

/** on_conflict condition type for table "venue_amenities" */
export type VenueAmenitiesOnConflict = {
  constraint: VenueAmenitiesConstraint;
  updateColumns?: Array<VenueAmenitiesUpdateColumn>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};

/** Ordering options when selecting data from "venue_amenities". */
export type VenueAmenitiesOrderBy = {
  amenity?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_amenities */
export type VenueAmenitiesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "venue_amenities" */
export enum VenueAmenitiesSelectColumn {
  /** column name */
  Amenity = 'amenity',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

/** input type for updating data in table "venue_amenities" */
export type VenueAmenitiesSetInput = {
  amenity?: InputMaybe<AmenitiesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "venue_amenities" */
export type VenueAmenitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueAmenitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueAmenitiesStreamCursorValueInput = {
  amenity?: InputMaybe<AmenitiesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "venue_amenities" */
export enum VenueAmenitiesUpdateColumn {
  /** column name */
  Amenity = 'amenity',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

export type VenueAmenitiesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueAmenitiesSetInput>;
  /** filter the rows which have to be updated */
  where: VenueAmenitiesBoolExp;
};

/** columns and relationships of "venue_court_surfaces" */
export type VenueCourtSurfaces = {
  __typename?: 'VenueCourtSurfaces';
  courtSurface: CourtSurfacesEnum;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "venue_court_surfaces" */
export type VenueCourtSurfacesAggregate = {
  __typename?: 'VenueCourtSurfacesAggregate';
  aggregate?: Maybe<VenueCourtSurfacesAggregateFields>;
  nodes: Array<VenueCourtSurfaces>;
};

export type VenueCourtSurfacesAggregateBoolExp = {
  count?: InputMaybe<VenueCourtSurfacesAggregateBoolExpCount>;
};

/** aggregate fields of "venue_court_surfaces" */
export type VenueCourtSurfacesAggregateFields = {
  __typename?: 'VenueCourtSurfacesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueCourtSurfacesMaxFields>;
  min?: Maybe<VenueCourtSurfacesMinFields>;
};


/** aggregate fields of "venue_court_surfaces" */
export type VenueCourtSurfacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "venue_court_surfaces" */
export type VenueCourtSurfacesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenueCourtSurfacesMaxOrderBy>;
  min?: InputMaybe<VenueCourtSurfacesMinOrderBy>;
};

/** input type for inserting array relation for remote table "venue_court_surfaces" */
export type VenueCourtSurfacesArrRelInsertInput = {
  data: Array<VenueCourtSurfacesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<VenueCourtSurfacesOnConflict>;
};

/** Boolean expression to filter rows from the table "venue_court_surfaces". All fields are combined with a logical 'AND'. */
export type VenueCourtSurfacesBoolExp = {
  _and?: InputMaybe<Array<VenueCourtSurfacesBoolExp>>;
  _not?: InputMaybe<VenueCourtSurfacesBoolExp>;
  _or?: InputMaybe<Array<VenueCourtSurfacesBoolExp>>;
  courtSurface?: InputMaybe<CourtSurfacesEnumComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "venue_court_surfaces" */
export enum VenueCourtSurfacesConstraint {
  /** unique or primary key constraint on columns "id" */
  VenueCourtSurfacesPkey = 'venue_court_surfaces_pkey',
  /** unique or primary key constraint on columns "venue_id", "court_surface" */
  VenueCourtSurfacesVenueIdCourtSurfaceKey = 'venue_court_surfaces_venue_id_court_surface_key'
}

/** input type for inserting data into table "venue_court_surfaces" */
export type VenueCourtSurfacesInsertInput = {
  courtSurface?: InputMaybe<CourtSurfacesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type VenueCourtSurfacesMaxFields = {
  __typename?: 'VenueCourtSurfacesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "venue_court_surfaces" */
export type VenueCourtSurfacesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type VenueCourtSurfacesMinFields = {
  __typename?: 'VenueCourtSurfacesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "venue_court_surfaces" */
export type VenueCourtSurfacesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "venue_court_surfaces" */
export type VenueCourtSurfacesMutationResponse = {
  __typename?: 'VenueCourtSurfacesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueCourtSurfaces>;
};

/** on_conflict condition type for table "venue_court_surfaces" */
export type VenueCourtSurfacesOnConflict = {
  constraint: VenueCourtSurfacesConstraint;
  updateColumns?: Array<VenueCourtSurfacesUpdateColumn>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};

/** Ordering options when selecting data from "venue_court_surfaces". */
export type VenueCourtSurfacesOrderBy = {
  courtSurface?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_court_surfaces */
export type VenueCourtSurfacesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "venue_court_surfaces" */
export enum VenueCourtSurfacesSelectColumn {
  /** column name */
  CourtSurface = 'courtSurface',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

/** input type for updating data in table "venue_court_surfaces" */
export type VenueCourtSurfacesSetInput = {
  courtSurface?: InputMaybe<CourtSurfacesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "venue_court_surfaces" */
export type VenueCourtSurfacesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueCourtSurfacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueCourtSurfacesStreamCursorValueInput = {
  courtSurface?: InputMaybe<CourtSurfacesEnum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "venue_court_surfaces" */
export enum VenueCourtSurfacesUpdateColumn {
  /** column name */
  CourtSurface = 'courtSurface',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venueId'
}

export type VenueCourtSurfacesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueCourtSurfacesSetInput>;
  /** filter the rows which have to be updated */
  where: VenueCourtSurfacesBoolExp;
};

/** columns and relationships of "venue_facility_types" */
export type VenueFacilityTypes = {
  __typename?: 'VenueFacilityTypes';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "venue_facility_types" */
export type VenueFacilityTypesAggregate = {
  __typename?: 'VenueFacilityTypesAggregate';
  aggregate?: Maybe<VenueFacilityTypesAggregateFields>;
  nodes: Array<VenueFacilityTypes>;
};

/** aggregate fields of "venue_facility_types" */
export type VenueFacilityTypesAggregateFields = {
  __typename?: 'VenueFacilityTypesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueFacilityTypesMaxFields>;
  min?: Maybe<VenueFacilityTypesMinFields>;
};


/** aggregate fields of "venue_facility_types" */
export type VenueFacilityTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue_facility_types". All fields are combined with a logical 'AND'. */
export type VenueFacilityTypesBoolExp = {
  _and?: InputMaybe<Array<VenueFacilityTypesBoolExp>>;
  _not?: InputMaybe<VenueFacilityTypesBoolExp>;
  _or?: InputMaybe<Array<VenueFacilityTypesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "venue_facility_types" */
export enum VenueFacilityTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  VenueFacilityTypesPkey = 'venue_facility_types_pkey'
}

export enum VenueFacilityTypesEnum {
  Club = 'CLUB',
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  School = 'SCHOOL'
}

/** Boolean expression to compare columns of type "VenueFacilityTypesEnum". All fields are combined with logical 'AND'. */
export type VenueFacilityTypesEnumComparisonExp = {
  _eq?: InputMaybe<VenueFacilityTypesEnum>;
  _in?: InputMaybe<Array<VenueFacilityTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueFacilityTypesEnum>;
  _nin?: InputMaybe<Array<VenueFacilityTypesEnum>>;
};

/** input type for inserting data into table "venue_facility_types" */
export type VenueFacilityTypesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type VenueFacilityTypesMaxFields = {
  __typename?: 'VenueFacilityTypesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type VenueFacilityTypesMinFields = {
  __typename?: 'VenueFacilityTypesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "venue_facility_types" */
export type VenueFacilityTypesMutationResponse = {
  __typename?: 'VenueFacilityTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueFacilityTypes>;
};

/** on_conflict condition type for table "venue_facility_types" */
export type VenueFacilityTypesOnConflict = {
  constraint: VenueFacilityTypesConstraint;
  updateColumns?: Array<VenueFacilityTypesUpdateColumn>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};

/** Ordering options when selecting data from "venue_facility_types". */
export type VenueFacilityTypesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_facility_types */
export type VenueFacilityTypesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "venue_facility_types" */
export enum VenueFacilityTypesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "venue_facility_types" */
export type VenueFacilityTypesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "venue_facility_types" */
export type VenueFacilityTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueFacilityTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueFacilityTypesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "venue_facility_types" */
export enum VenueFacilityTypesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type VenueFacilityTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueFacilityTypesSetInput>;
  /** filter the rows which have to be updated */
  where: VenueFacilityTypesBoolExp;
};

/** columns and relationships of "venue_follows" */
export type VenueFollows = {
  __typename?: 'VenueFollows';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  status: FollowStatusesEnum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  userProfile?: Maybe<UserProfiles>;
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "venue_follows" */
export type VenueFollowsAggregate = {
  __typename?: 'VenueFollowsAggregate';
  aggregate?: Maybe<VenueFollowsAggregateFields>;
  nodes: Array<VenueFollows>;
};

/** aggregate fields of "venue_follows" */
export type VenueFollowsAggregateFields = {
  __typename?: 'VenueFollowsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueFollowsMaxFields>;
  min?: Maybe<VenueFollowsMinFields>;
};


/** aggregate fields of "venue_follows" */
export type VenueFollowsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue_follows". All fields are combined with a logical 'AND'. */
export type VenueFollowsBoolExp = {
  _and?: InputMaybe<Array<VenueFollowsBoolExp>>;
  _not?: InputMaybe<VenueFollowsBoolExp>;
  _or?: InputMaybe<Array<VenueFollowsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<FollowStatusesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userProfile?: InputMaybe<UserProfilesBoolExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "venue_follows" */
export enum VenueFollowsConstraint {
  /** unique or primary key constraint on columns "id" */
  VenueFollowsPkey = 'venue_follows_pkey',
  /** unique or primary key constraint on columns "venue_id", "user_id" */
  VenueFollowsVenueIdUserIdKey = 'venue_follows_venue_id_user_id_key'
}

/** input type for inserting data into table "venue_follows" */
export type VenueFollowsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']>;
  userProfile?: InputMaybe<UserProfilesObjRelInsertInput>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type VenueFollowsMaxFields = {
  __typename?: 'VenueFollowsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type VenueFollowsMinFields = {
  __typename?: 'VenueFollowsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "venue_follows" */
export type VenueFollowsMutationResponse = {
  __typename?: 'VenueFollowsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueFollows>;
};

/** on_conflict condition type for table "venue_follows" */
export type VenueFollowsOnConflict = {
  constraint: VenueFollowsConstraint;
  updateColumns?: Array<VenueFollowsUpdateColumn>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};

/** Ordering options when selecting data from "venue_follows". */
export type VenueFollowsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userProfile?: InputMaybe<UserProfilesOrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_follows */
export type VenueFollowsPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "venue_follows" */
export enum VenueFollowsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VenueId = 'venueId'
}

/** input type for updating data in table "venue_follows" */
export type VenueFollowsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "venue_follows" */
export type VenueFollowsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueFollowsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueFollowsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<FollowStatusesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "venue_follows" */
export enum VenueFollowsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VenueId = 'venueId'
}

export type VenueFollowsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueFollowsSetInput>;
  /** filter the rows which have to be updated */
  where: VenueFollowsBoolExp;
};

/** columns and relationships of "venue_images" */
export type VenueImages = {
  __typename?: 'VenueImages';
  attributionHtml: Scalars['String'];
  attributionName: Scalars['String'];
  attributionUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName: Scalars['String'];
  fileType?: Maybe<Scalars['String']>;
  host: Scalars['String'];
  id: Scalars['uuid'];
  isScraped: Scalars['Boolean'];
  isVisible: Scalars['Boolean'];
  path: Scalars['String'];
  provider: Scalars['String'];
  providerId: Scalars['String'];
  providerUrl: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  url: Scalars['String'];
  /** An object relationship */
  venue: Venues;
  venueId: Scalars['uuid'];
};

/** aggregated selection of "venue_images" */
export type VenueImagesAggregate = {
  __typename?: 'VenueImagesAggregate';
  aggregate?: Maybe<VenueImagesAggregateFields>;
  nodes: Array<VenueImages>;
};

export type VenueImagesAggregateBoolExp = {
  bool_and?: InputMaybe<VenueImagesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<VenueImagesAggregateBoolExpBool_Or>;
  count?: InputMaybe<VenueImagesAggregateBoolExpCount>;
};

/** aggregate fields of "venue_images" */
export type VenueImagesAggregateFields = {
  __typename?: 'VenueImagesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueImagesMaxFields>;
  min?: Maybe<VenueImagesMinFields>;
};


/** aggregate fields of "venue_images" */
export type VenueImagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueImagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "venue_images" */
export type VenueImagesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenueImagesMaxOrderBy>;
  min?: InputMaybe<VenueImagesMinOrderBy>;
};

/** input type for inserting array relation for remote table "venue_images" */
export type VenueImagesArrRelInsertInput = {
  data: Array<VenueImagesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<VenueImagesOnConflict>;
};

/** Boolean expression to filter rows from the table "venue_images". All fields are combined with a logical 'AND'. */
export type VenueImagesBoolExp = {
  _and?: InputMaybe<Array<VenueImagesBoolExp>>;
  _not?: InputMaybe<VenueImagesBoolExp>;
  _or?: InputMaybe<Array<VenueImagesBoolExp>>;
  attributionHtml?: InputMaybe<StringComparisonExp>;
  attributionName?: InputMaybe<StringComparisonExp>;
  attributionUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  fileName?: InputMaybe<StringComparisonExp>;
  fileType?: InputMaybe<StringComparisonExp>;
  host?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isScraped?: InputMaybe<BooleanComparisonExp>;
  isVisible?: InputMaybe<BooleanComparisonExp>;
  path?: InputMaybe<StringComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  providerId?: InputMaybe<StringComparisonExp>;
  providerUrl?: InputMaybe<StringComparisonExp>;
  source?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
  venue?: InputMaybe<VenuesBoolExp>;
  venueId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "venue_images" */
export enum VenueImagesConstraint {
  /** unique or primary key constraint on columns "id" */
  VenueImagesPkey = 'venue_images_pkey',
  /** unique or primary key constraint on columns "venue_id", "file_name" */
  VenueImagesVenueIdFileNameKey = 'venue_images_venue_id_file_name_key'
}

/** input type for inserting data into table "venue_images" */
export type VenueImagesInsertInput = {
  attributionHtml?: InputMaybe<Scalars['String']>;
  attributionName?: InputMaybe<Scalars['String']>;
  attributionUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isScraped?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  venue?: InputMaybe<VenuesObjRelInsertInput>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type VenueImagesMaxFields = {
  __typename?: 'VenueImagesMaxFields';
  attributionHtml?: Maybe<Scalars['String']>;
  attributionName?: Maybe<Scalars['String']>;
  attributionUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName?: Maybe<Scalars['String']>;
  fileType?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  path?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerId?: Maybe<Scalars['String']>;
  providerUrl?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  url?: Maybe<Scalars['String']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "venue_images" */
export type VenueImagesMaxOrderBy = {
  attributionHtml?: InputMaybe<OrderBy>;
  attributionName?: InputMaybe<OrderBy>;
  attributionUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type VenueImagesMinFields = {
  __typename?: 'VenueImagesMinFields';
  attributionHtml?: Maybe<Scalars['String']>;
  attributionName?: Maybe<Scalars['String']>;
  attributionUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  fileName?: Maybe<Scalars['String']>;
  fileType?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  path?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
  providerId?: Maybe<Scalars['String']>;
  providerUrl?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  url?: Maybe<Scalars['String']>;
  venueId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "venue_images" */
export type VenueImagesMinOrderBy = {
  attributionHtml?: InputMaybe<OrderBy>;
  attributionName?: InputMaybe<OrderBy>;
  attributionUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "venue_images" */
export type VenueImagesMutationResponse = {
  __typename?: 'VenueImagesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueImages>;
};

/** on_conflict condition type for table "venue_images" */
export type VenueImagesOnConflict = {
  constraint: VenueImagesConstraint;
  updateColumns?: Array<VenueImagesUpdateColumn>;
  where?: InputMaybe<VenueImagesBoolExp>;
};

/** Ordering options when selecting data from "venue_images". */
export type VenueImagesOrderBy = {
  attributionHtml?: InputMaybe<OrderBy>;
  attributionName?: InputMaybe<OrderBy>;
  attributionUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  fileName?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  host?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isScraped?: InputMaybe<OrderBy>;
  isVisible?: InputMaybe<OrderBy>;
  path?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  providerId?: InputMaybe<OrderBy>;
  providerUrl?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  venue?: InputMaybe<VenuesOrderBy>;
  venueId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_images */
export type VenueImagesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "venue_images" */
export enum VenueImagesSelectColumn {
  /** column name */
  AttributionHtml = 'attributionHtml',
  /** column name */
  AttributionName = 'attributionName',
  /** column name */
  AttributionUrl = 'attributionUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  FileType = 'fileType',
  /** column name */
  Host = 'host',
  /** column name */
  Id = 'id',
  /** column name */
  IsScraped = 'isScraped',
  /** column name */
  IsVisible = 'isVisible',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  Source = 'source',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  VenueId = 'venueId'
}

/** select "venueImagesAggregateBoolExpBool_andArgumentsColumns" columns of table "venue_images" */
export enum VenueImagesSelectColumnVenueImagesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsScraped = 'isScraped',
  /** column name */
  IsVisible = 'isVisible'
}

/** select "venueImagesAggregateBoolExpBool_orArgumentsColumns" columns of table "venue_images" */
export enum VenueImagesSelectColumnVenueImagesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsScraped = 'isScraped',
  /** column name */
  IsVisible = 'isVisible'
}

/** input type for updating data in table "venue_images" */
export type VenueImagesSetInput = {
  attributionHtml?: InputMaybe<Scalars['String']>;
  attributionName?: InputMaybe<Scalars['String']>;
  attributionUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isScraped?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "venue_images" */
export type VenueImagesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueImagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueImagesStreamCursorValueInput = {
  attributionHtml?: InputMaybe<Scalars['String']>;
  attributionName?: InputMaybe<Scalars['String']>;
  attributionUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  fileName?: InputMaybe<Scalars['String']>;
  fileType?: InputMaybe<Scalars['String']>;
  host?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isScraped?: InputMaybe<Scalars['Boolean']>;
  isVisible?: InputMaybe<Scalars['Boolean']>;
  path?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUrl?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  url?: InputMaybe<Scalars['String']>;
  venueId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "venue_images" */
export enum VenueImagesUpdateColumn {
  /** column name */
  AttributionHtml = 'attributionHtml',
  /** column name */
  AttributionName = 'attributionName',
  /** column name */
  AttributionUrl = 'attributionUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  FileName = 'fileName',
  /** column name */
  FileType = 'fileType',
  /** column name */
  Host = 'host',
  /** column name */
  Id = 'id',
  /** column name */
  IsScraped = 'isScraped',
  /** column name */
  IsVisible = 'isVisible',
  /** column name */
  Path = 'path',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUrl = 'providerUrl',
  /** column name */
  Source = 'source',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  VenueId = 'venueId'
}

export type VenueImagesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueImagesSetInput>;
  /** filter the rows which have to be updated */
  where: VenueImagesBoolExp;
};

/** columns and relationships of "venue_lines" */
export type VenueLines = {
  __typename?: 'VenueLines';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "venue_lines" */
export type VenueLinesAggregate = {
  __typename?: 'VenueLinesAggregate';
  aggregate?: Maybe<VenueLinesAggregateFields>;
  nodes: Array<VenueLines>;
};

/** aggregate fields of "venue_lines" */
export type VenueLinesAggregateFields = {
  __typename?: 'VenueLinesAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueLinesMaxFields>;
  min?: Maybe<VenueLinesMinFields>;
};


/** aggregate fields of "venue_lines" */
export type VenueLinesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueLinesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue_lines". All fields are combined with a logical 'AND'. */
export type VenueLinesBoolExp = {
  _and?: InputMaybe<Array<VenueLinesBoolExp>>;
  _not?: InputMaybe<VenueLinesBoolExp>;
  _or?: InputMaybe<Array<VenueLinesBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "venue_lines" */
export enum VenueLinesConstraint {
  /** unique or primary key constraint on columns "value" */
  VenueLinesPkey = 'venue_lines_pkey'
}

export enum VenueLinesEnum {
  Chalk = 'CHALK',
  Permanent = 'PERMANENT',
  Tape = 'TAPE',
  Temporary = 'TEMPORARY'
}

/** Boolean expression to compare columns of type "VenueLinesEnum". All fields are combined with logical 'AND'. */
export type VenueLinesEnumComparisonExp = {
  _eq?: InputMaybe<VenueLinesEnum>;
  _in?: InputMaybe<Array<VenueLinesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueLinesEnum>;
  _nin?: InputMaybe<Array<VenueLinesEnum>>;
};

/** input type for inserting data into table "venue_lines" */
export type VenueLinesInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type VenueLinesMaxFields = {
  __typename?: 'VenueLinesMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type VenueLinesMinFields = {
  __typename?: 'VenueLinesMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "venue_lines" */
export type VenueLinesMutationResponse = {
  __typename?: 'VenueLinesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueLines>;
};

/** on_conflict condition type for table "venue_lines" */
export type VenueLinesOnConflict = {
  constraint: VenueLinesConstraint;
  updateColumns?: Array<VenueLinesUpdateColumn>;
  where?: InputMaybe<VenueLinesBoolExp>;
};

/** Ordering options when selecting data from "venue_lines". */
export type VenueLinesOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_lines */
export type VenueLinesPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "venue_lines" */
export enum VenueLinesSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "venue_lines" */
export type VenueLinesSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "venue_lines" */
export type VenueLinesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueLinesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueLinesStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "venue_lines" */
export enum VenueLinesUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type VenueLinesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueLinesSetInput>;
  /** filter the rows which have to be updated */
  where: VenueLinesBoolExp;
};

/** columns and relationships of "venue_nets" */
export type VenueNets = {
  __typename?: 'VenueNets';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "venue_nets" */
export type VenueNetsAggregate = {
  __typename?: 'VenueNetsAggregate';
  aggregate?: Maybe<VenueNetsAggregateFields>;
  nodes: Array<VenueNets>;
};

/** aggregate fields of "venue_nets" */
export type VenueNetsAggregateFields = {
  __typename?: 'VenueNetsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<VenueNetsMaxFields>;
  min?: Maybe<VenueNetsMinFields>;
};


/** aggregate fields of "venue_nets" */
export type VenueNetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenueNetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue_nets". All fields are combined with a logical 'AND'. */
export type VenueNetsBoolExp = {
  _and?: InputMaybe<Array<VenueNetsBoolExp>>;
  _not?: InputMaybe<VenueNetsBoolExp>;
  _or?: InputMaybe<Array<VenueNetsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "venue_nets" */
export enum VenueNetsConstraint {
  /** unique or primary key constraint on columns "value" */
  VenueNetsPkey = 'venue_nets_pkey'
}

export enum VenueNetsEnum {
  BringYourOwn = 'BRING_YOUR_OWN',
  Permanent = 'PERMANENT',
  Portable = 'PORTABLE',
  Tennis = 'TENNIS'
}

/** Boolean expression to compare columns of type "VenueNetsEnum". All fields are combined with logical 'AND'. */
export type VenueNetsEnumComparisonExp = {
  _eq?: InputMaybe<VenueNetsEnum>;
  _in?: InputMaybe<Array<VenueNetsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<VenueNetsEnum>;
  _nin?: InputMaybe<Array<VenueNetsEnum>>;
};

/** input type for inserting data into table "venue_nets" */
export type VenueNetsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type VenueNetsMaxFields = {
  __typename?: 'VenueNetsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type VenueNetsMinFields = {
  __typename?: 'VenueNetsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "venue_nets" */
export type VenueNetsMutationResponse = {
  __typename?: 'VenueNetsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VenueNets>;
};

/** on_conflict condition type for table "venue_nets" */
export type VenueNetsOnConflict = {
  constraint: VenueNetsConstraint;
  updateColumns?: Array<VenueNetsUpdateColumn>;
  where?: InputMaybe<VenueNetsBoolExp>;
};

/** Ordering options when selecting data from "venue_nets". */
export type VenueNetsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venue_nets */
export type VenueNetsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "venue_nets" */
export enum VenueNetsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "venue_nets" */
export type VenueNetsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "venue_nets" */
export type VenueNetsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenueNetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenueNetsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "venue_nets" */
export enum VenueNetsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type VenueNetsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenueNetsSetInput>;
  /** filter the rows which have to be updated */
  where: VenueNetsBoolExp;
};

/** columns and relationships of "venues" */
export type Venues = {
  __typename?: 'Venues';
  accessDetails: Scalars['String'];
  accessType?: Maybe<VenueAccessTypesEnum>;
  addressString: Scalars['String'];
  /** An array relationship */
  amenities: Array<VenueAmenities>;
  /** An aggregate relationship */
  amenitiesAggregate: VenueAmenitiesAggregate;
  /** An object relationship */
  city?: Maybe<Cities>;
  cityId?: Maybe<Scalars['uuid']>;
  coordinatesWkb: Scalars['String'];
  /** An array relationship */
  courtSurfaces: Array<VenueCourtSurfaces>;
  /** An aggregate relationship */
  courtSurfacesAggregate: VenueCourtSurfacesAggregate;
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description: Scalars['String'];
  email: Scalars['String'];
  facilityType?: Maybe<VenueFacilityTypesEnum>;
  featuredPriority?: Maybe<Scalars['Int']>;
  geometry?: Maybe<Scalars['geography']>;
  /** An array relationship */
  groups: Array<GroupVenues>;
  /** An aggregate relationship */
  groupsAggregate: GroupVenuesAggregate;
  hasPickleball: Scalars['Boolean'];
  hasReservations?: Maybe<Scalars['Boolean']>;
  id: Scalars['uuid'];
  /** An array relationship */
  images: Array<VenueImages>;
  /** An aggregate relationship */
  imagesAggregate: VenueImagesAggregate;
  indoorCourtCount: Scalars['Int'];
  isActive: Scalars['Boolean'];
  latitude: Scalars['numeric'];
  longitude: Scalars['numeric'];
  outdoorCourtCount: Scalars['Int'];
  phoneNumber: Scalars['String'];
  pickleballLines?: Maybe<VenueLinesEnum>;
  pickleballNets?: Maybe<VenueNetsEnum>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  scheduleDetails: Scalars['String'];
  shouldHideDefaultDescription: Scalars['Boolean'];
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  sourceCity?: Maybe<Scalars['String']>;
  sourceCityId?: Maybe<Scalars['String']>;
  sourceCitySlug?: Maybe<Scalars['String']>;
  sourceCountry?: Maybe<Scalars['String']>;
  sourceCountrySlug?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceLastFetchedAt?: Maybe<Scalars['timestamptz']>;
  sourceLastUpdatedAt?: Maybe<Scalars['timestamptz']>;
  sourceName?: Maybe<Scalars['String']>;
  sourceStateName?: Maybe<Scalars['String']>;
  sourceStateShort?: Maybe<Scalars['String']>;
  sourceStateSlug?: Maybe<Scalars['String']>;
  timezone: Scalars['String'];
  title: Scalars['String'];
  totalCourtCount: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
  venueSlug: Scalars['String'];
  websiteUrl: Scalars['String'];
};


/** columns and relationships of "venues" */
export type VenuesAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesAmenitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesCourtSurfacesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesImagesArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesImagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


/** columns and relationships of "venues" */
export type VenuesPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};

/** aggregated selection of "venues" */
export type VenuesAggregate = {
  __typename?: 'VenuesAggregate';
  aggregate?: Maybe<VenuesAggregateFields>;
  nodes: Array<Venues>;
};

export type VenuesAggregateBoolExp = {
  bool_and?: InputMaybe<VenuesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<VenuesAggregateBoolExpBool_Or>;
  count?: InputMaybe<VenuesAggregateBoolExpCount>;
};

/** aggregate fields of "venues" */
export type VenuesAggregateFields = {
  __typename?: 'VenuesAggregateFields';
  avg?: Maybe<VenuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<VenuesMaxFields>;
  min?: Maybe<VenuesMinFields>;
  stddev?: Maybe<VenuesStddevFields>;
  stddevPop?: Maybe<VenuesStddevPopFields>;
  stddevSamp?: Maybe<VenuesStddevSampFields>;
  sum?: Maybe<VenuesSumFields>;
  varPop?: Maybe<VenuesVarPopFields>;
  varSamp?: Maybe<VenuesVarSampFields>;
  variance?: Maybe<VenuesVarianceFields>;
};


/** aggregate fields of "venues" */
export type VenuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VenuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "venues" */
export type VenuesAggregateOrderBy = {
  avg?: InputMaybe<VenuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VenuesMaxOrderBy>;
  min?: InputMaybe<VenuesMinOrderBy>;
  stddev?: InputMaybe<VenuesStddevOrderBy>;
  stddevPop?: InputMaybe<VenuesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<VenuesStddevSampOrderBy>;
  sum?: InputMaybe<VenuesSumOrderBy>;
  varPop?: InputMaybe<VenuesVarPopOrderBy>;
  varSamp?: InputMaybe<VenuesVarSampOrderBy>;
  variance?: InputMaybe<VenuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "venues" */
export type VenuesArrRelInsertInput = {
  data: Array<VenuesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<VenuesOnConflict>;
};

/** aggregate avg on columns */
export type VenuesAvgFields = {
  __typename?: 'VenuesAvgFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "venues" */
export type VenuesAvgOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "venues". All fields are combined with a logical 'AND'. */
export type VenuesBoolExp = {
  _and?: InputMaybe<Array<VenuesBoolExp>>;
  _not?: InputMaybe<VenuesBoolExp>;
  _or?: InputMaybe<Array<VenuesBoolExp>>;
  accessDetails?: InputMaybe<StringComparisonExp>;
  accessType?: InputMaybe<VenueAccessTypesEnumComparisonExp>;
  addressString?: InputMaybe<StringComparisonExp>;
  amenities?: InputMaybe<VenueAmenitiesBoolExp>;
  amenitiesAggregate?: InputMaybe<VenueAmenitiesAggregateBoolExp>;
  city?: InputMaybe<CitiesBoolExp>;
  cityId?: InputMaybe<UuidComparisonExp>;
  coordinatesWkb?: InputMaybe<StringComparisonExp>;
  courtSurfaces?: InputMaybe<VenueCourtSurfacesBoolExp>;
  courtSurfacesAggregate?: InputMaybe<VenueCourtSurfacesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  facilityType?: InputMaybe<VenueFacilityTypesEnumComparisonExp>;
  featuredPriority?: InputMaybe<IntComparisonExp>;
  geometry?: InputMaybe<GeographyComparisonExp>;
  groups?: InputMaybe<GroupVenuesBoolExp>;
  groupsAggregate?: InputMaybe<GroupVenuesAggregateBoolExp>;
  hasPickleball?: InputMaybe<BooleanComparisonExp>;
  hasReservations?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  images?: InputMaybe<VenueImagesBoolExp>;
  imagesAggregate?: InputMaybe<VenueImagesAggregateBoolExp>;
  indoorCourtCount?: InputMaybe<IntComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  latitude?: InputMaybe<NumericComparisonExp>;
  longitude?: InputMaybe<NumericComparisonExp>;
  outdoorCourtCount?: InputMaybe<IntComparisonExp>;
  phoneNumber?: InputMaybe<StringComparisonExp>;
  pickleballLines?: InputMaybe<VenueLinesEnumComparisonExp>;
  pickleballNets?: InputMaybe<VenueNetsEnumComparisonExp>;
  playSessions?: InputMaybe<PlaySessionsBoolExp>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateBoolExp>;
  scheduleDetails?: InputMaybe<StringComparisonExp>;
  shouldHideDefaultDescription?: InputMaybe<BooleanComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  source?: InputMaybe<StringComparisonExp>;
  sourceCity?: InputMaybe<StringComparisonExp>;
  sourceCityId?: InputMaybe<StringComparisonExp>;
  sourceCitySlug?: InputMaybe<StringComparisonExp>;
  sourceCountry?: InputMaybe<StringComparisonExp>;
  sourceCountrySlug?: InputMaybe<StringComparisonExp>;
  sourceId?: InputMaybe<StringComparisonExp>;
  sourceLastFetchedAt?: InputMaybe<TimestamptzComparisonExp>;
  sourceLastUpdatedAt?: InputMaybe<TimestamptzComparisonExp>;
  sourceName?: InputMaybe<StringComparisonExp>;
  sourceStateName?: InputMaybe<StringComparisonExp>;
  sourceStateShort?: InputMaybe<StringComparisonExp>;
  sourceStateSlug?: InputMaybe<StringComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  totalCourtCount?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  venueSlug?: InputMaybe<StringComparisonExp>;
  websiteUrl?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "venues" */
export enum VenuesConstraint {
  /** unique or primary key constraint on columns "id" */
  VenuesPkey = 'venues_pkey',
  /** unique or primary key constraint on columns "slug" */
  VenuesSlugKey = 'venues_slug_key',
  /** unique or primary key constraint on columns "source_id" */
  VenuesSourceIdKey = 'venues_source_id_key'
}

/** input type for incrementing numeric columns in table "venues" */
export type VenuesIncInput = {
  featuredPriority?: InputMaybe<Scalars['Int']>;
  indoorCourtCount?: InputMaybe<Scalars['Int']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  outdoorCourtCount?: InputMaybe<Scalars['Int']>;
  totalCourtCount?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "venues" */
export type VenuesInsertInput = {
  accessDetails?: InputMaybe<Scalars['String']>;
  accessType?: InputMaybe<VenueAccessTypesEnum>;
  addressString?: InputMaybe<Scalars['String']>;
  amenities?: InputMaybe<VenueAmenitiesArrRelInsertInput>;
  city?: InputMaybe<CitiesObjRelInsertInput>;
  cityId?: InputMaybe<Scalars['uuid']>;
  coordinatesWkb?: InputMaybe<Scalars['String']>;
  courtSurfaces?: InputMaybe<VenueCourtSurfacesArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  facilityType?: InputMaybe<VenueFacilityTypesEnum>;
  featuredPriority?: InputMaybe<Scalars['Int']>;
  geometry?: InputMaybe<Scalars['geography']>;
  groups?: InputMaybe<GroupVenuesArrRelInsertInput>;
  hasPickleball?: InputMaybe<Scalars['Boolean']>;
  hasReservations?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  images?: InputMaybe<VenueImagesArrRelInsertInput>;
  indoorCourtCount?: InputMaybe<Scalars['Int']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  outdoorCourtCount?: InputMaybe<Scalars['Int']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballLines?: InputMaybe<VenueLinesEnum>;
  pickleballNets?: InputMaybe<VenueNetsEnum>;
  playSessions?: InputMaybe<PlaySessionsArrRelInsertInput>;
  scheduleDetails?: InputMaybe<Scalars['String']>;
  shouldHideDefaultDescription?: InputMaybe<Scalars['Boolean']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceCity?: InputMaybe<Scalars['String']>;
  sourceCityId?: InputMaybe<Scalars['String']>;
  sourceCitySlug?: InputMaybe<Scalars['String']>;
  sourceCountry?: InputMaybe<Scalars['String']>;
  sourceCountrySlug?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceLastFetchedAt?: InputMaybe<Scalars['timestamptz']>;
  sourceLastUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  sourceName?: InputMaybe<Scalars['String']>;
  sourceStateName?: InputMaybe<Scalars['String']>;
  sourceStateShort?: InputMaybe<Scalars['String']>;
  sourceStateSlug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  totalCourtCount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueSlug?: InputMaybe<Scalars['String']>;
  websiteUrl?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type VenuesMaxFields = {
  __typename?: 'VenuesMaxFields';
  accessDetails?: Maybe<Scalars['String']>;
  addressString?: Maybe<Scalars['String']>;
  cityId?: Maybe<Scalars['uuid']>;
  coordinatesWkb?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  featuredPriority?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  indoorCourtCount?: Maybe<Scalars['Int']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  outdoorCourtCount?: Maybe<Scalars['Int']>;
  phoneNumber?: Maybe<Scalars['String']>;
  scheduleDetails?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  sourceCity?: Maybe<Scalars['String']>;
  sourceCityId?: Maybe<Scalars['String']>;
  sourceCitySlug?: Maybe<Scalars['String']>;
  sourceCountry?: Maybe<Scalars['String']>;
  sourceCountrySlug?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceLastFetchedAt?: Maybe<Scalars['timestamptz']>;
  sourceLastUpdatedAt?: Maybe<Scalars['timestamptz']>;
  sourceName?: Maybe<Scalars['String']>;
  sourceStateName?: Maybe<Scalars['String']>;
  sourceStateShort?: Maybe<Scalars['String']>;
  sourceStateSlug?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalCourtCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueSlug?: Maybe<Scalars['String']>;
  websiteUrl?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "venues" */
export type VenuesMaxOrderBy = {
  accessDetails?: InputMaybe<OrderBy>;
  addressString?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  coordinatesWkb?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  featuredPriority?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  scheduleDetails?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceCity?: InputMaybe<OrderBy>;
  sourceCityId?: InputMaybe<OrderBy>;
  sourceCitySlug?: InputMaybe<OrderBy>;
  sourceCountry?: InputMaybe<OrderBy>;
  sourceCountrySlug?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceLastFetchedAt?: InputMaybe<OrderBy>;
  sourceLastUpdatedAt?: InputMaybe<OrderBy>;
  sourceName?: InputMaybe<OrderBy>;
  sourceStateName?: InputMaybe<OrderBy>;
  sourceStateShort?: InputMaybe<OrderBy>;
  sourceStateSlug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueSlug?: InputMaybe<OrderBy>;
  websiteUrl?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type VenuesMinFields = {
  __typename?: 'VenuesMinFields';
  accessDetails?: Maybe<Scalars['String']>;
  addressString?: Maybe<Scalars['String']>;
  cityId?: Maybe<Scalars['uuid']>;
  coordinatesWkb?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  featuredPriority?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  indoorCourtCount?: Maybe<Scalars['Int']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  outdoorCourtCount?: Maybe<Scalars['Int']>;
  phoneNumber?: Maybe<Scalars['String']>;
  scheduleDetails?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  sourceCity?: Maybe<Scalars['String']>;
  sourceCityId?: Maybe<Scalars['String']>;
  sourceCitySlug?: Maybe<Scalars['String']>;
  sourceCountry?: Maybe<Scalars['String']>;
  sourceCountrySlug?: Maybe<Scalars['String']>;
  sourceId?: Maybe<Scalars['String']>;
  sourceLastFetchedAt?: Maybe<Scalars['timestamptz']>;
  sourceLastUpdatedAt?: Maybe<Scalars['timestamptz']>;
  sourceName?: Maybe<Scalars['String']>;
  sourceStateName?: Maybe<Scalars['String']>;
  sourceStateShort?: Maybe<Scalars['String']>;
  sourceStateSlug?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalCourtCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venueSlug?: Maybe<Scalars['String']>;
  websiteUrl?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "venues" */
export type VenuesMinOrderBy = {
  accessDetails?: InputMaybe<OrderBy>;
  addressString?: InputMaybe<OrderBy>;
  cityId?: InputMaybe<OrderBy>;
  coordinatesWkb?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  featuredPriority?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  scheduleDetails?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceCity?: InputMaybe<OrderBy>;
  sourceCityId?: InputMaybe<OrderBy>;
  sourceCitySlug?: InputMaybe<OrderBy>;
  sourceCountry?: InputMaybe<OrderBy>;
  sourceCountrySlug?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceLastFetchedAt?: InputMaybe<OrderBy>;
  sourceLastUpdatedAt?: InputMaybe<OrderBy>;
  sourceName?: InputMaybe<OrderBy>;
  sourceStateName?: InputMaybe<OrderBy>;
  sourceStateShort?: InputMaybe<OrderBy>;
  sourceStateSlug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueSlug?: InputMaybe<OrderBy>;
  websiteUrl?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "venues" */
export type VenuesMutationResponse = {
  __typename?: 'VenuesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Venues>;
};

/** input type for inserting object relation for remote table "venues" */
export type VenuesObjRelInsertInput = {
  data: VenuesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<VenuesOnConflict>;
};

/** on_conflict condition type for table "venues" */
export type VenuesOnConflict = {
  constraint: VenuesConstraint;
  updateColumns?: Array<VenuesUpdateColumn>;
  where?: InputMaybe<VenuesBoolExp>;
};

/** Ordering options when selecting data from "venues". */
export type VenuesOrderBy = {
  accessDetails?: InputMaybe<OrderBy>;
  accessType?: InputMaybe<OrderBy>;
  addressString?: InputMaybe<OrderBy>;
  amenitiesAggregate?: InputMaybe<VenueAmenitiesAggregateOrderBy>;
  city?: InputMaybe<CitiesOrderBy>;
  cityId?: InputMaybe<OrderBy>;
  coordinatesWkb?: InputMaybe<OrderBy>;
  courtSurfacesAggregate?: InputMaybe<VenueCourtSurfacesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  facilityType?: InputMaybe<OrderBy>;
  featuredPriority?: InputMaybe<OrderBy>;
  geometry?: InputMaybe<OrderBy>;
  groupsAggregate?: InputMaybe<GroupVenuesAggregateOrderBy>;
  hasPickleball?: InputMaybe<OrderBy>;
  hasReservations?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imagesAggregate?: InputMaybe<VenueImagesAggregateOrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  phoneNumber?: InputMaybe<OrderBy>;
  pickleballLines?: InputMaybe<OrderBy>;
  pickleballNets?: InputMaybe<OrderBy>;
  playSessionsAggregate?: InputMaybe<PlaySessionsAggregateOrderBy>;
  scheduleDetails?: InputMaybe<OrderBy>;
  shouldHideDefaultDescription?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  source?: InputMaybe<OrderBy>;
  sourceCity?: InputMaybe<OrderBy>;
  sourceCityId?: InputMaybe<OrderBy>;
  sourceCitySlug?: InputMaybe<OrderBy>;
  sourceCountry?: InputMaybe<OrderBy>;
  sourceCountrySlug?: InputMaybe<OrderBy>;
  sourceId?: InputMaybe<OrderBy>;
  sourceLastFetchedAt?: InputMaybe<OrderBy>;
  sourceLastUpdatedAt?: InputMaybe<OrderBy>;
  sourceName?: InputMaybe<OrderBy>;
  sourceStateName?: InputMaybe<OrderBy>;
  sourceStateShort?: InputMaybe<OrderBy>;
  sourceStateSlug?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  venueSlug?: InputMaybe<OrderBy>;
  websiteUrl?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: venues */
export type VenuesPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "venues" */
export enum VenuesSelectColumn {
  /** column name */
  AccessDetails = 'accessDetails',
  /** column name */
  AccessType = 'accessType',
  /** column name */
  AddressString = 'addressString',
  /** column name */
  CityId = 'cityId',
  /** column name */
  CoordinatesWkb = 'coordinatesWkb',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Email = 'email',
  /** column name */
  FacilityType = 'facilityType',
  /** column name */
  FeaturedPriority = 'featuredPriority',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  HasPickleball = 'hasPickleball',
  /** column name */
  HasReservations = 'hasReservations',
  /** column name */
  Id = 'id',
  /** column name */
  IndoorCourtCount = 'indoorCourtCount',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  OutdoorCourtCount = 'outdoorCourtCount',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PickleballLines = 'pickleballLines',
  /** column name */
  PickleballNets = 'pickleballNets',
  /** column name */
  ScheduleDetails = 'scheduleDetails',
  /** column name */
  ShouldHideDefaultDescription = 'shouldHideDefaultDescription',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceCity = 'sourceCity',
  /** column name */
  SourceCityId = 'sourceCityId',
  /** column name */
  SourceCitySlug = 'sourceCitySlug',
  /** column name */
  SourceCountry = 'sourceCountry',
  /** column name */
  SourceCountrySlug = 'sourceCountrySlug',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  SourceLastFetchedAt = 'sourceLastFetchedAt',
  /** column name */
  SourceLastUpdatedAt = 'sourceLastUpdatedAt',
  /** column name */
  SourceName = 'sourceName',
  /** column name */
  SourceStateName = 'sourceStateName',
  /** column name */
  SourceStateShort = 'sourceStateShort',
  /** column name */
  SourceStateSlug = 'sourceStateSlug',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Title = 'title',
  /** column name */
  TotalCourtCount = 'totalCourtCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueSlug = 'venueSlug',
  /** column name */
  WebsiteUrl = 'websiteUrl'
}

/** select "venuesAggregateBoolExpBool_andArgumentsColumns" columns of table "venues" */
export enum VenuesSelectColumnVenuesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  HasPickleball = 'hasPickleball',
  /** column name */
  HasReservations = 'hasReservations',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  ShouldHideDefaultDescription = 'shouldHideDefaultDescription'
}

/** select "venuesAggregateBoolExpBool_orArgumentsColumns" columns of table "venues" */
export enum VenuesSelectColumnVenuesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  HasPickleball = 'hasPickleball',
  /** column name */
  HasReservations = 'hasReservations',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  ShouldHideDefaultDescription = 'shouldHideDefaultDescription'
}

/** input type for updating data in table "venues" */
export type VenuesSetInput = {
  accessDetails?: InputMaybe<Scalars['String']>;
  accessType?: InputMaybe<VenueAccessTypesEnum>;
  addressString?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  coordinatesWkb?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  facilityType?: InputMaybe<VenueFacilityTypesEnum>;
  featuredPriority?: InputMaybe<Scalars['Int']>;
  geometry?: InputMaybe<Scalars['geography']>;
  hasPickleball?: InputMaybe<Scalars['Boolean']>;
  hasReservations?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  indoorCourtCount?: InputMaybe<Scalars['Int']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  outdoorCourtCount?: InputMaybe<Scalars['Int']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballLines?: InputMaybe<VenueLinesEnum>;
  pickleballNets?: InputMaybe<VenueNetsEnum>;
  scheduleDetails?: InputMaybe<Scalars['String']>;
  shouldHideDefaultDescription?: InputMaybe<Scalars['Boolean']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceCity?: InputMaybe<Scalars['String']>;
  sourceCityId?: InputMaybe<Scalars['String']>;
  sourceCitySlug?: InputMaybe<Scalars['String']>;
  sourceCountry?: InputMaybe<Scalars['String']>;
  sourceCountrySlug?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceLastFetchedAt?: InputMaybe<Scalars['timestamptz']>;
  sourceLastUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  sourceName?: InputMaybe<Scalars['String']>;
  sourceStateName?: InputMaybe<Scalars['String']>;
  sourceStateShort?: InputMaybe<Scalars['String']>;
  sourceStateSlug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  totalCourtCount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueSlug?: InputMaybe<Scalars['String']>;
  websiteUrl?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type VenuesStddevFields = {
  __typename?: 'VenuesStddevFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "venues" */
export type VenuesStddevOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type VenuesStddevPopFields = {
  __typename?: 'VenuesStddevPopFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by stddevPop() on columns of table "venues" */
export type VenuesStddevPopOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type VenuesStddevSampFields = {
  __typename?: 'VenuesStddevSampFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by stddevSamp() on columns of table "venues" */
export type VenuesStddevSampOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "venues" */
export type VenuesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VenuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VenuesStreamCursorValueInput = {
  accessDetails?: InputMaybe<Scalars['String']>;
  accessType?: InputMaybe<VenueAccessTypesEnum>;
  addressString?: InputMaybe<Scalars['String']>;
  cityId?: InputMaybe<Scalars['uuid']>;
  coordinatesWkb?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  facilityType?: InputMaybe<VenueFacilityTypesEnum>;
  featuredPriority?: InputMaybe<Scalars['Int']>;
  geometry?: InputMaybe<Scalars['geography']>;
  hasPickleball?: InputMaybe<Scalars['Boolean']>;
  hasReservations?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  indoorCourtCount?: InputMaybe<Scalars['Int']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  outdoorCourtCount?: InputMaybe<Scalars['Int']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pickleballLines?: InputMaybe<VenueLinesEnum>;
  pickleballNets?: InputMaybe<VenueNetsEnum>;
  scheduleDetails?: InputMaybe<Scalars['String']>;
  shouldHideDefaultDescription?: InputMaybe<Scalars['Boolean']>;
  slug?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  sourceCity?: InputMaybe<Scalars['String']>;
  sourceCityId?: InputMaybe<Scalars['String']>;
  sourceCitySlug?: InputMaybe<Scalars['String']>;
  sourceCountry?: InputMaybe<Scalars['String']>;
  sourceCountrySlug?: InputMaybe<Scalars['String']>;
  sourceId?: InputMaybe<Scalars['String']>;
  sourceLastFetchedAt?: InputMaybe<Scalars['timestamptz']>;
  sourceLastUpdatedAt?: InputMaybe<Scalars['timestamptz']>;
  sourceName?: InputMaybe<Scalars['String']>;
  sourceStateName?: InputMaybe<Scalars['String']>;
  sourceStateShort?: InputMaybe<Scalars['String']>;
  sourceStateSlug?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  totalCourtCount?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venueSlug?: InputMaybe<Scalars['String']>;
  websiteUrl?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type VenuesSumFields = {
  __typename?: 'VenuesSumFields';
  featuredPriority?: Maybe<Scalars['Int']>;
  indoorCourtCount?: Maybe<Scalars['Int']>;
  latitude?: Maybe<Scalars['numeric']>;
  longitude?: Maybe<Scalars['numeric']>;
  outdoorCourtCount?: Maybe<Scalars['Int']>;
  totalCourtCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "venues" */
export type VenuesSumOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** update columns of table "venues" */
export enum VenuesUpdateColumn {
  /** column name */
  AccessDetails = 'accessDetails',
  /** column name */
  AccessType = 'accessType',
  /** column name */
  AddressString = 'addressString',
  /** column name */
  CityId = 'cityId',
  /** column name */
  CoordinatesWkb = 'coordinatesWkb',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  Email = 'email',
  /** column name */
  FacilityType = 'facilityType',
  /** column name */
  FeaturedPriority = 'featuredPriority',
  /** column name */
  Geometry = 'geometry',
  /** column name */
  HasPickleball = 'hasPickleball',
  /** column name */
  HasReservations = 'hasReservations',
  /** column name */
  Id = 'id',
  /** column name */
  IndoorCourtCount = 'indoorCourtCount',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  OutdoorCourtCount = 'outdoorCourtCount',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PickleballLines = 'pickleballLines',
  /** column name */
  PickleballNets = 'pickleballNets',
  /** column name */
  ScheduleDetails = 'scheduleDetails',
  /** column name */
  ShouldHideDefaultDescription = 'shouldHideDefaultDescription',
  /** column name */
  Slug = 'slug',
  /** column name */
  Source = 'source',
  /** column name */
  SourceCity = 'sourceCity',
  /** column name */
  SourceCityId = 'sourceCityId',
  /** column name */
  SourceCitySlug = 'sourceCitySlug',
  /** column name */
  SourceCountry = 'sourceCountry',
  /** column name */
  SourceCountrySlug = 'sourceCountrySlug',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  SourceLastFetchedAt = 'sourceLastFetchedAt',
  /** column name */
  SourceLastUpdatedAt = 'sourceLastUpdatedAt',
  /** column name */
  SourceName = 'sourceName',
  /** column name */
  SourceStateName = 'sourceStateName',
  /** column name */
  SourceStateShort = 'sourceStateShort',
  /** column name */
  SourceStateSlug = 'sourceStateSlug',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Title = 'title',
  /** column name */
  TotalCourtCount = 'totalCourtCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueSlug = 'venueSlug',
  /** column name */
  WebsiteUrl = 'websiteUrl'
}

export type VenuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<VenuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VenuesSetInput>;
  /** filter the rows which have to be updated */
  where: VenuesBoolExp;
};

/** aggregate varPop on columns */
export type VenuesVarPopFields = {
  __typename?: 'VenuesVarPopFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by varPop() on columns of table "venues" */
export type VenuesVarPopOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type VenuesVarSampFields = {
  __typename?: 'VenuesVarSampFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by varSamp() on columns of table "venues" */
export type VenuesVarSampOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type VenuesVarianceFields = {
  __typename?: 'VenuesVarianceFields';
  featuredPriority?: Maybe<Scalars['Float']>;
  indoorCourtCount?: Maybe<Scalars['Float']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  outdoorCourtCount?: Maybe<Scalars['Float']>;
  totalCourtCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "venues" */
export type VenuesVarianceOrderBy = {
  featuredPriority?: InputMaybe<OrderBy>;
  indoorCourtCount?: InputMaybe<OrderBy>;
  latitude?: InputMaybe<OrderBy>;
  longitude?: InputMaybe<OrderBy>;
  outdoorCourtCount?: InputMaybe<OrderBy>;
  totalCourtCount?: InputMaybe<OrderBy>;
};

/** Make template an enum later. Also maybe make a jsonb field if we ever want multiple emails during welcome. */
export type WelcomeEmailConfiguration = {
  __typename?: 'WelcomeEmailConfiguration';
  createdAt: Scalars['timestamptz'];
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email: Scalars['String'];
  id: Scalars['uuid'];
  template?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "welcome_email_configuration" */
export type WelcomeEmailConfigurationAggregate = {
  __typename?: 'WelcomeEmailConfigurationAggregate';
  aggregate?: Maybe<WelcomeEmailConfigurationAggregateFields>;
  nodes: Array<WelcomeEmailConfiguration>;
};

/** aggregate fields of "welcome_email_configuration" */
export type WelcomeEmailConfigurationAggregateFields = {
  __typename?: 'WelcomeEmailConfigurationAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<WelcomeEmailConfigurationMaxFields>;
  min?: Maybe<WelcomeEmailConfigurationMinFields>;
};


/** aggregate fields of "welcome_email_configuration" */
export type WelcomeEmailConfigurationAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<WelcomeEmailConfigurationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "welcome_email_configuration". All fields are combined with a logical 'AND'. */
export type WelcomeEmailConfigurationBoolExp = {
  _and?: InputMaybe<Array<WelcomeEmailConfigurationBoolExp>>;
  _not?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
  _or?: InputMaybe<Array<WelcomeEmailConfigurationBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  template?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "welcome_email_configuration" */
export enum WelcomeEmailConfigurationConstraint {
  /** unique or primary key constraint on columns "email" */
  WelcomeEmailConfigurationEmailKey = 'welcome_email_configuration_email_key',
  /** unique or primary key constraint on columns "id" */
  WelcomeEmailConfigurationPkey = 'welcome_email_configuration_pkey'
}

/** input type for inserting data into table "welcome_email_configuration" */
export type WelcomeEmailConfigurationInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  template?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type WelcomeEmailConfigurationMaxFields = {
  __typename?: 'WelcomeEmailConfigurationMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  template?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type WelcomeEmailConfigurationMinFields = {
  __typename?: 'WelcomeEmailConfigurationMinFields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deletedAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  template?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "welcome_email_configuration" */
export type WelcomeEmailConfigurationMutationResponse = {
  __typename?: 'WelcomeEmailConfigurationMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<WelcomeEmailConfiguration>;
};

/** on_conflict condition type for table "welcome_email_configuration" */
export type WelcomeEmailConfigurationOnConflict = {
  constraint: WelcomeEmailConfigurationConstraint;
  updateColumns?: Array<WelcomeEmailConfigurationUpdateColumn>;
  where?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
};

/** Ordering options when selecting data from "welcome_email_configuration". */
export type WelcomeEmailConfigurationOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  template?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: welcome_email_configuration */
export type WelcomeEmailConfigurationPkColumnsInput = {
  id: Scalars['uuid'];
};

/** select columns of table "welcome_email_configuration" */
export enum WelcomeEmailConfigurationSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Template = 'template',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "welcome_email_configuration" */
export type WelcomeEmailConfigurationSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  template?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "welcome_email_configuration" */
export type WelcomeEmailConfigurationStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: WelcomeEmailConfigurationStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type WelcomeEmailConfigurationStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  template?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "welcome_email_configuration" */
export enum WelcomeEmailConfigurationUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Template = 'template',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type WelcomeEmailConfigurationUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WelcomeEmailConfigurationSetInput>;
  /** filter the rows which have to be updated */
  where: WelcomeEmailConfigurationBoolExp;
};

/** columns and relationships of "win_reasons" */
export type WinReasons = {
  __typename?: 'WinReasons';
  description?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "win_reasons" */
export type WinReasonsAggregate = {
  __typename?: 'WinReasonsAggregate';
  aggregate?: Maybe<WinReasonsAggregateFields>;
  nodes: Array<WinReasons>;
};

/** aggregate fields of "win_reasons" */
export type WinReasonsAggregateFields = {
  __typename?: 'WinReasonsAggregateFields';
  count: Scalars['Int'];
  max?: Maybe<WinReasonsMaxFields>;
  min?: Maybe<WinReasonsMinFields>;
};


/** aggregate fields of "win_reasons" */
export type WinReasonsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<WinReasonsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "win_reasons". All fields are combined with a logical 'AND'. */
export type WinReasonsBoolExp = {
  _and?: InputMaybe<Array<WinReasonsBoolExp>>;
  _not?: InputMaybe<WinReasonsBoolExp>;
  _or?: InputMaybe<Array<WinReasonsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "win_reasons" */
export enum WinReasonsConstraint {
  /** unique or primary key constraint on columns "value" */
  WinReasonsPkey = 'win_reasons_pkey'
}

export enum WinReasonsEnum {
  Forfeit = 'FORFEIT',
  OrganizerSelected = 'ORGANIZER_SELECTED',
  Score = 'SCORE'
}

/** Boolean expression to compare columns of type "WinReasonsEnum". All fields are combined with logical 'AND'. */
export type WinReasonsEnumComparisonExp = {
  _eq?: InputMaybe<WinReasonsEnum>;
  _in?: InputMaybe<Array<WinReasonsEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<WinReasonsEnum>;
  _nin?: InputMaybe<Array<WinReasonsEnum>>;
};

/** input type for inserting data into table "win_reasons" */
export type WinReasonsInsertInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type WinReasonsMaxFields = {
  __typename?: 'WinReasonsMaxFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type WinReasonsMinFields = {
  __typename?: 'WinReasonsMinFields';
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "win_reasons" */
export type WinReasonsMutationResponse = {
  __typename?: 'WinReasonsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<WinReasons>;
};

/** on_conflict condition type for table "win_reasons" */
export type WinReasonsOnConflict = {
  constraint: WinReasonsConstraint;
  updateColumns?: Array<WinReasonsUpdateColumn>;
  where?: InputMaybe<WinReasonsBoolExp>;
};

/** Ordering options when selecting data from "win_reasons". */
export type WinReasonsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: win_reasons */
export type WinReasonsPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "win_reasons" */
export enum WinReasonsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "win_reasons" */
export type WinReasonsSetInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "win_reasons" */
export type WinReasonsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: WinReasonsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type WinReasonsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "win_reasons" */
export enum WinReasonsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type WinReasonsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WinReasonsSetInput>;
  /** filter the rows which have to be updated */
  where: WinReasonsBoolExp;
};

export type CitiesAggregateBoolExpBool_And = {
  arguments: CitiesSelectColumnCitiesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<CitiesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type CitiesAggregateBoolExpBool_Or = {
  arguments: CitiesSelectColumnCitiesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<CitiesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type CitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<CitiesBoolExp>;
  predicate: IntComparisonExp;
};

export type CountrySubdivisionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<CountrySubdivisionsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventCourtsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventCourtsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventCourtsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventFaqsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventFaqsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventFaqsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventGameScoresAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGameScoresBoolExp>;
  predicate: IntComparisonExp;
};

export type EventGroupPoolsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupPoolsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventGroupRegistrationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupRegistrationsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventGroupSequenceSeedingAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
  predicate: IntComparisonExp;
};

export type EventGroupSequencesAggregateBoolExpBool_And = {
  arguments: EventGroupSequencesSelectColumnEventGroupSequencesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupSequencesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EventGroupSequencesAggregateBoolExpBool_Or = {
  arguments: EventGroupSequencesSelectColumnEventGroupSequencesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupSequencesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EventGroupSequencesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupSequencesBoolExp>;
  predicate: IntComparisonExp;
};

export type EventGroupsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventGroupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventGroupsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventInvitationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventInvitationsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventListingFeesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventListingFeesBoolExp>;
  predicate: IntComparisonExp;
};

export type EventMatchGamesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventMatchGamesBoolExp>;
  predicate: IntComparisonExp;
};

export type EventMatchesAggregateBoolExpBool_And = {
  arguments: EventMatchesSelectColumnEventMatchesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventMatchesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EventMatchesAggregateBoolExpBool_Or = {
  arguments: EventMatchesSelectColumnEventMatchesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventMatchesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EventMatchesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventMatchesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventMatchesBoolExp>;
  predicate: IntComparisonExp;
};

export type EventMatchesTeamsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventMatchesTeamsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventPoolRoundsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventPoolRoundsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventPoolsTeamsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventPoolsTeamsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventRegistrationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventRegistrationsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventSponsorsAggregateBoolExpBool_And = {
  arguments: EventSponsorsSelectColumnEventSponsorsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventSponsorsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EventSponsorsAggregateBoolExpBool_Or = {
  arguments: EventSponsorsSelectColumnEventSponsorsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventSponsorsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EventSponsorsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventSponsorsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventTeamMembersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventTeamMembersBoolExp>;
  predicate: IntComparisonExp;
};

export type EventTeamsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventTeamsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventTeamsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventTransactionItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventTransactionItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type EventTransactionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<EventTransactionsBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupCommentVotesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupCommentVotesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupMembersAggregateBoolExpBool_And = {
  arguments: GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupMembersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupMembersAggregateBoolExpBool_Or = {
  arguments: GroupMembersSelectColumnGroupMembersAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupMembersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupMembersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupMembersBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupThreadCommentFilesAggregateBoolExpBool_And = {
  arguments: GroupThreadCommentFilesSelectColumnGroupThreadCommentFilesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupThreadCommentFilesAggregateBoolExpBool_Or = {
  arguments: GroupThreadCommentFilesSelectColumnGroupThreadCommentFilesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupThreadCommentFilesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentFilesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupThreadCommentsAggregateBoolExpBool_And = {
  arguments: GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupThreadCommentsAggregateBoolExpBool_Or = {
  arguments: GroupThreadCommentsSelectColumnGroupThreadCommentsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupThreadCommentsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadCommentsBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupThreadsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupThreadsBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupVenuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupVenuesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupsAggregateBoolExpBool_And = {
  arguments: GroupsSelectColumnGroupsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupsAggregateBoolExpBool_Or = {
  arguments: GroupsSelectColumnGroupsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GroupsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupsBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupsPlaySessionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GroupsPlaySessionsBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonEquipmentAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonEquipmentBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonOrderItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonOrderItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonParticipantsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonParticipantsBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonTemplatesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonTemplatesBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonTimesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonTimesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonTimesBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonWaitlistsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonWaitlistsBoolExp>;
  predicate: IntComparisonExp;
};

export type LessonsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LessonsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<LessonsBoolExp>;
  predicate: IntComparisonExp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "amenities" */
  deleteAmenities?: Maybe<AmenitiesMutationResponse>;
  /** delete single row from the table: "amenities" */
  deleteAmenitiesByPk?: Maybe<Amenities>;
  /** delete data from the table: "app_personas" */
  deleteAppPersonas?: Maybe<AppPersonasMutationResponse>;
  /** delete single row from the table: "app_personas" */
  deleteAppPersonasByPk?: Maybe<AppPersonas>;
  /** delete data from the table: "app_pings" */
  deleteAppPings?: Maybe<AppPingsMutationResponse>;
  /** delete single row from the table: "app_pings" */
  deleteAppPingsByPk?: Maybe<AppPings>;
  /** delete data from the table: "ball_types" */
  deleteBallTypes?: Maybe<BallTypesMutationResponse>;
  /** delete single row from the table: "ball_types" */
  deleteBallTypesByPk?: Maybe<BallTypes>;
  /** delete data from the table: "cities" */
  deleteCities?: Maybe<CitiesMutationResponse>;
  /** delete single row from the table: "cities" */
  deleteCitiesByPk?: Maybe<Cities>;
  /** delete data from the table: "coach_qualification_groups" */
  deleteCoachQualificationGroups?: Maybe<CoachQualificationGroupsMutationResponse>;
  /** delete single row from the table: "coach_qualification_groups" */
  deleteCoachQualificationGroupsByPk?: Maybe<CoachQualificationGroups>;
  /** delete data from the table: "coach_qualification_statuses" */
  deleteCoachQualificationStatuses?: Maybe<CoachQualificationStatusesMutationResponse>;
  /** delete single row from the table: "coach_qualification_statuses" */
  deleteCoachQualificationStatusesByPk?: Maybe<CoachQualificationStatuses>;
  /** delete data from the table: "coach_qualifications" */
  deleteCoachQualifications?: Maybe<CoachQualificationsMutationResponse>;
  /** delete single row from the table: "coach_qualifications" */
  deleteCoachQualificationsByPk?: Maybe<CoachQualifications>;
  /** delete data from the table: "coach_status" */
  deleteCoachStatus?: Maybe<CoachStatusMutationResponse>;
  /** delete single row from the table: "coach_status" */
  deleteCoachStatusByPk?: Maybe<CoachStatus>;
  /** delete data from the table: "comment_vote" */
  deleteCommentVote?: Maybe<CommentVoteMutationResponse>;
  /** delete single row from the table: "comment_vote" */
  deleteCommentVoteByPk?: Maybe<CommentVote>;
  /** delete data from the table: "communication_preference_statuses" */
  deleteCommunicationPreferenceStatuses?: Maybe<CommunicationPreferenceStatusesMutationResponse>;
  /** delete single row from the table: "communication_preference_statuses" */
  deleteCommunicationPreferenceStatusesByPk?: Maybe<CommunicationPreferenceStatuses>;
  /** delete data from the table: "competition_formats" */
  deleteCompetitionFormats?: Maybe<CompetitionFormatsMutationResponse>;
  /** delete single row from the table: "competition_formats" */
  deleteCompetitionFormatsByPk?: Maybe<CompetitionFormats>;
  /** delete data from the table: "competition_gender" */
  deleteCompetitionGender?: Maybe<CompetitionGenderMutationResponse>;
  /** delete single row from the table: "competition_gender" */
  deleteCompetitionGenderByPk?: Maybe<CompetitionGender>;
  /** delete data from the table: "countries" */
  deleteCountries?: Maybe<CountriesMutationResponse>;
  /** delete single row from the table: "countries" */
  deleteCountriesByPk?: Maybe<Countries>;
  /** delete data from the table: "country_subdivisions" */
  deleteCountrySubdivisions?: Maybe<CountrySubdivisionsMutationResponse>;
  /** delete single row from the table: "country_subdivisions" */
  deleteCountrySubdivisionsByPk?: Maybe<CountrySubdivisions>;
  /** delete data from the table: "court_surfaces" */
  deleteCourtSurfaces?: Maybe<CourtSurfacesMutationResponse>;
  /** delete single row from the table: "court_surfaces" */
  deleteCourtSurfacesByPk?: Maybe<CourtSurfaces>;
  /** delete data from the table: "event_contact_details" */
  deleteEventContactDetails?: Maybe<EventContactDetailsMutationResponse>;
  /** delete single row from the table: "event_contact_details" */
  deleteEventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** delete data from the table: "event_court_statuses" */
  deleteEventCourtStatuses?: Maybe<EventCourtStatusesMutationResponse>;
  /** delete single row from the table: "event_court_statuses" */
  deleteEventCourtStatusesByPk?: Maybe<EventCourtStatuses>;
  /** delete data from the table: "event_courts" */
  deleteEventCourts?: Maybe<EventCourtsMutationResponse>;
  /** delete single row from the table: "event_courts" */
  deleteEventCourtsByPk?: Maybe<EventCourts>;
  /** delete data from the table: "event_faqs" */
  deleteEventFaqs?: Maybe<EventFaqsMutationResponse>;
  /** delete single row from the table: "event_faqs" */
  deleteEventFaqsByPk?: Maybe<EventFaqs>;
  /** delete data from the table: "event_game_scores" */
  deleteEventGameScores?: Maybe<EventGameScoresMutationResponse>;
  /** delete single row from the table: "event_game_scores" */
  deleteEventGameScoresByPk?: Maybe<EventGameScores>;
  /** delete data from the table: "event_group_formats" */
  deleteEventGroupFormats?: Maybe<EventGroupFormatsMutationResponse>;
  /** delete single row from the table: "event_group_formats" */
  deleteEventGroupFormatsByPk?: Maybe<EventGroupFormats>;
  /** delete data from the table: "event_group_pools" */
  deleteEventGroupPools?: Maybe<EventGroupPoolsMutationResponse>;
  /** delete single row from the table: "event_group_pools" */
  deleteEventGroupPoolsByPk?: Maybe<EventGroupPools>;
  /** delete data from the table: "event_group_registration_statuses" */
  deleteEventGroupRegistrationStatuses?: Maybe<EventGroupRegistrationStatusesMutationResponse>;
  /** delete single row from the table: "event_group_registration_statuses" */
  deleteEventGroupRegistrationStatusesByPk?: Maybe<EventGroupRegistrationStatuses>;
  /** delete data from the table: "event_group_registrations" */
  deleteEventGroupRegistrations?: Maybe<EventGroupRegistrationsMutationResponse>;
  /** delete single row from the table: "event_group_registrations" */
  deleteEventGroupRegistrationsByPk?: Maybe<EventGroupRegistrations>;
  /** delete data from the table: "event_group_sequence_seeding" */
  deleteEventGroupSequenceSeeding?: Maybe<EventGroupSequenceSeedingMutationResponse>;
  /** delete single row from the table: "event_group_sequence_seeding" */
  deleteEventGroupSequenceSeedingByPk?: Maybe<EventGroupSequenceSeeding>;
  /** delete data from the table: "event_group_sequences" */
  deleteEventGroupSequences?: Maybe<EventGroupSequencesMutationResponse>;
  /** delete single row from the table: "event_group_sequences" */
  deleteEventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** delete data from the table: "event_groups" */
  deleteEventGroups?: Maybe<EventGroupsMutationResponse>;
  /** delete single row from the table: "event_groups" */
  deleteEventGroupsByPk?: Maybe<EventGroups>;
  /** delete data from the table: "event_invitation_statuses" */
  deleteEventInvitationStatuses?: Maybe<EventInvitationStatusesMutationResponse>;
  /** delete single row from the table: "event_invitation_statuses" */
  deleteEventInvitationStatusesByPk?: Maybe<EventInvitationStatuses>;
  /** delete data from the table: "event_invitations" */
  deleteEventInvitations?: Maybe<EventInvitationsMutationResponse>;
  /** delete single row from the table: "event_invitations" */
  deleteEventInvitationsByPk?: Maybe<EventInvitations>;
  /** delete data from the table: "event_listing_fees" */
  deleteEventListingFees?: Maybe<EventListingFeesMutationResponse>;
  /** delete single row from the table: "event_listing_fees" */
  deleteEventListingFeesByPk?: Maybe<EventListingFees>;
  /** delete data from the table: "event_match_games" */
  deleteEventMatchGames?: Maybe<EventMatchGamesMutationResponse>;
  /** delete single row from the table: "event_match_games" */
  deleteEventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** delete data from the table: "event_matches" */
  deleteEventMatches?: Maybe<EventMatchesMutationResponse>;
  /** delete single row from the table: "event_matches" */
  deleteEventMatchesByPk?: Maybe<EventMatches>;
  /** delete data from the table: "event_matches_teams" */
  deleteEventMatchesTeams?: Maybe<EventMatchesTeamsMutationResponse>;
  /** delete single row from the table: "event_matches_teams" */
  deleteEventMatchesTeamsByPk?: Maybe<EventMatchesTeams>;
  /** delete data from the table: "event_organizer_account_types" */
  deleteEventOrganizerAccountTypes?: Maybe<EventOrganizerAccountTypesMutationResponse>;
  /** delete single row from the table: "event_organizer_account_types" */
  deleteEventOrganizerAccountTypesByPk?: Maybe<EventOrganizerAccountTypes>;
  /** delete data from the table: "event_pool_rounds" */
  deleteEventPoolRounds?: Maybe<EventPoolRoundsMutationResponse>;
  /** delete single row from the table: "event_pool_rounds" */
  deleteEventPoolRoundsByPk?: Maybe<EventPoolRounds>;
  /** delete data from the table: "event_pools_teams" */
  deleteEventPoolsTeams?: Maybe<EventPoolsTeamsMutationResponse>;
  /** delete single row from the table: "event_pools_teams" */
  deleteEventPoolsTeamsByPk?: Maybe<EventPoolsTeams>;
  /** delete data from the table: "event_privacy" */
  deleteEventPrivacy?: Maybe<EventPrivacyMutationResponse>;
  /** delete single row from the table: "event_privacy" */
  deleteEventPrivacyByPk?: Maybe<EventPrivacy>;
  /** delete data from the table: "event_registration_details" */
  deleteEventRegistrationDetails?: Maybe<EventRegistrationDetailsMutationResponse>;
  /** delete single row from the table: "event_registration_details" */
  deleteEventRegistrationDetailsByPk?: Maybe<EventRegistrationDetails>;
  /** delete data from the table: "event_registrations" */
  deleteEventRegistrations?: Maybe<EventRegistrationsMutationResponse>;
  /** delete single row from the table: "event_registrations" */
  deleteEventRegistrationsByPk?: Maybe<EventRegistrations>;
  /** delete data from the table: "event_sequence_complete_reasons" */
  deleteEventSequenceCompleteReasons?: Maybe<EventSequenceCompleteReasonsMutationResponse>;
  /** delete single row from the table: "event_sequence_complete_reasons" */
  deleteEventSequenceCompleteReasonsByPk?: Maybe<EventSequenceCompleteReasons>;
  /** delete data from the table: "event_sponsors" */
  deleteEventSponsors?: Maybe<EventSponsorsMutationResponse>;
  /** delete single row from the table: "event_sponsors" */
  deleteEventSponsorsByPk?: Maybe<EventSponsors>;
  /** delete data from the table: "event_statuses" */
  deleteEventStatuses?: Maybe<EventStatusesMutationResponse>;
  /** delete single row from the table: "event_statuses" */
  deleteEventStatusesByPk?: Maybe<EventStatuses>;
  /** delete data from the table: "event_team_member_statuses" */
  deleteEventTeamMemberStatuses?: Maybe<EventTeamMemberStatusesMutationResponse>;
  /** delete single row from the table: "event_team_member_statuses" */
  deleteEventTeamMemberStatusesByPk?: Maybe<EventTeamMemberStatuses>;
  /** delete data from the table: "event_team_members" */
  deleteEventTeamMembers?: Maybe<EventTeamMembersMutationResponse>;
  /** delete single row from the table: "event_team_members" */
  deleteEventTeamMembersByPk?: Maybe<EventTeamMembers>;
  /** delete data from the table: "event_teams" */
  deleteEventTeams?: Maybe<EventTeamsMutationResponse>;
  /** delete single row from the table: "event_teams" */
  deleteEventTeamsByPk?: Maybe<EventTeams>;
  /** delete data from the table: "event_transaction_item_types" */
  deleteEventTransactionItemTypes?: Maybe<EventTransactionItemTypesMutationResponse>;
  /** delete single row from the table: "event_transaction_item_types" */
  deleteEventTransactionItemTypesByPk?: Maybe<EventTransactionItemTypes>;
  /** delete data from the table: "event_transaction_items" */
  deleteEventTransactionItems?: Maybe<EventTransactionItemsMutationResponse>;
  /** delete single row from the table: "event_transaction_items" */
  deleteEventTransactionItemsByPk?: Maybe<EventTransactionItems>;
  /** delete data from the table: "event_transactions" */
  deleteEventTransactions?: Maybe<EventTransactionsMutationResponse>;
  /** delete single row from the table: "event_transactions" */
  deleteEventTransactionsByPk?: Maybe<EventTransactions>;
  /** delete data from the table: "event_types" */
  deleteEventTypes?: Maybe<EventTypesMutationResponse>;
  /** delete single row from the table: "event_types" */
  deleteEventTypesByPk?: Maybe<EventTypes>;
  /** delete data from the table: "events" */
  deleteEvents?: Maybe<EventsMutationResponse>;
  /** delete single row from the table: "events" */
  deleteEventsByPk?: Maybe<Events>;
  /** delete data from the table: "follow_statuses" */
  deleteFollowStatuses?: Maybe<FollowStatusesMutationResponse>;
  /** delete single row from the table: "follow_statuses" */
  deleteFollowStatusesByPk?: Maybe<FollowStatuses>;
  /** delete data from the table: "gender" */
  deleteGender?: Maybe<GenderMutationResponse>;
  /** delete single row from the table: "gender" */
  deleteGenderByPk?: Maybe<Gender>;
  /** delete data from the table: "group_comment_votes" */
  deleteGroupCommentVotes?: Maybe<GroupCommentVotesMutationResponse>;
  /** delete single row from the table: "group_comment_votes" */
  deleteGroupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** delete data from the table: "group_members" */
  deleteGroupMembers?: Maybe<GroupMembersMutationResponse>;
  /** delete single row from the table: "group_members" */
  deleteGroupMembersByPk?: Maybe<GroupMembers>;
  /** delete data from the table: "group_thread_comment_files" */
  deleteGroupThreadCommentFiles?: Maybe<GroupThreadCommentFilesMutationResponse>;
  /** delete single row from the table: "group_thread_comment_files" */
  deleteGroupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** delete data from the table: "group_thread_comments" */
  deleteGroupThreadComments?: Maybe<GroupThreadCommentsMutationResponse>;
  /** delete single row from the table: "group_thread_comments" */
  deleteGroupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** delete data from the table: "group_threads" */
  deleteGroupThreads?: Maybe<GroupThreadsMutationResponse>;
  /** delete single row from the table: "group_threads" */
  deleteGroupThreadsByPk?: Maybe<GroupThreads>;
  /** delete data from the table: "group_venues" */
  deleteGroupVenues?: Maybe<GroupVenuesMutationResponse>;
  /** delete single row from the table: "group_venues" */
  deleteGroupVenuesByPk?: Maybe<GroupVenues>;
  /** delete data from the table: "groups" */
  deleteGroups?: Maybe<GroupsMutationResponse>;
  /** delete single row from the table: "groups" */
  deleteGroupsByPk?: Maybe<Groups>;
  /** delete data from the table: "groups_play_sessions" */
  deleteGroupsPlaySessions?: Maybe<GroupsPlaySessionsMutationResponse>;
  /** delete single row from the table: "groups_play_sessions" */
  deleteGroupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** delete data from the table: "lesson_equipment" */
  deleteLessonEquipment?: Maybe<LessonEquipmentMutationResponse>;
  /** delete single row from the table: "lesson_equipment" */
  deleteLessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** delete data from the table: "lesson_equipment_options" */
  deleteLessonEquipmentOptions?: Maybe<LessonEquipmentOptionsMutationResponse>;
  /** delete single row from the table: "lesson_equipment_options" */
  deleteLessonEquipmentOptionsByPk?: Maybe<LessonEquipmentOptions>;
  /** delete data from the table: "lesson_order_items" */
  deleteLessonOrderItems?: Maybe<LessonOrderItemsMutationResponse>;
  /** delete single row from the table: "lesson_order_items" */
  deleteLessonOrderItemsByPk?: Maybe<LessonOrderItems>;
  /** delete data from the table: "lesson_orders" */
  deleteLessonOrders?: Maybe<LessonOrdersMutationResponse>;
  /** delete single row from the table: "lesson_orders" */
  deleteLessonOrdersByPk?: Maybe<LessonOrders>;
  /** delete data from the table: "lesson_participant_statuses" */
  deleteLessonParticipantStatuses?: Maybe<LessonParticipantStatusesMutationResponse>;
  /** delete single row from the table: "lesson_participant_statuses" */
  deleteLessonParticipantStatusesByPk?: Maybe<LessonParticipantStatuses>;
  /** delete data from the table: "lesson_participants" */
  deleteLessonParticipants?: Maybe<LessonParticipantsMutationResponse>;
  /** delete single row from the table: "lesson_participants" */
  deleteLessonParticipantsByPk?: Maybe<LessonParticipants>;
  /** delete data from the table: "lesson_privacy" */
  deleteLessonPrivacy?: Maybe<LessonPrivacyMutationResponse>;
  /** delete single row from the table: "lesson_privacy" */
  deleteLessonPrivacyByPk?: Maybe<LessonPrivacy>;
  /** delete data from the table: "lesson_statuses" */
  deleteLessonStatuses?: Maybe<LessonStatusesMutationResponse>;
  /** delete single row from the table: "lesson_statuses" */
  deleteLessonStatusesByPk?: Maybe<LessonStatuses>;
  /** delete data from the table: "lesson_templates" */
  deleteLessonTemplates?: Maybe<LessonTemplatesMutationResponse>;
  /** delete single row from the table: "lesson_templates" */
  deleteLessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** delete data from the table: "lesson_times" */
  deleteLessonTimes?: Maybe<LessonTimesMutationResponse>;
  /** delete single row from the table: "lesson_times" */
  deleteLessonTimesByPk?: Maybe<LessonTimes>;
  /** delete data from the table: "lesson_types" */
  deleteLessonTypes?: Maybe<LessonTypesMutationResponse>;
  /** delete single row from the table: "lesson_types" */
  deleteLessonTypesByPk?: Maybe<LessonTypes>;
  /** delete data from the table: "lesson_waitlist_statuses" */
  deleteLessonWaitlistStatuses?: Maybe<LessonWaitlistStatusesMutationResponse>;
  /** delete single row from the table: "lesson_waitlist_statuses" */
  deleteLessonWaitlistStatusesByPk?: Maybe<LessonWaitlistStatuses>;
  /** delete data from the table: "lesson_waitlists" */
  deleteLessonWaitlists?: Maybe<LessonWaitlistsMutationResponse>;
  /** delete single row from the table: "lesson_waitlists" */
  deleteLessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** delete data from the table: "lessons" */
  deleteLessons?: Maybe<LessonsMutationResponse>;
  /** delete single row from the table: "lessons" */
  deleteLessonsByPk?: Maybe<Lessons>;
  /** delete data from the table: "match_selection_criteria" */
  deleteMatchSelectionCriteria?: Maybe<MatchSelectionCriteriaMutationResponse>;
  /** delete single row from the table: "match_selection_criteria" */
  deleteMatchSelectionCriteriaByPk?: Maybe<MatchSelectionCriteria>;
  /** delete data from the table: "notification_action_types" */
  deleteNotificationActionTypes?: Maybe<NotificationActionTypesMutationResponse>;
  /** delete single row from the table: "notification_action_types" */
  deleteNotificationActionTypesByPk?: Maybe<NotificationActionTypes>;
  /** delete data from the table: "notification_statuses" */
  deleteNotificationStatuses?: Maybe<NotificationStatusesMutationResponse>;
  /** delete single row from the table: "notification_statuses" */
  deleteNotificationStatusesByPk?: Maybe<NotificationStatuses>;
  /** delete data from the table: "order_statuses" */
  deleteOrderStatuses?: Maybe<OrderStatusesMutationResponse>;
  /** delete single row from the table: "order_statuses" */
  deleteOrderStatusesByPk?: Maybe<OrderStatuses>;
  /** delete data from the table: "payment_fulfillment_channels" */
  deletePaymentFulfillmentChannels?: Maybe<PaymentFulfillmentChannelsMutationResponse>;
  /** delete single row from the table: "payment_fulfillment_channels" */
  deletePaymentFulfillmentChannelsByPk?: Maybe<PaymentFulfillmentChannels>;
  /** delete data from the table: "payment_processors" */
  deletePaymentProcessors?: Maybe<PaymentProcessorsMutationResponse>;
  /** delete single row from the table: "payment_processors" */
  deletePaymentProcessorsByPk?: Maybe<PaymentProcessors>;
  /** delete data from the table: "pickleball_rating_scales" */
  deletePickleballRatingScales?: Maybe<PickleballRatingScalesMutationResponse>;
  /** delete single row from the table: "pickleball_rating_scales" */
  deletePickleballRatingScalesByPk?: Maybe<PickleballRatingScales>;
  /** delete data from the table: "play_session_comments" */
  deletePlaySessionComments?: Maybe<PlaySessionCommentsMutationResponse>;
  /** delete single row from the table: "play_session_comments" */
  deletePlaySessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** delete data from the table: "play_session_court_booking_statuses" */
  deletePlaySessionCourtBookingStatuses?: Maybe<PlaySessionCourtBookingStatusesMutationResponse>;
  /** delete single row from the table: "play_session_court_booking_statuses" */
  deletePlaySessionCourtBookingStatusesByPk?: Maybe<PlaySessionCourtBookingStatuses>;
  /** delete data from the table: "play_session_formats" */
  deletePlaySessionFormats?: Maybe<PlaySessionFormatsMutationResponse>;
  /** delete single row from the table: "play_session_formats" */
  deletePlaySessionFormatsByPk?: Maybe<PlaySessionFormats>;
  /** delete data from the table: "play_session_match_competitiveness" */
  deletePlaySessionMatchCompetitiveness?: Maybe<PlaySessionMatchCompetitivenessMutationResponse>;
  /** delete single row from the table: "play_session_match_competitiveness" */
  deletePlaySessionMatchCompetitivenessByPk?: Maybe<PlaySessionMatchCompetitiveness>;
  /** delete data from the table: "play_session_participant_statuses" */
  deletePlaySessionParticipantStatuses?: Maybe<PlaySessionParticipantStatusesMutationResponse>;
  /** delete single row from the table: "play_session_participant_statuses" */
  deletePlaySessionParticipantStatusesByPk?: Maybe<PlaySessionParticipantStatuses>;
  /** delete data from the table: "play_session_participants" */
  deletePlaySessionParticipants?: Maybe<PlaySessionParticipantsMutationResponse>;
  /** delete single row from the table: "play_session_participants" */
  deletePlaySessionParticipantsByPk?: Maybe<PlaySessionParticipants>;
  /** delete data from the table: "play_session_privacy" */
  deletePlaySessionPrivacy?: Maybe<PlaySessionPrivacyMutationResponse>;
  /** delete single row from the table: "play_session_privacy" */
  deletePlaySessionPrivacyByPk?: Maybe<PlaySessionPrivacy>;
  /** delete data from the table: "play_session_statuses" */
  deletePlaySessionStatuses?: Maybe<PlaySessionStatusesMutationResponse>;
  /** delete single row from the table: "play_session_statuses" */
  deletePlaySessionStatusesByPk?: Maybe<PlaySessionStatuses>;
  /** delete data from the table: "play_sessions" */
  deletePlaySessions?: Maybe<PlaySessionsMutationResponse>;
  /** delete single row from the table: "play_sessions" */
  deletePlaySessionsByPk?: Maybe<PlaySessions>;
  /** delete data from the table: "scoring_format" */
  deleteScoringFormat?: Maybe<ScoringFormatMutationResponse>;
  /** delete single row from the table: "scoring_format" */
  deleteScoringFormatByPk?: Maybe<ScoringFormat>;
  /** delete data from the table: "signup_requests" */
  deleteSignupRequests?: Maybe<SignupRequestsMutationResponse>;
  /** delete single row from the table: "signup_requests" */
  deleteSignupRequestsByPk?: Maybe<SignupRequests>;
  /** delete data from the table: "skill_levels" */
  deleteSkillLevels?: Maybe<SkillLevelsMutationResponse>;
  /** delete single row from the table: "skill_levels" */
  deleteSkillLevelsByPk?: Maybe<SkillLevels>;
  /** delete data from the table: "sports" */
  deleteSports?: Maybe<SportsMutationResponse>;
  /** delete single row from the table: "sports" */
  deleteSportsByPk?: Maybe<Sports>;
  /** delete data from the table: "stripe_charges" */
  deleteStripeCharges?: Maybe<StripeChargesMutationResponse>;
  /** delete single row from the table: "stripe_charges" */
  deleteStripeChargesByPk?: Maybe<StripeCharges>;
  /** delete data from the table: "stripe_payment_intents" */
  deleteStripePaymentIntents?: Maybe<StripePaymentIntentsMutationResponse>;
  /** delete single row from the table: "stripe_payment_intents" */
  deleteStripePaymentIntentsByPk?: Maybe<StripePaymentIntents>;
  /** delete data from the table: "team_types" */
  deleteTeamTypes?: Maybe<TeamTypesMutationResponse>;
  /** delete single row from the table: "team_types" */
  deleteTeamTypesByPk?: Maybe<TeamTypes>;
  /** delete data from the table: "tennis_rating_scales" */
  deleteTennisRatingScales?: Maybe<TennisRatingScalesMutationResponse>;
  /** delete single row from the table: "tennis_rating_scales" */
  deleteTennisRatingScalesByPk?: Maybe<TennisRatingScales>;
  /** delete data from the table: "user_auth_identities" */
  deleteUserAuthIdentities?: Maybe<UserAuthIdentitiesMutationResponse>;
  /** delete single row from the table: "user_auth_identities" */
  deleteUserAuthIdentitiesByPk?: Maybe<UserAuthIdentities>;
  /** delete data from the table: "user_coach_services" */
  deleteUserCoachServices?: Maybe<UserCoachServicesMutationResponse>;
  /** delete single row from the table: "user_coach_services" */
  deleteUserCoachServicesByPk?: Maybe<UserCoachServices>;
  /** delete data from the table: "user_communication_preferences" */
  deleteUserCommunicationPreferences?: Maybe<UserCommunicationPreferencesMutationResponse>;
  /** delete single row from the table: "user_communication_preferences" */
  deleteUserCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** delete data from the table: "user_credit_cards" */
  deleteUserCreditCards?: Maybe<UserCreditCardsMutationResponse>;
  /** delete single row from the table: "user_credit_cards" */
  deleteUserCreditCardsByPk?: Maybe<UserCreditCards>;
  /** delete data from the table: "user_custom_courts" */
  deleteUserCustomCourts?: Maybe<UserCustomCourtsMutationResponse>;
  /** delete single row from the table: "user_custom_courts" */
  deleteUserCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** delete data from the table: "user_follows" */
  deleteUserFollows?: Maybe<UserFollowsMutationResponse>;
  /** delete single row from the table: "user_follows" */
  deleteUserFollowsByPk?: Maybe<UserFollows>;
  /** delete data from the table: "user_image_log" */
  deleteUserImageLog?: Maybe<UserImageLogMutationResponse>;
  /** delete single row from the table: "user_image_log" */
  deleteUserImageLogByPk?: Maybe<UserImageLog>;
  /** delete data from the table: "user_notification_details" */
  deleteUserNotificationDetails?: Maybe<UserNotificationDetailsMutationResponse>;
  /** delete single row from the table: "user_notification_details" */
  deleteUserNotificationDetailsByPk?: Maybe<UserNotificationDetails>;
  /** delete data from the table: "user_notification_entities" */
  deleteUserNotificationEntities?: Maybe<UserNotificationEntitiesMutationResponse>;
  /** delete single row from the table: "user_notification_entities" */
  deleteUserNotificationEntitiesByPk?: Maybe<UserNotificationEntities>;
  /** delete data from the table: "user_notifications" */
  deleteUserNotifications?: Maybe<UserNotificationsMutationResponse>;
  /** delete single row from the table: "user_notifications" */
  deleteUserNotificationsByPk?: Maybe<UserNotifications>;
  /** delete data from the table: "user_profiles" */
  deleteUserProfiles?: Maybe<UserProfilesMutationResponse>;
  /** delete data from the table: "user_registration_details" */
  deleteUserRegistrationDetails?: Maybe<UserRegistrationDetailsMutationResponse>;
  /** delete single row from the table: "user_registration_details" */
  deleteUserRegistrationDetailsByPk?: Maybe<UserRegistrationDetails>;
  /** delete data from the table: "user_terms_of_service" */
  deleteUserTermsOfService?: Maybe<UserTermsOfServiceMutationResponse>;
  /** delete single row from the table: "user_terms_of_service" */
  deleteUserTermsOfServiceByPk?: Maybe<UserTermsOfService>;
  /** delete data from the table: "username_logs" */
  deleteUsernameLogs?: Maybe<UsernameLogsMutationResponse>;
  /** delete single row from the table: "username_logs" */
  deleteUsernameLogsByPk?: Maybe<UsernameLogs>;
  /** delete data from the table: "usernames_active" */
  deleteUsernamesActive?: Maybe<UsernamesActiveMutationResponse>;
  /** delete data from the table: "usernames_claimed" */
  deleteUsernamesClaimed?: Maybe<UsernamesClaimedMutationResponse>;
  /** delete single row from the table: "usernames_claimed" */
  deleteUsernamesClaimedByPk?: Maybe<UsernamesClaimed>;
  /** delete data from the table: "users" */
  deleteUsers?: Maybe<UsersMutationResponse>;
  /** delete single row from the table: "users" */
  deleteUsersByPk?: Maybe<Users>;
  /** delete data from the table: "users_coach_qualifications" */
  deleteUsersCoachQualifications?: Maybe<UsersCoachQualificationsMutationResponse>;
  /** delete single row from the table: "users_coach_qualifications" */
  deleteUsersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** delete data from the table: "venue_access_types" */
  deleteVenueAccessTypes?: Maybe<VenueAccessTypesMutationResponse>;
  /** delete single row from the table: "venue_access_types" */
  deleteVenueAccessTypesByPk?: Maybe<VenueAccessTypes>;
  /** delete data from the table: "venue_amenities" */
  deleteVenueAmenities?: Maybe<VenueAmenitiesMutationResponse>;
  /** delete single row from the table: "venue_amenities" */
  deleteVenueAmenitiesByPk?: Maybe<VenueAmenities>;
  /** delete data from the table: "venue_court_surfaces" */
  deleteVenueCourtSurfaces?: Maybe<VenueCourtSurfacesMutationResponse>;
  /** delete single row from the table: "venue_court_surfaces" */
  deleteVenueCourtSurfacesByPk?: Maybe<VenueCourtSurfaces>;
  /** delete data from the table: "venue_facility_types" */
  deleteVenueFacilityTypes?: Maybe<VenueFacilityTypesMutationResponse>;
  /** delete single row from the table: "venue_facility_types" */
  deleteVenueFacilityTypesByPk?: Maybe<VenueFacilityTypes>;
  /** delete data from the table: "venue_follows" */
  deleteVenueFollows?: Maybe<VenueFollowsMutationResponse>;
  /** delete single row from the table: "venue_follows" */
  deleteVenueFollowsByPk?: Maybe<VenueFollows>;
  /** delete data from the table: "venue_images" */
  deleteVenueImages?: Maybe<VenueImagesMutationResponse>;
  /** delete single row from the table: "venue_images" */
  deleteVenueImagesByPk?: Maybe<VenueImages>;
  /** delete data from the table: "venue_lines" */
  deleteVenueLines?: Maybe<VenueLinesMutationResponse>;
  /** delete single row from the table: "venue_lines" */
  deleteVenueLinesByPk?: Maybe<VenueLines>;
  /** delete data from the table: "venue_nets" */
  deleteVenueNets?: Maybe<VenueNetsMutationResponse>;
  /** delete single row from the table: "venue_nets" */
  deleteVenueNetsByPk?: Maybe<VenueNets>;
  /** delete data from the table: "venues" */
  deleteVenues?: Maybe<VenuesMutationResponse>;
  /** delete single row from the table: "venues" */
  deleteVenuesByPk?: Maybe<Venues>;
  /** delete data from the table: "welcome_email_configuration" */
  deleteWelcomeEmailConfiguration?: Maybe<WelcomeEmailConfigurationMutationResponse>;
  /** delete single row from the table: "welcome_email_configuration" */
  deleteWelcomeEmailConfigurationByPk?: Maybe<WelcomeEmailConfiguration>;
  /** delete data from the table: "win_reasons" */
  deleteWinReasons?: Maybe<WinReasonsMutationResponse>;
  /** delete single row from the table: "win_reasons" */
  deleteWinReasonsByPk?: Maybe<WinReasons>;
  /** insert data into the table: "amenities" */
  insertAmenities?: Maybe<AmenitiesMutationResponse>;
  /** insert a single row into the table: "amenities" */
  insertAmenitiesOne?: Maybe<Amenities>;
  /** insert data into the table: "app_personas" */
  insertAppPersonas?: Maybe<AppPersonasMutationResponse>;
  /** insert a single row into the table: "app_personas" */
  insertAppPersonasOne?: Maybe<AppPersonas>;
  /** insert data into the table: "app_pings" */
  insertAppPings?: Maybe<AppPingsMutationResponse>;
  /** insert a single row into the table: "app_pings" */
  insertAppPingsOne?: Maybe<AppPings>;
  /** insert data into the table: "ball_types" */
  insertBallTypes?: Maybe<BallTypesMutationResponse>;
  /** insert a single row into the table: "ball_types" */
  insertBallTypesOne?: Maybe<BallTypes>;
  /** insert data into the table: "cities" */
  insertCities?: Maybe<CitiesMutationResponse>;
  /** insert a single row into the table: "cities" */
  insertCitiesOne?: Maybe<Cities>;
  /** insert data into the table: "coach_qualification_groups" */
  insertCoachQualificationGroups?: Maybe<CoachQualificationGroupsMutationResponse>;
  /** insert a single row into the table: "coach_qualification_groups" */
  insertCoachQualificationGroupsOne?: Maybe<CoachQualificationGroups>;
  /** insert data into the table: "coach_qualification_statuses" */
  insertCoachQualificationStatuses?: Maybe<CoachQualificationStatusesMutationResponse>;
  /** insert a single row into the table: "coach_qualification_statuses" */
  insertCoachQualificationStatusesOne?: Maybe<CoachQualificationStatuses>;
  /** insert data into the table: "coach_qualifications" */
  insertCoachQualifications?: Maybe<CoachQualificationsMutationResponse>;
  /** insert a single row into the table: "coach_qualifications" */
  insertCoachQualificationsOne?: Maybe<CoachQualifications>;
  /** insert data into the table: "coach_status" */
  insertCoachStatus?: Maybe<CoachStatusMutationResponse>;
  /** insert a single row into the table: "coach_status" */
  insertCoachStatusOne?: Maybe<CoachStatus>;
  /** insert data into the table: "comment_vote" */
  insertCommentVote?: Maybe<CommentVoteMutationResponse>;
  /** insert a single row into the table: "comment_vote" */
  insertCommentVoteOne?: Maybe<CommentVote>;
  /** insert data into the table: "communication_preference_statuses" */
  insertCommunicationPreferenceStatuses?: Maybe<CommunicationPreferenceStatusesMutationResponse>;
  /** insert a single row into the table: "communication_preference_statuses" */
  insertCommunicationPreferenceStatusesOne?: Maybe<CommunicationPreferenceStatuses>;
  /** insert data into the table: "competition_formats" */
  insertCompetitionFormats?: Maybe<CompetitionFormatsMutationResponse>;
  /** insert a single row into the table: "competition_formats" */
  insertCompetitionFormatsOne?: Maybe<CompetitionFormats>;
  /** insert data into the table: "competition_gender" */
  insertCompetitionGender?: Maybe<CompetitionGenderMutationResponse>;
  /** insert a single row into the table: "competition_gender" */
  insertCompetitionGenderOne?: Maybe<CompetitionGender>;
  /** insert data into the table: "countries" */
  insertCountries?: Maybe<CountriesMutationResponse>;
  /** insert a single row into the table: "countries" */
  insertCountriesOne?: Maybe<Countries>;
  /** insert data into the table: "country_subdivisions" */
  insertCountrySubdivisions?: Maybe<CountrySubdivisionsMutationResponse>;
  /** insert a single row into the table: "country_subdivisions" */
  insertCountrySubdivisionsOne?: Maybe<CountrySubdivisions>;
  /** insert data into the table: "court_surfaces" */
  insertCourtSurfaces?: Maybe<CourtSurfacesMutationResponse>;
  /** insert a single row into the table: "court_surfaces" */
  insertCourtSurfacesOne?: Maybe<CourtSurfaces>;
  /** insert data into the table: "event_contact_details" */
  insertEventContactDetails?: Maybe<EventContactDetailsMutationResponse>;
  /** insert a single row into the table: "event_contact_details" */
  insertEventContactDetailsOne?: Maybe<EventContactDetails>;
  /** insert data into the table: "event_court_statuses" */
  insertEventCourtStatuses?: Maybe<EventCourtStatusesMutationResponse>;
  /** insert a single row into the table: "event_court_statuses" */
  insertEventCourtStatusesOne?: Maybe<EventCourtStatuses>;
  /** insert data into the table: "event_courts" */
  insertEventCourts?: Maybe<EventCourtsMutationResponse>;
  /** insert a single row into the table: "event_courts" */
  insertEventCourtsOne?: Maybe<EventCourts>;
  /** insert data into the table: "event_faqs" */
  insertEventFaqs?: Maybe<EventFaqsMutationResponse>;
  /** insert a single row into the table: "event_faqs" */
  insertEventFaqsOne?: Maybe<EventFaqs>;
  /** insert data into the table: "event_game_scores" */
  insertEventGameScores?: Maybe<EventGameScoresMutationResponse>;
  /** insert a single row into the table: "event_game_scores" */
  insertEventGameScoresOne?: Maybe<EventGameScores>;
  /** insert data into the table: "event_group_formats" */
  insertEventGroupFormats?: Maybe<EventGroupFormatsMutationResponse>;
  /** insert a single row into the table: "event_group_formats" */
  insertEventGroupFormatsOne?: Maybe<EventGroupFormats>;
  /** insert data into the table: "event_group_pools" */
  insertEventGroupPools?: Maybe<EventGroupPoolsMutationResponse>;
  /** insert a single row into the table: "event_group_pools" */
  insertEventGroupPoolsOne?: Maybe<EventGroupPools>;
  /** insert data into the table: "event_group_registration_statuses" */
  insertEventGroupRegistrationStatuses?: Maybe<EventGroupRegistrationStatusesMutationResponse>;
  /** insert a single row into the table: "event_group_registration_statuses" */
  insertEventGroupRegistrationStatusesOne?: Maybe<EventGroupRegistrationStatuses>;
  /** insert data into the table: "event_group_registrations" */
  insertEventGroupRegistrations?: Maybe<EventGroupRegistrationsMutationResponse>;
  /** insert a single row into the table: "event_group_registrations" */
  insertEventGroupRegistrationsOne?: Maybe<EventGroupRegistrations>;
  /** insert data into the table: "event_group_sequence_seeding" */
  insertEventGroupSequenceSeeding?: Maybe<EventGroupSequenceSeedingMutationResponse>;
  /** insert a single row into the table: "event_group_sequence_seeding" */
  insertEventGroupSequenceSeedingOne?: Maybe<EventGroupSequenceSeeding>;
  /** insert data into the table: "event_group_sequences" */
  insertEventGroupSequences?: Maybe<EventGroupSequencesMutationResponse>;
  /** insert a single row into the table: "event_group_sequences" */
  insertEventGroupSequencesOne?: Maybe<EventGroupSequences>;
  /** insert data into the table: "event_groups" */
  insertEventGroups?: Maybe<EventGroupsMutationResponse>;
  /** insert a single row into the table: "event_groups" */
  insertEventGroupsOne?: Maybe<EventGroups>;
  /** insert data into the table: "event_invitation_statuses" */
  insertEventInvitationStatuses?: Maybe<EventInvitationStatusesMutationResponse>;
  /** insert a single row into the table: "event_invitation_statuses" */
  insertEventInvitationStatusesOne?: Maybe<EventInvitationStatuses>;
  /** insert data into the table: "event_invitations" */
  insertEventInvitations?: Maybe<EventInvitationsMutationResponse>;
  /** insert a single row into the table: "event_invitations" */
  insertEventInvitationsOne?: Maybe<EventInvitations>;
  /** insert data into the table: "event_listing_fees" */
  insertEventListingFees?: Maybe<EventListingFeesMutationResponse>;
  /** insert a single row into the table: "event_listing_fees" */
  insertEventListingFeesOne?: Maybe<EventListingFees>;
  /** insert data into the table: "event_match_games" */
  insertEventMatchGames?: Maybe<EventMatchGamesMutationResponse>;
  /** insert a single row into the table: "event_match_games" */
  insertEventMatchGamesOne?: Maybe<EventMatchGames>;
  /** insert data into the table: "event_matches" */
  insertEventMatches?: Maybe<EventMatchesMutationResponse>;
  /** insert a single row into the table: "event_matches" */
  insertEventMatchesOne?: Maybe<EventMatches>;
  /** insert data into the table: "event_matches_teams" */
  insertEventMatchesTeams?: Maybe<EventMatchesTeamsMutationResponse>;
  /** insert a single row into the table: "event_matches_teams" */
  insertEventMatchesTeamsOne?: Maybe<EventMatchesTeams>;
  /** insert data into the table: "event_organizer_account_types" */
  insertEventOrganizerAccountTypes?: Maybe<EventOrganizerAccountTypesMutationResponse>;
  /** insert a single row into the table: "event_organizer_account_types" */
  insertEventOrganizerAccountTypesOne?: Maybe<EventOrganizerAccountTypes>;
  /** insert data into the table: "event_pool_rounds" */
  insertEventPoolRounds?: Maybe<EventPoolRoundsMutationResponse>;
  /** insert a single row into the table: "event_pool_rounds" */
  insertEventPoolRoundsOne?: Maybe<EventPoolRounds>;
  /** insert data into the table: "event_pools_teams" */
  insertEventPoolsTeams?: Maybe<EventPoolsTeamsMutationResponse>;
  /** insert a single row into the table: "event_pools_teams" */
  insertEventPoolsTeamsOne?: Maybe<EventPoolsTeams>;
  /** insert data into the table: "event_privacy" */
  insertEventPrivacy?: Maybe<EventPrivacyMutationResponse>;
  /** insert a single row into the table: "event_privacy" */
  insertEventPrivacyOne?: Maybe<EventPrivacy>;
  /** insert data into the table: "event_registration_details" */
  insertEventRegistrationDetails?: Maybe<EventRegistrationDetailsMutationResponse>;
  /** insert a single row into the table: "event_registration_details" */
  insertEventRegistrationDetailsOne?: Maybe<EventRegistrationDetails>;
  /** insert data into the table: "event_registrations" */
  insertEventRegistrations?: Maybe<EventRegistrationsMutationResponse>;
  /** insert a single row into the table: "event_registrations" */
  insertEventRegistrationsOne?: Maybe<EventRegistrations>;
  /** insert data into the table: "event_sequence_complete_reasons" */
  insertEventSequenceCompleteReasons?: Maybe<EventSequenceCompleteReasonsMutationResponse>;
  /** insert a single row into the table: "event_sequence_complete_reasons" */
  insertEventSequenceCompleteReasonsOne?: Maybe<EventSequenceCompleteReasons>;
  /** insert data into the table: "event_sponsors" */
  insertEventSponsors?: Maybe<EventSponsorsMutationResponse>;
  /** insert a single row into the table: "event_sponsors" */
  insertEventSponsorsOne?: Maybe<EventSponsors>;
  /** insert data into the table: "event_statuses" */
  insertEventStatuses?: Maybe<EventStatusesMutationResponse>;
  /** insert a single row into the table: "event_statuses" */
  insertEventStatusesOne?: Maybe<EventStatuses>;
  /** insert data into the table: "event_team_member_statuses" */
  insertEventTeamMemberStatuses?: Maybe<EventTeamMemberStatusesMutationResponse>;
  /** insert a single row into the table: "event_team_member_statuses" */
  insertEventTeamMemberStatusesOne?: Maybe<EventTeamMemberStatuses>;
  /** insert data into the table: "event_team_members" */
  insertEventTeamMembers?: Maybe<EventTeamMembersMutationResponse>;
  /** insert a single row into the table: "event_team_members" */
  insertEventTeamMembersOne?: Maybe<EventTeamMembers>;
  /** insert data into the table: "event_teams" */
  insertEventTeams?: Maybe<EventTeamsMutationResponse>;
  /** insert a single row into the table: "event_teams" */
  insertEventTeamsOne?: Maybe<EventTeams>;
  /** insert data into the table: "event_transaction_item_types" */
  insertEventTransactionItemTypes?: Maybe<EventTransactionItemTypesMutationResponse>;
  /** insert a single row into the table: "event_transaction_item_types" */
  insertEventTransactionItemTypesOne?: Maybe<EventTransactionItemTypes>;
  /** insert data into the table: "event_transaction_items" */
  insertEventTransactionItems?: Maybe<EventTransactionItemsMutationResponse>;
  /** insert a single row into the table: "event_transaction_items" */
  insertEventTransactionItemsOne?: Maybe<EventTransactionItems>;
  /** insert data into the table: "event_transactions" */
  insertEventTransactions?: Maybe<EventTransactionsMutationResponse>;
  /** insert a single row into the table: "event_transactions" */
  insertEventTransactionsOne?: Maybe<EventTransactions>;
  /** insert data into the table: "event_types" */
  insertEventTypes?: Maybe<EventTypesMutationResponse>;
  /** insert a single row into the table: "event_types" */
  insertEventTypesOne?: Maybe<EventTypes>;
  /** insert data into the table: "events" */
  insertEvents?: Maybe<EventsMutationResponse>;
  /** insert a single row into the table: "events" */
  insertEventsOne?: Maybe<Events>;
  /** insert data into the table: "follow_statuses" */
  insertFollowStatuses?: Maybe<FollowStatusesMutationResponse>;
  /** insert a single row into the table: "follow_statuses" */
  insertFollowStatusesOne?: Maybe<FollowStatuses>;
  /** insert data into the table: "gender" */
  insertGender?: Maybe<GenderMutationResponse>;
  /** insert a single row into the table: "gender" */
  insertGenderOne?: Maybe<Gender>;
  /** insert data into the table: "group_comment_votes" */
  insertGroupCommentVotes?: Maybe<GroupCommentVotesMutationResponse>;
  /** insert a single row into the table: "group_comment_votes" */
  insertGroupCommentVotesOne?: Maybe<GroupCommentVotes>;
  /** insert data into the table: "group_members" */
  insertGroupMembers?: Maybe<GroupMembersMutationResponse>;
  /** insert a single row into the table: "group_members" */
  insertGroupMembersOne?: Maybe<GroupMembers>;
  /** insert data into the table: "group_thread_comment_files" */
  insertGroupThreadCommentFiles?: Maybe<GroupThreadCommentFilesMutationResponse>;
  /** insert a single row into the table: "group_thread_comment_files" */
  insertGroupThreadCommentFilesOne?: Maybe<GroupThreadCommentFiles>;
  /** insert data into the table: "group_thread_comments" */
  insertGroupThreadComments?: Maybe<GroupThreadCommentsMutationResponse>;
  /** insert a single row into the table: "group_thread_comments" */
  insertGroupThreadCommentsOne?: Maybe<GroupThreadComments>;
  /** insert data into the table: "group_threads" */
  insertGroupThreads?: Maybe<GroupThreadsMutationResponse>;
  /** insert a single row into the table: "group_threads" */
  insertGroupThreadsOne?: Maybe<GroupThreads>;
  /** insert data into the table: "group_venues" */
  insertGroupVenues?: Maybe<GroupVenuesMutationResponse>;
  /** insert a single row into the table: "group_venues" */
  insertGroupVenuesOne?: Maybe<GroupVenues>;
  /** insert data into the table: "groups" */
  insertGroups?: Maybe<GroupsMutationResponse>;
  /** insert a single row into the table: "groups" */
  insertGroupsOne?: Maybe<Groups>;
  /** insert data into the table: "groups_play_sessions" */
  insertGroupsPlaySessions?: Maybe<GroupsPlaySessionsMutationResponse>;
  /** insert a single row into the table: "groups_play_sessions" */
  insertGroupsPlaySessionsOne?: Maybe<GroupsPlaySessions>;
  /** insert data into the table: "lesson_equipment" */
  insertLessonEquipment?: Maybe<LessonEquipmentMutationResponse>;
  /** insert a single row into the table: "lesson_equipment" */
  insertLessonEquipmentOne?: Maybe<LessonEquipment>;
  /** insert data into the table: "lesson_equipment_options" */
  insertLessonEquipmentOptions?: Maybe<LessonEquipmentOptionsMutationResponse>;
  /** insert a single row into the table: "lesson_equipment_options" */
  insertLessonEquipmentOptionsOne?: Maybe<LessonEquipmentOptions>;
  /** insert data into the table: "lesson_order_items" */
  insertLessonOrderItems?: Maybe<LessonOrderItemsMutationResponse>;
  /** insert a single row into the table: "lesson_order_items" */
  insertLessonOrderItemsOne?: Maybe<LessonOrderItems>;
  /** insert data into the table: "lesson_orders" */
  insertLessonOrders?: Maybe<LessonOrdersMutationResponse>;
  /** insert a single row into the table: "lesson_orders" */
  insertLessonOrdersOne?: Maybe<LessonOrders>;
  /** insert data into the table: "lesson_participant_statuses" */
  insertLessonParticipantStatuses?: Maybe<LessonParticipantStatusesMutationResponse>;
  /** insert a single row into the table: "lesson_participant_statuses" */
  insertLessonParticipantStatusesOne?: Maybe<LessonParticipantStatuses>;
  /** insert data into the table: "lesson_participants" */
  insertLessonParticipants?: Maybe<LessonParticipantsMutationResponse>;
  /** insert a single row into the table: "lesson_participants" */
  insertLessonParticipantsOne?: Maybe<LessonParticipants>;
  /** insert data into the table: "lesson_privacy" */
  insertLessonPrivacy?: Maybe<LessonPrivacyMutationResponse>;
  /** insert a single row into the table: "lesson_privacy" */
  insertLessonPrivacyOne?: Maybe<LessonPrivacy>;
  /** insert data into the table: "lesson_statuses" */
  insertLessonStatuses?: Maybe<LessonStatusesMutationResponse>;
  /** insert a single row into the table: "lesson_statuses" */
  insertLessonStatusesOne?: Maybe<LessonStatuses>;
  /** insert data into the table: "lesson_templates" */
  insertLessonTemplates?: Maybe<LessonTemplatesMutationResponse>;
  /** insert a single row into the table: "lesson_templates" */
  insertLessonTemplatesOne?: Maybe<LessonTemplates>;
  /** insert data into the table: "lesson_times" */
  insertLessonTimes?: Maybe<LessonTimesMutationResponse>;
  /** insert a single row into the table: "lesson_times" */
  insertLessonTimesOne?: Maybe<LessonTimes>;
  /** insert data into the table: "lesson_types" */
  insertLessonTypes?: Maybe<LessonTypesMutationResponse>;
  /** insert a single row into the table: "lesson_types" */
  insertLessonTypesOne?: Maybe<LessonTypes>;
  /** insert data into the table: "lesson_waitlist_statuses" */
  insertLessonWaitlistStatuses?: Maybe<LessonWaitlistStatusesMutationResponse>;
  /** insert a single row into the table: "lesson_waitlist_statuses" */
  insertLessonWaitlistStatusesOne?: Maybe<LessonWaitlistStatuses>;
  /** insert data into the table: "lesson_waitlists" */
  insertLessonWaitlists?: Maybe<LessonWaitlistsMutationResponse>;
  /** insert a single row into the table: "lesson_waitlists" */
  insertLessonWaitlistsOne?: Maybe<LessonWaitlists>;
  /** insert data into the table: "lessons" */
  insertLessons?: Maybe<LessonsMutationResponse>;
  /** insert a single row into the table: "lessons" */
  insertLessonsOne?: Maybe<Lessons>;
  /** insert data into the table: "match_selection_criteria" */
  insertMatchSelectionCriteria?: Maybe<MatchSelectionCriteriaMutationResponse>;
  /** insert a single row into the table: "match_selection_criteria" */
  insertMatchSelectionCriteriaOne?: Maybe<MatchSelectionCriteria>;
  /** insert data into the table: "notification_action_types" */
  insertNotificationActionTypes?: Maybe<NotificationActionTypesMutationResponse>;
  /** insert a single row into the table: "notification_action_types" */
  insertNotificationActionTypesOne?: Maybe<NotificationActionTypes>;
  /** insert data into the table: "notification_statuses" */
  insertNotificationStatuses?: Maybe<NotificationStatusesMutationResponse>;
  /** insert a single row into the table: "notification_statuses" */
  insertNotificationStatusesOne?: Maybe<NotificationStatuses>;
  /** insert data into the table: "order_statuses" */
  insertOrderStatuses?: Maybe<OrderStatusesMutationResponse>;
  /** insert a single row into the table: "order_statuses" */
  insertOrderStatusesOne?: Maybe<OrderStatuses>;
  /** insert data into the table: "payment_fulfillment_channels" */
  insertPaymentFulfillmentChannels?: Maybe<PaymentFulfillmentChannelsMutationResponse>;
  /** insert a single row into the table: "payment_fulfillment_channels" */
  insertPaymentFulfillmentChannelsOne?: Maybe<PaymentFulfillmentChannels>;
  /** insert data into the table: "payment_processors" */
  insertPaymentProcessors?: Maybe<PaymentProcessorsMutationResponse>;
  /** insert a single row into the table: "payment_processors" */
  insertPaymentProcessorsOne?: Maybe<PaymentProcessors>;
  /** insert data into the table: "pickleball_rating_scales" */
  insertPickleballRatingScales?: Maybe<PickleballRatingScalesMutationResponse>;
  /** insert a single row into the table: "pickleball_rating_scales" */
  insertPickleballRatingScalesOne?: Maybe<PickleballRatingScales>;
  /** insert data into the table: "play_session_comments" */
  insertPlaySessionComments?: Maybe<PlaySessionCommentsMutationResponse>;
  /** insert a single row into the table: "play_session_comments" */
  insertPlaySessionCommentsOne?: Maybe<PlaySessionComments>;
  /** insert data into the table: "play_session_court_booking_statuses" */
  insertPlaySessionCourtBookingStatuses?: Maybe<PlaySessionCourtBookingStatusesMutationResponse>;
  /** insert a single row into the table: "play_session_court_booking_statuses" */
  insertPlaySessionCourtBookingStatusesOne?: Maybe<PlaySessionCourtBookingStatuses>;
  /** insert data into the table: "play_session_formats" */
  insertPlaySessionFormats?: Maybe<PlaySessionFormatsMutationResponse>;
  /** insert a single row into the table: "play_session_formats" */
  insertPlaySessionFormatsOne?: Maybe<PlaySessionFormats>;
  /** insert data into the table: "play_session_match_competitiveness" */
  insertPlaySessionMatchCompetitiveness?: Maybe<PlaySessionMatchCompetitivenessMutationResponse>;
  /** insert a single row into the table: "play_session_match_competitiveness" */
  insertPlaySessionMatchCompetitivenessOne?: Maybe<PlaySessionMatchCompetitiveness>;
  /** insert data into the table: "play_session_participant_statuses" */
  insertPlaySessionParticipantStatuses?: Maybe<PlaySessionParticipantStatusesMutationResponse>;
  /** insert a single row into the table: "play_session_participant_statuses" */
  insertPlaySessionParticipantStatusesOne?: Maybe<PlaySessionParticipantStatuses>;
  /** insert data into the table: "play_session_participants" */
  insertPlaySessionParticipants?: Maybe<PlaySessionParticipantsMutationResponse>;
  /** insert a single row into the table: "play_session_participants" */
  insertPlaySessionParticipantsOne?: Maybe<PlaySessionParticipants>;
  /** insert data into the table: "play_session_privacy" */
  insertPlaySessionPrivacy?: Maybe<PlaySessionPrivacyMutationResponse>;
  /** insert a single row into the table: "play_session_privacy" */
  insertPlaySessionPrivacyOne?: Maybe<PlaySessionPrivacy>;
  /** insert data into the table: "play_session_statuses" */
  insertPlaySessionStatuses?: Maybe<PlaySessionStatusesMutationResponse>;
  /** insert a single row into the table: "play_session_statuses" */
  insertPlaySessionStatusesOne?: Maybe<PlaySessionStatuses>;
  /** insert data into the table: "play_sessions" */
  insertPlaySessions?: Maybe<PlaySessionsMutationResponse>;
  /** insert a single row into the table: "play_sessions" */
  insertPlaySessionsOne?: Maybe<PlaySessions>;
  /** insert data into the table: "scoring_format" */
  insertScoringFormat?: Maybe<ScoringFormatMutationResponse>;
  /** insert a single row into the table: "scoring_format" */
  insertScoringFormatOne?: Maybe<ScoringFormat>;
  /** insert data into the table: "signup_requests" */
  insertSignupRequests?: Maybe<SignupRequestsMutationResponse>;
  /** insert a single row into the table: "signup_requests" */
  insertSignupRequestsOne?: Maybe<SignupRequests>;
  /** insert data into the table: "skill_levels" */
  insertSkillLevels?: Maybe<SkillLevelsMutationResponse>;
  /** insert a single row into the table: "skill_levels" */
  insertSkillLevelsOne?: Maybe<SkillLevels>;
  /** insert data into the table: "sports" */
  insertSports?: Maybe<SportsMutationResponse>;
  /** insert a single row into the table: "sports" */
  insertSportsOne?: Maybe<Sports>;
  /** insert data into the table: "stripe_charges" */
  insertStripeCharges?: Maybe<StripeChargesMutationResponse>;
  /** insert a single row into the table: "stripe_charges" */
  insertStripeChargesOne?: Maybe<StripeCharges>;
  /** insert data into the table: "stripe_payment_intents" */
  insertStripePaymentIntents?: Maybe<StripePaymentIntentsMutationResponse>;
  /** insert a single row into the table: "stripe_payment_intents" */
  insertStripePaymentIntentsOne?: Maybe<StripePaymentIntents>;
  /** insert data into the table: "team_types" */
  insertTeamTypes?: Maybe<TeamTypesMutationResponse>;
  /** insert a single row into the table: "team_types" */
  insertTeamTypesOne?: Maybe<TeamTypes>;
  /** insert data into the table: "tennis_rating_scales" */
  insertTennisRatingScales?: Maybe<TennisRatingScalesMutationResponse>;
  /** insert a single row into the table: "tennis_rating_scales" */
  insertTennisRatingScalesOne?: Maybe<TennisRatingScales>;
  /** insert data into the table: "user_auth_identities" */
  insertUserAuthIdentities?: Maybe<UserAuthIdentitiesMutationResponse>;
  /** insert a single row into the table: "user_auth_identities" */
  insertUserAuthIdentitiesOne?: Maybe<UserAuthIdentities>;
  /** insert data into the table: "user_coach_services" */
  insertUserCoachServices?: Maybe<UserCoachServicesMutationResponse>;
  /** insert a single row into the table: "user_coach_services" */
  insertUserCoachServicesOne?: Maybe<UserCoachServices>;
  /** insert data into the table: "user_communication_preferences" */
  insertUserCommunicationPreferences?: Maybe<UserCommunicationPreferencesMutationResponse>;
  /** insert a single row into the table: "user_communication_preferences" */
  insertUserCommunicationPreferencesOne?: Maybe<UserCommunicationPreferences>;
  /** insert data into the table: "user_credit_cards" */
  insertUserCreditCards?: Maybe<UserCreditCardsMutationResponse>;
  /** insert a single row into the table: "user_credit_cards" */
  insertUserCreditCardsOne?: Maybe<UserCreditCards>;
  /** insert data into the table: "user_custom_courts" */
  insertUserCustomCourts?: Maybe<UserCustomCourtsMutationResponse>;
  /** insert a single row into the table: "user_custom_courts" */
  insertUserCustomCourtsOne?: Maybe<UserCustomCourts>;
  /** insert data into the table: "user_follows" */
  insertUserFollows?: Maybe<UserFollowsMutationResponse>;
  /** insert a single row into the table: "user_follows" */
  insertUserFollowsOne?: Maybe<UserFollows>;
  /** insert data into the table: "user_image_log" */
  insertUserImageLog?: Maybe<UserImageLogMutationResponse>;
  /** insert a single row into the table: "user_image_log" */
  insertUserImageLogOne?: Maybe<UserImageLog>;
  /** insert data into the table: "user_notification_details" */
  insertUserNotificationDetails?: Maybe<UserNotificationDetailsMutationResponse>;
  /** insert a single row into the table: "user_notification_details" */
  insertUserNotificationDetailsOne?: Maybe<UserNotificationDetails>;
  /** insert data into the table: "user_notification_entities" */
  insertUserNotificationEntities?: Maybe<UserNotificationEntitiesMutationResponse>;
  /** insert a single row into the table: "user_notification_entities" */
  insertUserNotificationEntitiesOne?: Maybe<UserNotificationEntities>;
  /** insert data into the table: "user_notifications" */
  insertUserNotifications?: Maybe<UserNotificationsMutationResponse>;
  /** insert a single row into the table: "user_notifications" */
  insertUserNotificationsOne?: Maybe<UserNotifications>;
  /** insert data into the table: "user_profiles" */
  insertUserProfiles?: Maybe<UserProfilesMutationResponse>;
  /** insert a single row into the table: "user_profiles" */
  insertUserProfilesOne?: Maybe<UserProfiles>;
  /** insert data into the table: "user_registration_details" */
  insertUserRegistrationDetails?: Maybe<UserRegistrationDetailsMutationResponse>;
  /** insert a single row into the table: "user_registration_details" */
  insertUserRegistrationDetailsOne?: Maybe<UserRegistrationDetails>;
  /** insert data into the table: "user_terms_of_service" */
  insertUserTermsOfService?: Maybe<UserTermsOfServiceMutationResponse>;
  /** insert a single row into the table: "user_terms_of_service" */
  insertUserTermsOfServiceOne?: Maybe<UserTermsOfService>;
  /** insert data into the table: "username_logs" */
  insertUsernameLogs?: Maybe<UsernameLogsMutationResponse>;
  /** insert a single row into the table: "username_logs" */
  insertUsernameLogsOne?: Maybe<UsernameLogs>;
  /** insert data into the table: "usernames_active" */
  insertUsernamesActive?: Maybe<UsernamesActiveMutationResponse>;
  /** insert a single row into the table: "usernames_active" */
  insertUsernamesActiveOne?: Maybe<UsernamesActive>;
  /** insert data into the table: "usernames_claimed" */
  insertUsernamesClaimed?: Maybe<UsernamesClaimedMutationResponse>;
  /** insert a single row into the table: "usernames_claimed" */
  insertUsernamesClaimedOne?: Maybe<UsernamesClaimed>;
  /** insert data into the table: "users" */
  insertUsers?: Maybe<UsersMutationResponse>;
  /** insert data into the table: "users_coach_qualifications" */
  insertUsersCoachQualifications?: Maybe<UsersCoachQualificationsMutationResponse>;
  /** insert a single row into the table: "users_coach_qualifications" */
  insertUsersCoachQualificationsOne?: Maybe<UsersCoachQualifications>;
  /** insert a single row into the table: "users" */
  insertUsersOne?: Maybe<Users>;
  /** insert data into the table: "venue_access_types" */
  insertVenueAccessTypes?: Maybe<VenueAccessTypesMutationResponse>;
  /** insert a single row into the table: "venue_access_types" */
  insertVenueAccessTypesOne?: Maybe<VenueAccessTypes>;
  /** insert data into the table: "venue_amenities" */
  insertVenueAmenities?: Maybe<VenueAmenitiesMutationResponse>;
  /** insert a single row into the table: "venue_amenities" */
  insertVenueAmenitiesOne?: Maybe<VenueAmenities>;
  /** insert data into the table: "venue_court_surfaces" */
  insertVenueCourtSurfaces?: Maybe<VenueCourtSurfacesMutationResponse>;
  /** insert a single row into the table: "venue_court_surfaces" */
  insertVenueCourtSurfacesOne?: Maybe<VenueCourtSurfaces>;
  /** insert data into the table: "venue_facility_types" */
  insertVenueFacilityTypes?: Maybe<VenueFacilityTypesMutationResponse>;
  /** insert a single row into the table: "venue_facility_types" */
  insertVenueFacilityTypesOne?: Maybe<VenueFacilityTypes>;
  /** insert data into the table: "venue_follows" */
  insertVenueFollows?: Maybe<VenueFollowsMutationResponse>;
  /** insert a single row into the table: "venue_follows" */
  insertVenueFollowsOne?: Maybe<VenueFollows>;
  /** insert data into the table: "venue_images" */
  insertVenueImages?: Maybe<VenueImagesMutationResponse>;
  /** insert a single row into the table: "venue_images" */
  insertVenueImagesOne?: Maybe<VenueImages>;
  /** insert data into the table: "venue_lines" */
  insertVenueLines?: Maybe<VenueLinesMutationResponse>;
  /** insert a single row into the table: "venue_lines" */
  insertVenueLinesOne?: Maybe<VenueLines>;
  /** insert data into the table: "venue_nets" */
  insertVenueNets?: Maybe<VenueNetsMutationResponse>;
  /** insert a single row into the table: "venue_nets" */
  insertVenueNetsOne?: Maybe<VenueNets>;
  /** insert data into the table: "venues" */
  insertVenues?: Maybe<VenuesMutationResponse>;
  /** insert a single row into the table: "venues" */
  insertVenuesOne?: Maybe<Venues>;
  /** insert data into the table: "welcome_email_configuration" */
  insertWelcomeEmailConfiguration?: Maybe<WelcomeEmailConfigurationMutationResponse>;
  /** insert a single row into the table: "welcome_email_configuration" */
  insertWelcomeEmailConfigurationOne?: Maybe<WelcomeEmailConfiguration>;
  /** insert data into the table: "win_reasons" */
  insertWinReasons?: Maybe<WinReasonsMutationResponse>;
  /** insert a single row into the table: "win_reasons" */
  insertWinReasonsOne?: Maybe<WinReasons>;
  /** update data of the table: "amenities" */
  updateAmenities?: Maybe<AmenitiesMutationResponse>;
  /** update single row of the table: "amenities" */
  updateAmenitiesByPk?: Maybe<Amenities>;
  /** update multiples rows of table: "amenities" */
  updateAmenitiesMany?: Maybe<Array<Maybe<AmenitiesMutationResponse>>>;
  /** update data of the table: "app_personas" */
  updateAppPersonas?: Maybe<AppPersonasMutationResponse>;
  /** update single row of the table: "app_personas" */
  updateAppPersonasByPk?: Maybe<AppPersonas>;
  /** update multiples rows of table: "app_personas" */
  updateAppPersonasMany?: Maybe<Array<Maybe<AppPersonasMutationResponse>>>;
  /** update data of the table: "app_pings" */
  updateAppPings?: Maybe<AppPingsMutationResponse>;
  /** update single row of the table: "app_pings" */
  updateAppPingsByPk?: Maybe<AppPings>;
  /** update multiples rows of table: "app_pings" */
  updateAppPingsMany?: Maybe<Array<Maybe<AppPingsMutationResponse>>>;
  /** update data of the table: "ball_types" */
  updateBallTypes?: Maybe<BallTypesMutationResponse>;
  /** update single row of the table: "ball_types" */
  updateBallTypesByPk?: Maybe<BallTypes>;
  /** update multiples rows of table: "ball_types" */
  updateBallTypesMany?: Maybe<Array<Maybe<BallTypesMutationResponse>>>;
  /** update data of the table: "cities" */
  updateCities?: Maybe<CitiesMutationResponse>;
  /** update single row of the table: "cities" */
  updateCitiesByPk?: Maybe<Cities>;
  /** update multiples rows of table: "cities" */
  updateCitiesMany?: Maybe<Array<Maybe<CitiesMutationResponse>>>;
  /** update data of the table: "coach_qualification_groups" */
  updateCoachQualificationGroups?: Maybe<CoachQualificationGroupsMutationResponse>;
  /** update single row of the table: "coach_qualification_groups" */
  updateCoachQualificationGroupsByPk?: Maybe<CoachQualificationGroups>;
  /** update multiples rows of table: "coach_qualification_groups" */
  updateCoachQualificationGroupsMany?: Maybe<Array<Maybe<CoachQualificationGroupsMutationResponse>>>;
  /** update data of the table: "coach_qualification_statuses" */
  updateCoachQualificationStatuses?: Maybe<CoachQualificationStatusesMutationResponse>;
  /** update single row of the table: "coach_qualification_statuses" */
  updateCoachQualificationStatusesByPk?: Maybe<CoachQualificationStatuses>;
  /** update multiples rows of table: "coach_qualification_statuses" */
  updateCoachQualificationStatusesMany?: Maybe<Array<Maybe<CoachQualificationStatusesMutationResponse>>>;
  /** update data of the table: "coach_qualifications" */
  updateCoachQualifications?: Maybe<CoachQualificationsMutationResponse>;
  /** update single row of the table: "coach_qualifications" */
  updateCoachQualificationsByPk?: Maybe<CoachQualifications>;
  /** update multiples rows of table: "coach_qualifications" */
  updateCoachQualificationsMany?: Maybe<Array<Maybe<CoachQualificationsMutationResponse>>>;
  /** update data of the table: "coach_status" */
  updateCoachStatus?: Maybe<CoachStatusMutationResponse>;
  /** update single row of the table: "coach_status" */
  updateCoachStatusByPk?: Maybe<CoachStatus>;
  /** update multiples rows of table: "coach_status" */
  updateCoachStatusMany?: Maybe<Array<Maybe<CoachStatusMutationResponse>>>;
  /** update data of the table: "comment_vote" */
  updateCommentVote?: Maybe<CommentVoteMutationResponse>;
  /** update single row of the table: "comment_vote" */
  updateCommentVoteByPk?: Maybe<CommentVote>;
  /** update multiples rows of table: "comment_vote" */
  updateCommentVoteMany?: Maybe<Array<Maybe<CommentVoteMutationResponse>>>;
  /** update data of the table: "communication_preference_statuses" */
  updateCommunicationPreferenceStatuses?: Maybe<CommunicationPreferenceStatusesMutationResponse>;
  /** update single row of the table: "communication_preference_statuses" */
  updateCommunicationPreferenceStatusesByPk?: Maybe<CommunicationPreferenceStatuses>;
  /** update multiples rows of table: "communication_preference_statuses" */
  updateCommunicationPreferenceStatusesMany?: Maybe<Array<Maybe<CommunicationPreferenceStatusesMutationResponse>>>;
  /** update data of the table: "competition_formats" */
  updateCompetitionFormats?: Maybe<CompetitionFormatsMutationResponse>;
  /** update single row of the table: "competition_formats" */
  updateCompetitionFormatsByPk?: Maybe<CompetitionFormats>;
  /** update multiples rows of table: "competition_formats" */
  updateCompetitionFormatsMany?: Maybe<Array<Maybe<CompetitionFormatsMutationResponse>>>;
  /** update data of the table: "competition_gender" */
  updateCompetitionGender?: Maybe<CompetitionGenderMutationResponse>;
  /** update single row of the table: "competition_gender" */
  updateCompetitionGenderByPk?: Maybe<CompetitionGender>;
  /** update multiples rows of table: "competition_gender" */
  updateCompetitionGenderMany?: Maybe<Array<Maybe<CompetitionGenderMutationResponse>>>;
  /** update data of the table: "countries" */
  updateCountries?: Maybe<CountriesMutationResponse>;
  /** update single row of the table: "countries" */
  updateCountriesByPk?: Maybe<Countries>;
  /** update multiples rows of table: "countries" */
  updateCountriesMany?: Maybe<Array<Maybe<CountriesMutationResponse>>>;
  /** update data of the table: "country_subdivisions" */
  updateCountrySubdivisions?: Maybe<CountrySubdivisionsMutationResponse>;
  /** update single row of the table: "country_subdivisions" */
  updateCountrySubdivisionsByPk?: Maybe<CountrySubdivisions>;
  /** update multiples rows of table: "country_subdivisions" */
  updateCountrySubdivisionsMany?: Maybe<Array<Maybe<CountrySubdivisionsMutationResponse>>>;
  /** update data of the table: "court_surfaces" */
  updateCourtSurfaces?: Maybe<CourtSurfacesMutationResponse>;
  /** update single row of the table: "court_surfaces" */
  updateCourtSurfacesByPk?: Maybe<CourtSurfaces>;
  /** update multiples rows of table: "court_surfaces" */
  updateCourtSurfacesMany?: Maybe<Array<Maybe<CourtSurfacesMutationResponse>>>;
  /** update data of the table: "event_contact_details" */
  updateEventContactDetails?: Maybe<EventContactDetailsMutationResponse>;
  /** update single row of the table: "event_contact_details" */
  updateEventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** update multiples rows of table: "event_contact_details" */
  updateEventContactDetailsMany?: Maybe<Array<Maybe<EventContactDetailsMutationResponse>>>;
  /** update data of the table: "event_court_statuses" */
  updateEventCourtStatuses?: Maybe<EventCourtStatusesMutationResponse>;
  /** update single row of the table: "event_court_statuses" */
  updateEventCourtStatusesByPk?: Maybe<EventCourtStatuses>;
  /** update multiples rows of table: "event_court_statuses" */
  updateEventCourtStatusesMany?: Maybe<Array<Maybe<EventCourtStatusesMutationResponse>>>;
  /** update data of the table: "event_courts" */
  updateEventCourts?: Maybe<EventCourtsMutationResponse>;
  /** update single row of the table: "event_courts" */
  updateEventCourtsByPk?: Maybe<EventCourts>;
  /** update multiples rows of table: "event_courts" */
  updateEventCourtsMany?: Maybe<Array<Maybe<EventCourtsMutationResponse>>>;
  /** update data of the table: "event_faqs" */
  updateEventFaqs?: Maybe<EventFaqsMutationResponse>;
  /** update single row of the table: "event_faqs" */
  updateEventFaqsByPk?: Maybe<EventFaqs>;
  /** update multiples rows of table: "event_faqs" */
  updateEventFaqsMany?: Maybe<Array<Maybe<EventFaqsMutationResponse>>>;
  /** update data of the table: "event_game_scores" */
  updateEventGameScores?: Maybe<EventGameScoresMutationResponse>;
  /** update single row of the table: "event_game_scores" */
  updateEventGameScoresByPk?: Maybe<EventGameScores>;
  /** update multiples rows of table: "event_game_scores" */
  updateEventGameScoresMany?: Maybe<Array<Maybe<EventGameScoresMutationResponse>>>;
  /** update data of the table: "event_group_formats" */
  updateEventGroupFormats?: Maybe<EventGroupFormatsMutationResponse>;
  /** update single row of the table: "event_group_formats" */
  updateEventGroupFormatsByPk?: Maybe<EventGroupFormats>;
  /** update multiples rows of table: "event_group_formats" */
  updateEventGroupFormatsMany?: Maybe<Array<Maybe<EventGroupFormatsMutationResponse>>>;
  /** update data of the table: "event_group_pools" */
  updateEventGroupPools?: Maybe<EventGroupPoolsMutationResponse>;
  /** update single row of the table: "event_group_pools" */
  updateEventGroupPoolsByPk?: Maybe<EventGroupPools>;
  /** update multiples rows of table: "event_group_pools" */
  updateEventGroupPoolsMany?: Maybe<Array<Maybe<EventGroupPoolsMutationResponse>>>;
  /** update data of the table: "event_group_registration_statuses" */
  updateEventGroupRegistrationStatuses?: Maybe<EventGroupRegistrationStatusesMutationResponse>;
  /** update single row of the table: "event_group_registration_statuses" */
  updateEventGroupRegistrationStatusesByPk?: Maybe<EventGroupRegistrationStatuses>;
  /** update multiples rows of table: "event_group_registration_statuses" */
  updateEventGroupRegistrationStatusesMany?: Maybe<Array<Maybe<EventGroupRegistrationStatusesMutationResponse>>>;
  /** update data of the table: "event_group_registrations" */
  updateEventGroupRegistrations?: Maybe<EventGroupRegistrationsMutationResponse>;
  /** update single row of the table: "event_group_registrations" */
  updateEventGroupRegistrationsByPk?: Maybe<EventGroupRegistrations>;
  /** update multiples rows of table: "event_group_registrations" */
  updateEventGroupRegistrationsMany?: Maybe<Array<Maybe<EventGroupRegistrationsMutationResponse>>>;
  /** update data of the table: "event_group_sequence_seeding" */
  updateEventGroupSequenceSeeding?: Maybe<EventGroupSequenceSeedingMutationResponse>;
  /** update single row of the table: "event_group_sequence_seeding" */
  updateEventGroupSequenceSeedingByPk?: Maybe<EventGroupSequenceSeeding>;
  /** update multiples rows of table: "event_group_sequence_seeding" */
  updateEventGroupSequenceSeedingMany?: Maybe<Array<Maybe<EventGroupSequenceSeedingMutationResponse>>>;
  /** update data of the table: "event_group_sequences" */
  updateEventGroupSequences?: Maybe<EventGroupSequencesMutationResponse>;
  /** update single row of the table: "event_group_sequences" */
  updateEventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** update multiples rows of table: "event_group_sequences" */
  updateEventGroupSequencesMany?: Maybe<Array<Maybe<EventGroupSequencesMutationResponse>>>;
  /** update data of the table: "event_groups" */
  updateEventGroups?: Maybe<EventGroupsMutationResponse>;
  /** update single row of the table: "event_groups" */
  updateEventGroupsByPk?: Maybe<EventGroups>;
  /** update multiples rows of table: "event_groups" */
  updateEventGroupsMany?: Maybe<Array<Maybe<EventGroupsMutationResponse>>>;
  /** update data of the table: "event_invitation_statuses" */
  updateEventInvitationStatuses?: Maybe<EventInvitationStatusesMutationResponse>;
  /** update single row of the table: "event_invitation_statuses" */
  updateEventInvitationStatusesByPk?: Maybe<EventInvitationStatuses>;
  /** update multiples rows of table: "event_invitation_statuses" */
  updateEventInvitationStatusesMany?: Maybe<Array<Maybe<EventInvitationStatusesMutationResponse>>>;
  /** update data of the table: "event_invitations" */
  updateEventInvitations?: Maybe<EventInvitationsMutationResponse>;
  /** update single row of the table: "event_invitations" */
  updateEventInvitationsByPk?: Maybe<EventInvitations>;
  /** update multiples rows of table: "event_invitations" */
  updateEventInvitationsMany?: Maybe<Array<Maybe<EventInvitationsMutationResponse>>>;
  /** update data of the table: "event_listing_fees" */
  updateEventListingFees?: Maybe<EventListingFeesMutationResponse>;
  /** update single row of the table: "event_listing_fees" */
  updateEventListingFeesByPk?: Maybe<EventListingFees>;
  /** update multiples rows of table: "event_listing_fees" */
  updateEventListingFeesMany?: Maybe<Array<Maybe<EventListingFeesMutationResponse>>>;
  /** update data of the table: "event_match_games" */
  updateEventMatchGames?: Maybe<EventMatchGamesMutationResponse>;
  /** update single row of the table: "event_match_games" */
  updateEventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** update multiples rows of table: "event_match_games" */
  updateEventMatchGamesMany?: Maybe<Array<Maybe<EventMatchGamesMutationResponse>>>;
  /** update data of the table: "event_matches" */
  updateEventMatches?: Maybe<EventMatchesMutationResponse>;
  /** update single row of the table: "event_matches" */
  updateEventMatchesByPk?: Maybe<EventMatches>;
  /** update multiples rows of table: "event_matches" */
  updateEventMatchesMany?: Maybe<Array<Maybe<EventMatchesMutationResponse>>>;
  /** update data of the table: "event_matches_teams" */
  updateEventMatchesTeams?: Maybe<EventMatchesTeamsMutationResponse>;
  /** update single row of the table: "event_matches_teams" */
  updateEventMatchesTeamsByPk?: Maybe<EventMatchesTeams>;
  /** update multiples rows of table: "event_matches_teams" */
  updateEventMatchesTeamsMany?: Maybe<Array<Maybe<EventMatchesTeamsMutationResponse>>>;
  /** update data of the table: "event_organizer_account_types" */
  updateEventOrganizerAccountTypes?: Maybe<EventOrganizerAccountTypesMutationResponse>;
  /** update single row of the table: "event_organizer_account_types" */
  updateEventOrganizerAccountTypesByPk?: Maybe<EventOrganizerAccountTypes>;
  /** update multiples rows of table: "event_organizer_account_types" */
  updateEventOrganizerAccountTypesMany?: Maybe<Array<Maybe<EventOrganizerAccountTypesMutationResponse>>>;
  /** update data of the table: "event_pool_rounds" */
  updateEventPoolRounds?: Maybe<EventPoolRoundsMutationResponse>;
  /** update single row of the table: "event_pool_rounds" */
  updateEventPoolRoundsByPk?: Maybe<EventPoolRounds>;
  /** update multiples rows of table: "event_pool_rounds" */
  updateEventPoolRoundsMany?: Maybe<Array<Maybe<EventPoolRoundsMutationResponse>>>;
  /** update data of the table: "event_pools_teams" */
  updateEventPoolsTeams?: Maybe<EventPoolsTeamsMutationResponse>;
  /** update single row of the table: "event_pools_teams" */
  updateEventPoolsTeamsByPk?: Maybe<EventPoolsTeams>;
  /** update multiples rows of table: "event_pools_teams" */
  updateEventPoolsTeamsMany?: Maybe<Array<Maybe<EventPoolsTeamsMutationResponse>>>;
  /** update data of the table: "event_privacy" */
  updateEventPrivacy?: Maybe<EventPrivacyMutationResponse>;
  /** update single row of the table: "event_privacy" */
  updateEventPrivacyByPk?: Maybe<EventPrivacy>;
  /** update multiples rows of table: "event_privacy" */
  updateEventPrivacyMany?: Maybe<Array<Maybe<EventPrivacyMutationResponse>>>;
  /** update data of the table: "event_registration_details" */
  updateEventRegistrationDetails?: Maybe<EventRegistrationDetailsMutationResponse>;
  /** update single row of the table: "event_registration_details" */
  updateEventRegistrationDetailsByPk?: Maybe<EventRegistrationDetails>;
  /** update multiples rows of table: "event_registration_details" */
  updateEventRegistrationDetailsMany?: Maybe<Array<Maybe<EventRegistrationDetailsMutationResponse>>>;
  /** update data of the table: "event_registrations" */
  updateEventRegistrations?: Maybe<EventRegistrationsMutationResponse>;
  /** update single row of the table: "event_registrations" */
  updateEventRegistrationsByPk?: Maybe<EventRegistrations>;
  /** update multiples rows of table: "event_registrations" */
  updateEventRegistrationsMany?: Maybe<Array<Maybe<EventRegistrationsMutationResponse>>>;
  /** update data of the table: "event_sequence_complete_reasons" */
  updateEventSequenceCompleteReasons?: Maybe<EventSequenceCompleteReasonsMutationResponse>;
  /** update single row of the table: "event_sequence_complete_reasons" */
  updateEventSequenceCompleteReasonsByPk?: Maybe<EventSequenceCompleteReasons>;
  /** update multiples rows of table: "event_sequence_complete_reasons" */
  updateEventSequenceCompleteReasonsMany?: Maybe<Array<Maybe<EventSequenceCompleteReasonsMutationResponse>>>;
  /** update data of the table: "event_sponsors" */
  updateEventSponsors?: Maybe<EventSponsorsMutationResponse>;
  /** update single row of the table: "event_sponsors" */
  updateEventSponsorsByPk?: Maybe<EventSponsors>;
  /** update multiples rows of table: "event_sponsors" */
  updateEventSponsorsMany?: Maybe<Array<Maybe<EventSponsorsMutationResponse>>>;
  /** update data of the table: "event_statuses" */
  updateEventStatuses?: Maybe<EventStatusesMutationResponse>;
  /** update single row of the table: "event_statuses" */
  updateEventStatusesByPk?: Maybe<EventStatuses>;
  /** update multiples rows of table: "event_statuses" */
  updateEventStatusesMany?: Maybe<Array<Maybe<EventStatusesMutationResponse>>>;
  /** update data of the table: "event_team_member_statuses" */
  updateEventTeamMemberStatuses?: Maybe<EventTeamMemberStatusesMutationResponse>;
  /** update single row of the table: "event_team_member_statuses" */
  updateEventTeamMemberStatusesByPk?: Maybe<EventTeamMemberStatuses>;
  /** update multiples rows of table: "event_team_member_statuses" */
  updateEventTeamMemberStatusesMany?: Maybe<Array<Maybe<EventTeamMemberStatusesMutationResponse>>>;
  /** update data of the table: "event_team_members" */
  updateEventTeamMembers?: Maybe<EventTeamMembersMutationResponse>;
  /** update single row of the table: "event_team_members" */
  updateEventTeamMembersByPk?: Maybe<EventTeamMembers>;
  /** update multiples rows of table: "event_team_members" */
  updateEventTeamMembersMany?: Maybe<Array<Maybe<EventTeamMembersMutationResponse>>>;
  /** update data of the table: "event_teams" */
  updateEventTeams?: Maybe<EventTeamsMutationResponse>;
  /** update single row of the table: "event_teams" */
  updateEventTeamsByPk?: Maybe<EventTeams>;
  /** update multiples rows of table: "event_teams" */
  updateEventTeamsMany?: Maybe<Array<Maybe<EventTeamsMutationResponse>>>;
  /** update data of the table: "event_transaction_item_types" */
  updateEventTransactionItemTypes?: Maybe<EventTransactionItemTypesMutationResponse>;
  /** update single row of the table: "event_transaction_item_types" */
  updateEventTransactionItemTypesByPk?: Maybe<EventTransactionItemTypes>;
  /** update multiples rows of table: "event_transaction_item_types" */
  updateEventTransactionItemTypesMany?: Maybe<Array<Maybe<EventTransactionItemTypesMutationResponse>>>;
  /** update data of the table: "event_transaction_items" */
  updateEventTransactionItems?: Maybe<EventTransactionItemsMutationResponse>;
  /** update single row of the table: "event_transaction_items" */
  updateEventTransactionItemsByPk?: Maybe<EventTransactionItems>;
  /** update multiples rows of table: "event_transaction_items" */
  updateEventTransactionItemsMany?: Maybe<Array<Maybe<EventTransactionItemsMutationResponse>>>;
  /** update data of the table: "event_transactions" */
  updateEventTransactions?: Maybe<EventTransactionsMutationResponse>;
  /** update single row of the table: "event_transactions" */
  updateEventTransactionsByPk?: Maybe<EventTransactions>;
  /** update multiples rows of table: "event_transactions" */
  updateEventTransactionsMany?: Maybe<Array<Maybe<EventTransactionsMutationResponse>>>;
  /** update data of the table: "event_types" */
  updateEventTypes?: Maybe<EventTypesMutationResponse>;
  /** update single row of the table: "event_types" */
  updateEventTypesByPk?: Maybe<EventTypes>;
  /** update multiples rows of table: "event_types" */
  updateEventTypesMany?: Maybe<Array<Maybe<EventTypesMutationResponse>>>;
  /** update data of the table: "events" */
  updateEvents?: Maybe<EventsMutationResponse>;
  /** update single row of the table: "events" */
  updateEventsByPk?: Maybe<Events>;
  /** update multiples rows of table: "events" */
  updateEventsMany?: Maybe<Array<Maybe<EventsMutationResponse>>>;
  /** update data of the table: "follow_statuses" */
  updateFollowStatuses?: Maybe<FollowStatusesMutationResponse>;
  /** update single row of the table: "follow_statuses" */
  updateFollowStatusesByPk?: Maybe<FollowStatuses>;
  /** update multiples rows of table: "follow_statuses" */
  updateFollowStatusesMany?: Maybe<Array<Maybe<FollowStatusesMutationResponse>>>;
  /** update data of the table: "gender" */
  updateGender?: Maybe<GenderMutationResponse>;
  /** update single row of the table: "gender" */
  updateGenderByPk?: Maybe<Gender>;
  /** update multiples rows of table: "gender" */
  updateGenderMany?: Maybe<Array<Maybe<GenderMutationResponse>>>;
  /** update data of the table: "group_comment_votes" */
  updateGroupCommentVotes?: Maybe<GroupCommentVotesMutationResponse>;
  /** update single row of the table: "group_comment_votes" */
  updateGroupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** update multiples rows of table: "group_comment_votes" */
  updateGroupCommentVotesMany?: Maybe<Array<Maybe<GroupCommentVotesMutationResponse>>>;
  /** update data of the table: "group_members" */
  updateGroupMembers?: Maybe<GroupMembersMutationResponse>;
  /** update single row of the table: "group_members" */
  updateGroupMembersByPk?: Maybe<GroupMembers>;
  /** update multiples rows of table: "group_members" */
  updateGroupMembersMany?: Maybe<Array<Maybe<GroupMembersMutationResponse>>>;
  /** update data of the table: "group_thread_comment_files" */
  updateGroupThreadCommentFiles?: Maybe<GroupThreadCommentFilesMutationResponse>;
  /** update single row of the table: "group_thread_comment_files" */
  updateGroupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** update multiples rows of table: "group_thread_comment_files" */
  updateGroupThreadCommentFilesMany?: Maybe<Array<Maybe<GroupThreadCommentFilesMutationResponse>>>;
  /** update data of the table: "group_thread_comments" */
  updateGroupThreadComments?: Maybe<GroupThreadCommentsMutationResponse>;
  /** update single row of the table: "group_thread_comments" */
  updateGroupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** update multiples rows of table: "group_thread_comments" */
  updateGroupThreadCommentsMany?: Maybe<Array<Maybe<GroupThreadCommentsMutationResponse>>>;
  /** update data of the table: "group_threads" */
  updateGroupThreads?: Maybe<GroupThreadsMutationResponse>;
  /** update single row of the table: "group_threads" */
  updateGroupThreadsByPk?: Maybe<GroupThreads>;
  /** update multiples rows of table: "group_threads" */
  updateGroupThreadsMany?: Maybe<Array<Maybe<GroupThreadsMutationResponse>>>;
  /** update data of the table: "group_venues" */
  updateGroupVenues?: Maybe<GroupVenuesMutationResponse>;
  /** update single row of the table: "group_venues" */
  updateGroupVenuesByPk?: Maybe<GroupVenues>;
  /** update multiples rows of table: "group_venues" */
  updateGroupVenuesMany?: Maybe<Array<Maybe<GroupVenuesMutationResponse>>>;
  /** update data of the table: "groups" */
  updateGroups?: Maybe<GroupsMutationResponse>;
  /** update single row of the table: "groups" */
  updateGroupsByPk?: Maybe<Groups>;
  /** update multiples rows of table: "groups" */
  updateGroupsMany?: Maybe<Array<Maybe<GroupsMutationResponse>>>;
  /** update data of the table: "groups_play_sessions" */
  updateGroupsPlaySessions?: Maybe<GroupsPlaySessionsMutationResponse>;
  /** update single row of the table: "groups_play_sessions" */
  updateGroupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** update multiples rows of table: "groups_play_sessions" */
  updateGroupsPlaySessionsMany?: Maybe<Array<Maybe<GroupsPlaySessionsMutationResponse>>>;
  /** update data of the table: "lesson_equipment" */
  updateLessonEquipment?: Maybe<LessonEquipmentMutationResponse>;
  /** update single row of the table: "lesson_equipment" */
  updateLessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** update multiples rows of table: "lesson_equipment" */
  updateLessonEquipmentMany?: Maybe<Array<Maybe<LessonEquipmentMutationResponse>>>;
  /** update data of the table: "lesson_equipment_options" */
  updateLessonEquipmentOptions?: Maybe<LessonEquipmentOptionsMutationResponse>;
  /** update single row of the table: "lesson_equipment_options" */
  updateLessonEquipmentOptionsByPk?: Maybe<LessonEquipmentOptions>;
  /** update multiples rows of table: "lesson_equipment_options" */
  updateLessonEquipmentOptionsMany?: Maybe<Array<Maybe<LessonEquipmentOptionsMutationResponse>>>;
  /** update data of the table: "lesson_order_items" */
  updateLessonOrderItems?: Maybe<LessonOrderItemsMutationResponse>;
  /** update single row of the table: "lesson_order_items" */
  updateLessonOrderItemsByPk?: Maybe<LessonOrderItems>;
  /** update multiples rows of table: "lesson_order_items" */
  updateLessonOrderItemsMany?: Maybe<Array<Maybe<LessonOrderItemsMutationResponse>>>;
  /** update data of the table: "lesson_orders" */
  updateLessonOrders?: Maybe<LessonOrdersMutationResponse>;
  /** update single row of the table: "lesson_orders" */
  updateLessonOrdersByPk?: Maybe<LessonOrders>;
  /** update multiples rows of table: "lesson_orders" */
  updateLessonOrdersMany?: Maybe<Array<Maybe<LessonOrdersMutationResponse>>>;
  /** update data of the table: "lesson_participant_statuses" */
  updateLessonParticipantStatuses?: Maybe<LessonParticipantStatusesMutationResponse>;
  /** update single row of the table: "lesson_participant_statuses" */
  updateLessonParticipantStatusesByPk?: Maybe<LessonParticipantStatuses>;
  /** update multiples rows of table: "lesson_participant_statuses" */
  updateLessonParticipantStatusesMany?: Maybe<Array<Maybe<LessonParticipantStatusesMutationResponse>>>;
  /** update data of the table: "lesson_participants" */
  updateLessonParticipants?: Maybe<LessonParticipantsMutationResponse>;
  /** update single row of the table: "lesson_participants" */
  updateLessonParticipantsByPk?: Maybe<LessonParticipants>;
  /** update multiples rows of table: "lesson_participants" */
  updateLessonParticipantsMany?: Maybe<Array<Maybe<LessonParticipantsMutationResponse>>>;
  /** update data of the table: "lesson_privacy" */
  updateLessonPrivacy?: Maybe<LessonPrivacyMutationResponse>;
  /** update single row of the table: "lesson_privacy" */
  updateLessonPrivacyByPk?: Maybe<LessonPrivacy>;
  /** update multiples rows of table: "lesson_privacy" */
  updateLessonPrivacyMany?: Maybe<Array<Maybe<LessonPrivacyMutationResponse>>>;
  /** update data of the table: "lesson_statuses" */
  updateLessonStatuses?: Maybe<LessonStatusesMutationResponse>;
  /** update single row of the table: "lesson_statuses" */
  updateLessonStatusesByPk?: Maybe<LessonStatuses>;
  /** update multiples rows of table: "lesson_statuses" */
  updateLessonStatusesMany?: Maybe<Array<Maybe<LessonStatusesMutationResponse>>>;
  /** update data of the table: "lesson_templates" */
  updateLessonTemplates?: Maybe<LessonTemplatesMutationResponse>;
  /** update single row of the table: "lesson_templates" */
  updateLessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** update multiples rows of table: "lesson_templates" */
  updateLessonTemplatesMany?: Maybe<Array<Maybe<LessonTemplatesMutationResponse>>>;
  /** update data of the table: "lesson_times" */
  updateLessonTimes?: Maybe<LessonTimesMutationResponse>;
  /** update single row of the table: "lesson_times" */
  updateLessonTimesByPk?: Maybe<LessonTimes>;
  /** update multiples rows of table: "lesson_times" */
  updateLessonTimesMany?: Maybe<Array<Maybe<LessonTimesMutationResponse>>>;
  /** update data of the table: "lesson_types" */
  updateLessonTypes?: Maybe<LessonTypesMutationResponse>;
  /** update single row of the table: "lesson_types" */
  updateLessonTypesByPk?: Maybe<LessonTypes>;
  /** update multiples rows of table: "lesson_types" */
  updateLessonTypesMany?: Maybe<Array<Maybe<LessonTypesMutationResponse>>>;
  /** update data of the table: "lesson_waitlist_statuses" */
  updateLessonWaitlistStatuses?: Maybe<LessonWaitlistStatusesMutationResponse>;
  /** update single row of the table: "lesson_waitlist_statuses" */
  updateLessonWaitlistStatusesByPk?: Maybe<LessonWaitlistStatuses>;
  /** update multiples rows of table: "lesson_waitlist_statuses" */
  updateLessonWaitlistStatusesMany?: Maybe<Array<Maybe<LessonWaitlistStatusesMutationResponse>>>;
  /** update data of the table: "lesson_waitlists" */
  updateLessonWaitlists?: Maybe<LessonWaitlistsMutationResponse>;
  /** update single row of the table: "lesson_waitlists" */
  updateLessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** update multiples rows of table: "lesson_waitlists" */
  updateLessonWaitlistsMany?: Maybe<Array<Maybe<LessonWaitlistsMutationResponse>>>;
  /** update data of the table: "lessons" */
  updateLessons?: Maybe<LessonsMutationResponse>;
  /** update single row of the table: "lessons" */
  updateLessonsByPk?: Maybe<Lessons>;
  /** update multiples rows of table: "lessons" */
  updateLessonsMany?: Maybe<Array<Maybe<LessonsMutationResponse>>>;
  /** update data of the table: "match_selection_criteria" */
  updateMatchSelectionCriteria?: Maybe<MatchSelectionCriteriaMutationResponse>;
  /** update single row of the table: "match_selection_criteria" */
  updateMatchSelectionCriteriaByPk?: Maybe<MatchSelectionCriteria>;
  /** update multiples rows of table: "match_selection_criteria" */
  updateMatchSelectionCriteriaMany?: Maybe<Array<Maybe<MatchSelectionCriteriaMutationResponse>>>;
  /** update data of the table: "notification_action_types" */
  updateNotificationActionTypes?: Maybe<NotificationActionTypesMutationResponse>;
  /** update single row of the table: "notification_action_types" */
  updateNotificationActionTypesByPk?: Maybe<NotificationActionTypes>;
  /** update multiples rows of table: "notification_action_types" */
  updateNotificationActionTypesMany?: Maybe<Array<Maybe<NotificationActionTypesMutationResponse>>>;
  /** update data of the table: "notification_statuses" */
  updateNotificationStatuses?: Maybe<NotificationStatusesMutationResponse>;
  /** update single row of the table: "notification_statuses" */
  updateNotificationStatusesByPk?: Maybe<NotificationStatuses>;
  /** update multiples rows of table: "notification_statuses" */
  updateNotificationStatusesMany?: Maybe<Array<Maybe<NotificationStatusesMutationResponse>>>;
  /** update data of the table: "order_statuses" */
  updateOrderStatuses?: Maybe<OrderStatusesMutationResponse>;
  /** update single row of the table: "order_statuses" */
  updateOrderStatusesByPk?: Maybe<OrderStatuses>;
  /** update multiples rows of table: "order_statuses" */
  updateOrderStatusesMany?: Maybe<Array<Maybe<OrderStatusesMutationResponse>>>;
  /** update data of the table: "payment_fulfillment_channels" */
  updatePaymentFulfillmentChannels?: Maybe<PaymentFulfillmentChannelsMutationResponse>;
  /** update single row of the table: "payment_fulfillment_channels" */
  updatePaymentFulfillmentChannelsByPk?: Maybe<PaymentFulfillmentChannels>;
  /** update multiples rows of table: "payment_fulfillment_channels" */
  updatePaymentFulfillmentChannelsMany?: Maybe<Array<Maybe<PaymentFulfillmentChannelsMutationResponse>>>;
  /** update data of the table: "payment_processors" */
  updatePaymentProcessors?: Maybe<PaymentProcessorsMutationResponse>;
  /** update single row of the table: "payment_processors" */
  updatePaymentProcessorsByPk?: Maybe<PaymentProcessors>;
  /** update multiples rows of table: "payment_processors" */
  updatePaymentProcessorsMany?: Maybe<Array<Maybe<PaymentProcessorsMutationResponse>>>;
  /** update data of the table: "pickleball_rating_scales" */
  updatePickleballRatingScales?: Maybe<PickleballRatingScalesMutationResponse>;
  /** update single row of the table: "pickleball_rating_scales" */
  updatePickleballRatingScalesByPk?: Maybe<PickleballRatingScales>;
  /** update multiples rows of table: "pickleball_rating_scales" */
  updatePickleballRatingScalesMany?: Maybe<Array<Maybe<PickleballRatingScalesMutationResponse>>>;
  /** update data of the table: "play_session_comments" */
  updatePlaySessionComments?: Maybe<PlaySessionCommentsMutationResponse>;
  /** update single row of the table: "play_session_comments" */
  updatePlaySessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** update multiples rows of table: "play_session_comments" */
  updatePlaySessionCommentsMany?: Maybe<Array<Maybe<PlaySessionCommentsMutationResponse>>>;
  /** update data of the table: "play_session_court_booking_statuses" */
  updatePlaySessionCourtBookingStatuses?: Maybe<PlaySessionCourtBookingStatusesMutationResponse>;
  /** update single row of the table: "play_session_court_booking_statuses" */
  updatePlaySessionCourtBookingStatusesByPk?: Maybe<PlaySessionCourtBookingStatuses>;
  /** update multiples rows of table: "play_session_court_booking_statuses" */
  updatePlaySessionCourtBookingStatusesMany?: Maybe<Array<Maybe<PlaySessionCourtBookingStatusesMutationResponse>>>;
  /** update data of the table: "play_session_formats" */
  updatePlaySessionFormats?: Maybe<PlaySessionFormatsMutationResponse>;
  /** update single row of the table: "play_session_formats" */
  updatePlaySessionFormatsByPk?: Maybe<PlaySessionFormats>;
  /** update multiples rows of table: "play_session_formats" */
  updatePlaySessionFormatsMany?: Maybe<Array<Maybe<PlaySessionFormatsMutationResponse>>>;
  /** update data of the table: "play_session_match_competitiveness" */
  updatePlaySessionMatchCompetitiveness?: Maybe<PlaySessionMatchCompetitivenessMutationResponse>;
  /** update single row of the table: "play_session_match_competitiveness" */
  updatePlaySessionMatchCompetitivenessByPk?: Maybe<PlaySessionMatchCompetitiveness>;
  /** update multiples rows of table: "play_session_match_competitiveness" */
  updatePlaySessionMatchCompetitivenessMany?: Maybe<Array<Maybe<PlaySessionMatchCompetitivenessMutationResponse>>>;
  /** update data of the table: "play_session_participant_statuses" */
  updatePlaySessionParticipantStatuses?: Maybe<PlaySessionParticipantStatusesMutationResponse>;
  /** update single row of the table: "play_session_participant_statuses" */
  updatePlaySessionParticipantStatusesByPk?: Maybe<PlaySessionParticipantStatuses>;
  /** update multiples rows of table: "play_session_participant_statuses" */
  updatePlaySessionParticipantStatusesMany?: Maybe<Array<Maybe<PlaySessionParticipantStatusesMutationResponse>>>;
  /** update data of the table: "play_session_participants" */
  updatePlaySessionParticipants?: Maybe<PlaySessionParticipantsMutationResponse>;
  /** update single row of the table: "play_session_participants" */
  updatePlaySessionParticipantsByPk?: Maybe<PlaySessionParticipants>;
  /** update multiples rows of table: "play_session_participants" */
  updatePlaySessionParticipantsMany?: Maybe<Array<Maybe<PlaySessionParticipantsMutationResponse>>>;
  /** update data of the table: "play_session_privacy" */
  updatePlaySessionPrivacy?: Maybe<PlaySessionPrivacyMutationResponse>;
  /** update single row of the table: "play_session_privacy" */
  updatePlaySessionPrivacyByPk?: Maybe<PlaySessionPrivacy>;
  /** update multiples rows of table: "play_session_privacy" */
  updatePlaySessionPrivacyMany?: Maybe<Array<Maybe<PlaySessionPrivacyMutationResponse>>>;
  /** update data of the table: "play_session_statuses" */
  updatePlaySessionStatuses?: Maybe<PlaySessionStatusesMutationResponse>;
  /** update single row of the table: "play_session_statuses" */
  updatePlaySessionStatusesByPk?: Maybe<PlaySessionStatuses>;
  /** update multiples rows of table: "play_session_statuses" */
  updatePlaySessionStatusesMany?: Maybe<Array<Maybe<PlaySessionStatusesMutationResponse>>>;
  /** update data of the table: "play_sessions" */
  updatePlaySessions?: Maybe<PlaySessionsMutationResponse>;
  /** update single row of the table: "play_sessions" */
  updatePlaySessionsByPk?: Maybe<PlaySessions>;
  /** update multiples rows of table: "play_sessions" */
  updatePlaySessionsMany?: Maybe<Array<Maybe<PlaySessionsMutationResponse>>>;
  /** update data of the table: "scoring_format" */
  updateScoringFormat?: Maybe<ScoringFormatMutationResponse>;
  /** update single row of the table: "scoring_format" */
  updateScoringFormatByPk?: Maybe<ScoringFormat>;
  /** update multiples rows of table: "scoring_format" */
  updateScoringFormatMany?: Maybe<Array<Maybe<ScoringFormatMutationResponse>>>;
  /** update data of the table: "signup_requests" */
  updateSignupRequests?: Maybe<SignupRequestsMutationResponse>;
  /** update single row of the table: "signup_requests" */
  updateSignupRequestsByPk?: Maybe<SignupRequests>;
  /** update multiples rows of table: "signup_requests" */
  updateSignupRequestsMany?: Maybe<Array<Maybe<SignupRequestsMutationResponse>>>;
  /** update data of the table: "skill_levels" */
  updateSkillLevels?: Maybe<SkillLevelsMutationResponse>;
  /** update single row of the table: "skill_levels" */
  updateSkillLevelsByPk?: Maybe<SkillLevels>;
  /** update multiples rows of table: "skill_levels" */
  updateSkillLevelsMany?: Maybe<Array<Maybe<SkillLevelsMutationResponse>>>;
  /** update data of the table: "sports" */
  updateSports?: Maybe<SportsMutationResponse>;
  /** update single row of the table: "sports" */
  updateSportsByPk?: Maybe<Sports>;
  /** update multiples rows of table: "sports" */
  updateSportsMany?: Maybe<Array<Maybe<SportsMutationResponse>>>;
  /** update data of the table: "stripe_charges" */
  updateStripeCharges?: Maybe<StripeChargesMutationResponse>;
  /** update single row of the table: "stripe_charges" */
  updateStripeChargesByPk?: Maybe<StripeCharges>;
  /** update multiples rows of table: "stripe_charges" */
  updateStripeChargesMany?: Maybe<Array<Maybe<StripeChargesMutationResponse>>>;
  /** update data of the table: "stripe_payment_intents" */
  updateStripePaymentIntents?: Maybe<StripePaymentIntentsMutationResponse>;
  /** update single row of the table: "stripe_payment_intents" */
  updateStripePaymentIntentsByPk?: Maybe<StripePaymentIntents>;
  /** update multiples rows of table: "stripe_payment_intents" */
  updateStripePaymentIntentsMany?: Maybe<Array<Maybe<StripePaymentIntentsMutationResponse>>>;
  /** update data of the table: "team_types" */
  updateTeamTypes?: Maybe<TeamTypesMutationResponse>;
  /** update single row of the table: "team_types" */
  updateTeamTypesByPk?: Maybe<TeamTypes>;
  /** update multiples rows of table: "team_types" */
  updateTeamTypesMany?: Maybe<Array<Maybe<TeamTypesMutationResponse>>>;
  /** update data of the table: "tennis_rating_scales" */
  updateTennisRatingScales?: Maybe<TennisRatingScalesMutationResponse>;
  /** update single row of the table: "tennis_rating_scales" */
  updateTennisRatingScalesByPk?: Maybe<TennisRatingScales>;
  /** update multiples rows of table: "tennis_rating_scales" */
  updateTennisRatingScalesMany?: Maybe<Array<Maybe<TennisRatingScalesMutationResponse>>>;
  /** update data of the table: "user_auth_identities" */
  updateUserAuthIdentities?: Maybe<UserAuthIdentitiesMutationResponse>;
  /** update single row of the table: "user_auth_identities" */
  updateUserAuthIdentitiesByPk?: Maybe<UserAuthIdentities>;
  /** update multiples rows of table: "user_auth_identities" */
  updateUserAuthIdentitiesMany?: Maybe<Array<Maybe<UserAuthIdentitiesMutationResponse>>>;
  /** update data of the table: "user_coach_services" */
  updateUserCoachServices?: Maybe<UserCoachServicesMutationResponse>;
  /** update single row of the table: "user_coach_services" */
  updateUserCoachServicesByPk?: Maybe<UserCoachServices>;
  /** update multiples rows of table: "user_coach_services" */
  updateUserCoachServicesMany?: Maybe<Array<Maybe<UserCoachServicesMutationResponse>>>;
  /** update data of the table: "user_communication_preferences" */
  updateUserCommunicationPreferences?: Maybe<UserCommunicationPreferencesMutationResponse>;
  /** update single row of the table: "user_communication_preferences" */
  updateUserCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** update multiples rows of table: "user_communication_preferences" */
  updateUserCommunicationPreferencesMany?: Maybe<Array<Maybe<UserCommunicationPreferencesMutationResponse>>>;
  /** update data of the table: "user_credit_cards" */
  updateUserCreditCards?: Maybe<UserCreditCardsMutationResponse>;
  /** update single row of the table: "user_credit_cards" */
  updateUserCreditCardsByPk?: Maybe<UserCreditCards>;
  /** update multiples rows of table: "user_credit_cards" */
  updateUserCreditCardsMany?: Maybe<Array<Maybe<UserCreditCardsMutationResponse>>>;
  /** update data of the table: "user_custom_courts" */
  updateUserCustomCourts?: Maybe<UserCustomCourtsMutationResponse>;
  /** update single row of the table: "user_custom_courts" */
  updateUserCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** update multiples rows of table: "user_custom_courts" */
  updateUserCustomCourtsMany?: Maybe<Array<Maybe<UserCustomCourtsMutationResponse>>>;
  /** update data of the table: "user_follows" */
  updateUserFollows?: Maybe<UserFollowsMutationResponse>;
  /** update single row of the table: "user_follows" */
  updateUserFollowsByPk?: Maybe<UserFollows>;
  /** update multiples rows of table: "user_follows" */
  updateUserFollowsMany?: Maybe<Array<Maybe<UserFollowsMutationResponse>>>;
  /** update data of the table: "user_image_log" */
  updateUserImageLog?: Maybe<UserImageLogMutationResponse>;
  /** update single row of the table: "user_image_log" */
  updateUserImageLogByPk?: Maybe<UserImageLog>;
  /** update multiples rows of table: "user_image_log" */
  updateUserImageLogMany?: Maybe<Array<Maybe<UserImageLogMutationResponse>>>;
  /** update data of the table: "user_notification_details" */
  updateUserNotificationDetails?: Maybe<UserNotificationDetailsMutationResponse>;
  /** update single row of the table: "user_notification_details" */
  updateUserNotificationDetailsByPk?: Maybe<UserNotificationDetails>;
  /** update multiples rows of table: "user_notification_details" */
  updateUserNotificationDetailsMany?: Maybe<Array<Maybe<UserNotificationDetailsMutationResponse>>>;
  /** update data of the table: "user_notification_entities" */
  updateUserNotificationEntities?: Maybe<UserNotificationEntitiesMutationResponse>;
  /** update single row of the table: "user_notification_entities" */
  updateUserNotificationEntitiesByPk?: Maybe<UserNotificationEntities>;
  /** update multiples rows of table: "user_notification_entities" */
  updateUserNotificationEntitiesMany?: Maybe<Array<Maybe<UserNotificationEntitiesMutationResponse>>>;
  /** update data of the table: "user_notifications" */
  updateUserNotifications?: Maybe<UserNotificationsMutationResponse>;
  /** update single row of the table: "user_notifications" */
  updateUserNotificationsByPk?: Maybe<UserNotifications>;
  /** update multiples rows of table: "user_notifications" */
  updateUserNotificationsMany?: Maybe<Array<Maybe<UserNotificationsMutationResponse>>>;
  /** update data of the table: "user_profiles" */
  updateUserProfiles?: Maybe<UserProfilesMutationResponse>;
  /** update multiples rows of table: "user_profiles" */
  updateUserProfilesMany?: Maybe<Array<Maybe<UserProfilesMutationResponse>>>;
  /** update data of the table: "user_registration_details" */
  updateUserRegistrationDetails?: Maybe<UserRegistrationDetailsMutationResponse>;
  /** update single row of the table: "user_registration_details" */
  updateUserRegistrationDetailsByPk?: Maybe<UserRegistrationDetails>;
  /** update multiples rows of table: "user_registration_details" */
  updateUserRegistrationDetailsMany?: Maybe<Array<Maybe<UserRegistrationDetailsMutationResponse>>>;
  /** update data of the table: "user_terms_of_service" */
  updateUserTermsOfService?: Maybe<UserTermsOfServiceMutationResponse>;
  /** update single row of the table: "user_terms_of_service" */
  updateUserTermsOfServiceByPk?: Maybe<UserTermsOfService>;
  /** update multiples rows of table: "user_terms_of_service" */
  updateUserTermsOfServiceMany?: Maybe<Array<Maybe<UserTermsOfServiceMutationResponse>>>;
  /** update data of the table: "username_logs" */
  updateUsernameLogs?: Maybe<UsernameLogsMutationResponse>;
  /** update single row of the table: "username_logs" */
  updateUsernameLogsByPk?: Maybe<UsernameLogs>;
  /** update multiples rows of table: "username_logs" */
  updateUsernameLogsMany?: Maybe<Array<Maybe<UsernameLogsMutationResponse>>>;
  /** update data of the table: "usernames_active" */
  updateUsernamesActive?: Maybe<UsernamesActiveMutationResponse>;
  /** update multiples rows of table: "usernames_active" */
  updateUsernamesActiveMany?: Maybe<Array<Maybe<UsernamesActiveMutationResponse>>>;
  /** update data of the table: "usernames_claimed" */
  updateUsernamesClaimed?: Maybe<UsernamesClaimedMutationResponse>;
  /** update single row of the table: "usernames_claimed" */
  updateUsernamesClaimedByPk?: Maybe<UsernamesClaimed>;
  /** update multiples rows of table: "usernames_claimed" */
  updateUsernamesClaimedMany?: Maybe<Array<Maybe<UsernamesClaimedMutationResponse>>>;
  /** update data of the table: "users" */
  updateUsers?: Maybe<UsersMutationResponse>;
  /** update single row of the table: "users" */
  updateUsersByPk?: Maybe<Users>;
  /** update data of the table: "users_coach_qualifications" */
  updateUsersCoachQualifications?: Maybe<UsersCoachQualificationsMutationResponse>;
  /** update single row of the table: "users_coach_qualifications" */
  updateUsersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** update multiples rows of table: "users_coach_qualifications" */
  updateUsersCoachQualificationsMany?: Maybe<Array<Maybe<UsersCoachQualificationsMutationResponse>>>;
  /** update multiples rows of table: "users" */
  updateUsersMany?: Maybe<Array<Maybe<UsersMutationResponse>>>;
  /** update data of the table: "venue_access_types" */
  updateVenueAccessTypes?: Maybe<VenueAccessTypesMutationResponse>;
  /** update single row of the table: "venue_access_types" */
  updateVenueAccessTypesByPk?: Maybe<VenueAccessTypes>;
  /** update multiples rows of table: "venue_access_types" */
  updateVenueAccessTypesMany?: Maybe<Array<Maybe<VenueAccessTypesMutationResponse>>>;
  /** update data of the table: "venue_amenities" */
  updateVenueAmenities?: Maybe<VenueAmenitiesMutationResponse>;
  /** update single row of the table: "venue_amenities" */
  updateVenueAmenitiesByPk?: Maybe<VenueAmenities>;
  /** update multiples rows of table: "venue_amenities" */
  updateVenueAmenitiesMany?: Maybe<Array<Maybe<VenueAmenitiesMutationResponse>>>;
  /** update data of the table: "venue_court_surfaces" */
  updateVenueCourtSurfaces?: Maybe<VenueCourtSurfacesMutationResponse>;
  /** update single row of the table: "venue_court_surfaces" */
  updateVenueCourtSurfacesByPk?: Maybe<VenueCourtSurfaces>;
  /** update multiples rows of table: "venue_court_surfaces" */
  updateVenueCourtSurfacesMany?: Maybe<Array<Maybe<VenueCourtSurfacesMutationResponse>>>;
  /** update data of the table: "venue_facility_types" */
  updateVenueFacilityTypes?: Maybe<VenueFacilityTypesMutationResponse>;
  /** update single row of the table: "venue_facility_types" */
  updateVenueFacilityTypesByPk?: Maybe<VenueFacilityTypes>;
  /** update multiples rows of table: "venue_facility_types" */
  updateVenueFacilityTypesMany?: Maybe<Array<Maybe<VenueFacilityTypesMutationResponse>>>;
  /** update data of the table: "venue_follows" */
  updateVenueFollows?: Maybe<VenueFollowsMutationResponse>;
  /** update single row of the table: "venue_follows" */
  updateVenueFollowsByPk?: Maybe<VenueFollows>;
  /** update multiples rows of table: "venue_follows" */
  updateVenueFollowsMany?: Maybe<Array<Maybe<VenueFollowsMutationResponse>>>;
  /** update data of the table: "venue_images" */
  updateVenueImages?: Maybe<VenueImagesMutationResponse>;
  /** update single row of the table: "venue_images" */
  updateVenueImagesByPk?: Maybe<VenueImages>;
  /** update multiples rows of table: "venue_images" */
  updateVenueImagesMany?: Maybe<Array<Maybe<VenueImagesMutationResponse>>>;
  /** update data of the table: "venue_lines" */
  updateVenueLines?: Maybe<VenueLinesMutationResponse>;
  /** update single row of the table: "venue_lines" */
  updateVenueLinesByPk?: Maybe<VenueLines>;
  /** update multiples rows of table: "venue_lines" */
  updateVenueLinesMany?: Maybe<Array<Maybe<VenueLinesMutationResponse>>>;
  /** update data of the table: "venue_nets" */
  updateVenueNets?: Maybe<VenueNetsMutationResponse>;
  /** update single row of the table: "venue_nets" */
  updateVenueNetsByPk?: Maybe<VenueNets>;
  /** update multiples rows of table: "venue_nets" */
  updateVenueNetsMany?: Maybe<Array<Maybe<VenueNetsMutationResponse>>>;
  /** update data of the table: "venues" */
  updateVenues?: Maybe<VenuesMutationResponse>;
  /** update single row of the table: "venues" */
  updateVenuesByPk?: Maybe<Venues>;
  /** update multiples rows of table: "venues" */
  updateVenuesMany?: Maybe<Array<Maybe<VenuesMutationResponse>>>;
  /** update data of the table: "welcome_email_configuration" */
  updateWelcomeEmailConfiguration?: Maybe<WelcomeEmailConfigurationMutationResponse>;
  /** update single row of the table: "welcome_email_configuration" */
  updateWelcomeEmailConfigurationByPk?: Maybe<WelcomeEmailConfiguration>;
  /** update multiples rows of table: "welcome_email_configuration" */
  updateWelcomeEmailConfigurationMany?: Maybe<Array<Maybe<WelcomeEmailConfigurationMutationResponse>>>;
  /** update data of the table: "win_reasons" */
  updateWinReasons?: Maybe<WinReasonsMutationResponse>;
  /** update single row of the table: "win_reasons" */
  updateWinReasonsByPk?: Maybe<WinReasons>;
  /** update multiples rows of table: "win_reasons" */
  updateWinReasonsMany?: Maybe<Array<Maybe<WinReasonsMutationResponse>>>;
};


/** mutation root */
export type Mutation_RootDeleteAmenitiesArgs = {
  where: AmenitiesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAmenitiesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteAppPersonasArgs = {
  where: AppPersonasBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAppPersonasByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteAppPingsArgs = {
  where: AppPingsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAppPingsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteBallTypesArgs = {
  where: BallTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBallTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCitiesArgs = {
  where: CitiesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCitiesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteCoachQualificationGroupsArgs = {
  where: CoachQualificationGroupsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCoachQualificationGroupsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCoachQualificationStatusesArgs = {
  where: CoachQualificationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCoachQualificationStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCoachQualificationsArgs = {
  where: CoachQualificationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteCoachStatusArgs = {
  where: CoachStatusBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCoachStatusByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCommentVoteArgs = {
  where: CommentVoteBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCommentVoteByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCommunicationPreferenceStatusesArgs = {
  where: CommunicationPreferenceStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCommunicationPreferenceStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCompetitionFormatsArgs = {
  where: CompetitionFormatsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCompetitionFormatsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCompetitionGenderArgs = {
  where: CompetitionGenderBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCompetitionGenderByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCountriesArgs = {
  where: CountriesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCountriesByPkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteCountrySubdivisionsArgs = {
  where: CountrySubdivisionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCountrySubdivisionsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteCourtSurfacesArgs = {
  where: CourtSurfacesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCourtSurfacesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventContactDetailsArgs = {
  where: EventContactDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventContactDetailsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventCourtStatusesArgs = {
  where: EventCourtStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventCourtStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventCourtsArgs = {
  where: EventCourtsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventCourtsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventFaqsArgs = {
  where: EventFaqsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventFaqsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventGameScoresArgs = {
  where: EventGameScoresBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGameScoresByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupFormatsArgs = {
  where: EventGroupFormatsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupFormatsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupPoolsArgs = {
  where: EventGroupPoolsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupPoolsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupRegistrationStatusesArgs = {
  where: EventGroupRegistrationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupRegistrationStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupRegistrationsArgs = {
  where: EventGroupRegistrationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupSequenceSeedingArgs = {
  where: EventGroupSequenceSeedingBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupSequenceSeedingByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupSequencesArgs = {
  where: EventGroupSequencesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupSequencesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventGroupsArgs = {
  where: EventGroupsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventGroupsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventInvitationStatusesArgs = {
  where: EventInvitationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventInvitationStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventInvitationsArgs = {
  where: EventInvitationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventInvitationsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventListingFeesArgs = {
  where: EventListingFeesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventListingFeesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventMatchGamesArgs = {
  where: EventMatchGamesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventMatchGamesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventMatchesArgs = {
  where: EventMatchesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventMatchesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventMatchesTeamsArgs = {
  where: EventMatchesTeamsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventMatchesTeamsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventOrganizerAccountTypesArgs = {
  where: EventOrganizerAccountTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventOrganizerAccountTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventPoolRoundsArgs = {
  where: EventPoolRoundsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventPoolRoundsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventPoolsTeamsArgs = {
  where: EventPoolsTeamsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventPoolsTeamsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventPrivacyArgs = {
  where: EventPrivacyBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventPrivacyByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventRegistrationDetailsArgs = {
  where: EventRegistrationDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventRegistrationsArgs = {
  where: EventRegistrationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventSequenceCompleteReasonsArgs = {
  where: EventSequenceCompleteReasonsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventSequenceCompleteReasonsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventSponsorsArgs = {
  where: EventSponsorsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventSponsorsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventStatusesArgs = {
  where: EventStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventTeamMemberStatusesArgs = {
  where: EventTeamMemberStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTeamMemberStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventTeamMembersArgs = {
  where: EventTeamMembersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTeamMembersByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventTeamsArgs = {
  where: EventTeamsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTeamsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventTransactionItemTypesArgs = {
  where: EventTransactionItemTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTransactionItemTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventTransactionItemsArgs = {
  where: EventTransactionItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTransactionItemsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventTransactionsArgs = {
  where: EventTransactionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTransactionsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteEventTypesArgs = {
  where: EventTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteEventsArgs = {
  where: EventsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEventsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteFollowStatusesArgs = {
  where: FollowStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteFollowStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteGenderArgs = {
  where: GenderBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGenderByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteGroupCommentVotesArgs = {
  where: GroupCommentVotesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupCommentVotesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupMembersArgs = {
  where: GroupMembersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupMembersByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupThreadCommentFilesArgs = {
  where: GroupThreadCommentFilesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupThreadCommentFilesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupThreadCommentsArgs = {
  where: GroupThreadCommentsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupThreadCommentsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupThreadsArgs = {
  where: GroupThreadsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupThreadsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupVenuesArgs = {
  where: GroupVenuesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupVenuesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupsArgs = {
  where: GroupsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGroupsPlaySessionsArgs = {
  where: GroupsPlaySessionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGroupsPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonEquipmentArgs = {
  where: LessonEquipmentBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonEquipmentByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonEquipmentOptionsArgs = {
  where: LessonEquipmentOptionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonEquipmentOptionsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteLessonOrderItemsArgs = {
  where: LessonOrderItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonOrderItemsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonOrdersArgs = {
  where: LessonOrdersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonOrdersByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonParticipantStatusesArgs = {
  where: LessonParticipantStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteLessonParticipantsArgs = {
  where: LessonParticipantsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonPrivacyArgs = {
  where: LessonPrivacyBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonPrivacyByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteLessonStatusesArgs = {
  where: LessonStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteLessonTemplatesArgs = {
  where: LessonTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonTemplatesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonTimesArgs = {
  where: LessonTimesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonTimesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonTypesArgs = {
  where: LessonTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteLessonWaitlistStatusesArgs = {
  where: LessonWaitlistStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonWaitlistStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteLessonWaitlistsArgs = {
  where: LessonWaitlistsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonWaitlistsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteLessonsArgs = {
  where: LessonsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLessonsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteMatchSelectionCriteriaArgs = {
  where: MatchSelectionCriteriaBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMatchSelectionCriteriaByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteNotificationActionTypesArgs = {
  where: NotificationActionTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteNotificationActionTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteNotificationStatusesArgs = {
  where: NotificationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteNotificationStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteOrderStatusesArgs = {
  where: OrderStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteOrderStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePaymentFulfillmentChannelsArgs = {
  where: PaymentFulfillmentChannelsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePaymentFulfillmentChannelsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePaymentProcessorsArgs = {
  where: PaymentProcessorsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePaymentProcessorsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePickleballRatingScalesArgs = {
  where: PickleballRatingScalesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePickleballRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionCommentsArgs = {
  where: PlaySessionCommentsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionCommentsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionCourtBookingStatusesArgs = {
  where: PlaySessionCourtBookingStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionCourtBookingStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionFormatsArgs = {
  where: PlaySessionFormatsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionFormatsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionMatchCompetitivenessArgs = {
  where: PlaySessionMatchCompetitivenessBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionMatchCompetitivenessByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionParticipantStatusesArgs = {
  where: PlaySessionParticipantStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionParticipantsArgs = {
  where: PlaySessionParticipantsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionPrivacyArgs = {
  where: PlaySessionPrivacyBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionPrivacyByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionStatusesArgs = {
  where: PlaySessionStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionStatusesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeletePlaySessionsArgs = {
  where: PlaySessionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteScoringFormatArgs = {
  where: ScoringFormatBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteScoringFormatByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteSignupRequestsArgs = {
  where: SignupRequestsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSignupRequestsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteSkillLevelsArgs = {
  where: SkillLevelsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSkillLevelsByPkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteSportsArgs = {
  where: SportsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSportsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteStripeChargesArgs = {
  where: StripeChargesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteStripeChargesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteStripePaymentIntentsArgs = {
  where: StripePaymentIntentsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteStripePaymentIntentsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteTeamTypesArgs = {
  where: TeamTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteTeamTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteTennisRatingScalesArgs = {
  where: TennisRatingScalesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteTennisRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserAuthIdentitiesArgs = {
  where: UserAuthIdentitiesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserAuthIdentitiesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserCoachServicesArgs = {
  where: UserCoachServicesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserCoachServicesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserCommunicationPreferencesArgs = {
  where: UserCommunicationPreferencesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserCommunicationPreferencesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserCreditCardsArgs = {
  where: UserCreditCardsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserCreditCardsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserCustomCourtsArgs = {
  where: UserCustomCourtsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserCustomCourtsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserFollowsArgs = {
  where: UserFollowsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserFollowsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserImageLogArgs = {
  where: UserImageLogBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserImageLogByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserNotificationDetailsArgs = {
  where: UserNotificationDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserNotificationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserNotificationEntitiesArgs = {
  where: UserNotificationEntitiesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserNotificationEntitiesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserNotificationsArgs = {
  where: UserNotificationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserNotificationsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserProfilesArgs = {
  where: UserProfilesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserRegistrationDetailsArgs = {
  where: UserRegistrationDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUserTermsOfServiceArgs = {
  where: UserTermsOfServiceBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserTermsOfServiceByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUsernameLogsArgs = {
  where: UsernameLogsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsernameLogsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUsernamesActiveArgs = {
  where: UsernamesActiveBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsernamesClaimedArgs = {
  where: UsernamesClaimedBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsernamesClaimedByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUsersArgs = {
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsersByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUsersCoachQualificationsArgs = {
  where: UsersCoachQualificationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsersCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteVenueAccessTypesArgs = {
  where: VenueAccessTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueAccessTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteVenueAmenitiesArgs = {
  where: VenueAmenitiesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueAmenitiesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteVenueCourtSurfacesArgs = {
  where: VenueCourtSurfacesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueCourtSurfacesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteVenueFacilityTypesArgs = {
  where: VenueFacilityTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueFacilityTypesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteVenueFollowsArgs = {
  where: VenueFollowsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueFollowsByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteVenueImagesArgs = {
  where: VenueImagesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueImagesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteVenueLinesArgs = {
  where: VenueLinesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueLinesByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteVenueNetsArgs = {
  where: VenueNetsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenueNetsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteVenuesArgs = {
  where: VenuesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVenuesByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteWelcomeEmailConfigurationArgs = {
  where: WelcomeEmailConfigurationBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteWelcomeEmailConfigurationByPkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteWinReasonsArgs = {
  where: WinReasonsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteWinReasonsByPkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootInsertAmenitiesArgs = {
  objects: Array<AmenitiesInsertInput>;
  onConflict?: InputMaybe<AmenitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAmenitiesOneArgs = {
  object: AmenitiesInsertInput;
  onConflict?: InputMaybe<AmenitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppPersonasArgs = {
  objects: Array<AppPersonasInsertInput>;
  onConflict?: InputMaybe<AppPersonasOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppPersonasOneArgs = {
  object: AppPersonasInsertInput;
  onConflict?: InputMaybe<AppPersonasOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppPingsArgs = {
  objects: Array<AppPingsInsertInput>;
  onConflict?: InputMaybe<AppPingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppPingsOneArgs = {
  object: AppPingsInsertInput;
  onConflict?: InputMaybe<AppPingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBallTypesArgs = {
  objects: Array<BallTypesInsertInput>;
  onConflict?: InputMaybe<BallTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBallTypesOneArgs = {
  object: BallTypesInsertInput;
  onConflict?: InputMaybe<BallTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCitiesArgs = {
  objects: Array<CitiesInsertInput>;
  onConflict?: InputMaybe<CitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCitiesOneArgs = {
  object: CitiesInsertInput;
  onConflict?: InputMaybe<CitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachQualificationGroupsArgs = {
  objects: Array<CoachQualificationGroupsInsertInput>;
  onConflict?: InputMaybe<CoachQualificationGroupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachQualificationGroupsOneArgs = {
  object: CoachQualificationGroupsInsertInput;
  onConflict?: InputMaybe<CoachQualificationGroupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachQualificationStatusesArgs = {
  objects: Array<CoachQualificationStatusesInsertInput>;
  onConflict?: InputMaybe<CoachQualificationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachQualificationStatusesOneArgs = {
  object: CoachQualificationStatusesInsertInput;
  onConflict?: InputMaybe<CoachQualificationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachQualificationsArgs = {
  objects: Array<CoachQualificationsInsertInput>;
  onConflict?: InputMaybe<CoachQualificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachQualificationsOneArgs = {
  object: CoachQualificationsInsertInput;
  onConflict?: InputMaybe<CoachQualificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachStatusArgs = {
  objects: Array<CoachStatusInsertInput>;
  onConflict?: InputMaybe<CoachStatusOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCoachStatusOneArgs = {
  object: CoachStatusInsertInput;
  onConflict?: InputMaybe<CoachStatusOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCommentVoteArgs = {
  objects: Array<CommentVoteInsertInput>;
  onConflict?: InputMaybe<CommentVoteOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCommentVoteOneArgs = {
  object: CommentVoteInsertInput;
  onConflict?: InputMaybe<CommentVoteOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCommunicationPreferenceStatusesArgs = {
  objects: Array<CommunicationPreferenceStatusesInsertInput>;
  onConflict?: InputMaybe<CommunicationPreferenceStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCommunicationPreferenceStatusesOneArgs = {
  object: CommunicationPreferenceStatusesInsertInput;
  onConflict?: InputMaybe<CommunicationPreferenceStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCompetitionFormatsArgs = {
  objects: Array<CompetitionFormatsInsertInput>;
  onConflict?: InputMaybe<CompetitionFormatsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCompetitionFormatsOneArgs = {
  object: CompetitionFormatsInsertInput;
  onConflict?: InputMaybe<CompetitionFormatsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCompetitionGenderArgs = {
  objects: Array<CompetitionGenderInsertInput>;
  onConflict?: InputMaybe<CompetitionGenderOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCompetitionGenderOneArgs = {
  object: CompetitionGenderInsertInput;
  onConflict?: InputMaybe<CompetitionGenderOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCountriesArgs = {
  objects: Array<CountriesInsertInput>;
  onConflict?: InputMaybe<CountriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCountriesOneArgs = {
  object: CountriesInsertInput;
  onConflict?: InputMaybe<CountriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCountrySubdivisionsArgs = {
  objects: Array<CountrySubdivisionsInsertInput>;
  onConflict?: InputMaybe<CountrySubdivisionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCountrySubdivisionsOneArgs = {
  object: CountrySubdivisionsInsertInput;
  onConflict?: InputMaybe<CountrySubdivisionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCourtSurfacesArgs = {
  objects: Array<CourtSurfacesInsertInput>;
  onConflict?: InputMaybe<CourtSurfacesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCourtSurfacesOneArgs = {
  object: CourtSurfacesInsertInput;
  onConflict?: InputMaybe<CourtSurfacesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventContactDetailsArgs = {
  objects: Array<EventContactDetailsInsertInput>;
  onConflict?: InputMaybe<EventContactDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventContactDetailsOneArgs = {
  object: EventContactDetailsInsertInput;
  onConflict?: InputMaybe<EventContactDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventCourtStatusesArgs = {
  objects: Array<EventCourtStatusesInsertInput>;
  onConflict?: InputMaybe<EventCourtStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventCourtStatusesOneArgs = {
  object: EventCourtStatusesInsertInput;
  onConflict?: InputMaybe<EventCourtStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventCourtsArgs = {
  objects: Array<EventCourtsInsertInput>;
  onConflict?: InputMaybe<EventCourtsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventCourtsOneArgs = {
  object: EventCourtsInsertInput;
  onConflict?: InputMaybe<EventCourtsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventFaqsArgs = {
  objects: Array<EventFaqsInsertInput>;
  onConflict?: InputMaybe<EventFaqsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventFaqsOneArgs = {
  object: EventFaqsInsertInput;
  onConflict?: InputMaybe<EventFaqsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGameScoresArgs = {
  objects: Array<EventGameScoresInsertInput>;
  onConflict?: InputMaybe<EventGameScoresOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGameScoresOneArgs = {
  object: EventGameScoresInsertInput;
  onConflict?: InputMaybe<EventGameScoresOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupFormatsArgs = {
  objects: Array<EventGroupFormatsInsertInput>;
  onConflict?: InputMaybe<EventGroupFormatsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupFormatsOneArgs = {
  object: EventGroupFormatsInsertInput;
  onConflict?: InputMaybe<EventGroupFormatsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupPoolsArgs = {
  objects: Array<EventGroupPoolsInsertInput>;
  onConflict?: InputMaybe<EventGroupPoolsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupPoolsOneArgs = {
  object: EventGroupPoolsInsertInput;
  onConflict?: InputMaybe<EventGroupPoolsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupRegistrationStatusesArgs = {
  objects: Array<EventGroupRegistrationStatusesInsertInput>;
  onConflict?: InputMaybe<EventGroupRegistrationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupRegistrationStatusesOneArgs = {
  object: EventGroupRegistrationStatusesInsertInput;
  onConflict?: InputMaybe<EventGroupRegistrationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupRegistrationsArgs = {
  objects: Array<EventGroupRegistrationsInsertInput>;
  onConflict?: InputMaybe<EventGroupRegistrationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupRegistrationsOneArgs = {
  object: EventGroupRegistrationsInsertInput;
  onConflict?: InputMaybe<EventGroupRegistrationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupSequenceSeedingArgs = {
  objects: Array<EventGroupSequenceSeedingInsertInput>;
  onConflict?: InputMaybe<EventGroupSequenceSeedingOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupSequenceSeedingOneArgs = {
  object: EventGroupSequenceSeedingInsertInput;
  onConflict?: InputMaybe<EventGroupSequenceSeedingOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupSequencesArgs = {
  objects: Array<EventGroupSequencesInsertInput>;
  onConflict?: InputMaybe<EventGroupSequencesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupSequencesOneArgs = {
  object: EventGroupSequencesInsertInput;
  onConflict?: InputMaybe<EventGroupSequencesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupsArgs = {
  objects: Array<EventGroupsInsertInput>;
  onConflict?: InputMaybe<EventGroupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGroupsOneArgs = {
  object: EventGroupsInsertInput;
  onConflict?: InputMaybe<EventGroupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventInvitationStatusesArgs = {
  objects: Array<EventInvitationStatusesInsertInput>;
  onConflict?: InputMaybe<EventInvitationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventInvitationStatusesOneArgs = {
  object: EventInvitationStatusesInsertInput;
  onConflict?: InputMaybe<EventInvitationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventInvitationsArgs = {
  objects: Array<EventInvitationsInsertInput>;
  onConflict?: InputMaybe<EventInvitationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventInvitationsOneArgs = {
  object: EventInvitationsInsertInput;
  onConflict?: InputMaybe<EventInvitationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventListingFeesArgs = {
  objects: Array<EventListingFeesInsertInput>;
  onConflict?: InputMaybe<EventListingFeesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventListingFeesOneArgs = {
  object: EventListingFeesInsertInput;
  onConflict?: InputMaybe<EventListingFeesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchGamesArgs = {
  objects: Array<EventMatchGamesInsertInput>;
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchGamesOneArgs = {
  object: EventMatchGamesInsertInput;
  onConflict?: InputMaybe<EventMatchGamesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchesArgs = {
  objects: Array<EventMatchesInsertInput>;
  onConflict?: InputMaybe<EventMatchesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchesOneArgs = {
  object: EventMatchesInsertInput;
  onConflict?: InputMaybe<EventMatchesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchesTeamsArgs = {
  objects: Array<EventMatchesTeamsInsertInput>;
  onConflict?: InputMaybe<EventMatchesTeamsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventMatchesTeamsOneArgs = {
  object: EventMatchesTeamsInsertInput;
  onConflict?: InputMaybe<EventMatchesTeamsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventOrganizerAccountTypesArgs = {
  objects: Array<EventOrganizerAccountTypesInsertInput>;
  onConflict?: InputMaybe<EventOrganizerAccountTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventOrganizerAccountTypesOneArgs = {
  object: EventOrganizerAccountTypesInsertInput;
  onConflict?: InputMaybe<EventOrganizerAccountTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventPoolRoundsArgs = {
  objects: Array<EventPoolRoundsInsertInput>;
  onConflict?: InputMaybe<EventPoolRoundsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventPoolRoundsOneArgs = {
  object: EventPoolRoundsInsertInput;
  onConflict?: InputMaybe<EventPoolRoundsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventPoolsTeamsArgs = {
  objects: Array<EventPoolsTeamsInsertInput>;
  onConflict?: InputMaybe<EventPoolsTeamsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventPoolsTeamsOneArgs = {
  object: EventPoolsTeamsInsertInput;
  onConflict?: InputMaybe<EventPoolsTeamsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventPrivacyArgs = {
  objects: Array<EventPrivacyInsertInput>;
  onConflict?: InputMaybe<EventPrivacyOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventPrivacyOneArgs = {
  object: EventPrivacyInsertInput;
  onConflict?: InputMaybe<EventPrivacyOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventRegistrationDetailsArgs = {
  objects: Array<EventRegistrationDetailsInsertInput>;
  onConflict?: InputMaybe<EventRegistrationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventRegistrationDetailsOneArgs = {
  object: EventRegistrationDetailsInsertInput;
  onConflict?: InputMaybe<EventRegistrationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventRegistrationsArgs = {
  objects: Array<EventRegistrationsInsertInput>;
  onConflict?: InputMaybe<EventRegistrationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventRegistrationsOneArgs = {
  object: EventRegistrationsInsertInput;
  onConflict?: InputMaybe<EventRegistrationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventSequenceCompleteReasonsArgs = {
  objects: Array<EventSequenceCompleteReasonsInsertInput>;
  onConflict?: InputMaybe<EventSequenceCompleteReasonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventSequenceCompleteReasonsOneArgs = {
  object: EventSequenceCompleteReasonsInsertInput;
  onConflict?: InputMaybe<EventSequenceCompleteReasonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventSponsorsArgs = {
  objects: Array<EventSponsorsInsertInput>;
  onConflict?: InputMaybe<EventSponsorsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventSponsorsOneArgs = {
  object: EventSponsorsInsertInput;
  onConflict?: InputMaybe<EventSponsorsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventStatusesArgs = {
  objects: Array<EventStatusesInsertInput>;
  onConflict?: InputMaybe<EventStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventStatusesOneArgs = {
  object: EventStatusesInsertInput;
  onConflict?: InputMaybe<EventStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTeamMemberStatusesArgs = {
  objects: Array<EventTeamMemberStatusesInsertInput>;
  onConflict?: InputMaybe<EventTeamMemberStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTeamMemberStatusesOneArgs = {
  object: EventTeamMemberStatusesInsertInput;
  onConflict?: InputMaybe<EventTeamMemberStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTeamMembersArgs = {
  objects: Array<EventTeamMembersInsertInput>;
  onConflict?: InputMaybe<EventTeamMembersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTeamMembersOneArgs = {
  object: EventTeamMembersInsertInput;
  onConflict?: InputMaybe<EventTeamMembersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTeamsArgs = {
  objects: Array<EventTeamsInsertInput>;
  onConflict?: InputMaybe<EventTeamsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTeamsOneArgs = {
  object: EventTeamsInsertInput;
  onConflict?: InputMaybe<EventTeamsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTransactionItemTypesArgs = {
  objects: Array<EventTransactionItemTypesInsertInput>;
  onConflict?: InputMaybe<EventTransactionItemTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTransactionItemTypesOneArgs = {
  object: EventTransactionItemTypesInsertInput;
  onConflict?: InputMaybe<EventTransactionItemTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTransactionItemsArgs = {
  objects: Array<EventTransactionItemsInsertInput>;
  onConflict?: InputMaybe<EventTransactionItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTransactionItemsOneArgs = {
  object: EventTransactionItemsInsertInput;
  onConflict?: InputMaybe<EventTransactionItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTransactionsArgs = {
  objects: Array<EventTransactionsInsertInput>;
  onConflict?: InputMaybe<EventTransactionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTransactionsOneArgs = {
  object: EventTransactionsInsertInput;
  onConflict?: InputMaybe<EventTransactionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTypesArgs = {
  objects: Array<EventTypesInsertInput>;
  onConflict?: InputMaybe<EventTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventTypesOneArgs = {
  object: EventTypesInsertInput;
  onConflict?: InputMaybe<EventTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventsArgs = {
  objects: Array<EventsInsertInput>;
  onConflict?: InputMaybe<EventsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEventsOneArgs = {
  object: EventsInsertInput;
  onConflict?: InputMaybe<EventsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFollowStatusesArgs = {
  objects: Array<FollowStatusesInsertInput>;
  onConflict?: InputMaybe<FollowStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFollowStatusesOneArgs = {
  object: FollowStatusesInsertInput;
  onConflict?: InputMaybe<FollowStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGenderArgs = {
  objects: Array<GenderInsertInput>;
  onConflict?: InputMaybe<GenderOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGenderOneArgs = {
  object: GenderInsertInput;
  onConflict?: InputMaybe<GenderOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupCommentVotesArgs = {
  objects: Array<GroupCommentVotesInsertInput>;
  onConflict?: InputMaybe<GroupCommentVotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupCommentVotesOneArgs = {
  object: GroupCommentVotesInsertInput;
  onConflict?: InputMaybe<GroupCommentVotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupMembersArgs = {
  objects: Array<GroupMembersInsertInput>;
  onConflict?: InputMaybe<GroupMembersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupMembersOneArgs = {
  object: GroupMembersInsertInput;
  onConflict?: InputMaybe<GroupMembersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentFilesArgs = {
  objects: Array<GroupThreadCommentFilesInsertInput>;
  onConflict?: InputMaybe<GroupThreadCommentFilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentFilesOneArgs = {
  object: GroupThreadCommentFilesInsertInput;
  onConflict?: InputMaybe<GroupThreadCommentFilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentsArgs = {
  objects: Array<GroupThreadCommentsInsertInput>;
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadCommentsOneArgs = {
  object: GroupThreadCommentsInsertInput;
  onConflict?: InputMaybe<GroupThreadCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadsArgs = {
  objects: Array<GroupThreadsInsertInput>;
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupThreadsOneArgs = {
  object: GroupThreadsInsertInput;
  onConflict?: InputMaybe<GroupThreadsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupVenuesArgs = {
  objects: Array<GroupVenuesInsertInput>;
  onConflict?: InputMaybe<GroupVenuesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupVenuesOneArgs = {
  object: GroupVenuesInsertInput;
  onConflict?: InputMaybe<GroupVenuesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupsArgs = {
  objects: Array<GroupsInsertInput>;
  onConflict?: InputMaybe<GroupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupsOneArgs = {
  object: GroupsInsertInput;
  onConflict?: InputMaybe<GroupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupsPlaySessionsArgs = {
  objects: Array<GroupsPlaySessionsInsertInput>;
  onConflict?: InputMaybe<GroupsPlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGroupsPlaySessionsOneArgs = {
  object: GroupsPlaySessionsInsertInput;
  onConflict?: InputMaybe<GroupsPlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonEquipmentArgs = {
  objects: Array<LessonEquipmentInsertInput>;
  onConflict?: InputMaybe<LessonEquipmentOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonEquipmentOneArgs = {
  object: LessonEquipmentInsertInput;
  onConflict?: InputMaybe<LessonEquipmentOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonEquipmentOptionsArgs = {
  objects: Array<LessonEquipmentOptionsInsertInput>;
  onConflict?: InputMaybe<LessonEquipmentOptionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonEquipmentOptionsOneArgs = {
  object: LessonEquipmentOptionsInsertInput;
  onConflict?: InputMaybe<LessonEquipmentOptionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonOrderItemsArgs = {
  objects: Array<LessonOrderItemsInsertInput>;
  onConflict?: InputMaybe<LessonOrderItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonOrderItemsOneArgs = {
  object: LessonOrderItemsInsertInput;
  onConflict?: InputMaybe<LessonOrderItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonOrdersArgs = {
  objects: Array<LessonOrdersInsertInput>;
  onConflict?: InputMaybe<LessonOrdersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonOrdersOneArgs = {
  object: LessonOrdersInsertInput;
  onConflict?: InputMaybe<LessonOrdersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonParticipantStatusesArgs = {
  objects: Array<LessonParticipantStatusesInsertInput>;
  onConflict?: InputMaybe<LessonParticipantStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonParticipantStatusesOneArgs = {
  object: LessonParticipantStatusesInsertInput;
  onConflict?: InputMaybe<LessonParticipantStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonParticipantsArgs = {
  objects: Array<LessonParticipantsInsertInput>;
  onConflict?: InputMaybe<LessonParticipantsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonParticipantsOneArgs = {
  object: LessonParticipantsInsertInput;
  onConflict?: InputMaybe<LessonParticipantsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonPrivacyArgs = {
  objects: Array<LessonPrivacyInsertInput>;
  onConflict?: InputMaybe<LessonPrivacyOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonPrivacyOneArgs = {
  object: LessonPrivacyInsertInput;
  onConflict?: InputMaybe<LessonPrivacyOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonStatusesArgs = {
  objects: Array<LessonStatusesInsertInput>;
  onConflict?: InputMaybe<LessonStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonStatusesOneArgs = {
  object: LessonStatusesInsertInput;
  onConflict?: InputMaybe<LessonStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTemplatesArgs = {
  objects: Array<LessonTemplatesInsertInput>;
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTemplatesOneArgs = {
  object: LessonTemplatesInsertInput;
  onConflict?: InputMaybe<LessonTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTimesArgs = {
  objects: Array<LessonTimesInsertInput>;
  onConflict?: InputMaybe<LessonTimesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTimesOneArgs = {
  object: LessonTimesInsertInput;
  onConflict?: InputMaybe<LessonTimesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTypesArgs = {
  objects: Array<LessonTypesInsertInput>;
  onConflict?: InputMaybe<LessonTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonTypesOneArgs = {
  object: LessonTypesInsertInput;
  onConflict?: InputMaybe<LessonTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonWaitlistStatusesArgs = {
  objects: Array<LessonWaitlistStatusesInsertInput>;
  onConflict?: InputMaybe<LessonWaitlistStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonWaitlistStatusesOneArgs = {
  object: LessonWaitlistStatusesInsertInput;
  onConflict?: InputMaybe<LessonWaitlistStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonWaitlistsArgs = {
  objects: Array<LessonWaitlistsInsertInput>;
  onConflict?: InputMaybe<LessonWaitlistsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonWaitlistsOneArgs = {
  object: LessonWaitlistsInsertInput;
  onConflict?: InputMaybe<LessonWaitlistsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonsArgs = {
  objects: Array<LessonsInsertInput>;
  onConflict?: InputMaybe<LessonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLessonsOneArgs = {
  object: LessonsInsertInput;
  onConflict?: InputMaybe<LessonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMatchSelectionCriteriaArgs = {
  objects: Array<MatchSelectionCriteriaInsertInput>;
  onConflict?: InputMaybe<MatchSelectionCriteriaOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMatchSelectionCriteriaOneArgs = {
  object: MatchSelectionCriteriaInsertInput;
  onConflict?: InputMaybe<MatchSelectionCriteriaOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotificationActionTypesArgs = {
  objects: Array<NotificationActionTypesInsertInput>;
  onConflict?: InputMaybe<NotificationActionTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotificationActionTypesOneArgs = {
  object: NotificationActionTypesInsertInput;
  onConflict?: InputMaybe<NotificationActionTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotificationStatusesArgs = {
  objects: Array<NotificationStatusesInsertInput>;
  onConflict?: InputMaybe<NotificationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotificationStatusesOneArgs = {
  object: NotificationStatusesInsertInput;
  onConflict?: InputMaybe<NotificationStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertOrderStatusesArgs = {
  objects: Array<OrderStatusesInsertInput>;
  onConflict?: InputMaybe<OrderStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertOrderStatusesOneArgs = {
  object: OrderStatusesInsertInput;
  onConflict?: InputMaybe<OrderStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPaymentFulfillmentChannelsArgs = {
  objects: Array<PaymentFulfillmentChannelsInsertInput>;
  onConflict?: InputMaybe<PaymentFulfillmentChannelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPaymentFulfillmentChannelsOneArgs = {
  object: PaymentFulfillmentChannelsInsertInput;
  onConflict?: InputMaybe<PaymentFulfillmentChannelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPaymentProcessorsArgs = {
  objects: Array<PaymentProcessorsInsertInput>;
  onConflict?: InputMaybe<PaymentProcessorsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPaymentProcessorsOneArgs = {
  object: PaymentProcessorsInsertInput;
  onConflict?: InputMaybe<PaymentProcessorsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPickleballRatingScalesArgs = {
  objects: Array<PickleballRatingScalesInsertInput>;
  onConflict?: InputMaybe<PickleballRatingScalesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPickleballRatingScalesOneArgs = {
  object: PickleballRatingScalesInsertInput;
  onConflict?: InputMaybe<PickleballRatingScalesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionCommentsArgs = {
  objects: Array<PlaySessionCommentsInsertInput>;
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionCommentsOneArgs = {
  object: PlaySessionCommentsInsertInput;
  onConflict?: InputMaybe<PlaySessionCommentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionCourtBookingStatusesArgs = {
  objects: Array<PlaySessionCourtBookingStatusesInsertInput>;
  onConflict?: InputMaybe<PlaySessionCourtBookingStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionCourtBookingStatusesOneArgs = {
  object: PlaySessionCourtBookingStatusesInsertInput;
  onConflict?: InputMaybe<PlaySessionCourtBookingStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionFormatsArgs = {
  objects: Array<PlaySessionFormatsInsertInput>;
  onConflict?: InputMaybe<PlaySessionFormatsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionFormatsOneArgs = {
  object: PlaySessionFormatsInsertInput;
  onConflict?: InputMaybe<PlaySessionFormatsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionMatchCompetitivenessArgs = {
  objects: Array<PlaySessionMatchCompetitivenessInsertInput>;
  onConflict?: InputMaybe<PlaySessionMatchCompetitivenessOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionMatchCompetitivenessOneArgs = {
  object: PlaySessionMatchCompetitivenessInsertInput;
  onConflict?: InputMaybe<PlaySessionMatchCompetitivenessOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionParticipantStatusesArgs = {
  objects: Array<PlaySessionParticipantStatusesInsertInput>;
  onConflict?: InputMaybe<PlaySessionParticipantStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionParticipantStatusesOneArgs = {
  object: PlaySessionParticipantStatusesInsertInput;
  onConflict?: InputMaybe<PlaySessionParticipantStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionParticipantsArgs = {
  objects: Array<PlaySessionParticipantsInsertInput>;
  onConflict?: InputMaybe<PlaySessionParticipantsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionParticipantsOneArgs = {
  object: PlaySessionParticipantsInsertInput;
  onConflict?: InputMaybe<PlaySessionParticipantsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionPrivacyArgs = {
  objects: Array<PlaySessionPrivacyInsertInput>;
  onConflict?: InputMaybe<PlaySessionPrivacyOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionPrivacyOneArgs = {
  object: PlaySessionPrivacyInsertInput;
  onConflict?: InputMaybe<PlaySessionPrivacyOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionStatusesArgs = {
  objects: Array<PlaySessionStatusesInsertInput>;
  onConflict?: InputMaybe<PlaySessionStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionStatusesOneArgs = {
  object: PlaySessionStatusesInsertInput;
  onConflict?: InputMaybe<PlaySessionStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionsArgs = {
  objects: Array<PlaySessionsInsertInput>;
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPlaySessionsOneArgs = {
  object: PlaySessionsInsertInput;
  onConflict?: InputMaybe<PlaySessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertScoringFormatArgs = {
  objects: Array<ScoringFormatInsertInput>;
  onConflict?: InputMaybe<ScoringFormatOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertScoringFormatOneArgs = {
  object: ScoringFormatInsertInput;
  onConflict?: InputMaybe<ScoringFormatOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSignupRequestsArgs = {
  objects: Array<SignupRequestsInsertInput>;
  onConflict?: InputMaybe<SignupRequestsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSignupRequestsOneArgs = {
  object: SignupRequestsInsertInput;
  onConflict?: InputMaybe<SignupRequestsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSkillLevelsArgs = {
  objects: Array<SkillLevelsInsertInput>;
  onConflict?: InputMaybe<SkillLevelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSkillLevelsOneArgs = {
  object: SkillLevelsInsertInput;
  onConflict?: InputMaybe<SkillLevelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSportsArgs = {
  objects: Array<SportsInsertInput>;
  onConflict?: InputMaybe<SportsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSportsOneArgs = {
  object: SportsInsertInput;
  onConflict?: InputMaybe<SportsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStripeChargesArgs = {
  objects: Array<StripeChargesInsertInput>;
  onConflict?: InputMaybe<StripeChargesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStripeChargesOneArgs = {
  object: StripeChargesInsertInput;
  onConflict?: InputMaybe<StripeChargesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStripePaymentIntentsArgs = {
  objects: Array<StripePaymentIntentsInsertInput>;
  onConflict?: InputMaybe<StripePaymentIntentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStripePaymentIntentsOneArgs = {
  object: StripePaymentIntentsInsertInput;
  onConflict?: InputMaybe<StripePaymentIntentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTeamTypesArgs = {
  objects: Array<TeamTypesInsertInput>;
  onConflict?: InputMaybe<TeamTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTeamTypesOneArgs = {
  object: TeamTypesInsertInput;
  onConflict?: InputMaybe<TeamTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTennisRatingScalesArgs = {
  objects: Array<TennisRatingScalesInsertInput>;
  onConflict?: InputMaybe<TennisRatingScalesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTennisRatingScalesOneArgs = {
  object: TennisRatingScalesInsertInput;
  onConflict?: InputMaybe<TennisRatingScalesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserAuthIdentitiesArgs = {
  objects: Array<UserAuthIdentitiesInsertInput>;
  onConflict?: InputMaybe<UserAuthIdentitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserAuthIdentitiesOneArgs = {
  object: UserAuthIdentitiesInsertInput;
  onConflict?: InputMaybe<UserAuthIdentitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCoachServicesArgs = {
  objects: Array<UserCoachServicesInsertInput>;
  onConflict?: InputMaybe<UserCoachServicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCoachServicesOneArgs = {
  object: UserCoachServicesInsertInput;
  onConflict?: InputMaybe<UserCoachServicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCommunicationPreferencesArgs = {
  objects: Array<UserCommunicationPreferencesInsertInput>;
  onConflict?: InputMaybe<UserCommunicationPreferencesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCommunicationPreferencesOneArgs = {
  object: UserCommunicationPreferencesInsertInput;
  onConflict?: InputMaybe<UserCommunicationPreferencesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCreditCardsArgs = {
  objects: Array<UserCreditCardsInsertInput>;
  onConflict?: InputMaybe<UserCreditCardsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCreditCardsOneArgs = {
  object: UserCreditCardsInsertInput;
  onConflict?: InputMaybe<UserCreditCardsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCustomCourtsArgs = {
  objects: Array<UserCustomCourtsInsertInput>;
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserCustomCourtsOneArgs = {
  object: UserCustomCourtsInsertInput;
  onConflict?: InputMaybe<UserCustomCourtsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserFollowsArgs = {
  objects: Array<UserFollowsInsertInput>;
  onConflict?: InputMaybe<UserFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserFollowsOneArgs = {
  object: UserFollowsInsertInput;
  onConflict?: InputMaybe<UserFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserImageLogArgs = {
  objects: Array<UserImageLogInsertInput>;
  onConflict?: InputMaybe<UserImageLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserImageLogOneArgs = {
  object: UserImageLogInsertInput;
  onConflict?: InputMaybe<UserImageLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserNotificationDetailsArgs = {
  objects: Array<UserNotificationDetailsInsertInput>;
  onConflict?: InputMaybe<UserNotificationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserNotificationDetailsOneArgs = {
  object: UserNotificationDetailsInsertInput;
  onConflict?: InputMaybe<UserNotificationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserNotificationEntitiesArgs = {
  objects: Array<UserNotificationEntitiesInsertInput>;
  onConflict?: InputMaybe<UserNotificationEntitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserNotificationEntitiesOneArgs = {
  object: UserNotificationEntitiesInsertInput;
  onConflict?: InputMaybe<UserNotificationEntitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserNotificationsArgs = {
  objects: Array<UserNotificationsInsertInput>;
  onConflict?: InputMaybe<UserNotificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserNotificationsOneArgs = {
  object: UserNotificationsInsertInput;
  onConflict?: InputMaybe<UserNotificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserProfilesArgs = {
  objects: Array<UserProfilesInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertUserProfilesOneArgs = {
  object: UserProfilesInsertInput;
};


/** mutation root */
export type Mutation_RootInsertUserRegistrationDetailsArgs = {
  objects: Array<UserRegistrationDetailsInsertInput>;
  onConflict?: InputMaybe<UserRegistrationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserRegistrationDetailsOneArgs = {
  object: UserRegistrationDetailsInsertInput;
  onConflict?: InputMaybe<UserRegistrationDetailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserTermsOfServiceArgs = {
  objects: Array<UserTermsOfServiceInsertInput>;
  onConflict?: InputMaybe<UserTermsOfServiceOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserTermsOfServiceOneArgs = {
  object: UserTermsOfServiceInsertInput;
  onConflict?: InputMaybe<UserTermsOfServiceOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsernameLogsArgs = {
  objects: Array<UsernameLogsInsertInput>;
  onConflict?: InputMaybe<UsernameLogsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsernameLogsOneArgs = {
  object: UsernameLogsInsertInput;
  onConflict?: InputMaybe<UsernameLogsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsernamesActiveArgs = {
  objects: Array<UsernamesActiveInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertUsernamesActiveOneArgs = {
  object: UsernamesActiveInsertInput;
};


/** mutation root */
export type Mutation_RootInsertUsernamesClaimedArgs = {
  objects: Array<UsernamesClaimedInsertInput>;
  onConflict?: InputMaybe<UsernamesClaimedOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsernamesClaimedOneArgs = {
  object: UsernamesClaimedInsertInput;
  onConflict?: InputMaybe<UsernamesClaimedOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersArgs = {
  objects: Array<UsersInsertInput>;
  onConflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersCoachQualificationsArgs = {
  objects: Array<UsersCoachQualificationsInsertInput>;
  onConflict?: InputMaybe<UsersCoachQualificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersCoachQualificationsOneArgs = {
  object: UsersCoachQualificationsInsertInput;
  onConflict?: InputMaybe<UsersCoachQualificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersOneArgs = {
  object: UsersInsertInput;
  onConflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueAccessTypesArgs = {
  objects: Array<VenueAccessTypesInsertInput>;
  onConflict?: InputMaybe<VenueAccessTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueAccessTypesOneArgs = {
  object: VenueAccessTypesInsertInput;
  onConflict?: InputMaybe<VenueAccessTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueAmenitiesArgs = {
  objects: Array<VenueAmenitiesInsertInput>;
  onConflict?: InputMaybe<VenueAmenitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueAmenitiesOneArgs = {
  object: VenueAmenitiesInsertInput;
  onConflict?: InputMaybe<VenueAmenitiesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueCourtSurfacesArgs = {
  objects: Array<VenueCourtSurfacesInsertInput>;
  onConflict?: InputMaybe<VenueCourtSurfacesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueCourtSurfacesOneArgs = {
  object: VenueCourtSurfacesInsertInput;
  onConflict?: InputMaybe<VenueCourtSurfacesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueFacilityTypesArgs = {
  objects: Array<VenueFacilityTypesInsertInput>;
  onConflict?: InputMaybe<VenueFacilityTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueFacilityTypesOneArgs = {
  object: VenueFacilityTypesInsertInput;
  onConflict?: InputMaybe<VenueFacilityTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueFollowsArgs = {
  objects: Array<VenueFollowsInsertInput>;
  onConflict?: InputMaybe<VenueFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueFollowsOneArgs = {
  object: VenueFollowsInsertInput;
  onConflict?: InputMaybe<VenueFollowsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueImagesArgs = {
  objects: Array<VenueImagesInsertInput>;
  onConflict?: InputMaybe<VenueImagesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueImagesOneArgs = {
  object: VenueImagesInsertInput;
  onConflict?: InputMaybe<VenueImagesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueLinesArgs = {
  objects: Array<VenueLinesInsertInput>;
  onConflict?: InputMaybe<VenueLinesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueLinesOneArgs = {
  object: VenueLinesInsertInput;
  onConflict?: InputMaybe<VenueLinesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueNetsArgs = {
  objects: Array<VenueNetsInsertInput>;
  onConflict?: InputMaybe<VenueNetsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenueNetsOneArgs = {
  object: VenueNetsInsertInput;
  onConflict?: InputMaybe<VenueNetsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenuesArgs = {
  objects: Array<VenuesInsertInput>;
  onConflict?: InputMaybe<VenuesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVenuesOneArgs = {
  object: VenuesInsertInput;
  onConflict?: InputMaybe<VenuesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertWelcomeEmailConfigurationArgs = {
  objects: Array<WelcomeEmailConfigurationInsertInput>;
  onConflict?: InputMaybe<WelcomeEmailConfigurationOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertWelcomeEmailConfigurationOneArgs = {
  object: WelcomeEmailConfigurationInsertInput;
  onConflict?: InputMaybe<WelcomeEmailConfigurationOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertWinReasonsArgs = {
  objects: Array<WinReasonsInsertInput>;
  onConflict?: InputMaybe<WinReasonsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertWinReasonsOneArgs = {
  object: WinReasonsInsertInput;
  onConflict?: InputMaybe<WinReasonsOnConflict>;
};


/** mutation root */
export type Mutation_RootUpdateAmenitiesArgs = {
  _set?: InputMaybe<AmenitiesSetInput>;
  where: AmenitiesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAmenitiesByPkArgs = {
  _set?: InputMaybe<AmenitiesSetInput>;
  pkColumns: AmenitiesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAmenitiesManyArgs = {
  updates: Array<AmenitiesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAppPersonasArgs = {
  _set?: InputMaybe<AppPersonasSetInput>;
  where: AppPersonasBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAppPersonasByPkArgs = {
  _set?: InputMaybe<AppPersonasSetInput>;
  pkColumns: AppPersonasPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAppPersonasManyArgs = {
  updates: Array<AppPersonasUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAppPingsArgs = {
  _append?: InputMaybe<AppPingsAppendInput>;
  _deleteAtPath?: InputMaybe<AppPingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AppPingsDeleteElemInput>;
  _deleteKey?: InputMaybe<AppPingsDeleteKeyInput>;
  _prepend?: InputMaybe<AppPingsPrependInput>;
  _set?: InputMaybe<AppPingsSetInput>;
  where: AppPingsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAppPingsByPkArgs = {
  _append?: InputMaybe<AppPingsAppendInput>;
  _deleteAtPath?: InputMaybe<AppPingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AppPingsDeleteElemInput>;
  _deleteKey?: InputMaybe<AppPingsDeleteKeyInput>;
  _prepend?: InputMaybe<AppPingsPrependInput>;
  _set?: InputMaybe<AppPingsSetInput>;
  pkColumns: AppPingsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAppPingsManyArgs = {
  updates: Array<AppPingsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateBallTypesArgs = {
  _set?: InputMaybe<BallTypesSetInput>;
  where: BallTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateBallTypesByPkArgs = {
  _set?: InputMaybe<BallTypesSetInput>;
  pkColumns: BallTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateBallTypesManyArgs = {
  updates: Array<BallTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCitiesArgs = {
  _inc?: InputMaybe<CitiesIncInput>;
  _set?: InputMaybe<CitiesSetInput>;
  where: CitiesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCitiesByPkArgs = {
  _inc?: InputMaybe<CitiesIncInput>;
  _set?: InputMaybe<CitiesSetInput>;
  pkColumns: CitiesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCitiesManyArgs = {
  updates: Array<CitiesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationGroupsArgs = {
  _set?: InputMaybe<CoachQualificationGroupsSetInput>;
  where: CoachQualificationGroupsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationGroupsByPkArgs = {
  _set?: InputMaybe<CoachQualificationGroupsSetInput>;
  pkColumns: CoachQualificationGroupsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationGroupsManyArgs = {
  updates: Array<CoachQualificationGroupsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationStatusesArgs = {
  _set?: InputMaybe<CoachQualificationStatusesSetInput>;
  where: CoachQualificationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationStatusesByPkArgs = {
  _set?: InputMaybe<CoachQualificationStatusesSetInput>;
  pkColumns: CoachQualificationStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationStatusesManyArgs = {
  updates: Array<CoachQualificationStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationsArgs = {
  _inc?: InputMaybe<CoachQualificationsIncInput>;
  _set?: InputMaybe<CoachQualificationsSetInput>;
  where: CoachQualificationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationsByPkArgs = {
  _inc?: InputMaybe<CoachQualificationsIncInput>;
  _set?: InputMaybe<CoachQualificationsSetInput>;
  pkColumns: CoachQualificationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCoachQualificationsManyArgs = {
  updates: Array<CoachQualificationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCoachStatusArgs = {
  _set?: InputMaybe<CoachStatusSetInput>;
  where: CoachStatusBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCoachStatusByPkArgs = {
  _set?: InputMaybe<CoachStatusSetInput>;
  pkColumns: CoachStatusPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCoachStatusManyArgs = {
  updates: Array<CoachStatusUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCommentVoteArgs = {
  _set?: InputMaybe<CommentVoteSetInput>;
  where: CommentVoteBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCommentVoteByPkArgs = {
  _set?: InputMaybe<CommentVoteSetInput>;
  pkColumns: CommentVotePkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCommentVoteManyArgs = {
  updates: Array<CommentVoteUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCommunicationPreferenceStatusesArgs = {
  _set?: InputMaybe<CommunicationPreferenceStatusesSetInput>;
  where: CommunicationPreferenceStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCommunicationPreferenceStatusesByPkArgs = {
  _set?: InputMaybe<CommunicationPreferenceStatusesSetInput>;
  pkColumns: CommunicationPreferenceStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCommunicationPreferenceStatusesManyArgs = {
  updates: Array<CommunicationPreferenceStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCompetitionFormatsArgs = {
  _set?: InputMaybe<CompetitionFormatsSetInput>;
  where: CompetitionFormatsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCompetitionFormatsByPkArgs = {
  _set?: InputMaybe<CompetitionFormatsSetInput>;
  pkColumns: CompetitionFormatsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCompetitionFormatsManyArgs = {
  updates: Array<CompetitionFormatsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCompetitionGenderArgs = {
  _set?: InputMaybe<CompetitionGenderSetInput>;
  where: CompetitionGenderBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCompetitionGenderByPkArgs = {
  _set?: InputMaybe<CompetitionGenderSetInput>;
  pkColumns: CompetitionGenderPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCompetitionGenderManyArgs = {
  updates: Array<CompetitionGenderUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCountriesArgs = {
  _inc?: InputMaybe<CountriesIncInput>;
  _set?: InputMaybe<CountriesSetInput>;
  where: CountriesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCountriesByPkArgs = {
  _inc?: InputMaybe<CountriesIncInput>;
  _set?: InputMaybe<CountriesSetInput>;
  pkColumns: CountriesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCountriesManyArgs = {
  updates: Array<CountriesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCountrySubdivisionsArgs = {
  _inc?: InputMaybe<CountrySubdivisionsIncInput>;
  _set?: InputMaybe<CountrySubdivisionsSetInput>;
  where: CountrySubdivisionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCountrySubdivisionsByPkArgs = {
  _inc?: InputMaybe<CountrySubdivisionsIncInput>;
  _set?: InputMaybe<CountrySubdivisionsSetInput>;
  pkColumns: CountrySubdivisionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCountrySubdivisionsManyArgs = {
  updates: Array<CountrySubdivisionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCourtSurfacesArgs = {
  _set?: InputMaybe<CourtSurfacesSetInput>;
  where: CourtSurfacesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCourtSurfacesByPkArgs = {
  _set?: InputMaybe<CourtSurfacesSetInput>;
  pkColumns: CourtSurfacesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCourtSurfacesManyArgs = {
  updates: Array<CourtSurfacesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventContactDetailsArgs = {
  _set?: InputMaybe<EventContactDetailsSetInput>;
  where: EventContactDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventContactDetailsByPkArgs = {
  _set?: InputMaybe<EventContactDetailsSetInput>;
  pkColumns: EventContactDetailsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventContactDetailsManyArgs = {
  updates: Array<EventContactDetailsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtStatusesArgs = {
  _set?: InputMaybe<EventCourtStatusesSetInput>;
  where: EventCourtStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtStatusesByPkArgs = {
  _set?: InputMaybe<EventCourtStatusesSetInput>;
  pkColumns: EventCourtStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtStatusesManyArgs = {
  updates: Array<EventCourtStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtsArgs = {
  _inc?: InputMaybe<EventCourtsIncInput>;
  _set?: InputMaybe<EventCourtsSetInput>;
  where: EventCourtsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtsByPkArgs = {
  _inc?: InputMaybe<EventCourtsIncInput>;
  _set?: InputMaybe<EventCourtsSetInput>;
  pkColumns: EventCourtsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventCourtsManyArgs = {
  updates: Array<EventCourtsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventFaqsArgs = {
  _set?: InputMaybe<EventFaqsSetInput>;
  where: EventFaqsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventFaqsByPkArgs = {
  _set?: InputMaybe<EventFaqsSetInput>;
  pkColumns: EventFaqsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventFaqsManyArgs = {
  updates: Array<EventFaqsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGameScoresArgs = {
  _inc?: InputMaybe<EventGameScoresIncInput>;
  _set?: InputMaybe<EventGameScoresSetInput>;
  where: EventGameScoresBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGameScoresByPkArgs = {
  _inc?: InputMaybe<EventGameScoresIncInput>;
  _set?: InputMaybe<EventGameScoresSetInput>;
  pkColumns: EventGameScoresPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGameScoresManyArgs = {
  updates: Array<EventGameScoresUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupFormatsArgs = {
  _set?: InputMaybe<EventGroupFormatsSetInput>;
  where: EventGroupFormatsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupFormatsByPkArgs = {
  _set?: InputMaybe<EventGroupFormatsSetInput>;
  pkColumns: EventGroupFormatsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupFormatsManyArgs = {
  updates: Array<EventGroupFormatsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupPoolsArgs = {
  _set?: InputMaybe<EventGroupPoolsSetInput>;
  where: EventGroupPoolsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupPoolsByPkArgs = {
  _set?: InputMaybe<EventGroupPoolsSetInput>;
  pkColumns: EventGroupPoolsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupPoolsManyArgs = {
  updates: Array<EventGroupPoolsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupRegistrationStatusesArgs = {
  _set?: InputMaybe<EventGroupRegistrationStatusesSetInput>;
  where: EventGroupRegistrationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupRegistrationStatusesByPkArgs = {
  _set?: InputMaybe<EventGroupRegistrationStatusesSetInput>;
  pkColumns: EventGroupRegistrationStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupRegistrationStatusesManyArgs = {
  updates: Array<EventGroupRegistrationStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupRegistrationsArgs = {
  _set?: InputMaybe<EventGroupRegistrationsSetInput>;
  where: EventGroupRegistrationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupRegistrationsByPkArgs = {
  _set?: InputMaybe<EventGroupRegistrationsSetInput>;
  pkColumns: EventGroupRegistrationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupRegistrationsManyArgs = {
  updates: Array<EventGroupRegistrationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequenceSeedingArgs = {
  _inc?: InputMaybe<EventGroupSequenceSeedingIncInput>;
  _set?: InputMaybe<EventGroupSequenceSeedingSetInput>;
  where: EventGroupSequenceSeedingBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequenceSeedingByPkArgs = {
  _inc?: InputMaybe<EventGroupSequenceSeedingIncInput>;
  _set?: InputMaybe<EventGroupSequenceSeedingSetInput>;
  pkColumns: EventGroupSequenceSeedingPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequenceSeedingManyArgs = {
  updates: Array<EventGroupSequenceSeedingUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequencesArgs = {
  _inc?: InputMaybe<EventGroupSequencesIncInput>;
  _set?: InputMaybe<EventGroupSequencesSetInput>;
  where: EventGroupSequencesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequencesByPkArgs = {
  _inc?: InputMaybe<EventGroupSequencesIncInput>;
  _set?: InputMaybe<EventGroupSequencesSetInput>;
  pkColumns: EventGroupSequencesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupSequencesManyArgs = {
  updates: Array<EventGroupSequencesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupsArgs = {
  _inc?: InputMaybe<EventGroupsIncInput>;
  _set?: InputMaybe<EventGroupsSetInput>;
  where: EventGroupsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupsByPkArgs = {
  _inc?: InputMaybe<EventGroupsIncInput>;
  _set?: InputMaybe<EventGroupsSetInput>;
  pkColumns: EventGroupsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventGroupsManyArgs = {
  updates: Array<EventGroupsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventInvitationStatusesArgs = {
  _set?: InputMaybe<EventInvitationStatusesSetInput>;
  where: EventInvitationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventInvitationStatusesByPkArgs = {
  _set?: InputMaybe<EventInvitationStatusesSetInput>;
  pkColumns: EventInvitationStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventInvitationStatusesManyArgs = {
  updates: Array<EventInvitationStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventInvitationsArgs = {
  _set?: InputMaybe<EventInvitationsSetInput>;
  where: EventInvitationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventInvitationsByPkArgs = {
  _set?: InputMaybe<EventInvitationsSetInput>;
  pkColumns: EventInvitationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventInvitationsManyArgs = {
  updates: Array<EventInvitationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventListingFeesArgs = {
  _inc?: InputMaybe<EventListingFeesIncInput>;
  _set?: InputMaybe<EventListingFeesSetInput>;
  where: EventListingFeesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventListingFeesByPkArgs = {
  _inc?: InputMaybe<EventListingFeesIncInput>;
  _set?: InputMaybe<EventListingFeesSetInput>;
  pkColumns: EventListingFeesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventListingFeesManyArgs = {
  updates: Array<EventListingFeesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchGamesArgs = {
  _inc?: InputMaybe<EventMatchGamesIncInput>;
  _set?: InputMaybe<EventMatchGamesSetInput>;
  where: EventMatchGamesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchGamesByPkArgs = {
  _inc?: InputMaybe<EventMatchGamesIncInput>;
  _set?: InputMaybe<EventMatchGamesSetInput>;
  pkColumns: EventMatchGamesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchGamesManyArgs = {
  updates: Array<EventMatchGamesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesArgs = {
  _inc?: InputMaybe<EventMatchesIncInput>;
  _set?: InputMaybe<EventMatchesSetInput>;
  where: EventMatchesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesByPkArgs = {
  _inc?: InputMaybe<EventMatchesIncInput>;
  _set?: InputMaybe<EventMatchesSetInput>;
  pkColumns: EventMatchesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesManyArgs = {
  updates: Array<EventMatchesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesTeamsArgs = {
  _inc?: InputMaybe<EventMatchesTeamsIncInput>;
  _set?: InputMaybe<EventMatchesTeamsSetInput>;
  where: EventMatchesTeamsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesTeamsByPkArgs = {
  _inc?: InputMaybe<EventMatchesTeamsIncInput>;
  _set?: InputMaybe<EventMatchesTeamsSetInput>;
  pkColumns: EventMatchesTeamsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventMatchesTeamsManyArgs = {
  updates: Array<EventMatchesTeamsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventOrganizerAccountTypesArgs = {
  _set?: InputMaybe<EventOrganizerAccountTypesSetInput>;
  where: EventOrganizerAccountTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventOrganizerAccountTypesByPkArgs = {
  _set?: InputMaybe<EventOrganizerAccountTypesSetInput>;
  pkColumns: EventOrganizerAccountTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventOrganizerAccountTypesManyArgs = {
  updates: Array<EventOrganizerAccountTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventPoolRoundsArgs = {
  _inc?: InputMaybe<EventPoolRoundsIncInput>;
  _set?: InputMaybe<EventPoolRoundsSetInput>;
  where: EventPoolRoundsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventPoolRoundsByPkArgs = {
  _inc?: InputMaybe<EventPoolRoundsIncInput>;
  _set?: InputMaybe<EventPoolRoundsSetInput>;
  pkColumns: EventPoolRoundsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventPoolRoundsManyArgs = {
  updates: Array<EventPoolRoundsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventPoolsTeamsArgs = {
  _set?: InputMaybe<EventPoolsTeamsSetInput>;
  where: EventPoolsTeamsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventPoolsTeamsByPkArgs = {
  _set?: InputMaybe<EventPoolsTeamsSetInput>;
  pkColumns: EventPoolsTeamsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventPoolsTeamsManyArgs = {
  updates: Array<EventPoolsTeamsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventPrivacyArgs = {
  _set?: InputMaybe<EventPrivacySetInput>;
  where: EventPrivacyBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventPrivacyByPkArgs = {
  _set?: InputMaybe<EventPrivacySetInput>;
  pkColumns: EventPrivacyPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventPrivacyManyArgs = {
  updates: Array<EventPrivacyUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventRegistrationDetailsArgs = {
  _set?: InputMaybe<EventRegistrationDetailsSetInput>;
  where: EventRegistrationDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventRegistrationDetailsByPkArgs = {
  _set?: InputMaybe<EventRegistrationDetailsSetInput>;
  pkColumns: EventRegistrationDetailsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventRegistrationDetailsManyArgs = {
  updates: Array<EventRegistrationDetailsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventRegistrationsArgs = {
  _set?: InputMaybe<EventRegistrationsSetInput>;
  where: EventRegistrationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventRegistrationsByPkArgs = {
  _set?: InputMaybe<EventRegistrationsSetInput>;
  pkColumns: EventRegistrationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventRegistrationsManyArgs = {
  updates: Array<EventRegistrationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventSequenceCompleteReasonsArgs = {
  _set?: InputMaybe<EventSequenceCompleteReasonsSetInput>;
  where: EventSequenceCompleteReasonsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventSequenceCompleteReasonsByPkArgs = {
  _set?: InputMaybe<EventSequenceCompleteReasonsSetInput>;
  pkColumns: EventSequenceCompleteReasonsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventSequenceCompleteReasonsManyArgs = {
  updates: Array<EventSequenceCompleteReasonsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventSponsorsArgs = {
  _set?: InputMaybe<EventSponsorsSetInput>;
  where: EventSponsorsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventSponsorsByPkArgs = {
  _set?: InputMaybe<EventSponsorsSetInput>;
  pkColumns: EventSponsorsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventSponsorsManyArgs = {
  updates: Array<EventSponsorsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventStatusesArgs = {
  _set?: InputMaybe<EventStatusesSetInput>;
  where: EventStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventStatusesByPkArgs = {
  _set?: InputMaybe<EventStatusesSetInput>;
  pkColumns: EventStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventStatusesManyArgs = {
  updates: Array<EventStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamMemberStatusesArgs = {
  _set?: InputMaybe<EventTeamMemberStatusesSetInput>;
  where: EventTeamMemberStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamMemberStatusesByPkArgs = {
  _set?: InputMaybe<EventTeamMemberStatusesSetInput>;
  pkColumns: EventTeamMemberStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamMemberStatusesManyArgs = {
  updates: Array<EventTeamMemberStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamMembersArgs = {
  _set?: InputMaybe<EventTeamMembersSetInput>;
  where: EventTeamMembersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamMembersByPkArgs = {
  _set?: InputMaybe<EventTeamMembersSetInput>;
  pkColumns: EventTeamMembersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamMembersManyArgs = {
  updates: Array<EventTeamMembersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamsArgs = {
  _set?: InputMaybe<EventTeamsSetInput>;
  where: EventTeamsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamsByPkArgs = {
  _set?: InputMaybe<EventTeamsSetInput>;
  pkColumns: EventTeamsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTeamsManyArgs = {
  updates: Array<EventTeamsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionItemTypesArgs = {
  _set?: InputMaybe<EventTransactionItemTypesSetInput>;
  where: EventTransactionItemTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionItemTypesByPkArgs = {
  _set?: InputMaybe<EventTransactionItemTypesSetInput>;
  pkColumns: EventTransactionItemTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionItemTypesManyArgs = {
  updates: Array<EventTransactionItemTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionItemsArgs = {
  _inc?: InputMaybe<EventTransactionItemsIncInput>;
  _set?: InputMaybe<EventTransactionItemsSetInput>;
  where: EventTransactionItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionItemsByPkArgs = {
  _inc?: InputMaybe<EventTransactionItemsIncInput>;
  _set?: InputMaybe<EventTransactionItemsSetInput>;
  pkColumns: EventTransactionItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionItemsManyArgs = {
  updates: Array<EventTransactionItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionsArgs = {
  _inc?: InputMaybe<EventTransactionsIncInput>;
  _set?: InputMaybe<EventTransactionsSetInput>;
  where: EventTransactionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionsByPkArgs = {
  _inc?: InputMaybe<EventTransactionsIncInput>;
  _set?: InputMaybe<EventTransactionsSetInput>;
  pkColumns: EventTransactionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTransactionsManyArgs = {
  updates: Array<EventTransactionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventTypesArgs = {
  _set?: InputMaybe<EventTypesSetInput>;
  where: EventTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventTypesByPkArgs = {
  _set?: InputMaybe<EventTypesSetInput>;
  pkColumns: EventTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventTypesManyArgs = {
  updates: Array<EventTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEventsArgs = {
  _inc?: InputMaybe<EventsIncInput>;
  _set?: InputMaybe<EventsSetInput>;
  where: EventsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEventsByPkArgs = {
  _inc?: InputMaybe<EventsIncInput>;
  _set?: InputMaybe<EventsSetInput>;
  pkColumns: EventsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEventsManyArgs = {
  updates: Array<EventsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateFollowStatusesArgs = {
  _set?: InputMaybe<FollowStatusesSetInput>;
  where: FollowStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateFollowStatusesByPkArgs = {
  _set?: InputMaybe<FollowStatusesSetInput>;
  pkColumns: FollowStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateFollowStatusesManyArgs = {
  updates: Array<FollowStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGenderArgs = {
  _set?: InputMaybe<GenderSetInput>;
  where: GenderBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGenderByPkArgs = {
  _set?: InputMaybe<GenderSetInput>;
  pkColumns: GenderPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGenderManyArgs = {
  updates: Array<GenderUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupCommentVotesArgs = {
  _set?: InputMaybe<GroupCommentVotesSetInput>;
  where: GroupCommentVotesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupCommentVotesByPkArgs = {
  _set?: InputMaybe<GroupCommentVotesSetInput>;
  pkColumns: GroupCommentVotesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupCommentVotesManyArgs = {
  updates: Array<GroupCommentVotesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupMembersArgs = {
  _set?: InputMaybe<GroupMembersSetInput>;
  where: GroupMembersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupMembersByPkArgs = {
  _set?: InputMaybe<GroupMembersSetInput>;
  pkColumns: GroupMembersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupMembersManyArgs = {
  updates: Array<GroupMembersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentFilesArgs = {
  _set?: InputMaybe<GroupThreadCommentFilesSetInput>;
  where: GroupThreadCommentFilesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentFilesByPkArgs = {
  _set?: InputMaybe<GroupThreadCommentFilesSetInput>;
  pkColumns: GroupThreadCommentFilesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentFilesManyArgs = {
  updates: Array<GroupThreadCommentFilesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentsArgs = {
  _set?: InputMaybe<GroupThreadCommentsSetInput>;
  where: GroupThreadCommentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentsByPkArgs = {
  _set?: InputMaybe<GroupThreadCommentsSetInput>;
  pkColumns: GroupThreadCommentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadCommentsManyArgs = {
  updates: Array<GroupThreadCommentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadsArgs = {
  _set?: InputMaybe<GroupThreadsSetInput>;
  where: GroupThreadsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadsByPkArgs = {
  _set?: InputMaybe<GroupThreadsSetInput>;
  pkColumns: GroupThreadsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupThreadsManyArgs = {
  updates: Array<GroupThreadsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupVenuesArgs = {
  _set?: InputMaybe<GroupVenuesSetInput>;
  where: GroupVenuesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupVenuesByPkArgs = {
  _set?: InputMaybe<GroupVenuesSetInput>;
  pkColumns: GroupVenuesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupVenuesManyArgs = {
  updates: Array<GroupVenuesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupsArgs = {
  _inc?: InputMaybe<GroupsIncInput>;
  _set?: InputMaybe<GroupsSetInput>;
  where: GroupsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupsByPkArgs = {
  _inc?: InputMaybe<GroupsIncInput>;
  _set?: InputMaybe<GroupsSetInput>;
  pkColumns: GroupsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupsManyArgs = {
  updates: Array<GroupsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGroupsPlaySessionsArgs = {
  _set?: InputMaybe<GroupsPlaySessionsSetInput>;
  where: GroupsPlaySessionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGroupsPlaySessionsByPkArgs = {
  _set?: InputMaybe<GroupsPlaySessionsSetInput>;
  pkColumns: GroupsPlaySessionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGroupsPlaySessionsManyArgs = {
  updates: Array<GroupsPlaySessionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentArgs = {
  _set?: InputMaybe<LessonEquipmentSetInput>;
  where: LessonEquipmentBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentByPkArgs = {
  _set?: InputMaybe<LessonEquipmentSetInput>;
  pkColumns: LessonEquipmentPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentManyArgs = {
  updates: Array<LessonEquipmentUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentOptionsArgs = {
  _set?: InputMaybe<LessonEquipmentOptionsSetInput>;
  where: LessonEquipmentOptionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentOptionsByPkArgs = {
  _set?: InputMaybe<LessonEquipmentOptionsSetInput>;
  pkColumns: LessonEquipmentOptionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonEquipmentOptionsManyArgs = {
  updates: Array<LessonEquipmentOptionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonOrderItemsArgs = {
  _inc?: InputMaybe<LessonOrderItemsIncInput>;
  _set?: InputMaybe<LessonOrderItemsSetInput>;
  where: LessonOrderItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonOrderItemsByPkArgs = {
  _inc?: InputMaybe<LessonOrderItemsIncInput>;
  _set?: InputMaybe<LessonOrderItemsSetInput>;
  pkColumns: LessonOrderItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonOrderItemsManyArgs = {
  updates: Array<LessonOrderItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonOrdersArgs = {
  _inc?: InputMaybe<LessonOrdersIncInput>;
  _set?: InputMaybe<LessonOrdersSetInput>;
  where: LessonOrdersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonOrdersByPkArgs = {
  _inc?: InputMaybe<LessonOrdersIncInput>;
  _set?: InputMaybe<LessonOrdersSetInput>;
  pkColumns: LessonOrdersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonOrdersManyArgs = {
  updates: Array<LessonOrdersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonParticipantStatusesArgs = {
  _set?: InputMaybe<LessonParticipantStatusesSetInput>;
  where: LessonParticipantStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonParticipantStatusesByPkArgs = {
  _set?: InputMaybe<LessonParticipantStatusesSetInput>;
  pkColumns: LessonParticipantStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonParticipantStatusesManyArgs = {
  updates: Array<LessonParticipantStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonParticipantsArgs = {
  _set?: InputMaybe<LessonParticipantsSetInput>;
  where: LessonParticipantsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonParticipantsByPkArgs = {
  _set?: InputMaybe<LessonParticipantsSetInput>;
  pkColumns: LessonParticipantsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonParticipantsManyArgs = {
  updates: Array<LessonParticipantsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonPrivacyArgs = {
  _set?: InputMaybe<LessonPrivacySetInput>;
  where: LessonPrivacyBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonPrivacyByPkArgs = {
  _set?: InputMaybe<LessonPrivacySetInput>;
  pkColumns: LessonPrivacyPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonPrivacyManyArgs = {
  updates: Array<LessonPrivacyUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonStatusesArgs = {
  _set?: InputMaybe<LessonStatusesSetInput>;
  where: LessonStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonStatusesByPkArgs = {
  _set?: InputMaybe<LessonStatusesSetInput>;
  pkColumns: LessonStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonStatusesManyArgs = {
  updates: Array<LessonStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonTemplatesArgs = {
  _inc?: InputMaybe<LessonTemplatesIncInput>;
  _set?: InputMaybe<LessonTemplatesSetInput>;
  where: LessonTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonTemplatesByPkArgs = {
  _inc?: InputMaybe<LessonTemplatesIncInput>;
  _set?: InputMaybe<LessonTemplatesSetInput>;
  pkColumns: LessonTemplatesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonTemplatesManyArgs = {
  updates: Array<LessonTemplatesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonTimesArgs = {
  _set?: InputMaybe<LessonTimesSetInput>;
  where: LessonTimesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonTimesByPkArgs = {
  _set?: InputMaybe<LessonTimesSetInput>;
  pkColumns: LessonTimesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonTimesManyArgs = {
  updates: Array<LessonTimesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonTypesArgs = {
  _set?: InputMaybe<LessonTypesSetInput>;
  where: LessonTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonTypesByPkArgs = {
  _set?: InputMaybe<LessonTypesSetInput>;
  pkColumns: LessonTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonTypesManyArgs = {
  updates: Array<LessonTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistStatusesArgs = {
  _set?: InputMaybe<LessonWaitlistStatusesSetInput>;
  where: LessonWaitlistStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistStatusesByPkArgs = {
  _set?: InputMaybe<LessonWaitlistStatusesSetInput>;
  pkColumns: LessonWaitlistStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistStatusesManyArgs = {
  updates: Array<LessonWaitlistStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistsArgs = {
  _set?: InputMaybe<LessonWaitlistsSetInput>;
  where: LessonWaitlistsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistsByPkArgs = {
  _set?: InputMaybe<LessonWaitlistsSetInput>;
  pkColumns: LessonWaitlistsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonWaitlistsManyArgs = {
  updates: Array<LessonWaitlistsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLessonsArgs = {
  _inc?: InputMaybe<LessonsIncInput>;
  _set?: InputMaybe<LessonsSetInput>;
  where: LessonsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLessonsByPkArgs = {
  _inc?: InputMaybe<LessonsIncInput>;
  _set?: InputMaybe<LessonsSetInput>;
  pkColumns: LessonsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLessonsManyArgs = {
  updates: Array<LessonsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMatchSelectionCriteriaArgs = {
  _set?: InputMaybe<MatchSelectionCriteriaSetInput>;
  where: MatchSelectionCriteriaBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMatchSelectionCriteriaByPkArgs = {
  _set?: InputMaybe<MatchSelectionCriteriaSetInput>;
  pkColumns: MatchSelectionCriteriaPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateMatchSelectionCriteriaManyArgs = {
  updates: Array<MatchSelectionCriteriaUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateNotificationActionTypesArgs = {
  _set?: InputMaybe<NotificationActionTypesSetInput>;
  where: NotificationActionTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateNotificationActionTypesByPkArgs = {
  _set?: InputMaybe<NotificationActionTypesSetInput>;
  pkColumns: NotificationActionTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateNotificationActionTypesManyArgs = {
  updates: Array<NotificationActionTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateNotificationStatusesArgs = {
  _set?: InputMaybe<NotificationStatusesSetInput>;
  where: NotificationStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateNotificationStatusesByPkArgs = {
  _set?: InputMaybe<NotificationStatusesSetInput>;
  pkColumns: NotificationStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateNotificationStatusesManyArgs = {
  updates: Array<NotificationStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateOrderStatusesArgs = {
  _set?: InputMaybe<OrderStatusesSetInput>;
  where: OrderStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateOrderStatusesByPkArgs = {
  _set?: InputMaybe<OrderStatusesSetInput>;
  pkColumns: OrderStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateOrderStatusesManyArgs = {
  updates: Array<OrderStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePaymentFulfillmentChannelsArgs = {
  _set?: InputMaybe<PaymentFulfillmentChannelsSetInput>;
  where: PaymentFulfillmentChannelsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePaymentFulfillmentChannelsByPkArgs = {
  _set?: InputMaybe<PaymentFulfillmentChannelsSetInput>;
  pkColumns: PaymentFulfillmentChannelsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePaymentFulfillmentChannelsManyArgs = {
  updates: Array<PaymentFulfillmentChannelsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePaymentProcessorsArgs = {
  _set?: InputMaybe<PaymentProcessorsSetInput>;
  where: PaymentProcessorsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePaymentProcessorsByPkArgs = {
  _set?: InputMaybe<PaymentProcessorsSetInput>;
  pkColumns: PaymentProcessorsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePaymentProcessorsManyArgs = {
  updates: Array<PaymentProcessorsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePickleballRatingScalesArgs = {
  _inc?: InputMaybe<PickleballRatingScalesIncInput>;
  _set?: InputMaybe<PickleballRatingScalesSetInput>;
  where: PickleballRatingScalesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePickleballRatingScalesByPkArgs = {
  _inc?: InputMaybe<PickleballRatingScalesIncInput>;
  _set?: InputMaybe<PickleballRatingScalesSetInput>;
  pkColumns: PickleballRatingScalesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePickleballRatingScalesManyArgs = {
  updates: Array<PickleballRatingScalesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCommentsArgs = {
  _set?: InputMaybe<PlaySessionCommentsSetInput>;
  where: PlaySessionCommentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCommentsByPkArgs = {
  _set?: InputMaybe<PlaySessionCommentsSetInput>;
  pkColumns: PlaySessionCommentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCommentsManyArgs = {
  updates: Array<PlaySessionCommentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCourtBookingStatusesArgs = {
  _set?: InputMaybe<PlaySessionCourtBookingStatusesSetInput>;
  where: PlaySessionCourtBookingStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCourtBookingStatusesByPkArgs = {
  _set?: InputMaybe<PlaySessionCourtBookingStatusesSetInput>;
  pkColumns: PlaySessionCourtBookingStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionCourtBookingStatusesManyArgs = {
  updates: Array<PlaySessionCourtBookingStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionFormatsArgs = {
  _set?: InputMaybe<PlaySessionFormatsSetInput>;
  where: PlaySessionFormatsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionFormatsByPkArgs = {
  _set?: InputMaybe<PlaySessionFormatsSetInput>;
  pkColumns: PlaySessionFormatsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionFormatsManyArgs = {
  updates: Array<PlaySessionFormatsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionMatchCompetitivenessArgs = {
  _set?: InputMaybe<PlaySessionMatchCompetitivenessSetInput>;
  where: PlaySessionMatchCompetitivenessBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionMatchCompetitivenessByPkArgs = {
  _set?: InputMaybe<PlaySessionMatchCompetitivenessSetInput>;
  pkColumns: PlaySessionMatchCompetitivenessPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionMatchCompetitivenessManyArgs = {
  updates: Array<PlaySessionMatchCompetitivenessUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionParticipantStatusesArgs = {
  _set?: InputMaybe<PlaySessionParticipantStatusesSetInput>;
  where: PlaySessionParticipantStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionParticipantStatusesByPkArgs = {
  _set?: InputMaybe<PlaySessionParticipantStatusesSetInput>;
  pkColumns: PlaySessionParticipantStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionParticipantStatusesManyArgs = {
  updates: Array<PlaySessionParticipantStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionParticipantsArgs = {
  _set?: InputMaybe<PlaySessionParticipantsSetInput>;
  where: PlaySessionParticipantsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionParticipantsByPkArgs = {
  _set?: InputMaybe<PlaySessionParticipantsSetInput>;
  pkColumns: PlaySessionParticipantsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionParticipantsManyArgs = {
  updates: Array<PlaySessionParticipantsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionPrivacyArgs = {
  _set?: InputMaybe<PlaySessionPrivacySetInput>;
  where: PlaySessionPrivacyBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionPrivacyByPkArgs = {
  _set?: InputMaybe<PlaySessionPrivacySetInput>;
  pkColumns: PlaySessionPrivacyPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionPrivacyManyArgs = {
  updates: Array<PlaySessionPrivacyUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionStatusesArgs = {
  _set?: InputMaybe<PlaySessionStatusesSetInput>;
  where: PlaySessionStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionStatusesByPkArgs = {
  _set?: InputMaybe<PlaySessionStatusesSetInput>;
  pkColumns: PlaySessionStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionStatusesManyArgs = {
  updates: Array<PlaySessionStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionsArgs = {
  _inc?: InputMaybe<PlaySessionsIncInput>;
  _set?: InputMaybe<PlaySessionsSetInput>;
  where: PlaySessionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionsByPkArgs = {
  _inc?: InputMaybe<PlaySessionsIncInput>;
  _set?: InputMaybe<PlaySessionsSetInput>;
  pkColumns: PlaySessionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePlaySessionsManyArgs = {
  updates: Array<PlaySessionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateScoringFormatArgs = {
  _set?: InputMaybe<ScoringFormatSetInput>;
  where: ScoringFormatBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateScoringFormatByPkArgs = {
  _set?: InputMaybe<ScoringFormatSetInput>;
  pkColumns: ScoringFormatPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateScoringFormatManyArgs = {
  updates: Array<ScoringFormatUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSignupRequestsArgs = {
  _append?: InputMaybe<SignupRequestsAppendInput>;
  _deleteAtPath?: InputMaybe<SignupRequestsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SignupRequestsDeleteElemInput>;
  _deleteKey?: InputMaybe<SignupRequestsDeleteKeyInput>;
  _inc?: InputMaybe<SignupRequestsIncInput>;
  _prepend?: InputMaybe<SignupRequestsPrependInput>;
  _set?: InputMaybe<SignupRequestsSetInput>;
  where: SignupRequestsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSignupRequestsByPkArgs = {
  _append?: InputMaybe<SignupRequestsAppendInput>;
  _deleteAtPath?: InputMaybe<SignupRequestsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SignupRequestsDeleteElemInput>;
  _deleteKey?: InputMaybe<SignupRequestsDeleteKeyInput>;
  _inc?: InputMaybe<SignupRequestsIncInput>;
  _prepend?: InputMaybe<SignupRequestsPrependInput>;
  _set?: InputMaybe<SignupRequestsSetInput>;
  pkColumns: SignupRequestsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSignupRequestsManyArgs = {
  updates: Array<SignupRequestsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSkillLevelsArgs = {
  _inc?: InputMaybe<SkillLevelsIncInput>;
  _set?: InputMaybe<SkillLevelsSetInput>;
  where: SkillLevelsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSkillLevelsByPkArgs = {
  _inc?: InputMaybe<SkillLevelsIncInput>;
  _set?: InputMaybe<SkillLevelsSetInput>;
  pkColumns: SkillLevelsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSkillLevelsManyArgs = {
  updates: Array<SkillLevelsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSportsArgs = {
  _set?: InputMaybe<SportsSetInput>;
  where: SportsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSportsByPkArgs = {
  _set?: InputMaybe<SportsSetInput>;
  pkColumns: SportsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSportsManyArgs = {
  updates: Array<SportsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateStripeChargesArgs = {
  _inc?: InputMaybe<StripeChargesIncInput>;
  _set?: InputMaybe<StripeChargesSetInput>;
  where: StripeChargesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateStripeChargesByPkArgs = {
  _inc?: InputMaybe<StripeChargesIncInput>;
  _set?: InputMaybe<StripeChargesSetInput>;
  pkColumns: StripeChargesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateStripeChargesManyArgs = {
  updates: Array<StripeChargesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateStripePaymentIntentsArgs = {
  _inc?: InputMaybe<StripePaymentIntentsIncInput>;
  _set?: InputMaybe<StripePaymentIntentsSetInput>;
  where: StripePaymentIntentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateStripePaymentIntentsByPkArgs = {
  _inc?: InputMaybe<StripePaymentIntentsIncInput>;
  _set?: InputMaybe<StripePaymentIntentsSetInput>;
  pkColumns: StripePaymentIntentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateStripePaymentIntentsManyArgs = {
  updates: Array<StripePaymentIntentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateTeamTypesArgs = {
  _set?: InputMaybe<TeamTypesSetInput>;
  where: TeamTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateTeamTypesByPkArgs = {
  _set?: InputMaybe<TeamTypesSetInput>;
  pkColumns: TeamTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateTeamTypesManyArgs = {
  updates: Array<TeamTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateTennisRatingScalesArgs = {
  _inc?: InputMaybe<TennisRatingScalesIncInput>;
  _set?: InputMaybe<TennisRatingScalesSetInput>;
  where: TennisRatingScalesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateTennisRatingScalesByPkArgs = {
  _inc?: InputMaybe<TennisRatingScalesIncInput>;
  _set?: InputMaybe<TennisRatingScalesSetInput>;
  pkColumns: TennisRatingScalesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateTennisRatingScalesManyArgs = {
  updates: Array<TennisRatingScalesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserAuthIdentitiesArgs = {
  _set?: InputMaybe<UserAuthIdentitiesSetInput>;
  where: UserAuthIdentitiesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserAuthIdentitiesByPkArgs = {
  _set?: InputMaybe<UserAuthIdentitiesSetInput>;
  pkColumns: UserAuthIdentitiesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserAuthIdentitiesManyArgs = {
  updates: Array<UserAuthIdentitiesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCoachServicesArgs = {
  _inc?: InputMaybe<UserCoachServicesIncInput>;
  _set?: InputMaybe<UserCoachServicesSetInput>;
  where: UserCoachServicesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCoachServicesByPkArgs = {
  _inc?: InputMaybe<UserCoachServicesIncInput>;
  _set?: InputMaybe<UserCoachServicesSetInput>;
  pkColumns: UserCoachServicesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCoachServicesManyArgs = {
  updates: Array<UserCoachServicesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCommunicationPreferencesArgs = {
  _set?: InputMaybe<UserCommunicationPreferencesSetInput>;
  where: UserCommunicationPreferencesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCommunicationPreferencesByPkArgs = {
  _set?: InputMaybe<UserCommunicationPreferencesSetInput>;
  pkColumns: UserCommunicationPreferencesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCommunicationPreferencesManyArgs = {
  updates: Array<UserCommunicationPreferencesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCreditCardsArgs = {
  _inc?: InputMaybe<UserCreditCardsIncInput>;
  _set?: InputMaybe<UserCreditCardsSetInput>;
  where: UserCreditCardsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCreditCardsByPkArgs = {
  _inc?: InputMaybe<UserCreditCardsIncInput>;
  _set?: InputMaybe<UserCreditCardsSetInput>;
  pkColumns: UserCreditCardsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCreditCardsManyArgs = {
  updates: Array<UserCreditCardsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserCustomCourtsArgs = {
  _set?: InputMaybe<UserCustomCourtsSetInput>;
  where: UserCustomCourtsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserCustomCourtsByPkArgs = {
  _set?: InputMaybe<UserCustomCourtsSetInput>;
  pkColumns: UserCustomCourtsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserCustomCourtsManyArgs = {
  updates: Array<UserCustomCourtsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserFollowsArgs = {
  _set?: InputMaybe<UserFollowsSetInput>;
  where: UserFollowsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserFollowsByPkArgs = {
  _set?: InputMaybe<UserFollowsSetInput>;
  pkColumns: UserFollowsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserFollowsManyArgs = {
  updates: Array<UserFollowsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserImageLogArgs = {
  _set?: InputMaybe<UserImageLogSetInput>;
  where: UserImageLogBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserImageLogByPkArgs = {
  _set?: InputMaybe<UserImageLogSetInput>;
  pkColumns: UserImageLogPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserImageLogManyArgs = {
  updates: Array<UserImageLogUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationDetailsArgs = {
  _set?: InputMaybe<UserNotificationDetailsSetInput>;
  where: UserNotificationDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationDetailsByPkArgs = {
  _set?: InputMaybe<UserNotificationDetailsSetInput>;
  pkColumns: UserNotificationDetailsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationDetailsManyArgs = {
  updates: Array<UserNotificationDetailsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationEntitiesArgs = {
  _set?: InputMaybe<UserNotificationEntitiesSetInput>;
  where: UserNotificationEntitiesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationEntitiesByPkArgs = {
  _set?: InputMaybe<UserNotificationEntitiesSetInput>;
  pkColumns: UserNotificationEntitiesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationEntitiesManyArgs = {
  updates: Array<UserNotificationEntitiesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationsArgs = {
  _set?: InputMaybe<UserNotificationsSetInput>;
  where: UserNotificationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationsByPkArgs = {
  _set?: InputMaybe<UserNotificationsSetInput>;
  pkColumns: UserNotificationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserNotificationsManyArgs = {
  updates: Array<UserNotificationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserProfilesArgs = {
  _inc?: InputMaybe<UserProfilesIncInput>;
  _set?: InputMaybe<UserProfilesSetInput>;
  where: UserProfilesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserProfilesManyArgs = {
  updates: Array<UserProfilesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserRegistrationDetailsArgs = {
  _append?: InputMaybe<UserRegistrationDetailsAppendInput>;
  _deleteAtPath?: InputMaybe<UserRegistrationDetailsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UserRegistrationDetailsDeleteElemInput>;
  _deleteKey?: InputMaybe<UserRegistrationDetailsDeleteKeyInput>;
  _prepend?: InputMaybe<UserRegistrationDetailsPrependInput>;
  _set?: InputMaybe<UserRegistrationDetailsSetInput>;
  where: UserRegistrationDetailsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserRegistrationDetailsByPkArgs = {
  _append?: InputMaybe<UserRegistrationDetailsAppendInput>;
  _deleteAtPath?: InputMaybe<UserRegistrationDetailsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UserRegistrationDetailsDeleteElemInput>;
  _deleteKey?: InputMaybe<UserRegistrationDetailsDeleteKeyInput>;
  _prepend?: InputMaybe<UserRegistrationDetailsPrependInput>;
  _set?: InputMaybe<UserRegistrationDetailsSetInput>;
  pkColumns: UserRegistrationDetailsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserRegistrationDetailsManyArgs = {
  updates: Array<UserRegistrationDetailsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserTermsOfServiceArgs = {
  _set?: InputMaybe<UserTermsOfServiceSetInput>;
  where: UserTermsOfServiceBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserTermsOfServiceByPkArgs = {
  _set?: InputMaybe<UserTermsOfServiceSetInput>;
  pkColumns: UserTermsOfServicePkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserTermsOfServiceManyArgs = {
  updates: Array<UserTermsOfServiceUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsernameLogsArgs = {
  _set?: InputMaybe<UsernameLogsSetInput>;
  where: UsernameLogsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsernameLogsByPkArgs = {
  _set?: InputMaybe<UsernameLogsSetInput>;
  pkColumns: UsernameLogsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsernameLogsManyArgs = {
  updates: Array<UsernameLogsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsernamesActiveArgs = {
  _set?: InputMaybe<UsernamesActiveSetInput>;
  where: UsernamesActiveBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsernamesActiveManyArgs = {
  updates: Array<UsernamesActiveUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsernamesClaimedArgs = {
  _set?: InputMaybe<UsernamesClaimedSetInput>;
  where: UsernamesClaimedBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsernamesClaimedByPkArgs = {
  _set?: InputMaybe<UsernamesClaimedSetInput>;
  pkColumns: UsernamesClaimedPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsernamesClaimedManyArgs = {
  updates: Array<UsernamesClaimedUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersArgs = {
  _append?: InputMaybe<UsersAppendInput>;
  _deleteAtPath?: InputMaybe<UsersDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UsersDeleteElemInput>;
  _deleteKey?: InputMaybe<UsersDeleteKeyInput>;
  _inc?: InputMaybe<UsersIncInput>;
  _prepend?: InputMaybe<UsersPrependInput>;
  _set?: InputMaybe<UsersSetInput>;
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersByPkArgs = {
  _append?: InputMaybe<UsersAppendInput>;
  _deleteAtPath?: InputMaybe<UsersDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UsersDeleteElemInput>;
  _deleteKey?: InputMaybe<UsersDeleteKeyInput>;
  _inc?: InputMaybe<UsersIncInput>;
  _prepend?: InputMaybe<UsersPrependInput>;
  _set?: InputMaybe<UsersSetInput>;
  pkColumns: UsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsersCoachQualificationsArgs = {
  _set?: InputMaybe<UsersCoachQualificationsSetInput>;
  where: UsersCoachQualificationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersCoachQualificationsByPkArgs = {
  _set?: InputMaybe<UsersCoachQualificationsSetInput>;
  pkColumns: UsersCoachQualificationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsersCoachQualificationsManyArgs = {
  updates: Array<UsersCoachQualificationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersManyArgs = {
  updates: Array<UsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueAccessTypesArgs = {
  _set?: InputMaybe<VenueAccessTypesSetInput>;
  where: VenueAccessTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueAccessTypesByPkArgs = {
  _set?: InputMaybe<VenueAccessTypesSetInput>;
  pkColumns: VenueAccessTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueAccessTypesManyArgs = {
  updates: Array<VenueAccessTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueAmenitiesArgs = {
  _set?: InputMaybe<VenueAmenitiesSetInput>;
  where: VenueAmenitiesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueAmenitiesByPkArgs = {
  _set?: InputMaybe<VenueAmenitiesSetInput>;
  pkColumns: VenueAmenitiesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueAmenitiesManyArgs = {
  updates: Array<VenueAmenitiesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueCourtSurfacesArgs = {
  _set?: InputMaybe<VenueCourtSurfacesSetInput>;
  where: VenueCourtSurfacesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueCourtSurfacesByPkArgs = {
  _set?: InputMaybe<VenueCourtSurfacesSetInput>;
  pkColumns: VenueCourtSurfacesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueCourtSurfacesManyArgs = {
  updates: Array<VenueCourtSurfacesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueFacilityTypesArgs = {
  _set?: InputMaybe<VenueFacilityTypesSetInput>;
  where: VenueFacilityTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueFacilityTypesByPkArgs = {
  _set?: InputMaybe<VenueFacilityTypesSetInput>;
  pkColumns: VenueFacilityTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueFacilityTypesManyArgs = {
  updates: Array<VenueFacilityTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueFollowsArgs = {
  _set?: InputMaybe<VenueFollowsSetInput>;
  where: VenueFollowsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueFollowsByPkArgs = {
  _set?: InputMaybe<VenueFollowsSetInput>;
  pkColumns: VenueFollowsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueFollowsManyArgs = {
  updates: Array<VenueFollowsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueImagesArgs = {
  _set?: InputMaybe<VenueImagesSetInput>;
  where: VenueImagesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueImagesByPkArgs = {
  _set?: InputMaybe<VenueImagesSetInput>;
  pkColumns: VenueImagesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueImagesManyArgs = {
  updates: Array<VenueImagesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueLinesArgs = {
  _set?: InputMaybe<VenueLinesSetInput>;
  where: VenueLinesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueLinesByPkArgs = {
  _set?: InputMaybe<VenueLinesSetInput>;
  pkColumns: VenueLinesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueLinesManyArgs = {
  updates: Array<VenueLinesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenueNetsArgs = {
  _set?: InputMaybe<VenueNetsSetInput>;
  where: VenueNetsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenueNetsByPkArgs = {
  _set?: InputMaybe<VenueNetsSetInput>;
  pkColumns: VenueNetsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenueNetsManyArgs = {
  updates: Array<VenueNetsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVenuesArgs = {
  _inc?: InputMaybe<VenuesIncInput>;
  _set?: InputMaybe<VenuesSetInput>;
  where: VenuesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVenuesByPkArgs = {
  _inc?: InputMaybe<VenuesIncInput>;
  _set?: InputMaybe<VenuesSetInput>;
  pkColumns: VenuesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVenuesManyArgs = {
  updates: Array<VenuesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateWelcomeEmailConfigurationArgs = {
  _set?: InputMaybe<WelcomeEmailConfigurationSetInput>;
  where: WelcomeEmailConfigurationBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateWelcomeEmailConfigurationByPkArgs = {
  _set?: InputMaybe<WelcomeEmailConfigurationSetInput>;
  pkColumns: WelcomeEmailConfigurationPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateWelcomeEmailConfigurationManyArgs = {
  updates: Array<WelcomeEmailConfigurationUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateWinReasonsArgs = {
  _set?: InputMaybe<WinReasonsSetInput>;
  where: WinReasonsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateWinReasonsByPkArgs = {
  _set?: InputMaybe<WinReasonsSetInput>;
  pkColumns: WinReasonsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateWinReasonsManyArgs = {
  updates: Array<WinReasonsUpdates>;
};

export type PlaySessionCommentsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionCommentsBoolExp>;
  predicate: IntComparisonExp;
};

export type PlaySessionParticipantsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionParticipantsBoolExp>;
  predicate: IntComparisonExp;
};

export type PlaySessionsAggregateBoolExpBool_And = {
  arguments: PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PlaySessionsAggregateBoolExpBool_Or = {
  arguments: PlaySessionsSelectColumnPlaySessionsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PlaySessionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PlaySessionsBoolExp>;
  predicate: IntComparisonExp;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "amenities" */
  amenities: Array<Amenities>;
  /** fetch aggregated fields from the table: "amenities" */
  amenitiesAggregate: AmenitiesAggregate;
  /** fetch data from the table: "amenities" using primary key columns */
  amenitiesByPk?: Maybe<Amenities>;
  /** fetch data from the table: "app_personas" */
  appPersonas: Array<AppPersonas>;
  /** fetch aggregated fields from the table: "app_personas" */
  appPersonasAggregate: AppPersonasAggregate;
  /** fetch data from the table: "app_personas" using primary key columns */
  appPersonasByPk?: Maybe<AppPersonas>;
  /** fetch data from the table: "app_pings" */
  appPings: Array<AppPings>;
  /** fetch aggregated fields from the table: "app_pings" */
  appPingsAggregate: AppPingsAggregate;
  /** fetch data from the table: "app_pings" using primary key columns */
  appPingsByPk?: Maybe<AppPings>;
  /** fetch data from the table: "ball_types" */
  ballTypes: Array<BallTypes>;
  /** fetch aggregated fields from the table: "ball_types" */
  ballTypesAggregate: BallTypesAggregate;
  /** fetch data from the table: "ball_types" using primary key columns */
  ballTypesByPk?: Maybe<BallTypes>;
  /** An array relationship */
  cities: Array<Cities>;
  /** An aggregate relationship */
  citiesAggregate: CitiesAggregate;
  /** fetch data from the table: "cities" using primary key columns */
  citiesByPk?: Maybe<Cities>;
  /** fetch data from the table: "coach_qualification_groups" */
  coachQualificationGroups: Array<CoachQualificationGroups>;
  /** fetch aggregated fields from the table: "coach_qualification_groups" */
  coachQualificationGroupsAggregate: CoachQualificationGroupsAggregate;
  /** fetch data from the table: "coach_qualification_groups" using primary key columns */
  coachQualificationGroupsByPk?: Maybe<CoachQualificationGroups>;
  /** fetch data from the table: "coach_qualification_statuses" */
  coachQualificationStatuses: Array<CoachQualificationStatuses>;
  /** fetch aggregated fields from the table: "coach_qualification_statuses" */
  coachQualificationStatusesAggregate: CoachQualificationStatusesAggregate;
  /** fetch data from the table: "coach_qualification_statuses" using primary key columns */
  coachQualificationStatusesByPk?: Maybe<CoachQualificationStatuses>;
  /** fetch data from the table: "coach_qualifications" */
  coachQualifications: Array<CoachQualifications>;
  /** fetch aggregated fields from the table: "coach_qualifications" */
  coachQualificationsAggregate: CoachQualificationsAggregate;
  /** fetch data from the table: "coach_qualifications" using primary key columns */
  coachQualificationsByPk?: Maybe<CoachQualifications>;
  /** fetch data from the table: "coach_status" */
  coachStatus: Array<CoachStatus>;
  /** fetch aggregated fields from the table: "coach_status" */
  coachStatusAggregate: CoachStatusAggregate;
  /** fetch data from the table: "coach_status" using primary key columns */
  coachStatusByPk?: Maybe<CoachStatus>;
  /** fetch data from the table: "comment_vote" */
  commentVote: Array<CommentVote>;
  /** fetch aggregated fields from the table: "comment_vote" */
  commentVoteAggregate: CommentVoteAggregate;
  /** fetch data from the table: "comment_vote" using primary key columns */
  commentVoteByPk?: Maybe<CommentVote>;
  /** fetch data from the table: "communication_preference_statuses" */
  communicationPreferenceStatuses: Array<CommunicationPreferenceStatuses>;
  /** fetch aggregated fields from the table: "communication_preference_statuses" */
  communicationPreferenceStatusesAggregate: CommunicationPreferenceStatusesAggregate;
  /** fetch data from the table: "communication_preference_statuses" using primary key columns */
  communicationPreferenceStatusesByPk?: Maybe<CommunicationPreferenceStatuses>;
  /** fetch data from the table: "competition_formats" */
  competitionFormats: Array<CompetitionFormats>;
  /** fetch aggregated fields from the table: "competition_formats" */
  competitionFormatsAggregate: CompetitionFormatsAggregate;
  /** fetch data from the table: "competition_formats" using primary key columns */
  competitionFormatsByPk?: Maybe<CompetitionFormats>;
  /** fetch data from the table: "competition_gender" */
  competitionGender: Array<CompetitionGender>;
  /** fetch aggregated fields from the table: "competition_gender" */
  competitionGenderAggregate: CompetitionGenderAggregate;
  /** fetch data from the table: "competition_gender" using primary key columns */
  competitionGenderByPk?: Maybe<CompetitionGender>;
  /** fetch data from the table: "countries" */
  countries: Array<Countries>;
  /** fetch aggregated fields from the table: "countries" */
  countriesAggregate: CountriesAggregate;
  /** fetch data from the table: "countries" using primary key columns */
  countriesByPk?: Maybe<Countries>;
  /** fetch data from the table: "country_subdivisions" */
  countrySubdivisions: Array<CountrySubdivisions>;
  /** fetch aggregated fields from the table: "country_subdivisions" */
  countrySubdivisionsAggregate: CountrySubdivisionsAggregate;
  /** fetch data from the table: "country_subdivisions" using primary key columns */
  countrySubdivisionsByPk?: Maybe<CountrySubdivisions>;
  /** fetch data from the table: "court_surfaces" */
  courtSurfaces: Array<CourtSurfaces>;
  /** fetch aggregated fields from the table: "court_surfaces" */
  courtSurfacesAggregate: CourtSurfacesAggregate;
  /** fetch data from the table: "court_surfaces" using primary key columns */
  courtSurfacesByPk?: Maybe<CourtSurfaces>;
  /** fetch data from the table: "event_contact_details" */
  eventContactDetails: Array<EventContactDetails>;
  /** fetch aggregated fields from the table: "event_contact_details" */
  eventContactDetailsAggregate: EventContactDetailsAggregate;
  /** fetch data from the table: "event_contact_details" using primary key columns */
  eventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** fetch data from the table: "event_court_statuses" */
  eventCourtStatuses: Array<EventCourtStatuses>;
  /** fetch aggregated fields from the table: "event_court_statuses" */
  eventCourtStatusesAggregate: EventCourtStatusesAggregate;
  /** fetch data from the table: "event_court_statuses" using primary key columns */
  eventCourtStatusesByPk?: Maybe<EventCourtStatuses>;
  /** fetch data from the table: "event_courts" */
  eventCourts: Array<EventCourts>;
  /** fetch aggregated fields from the table: "event_courts" */
  eventCourtsAggregate: EventCourtsAggregate;
  /** fetch data from the table: "event_courts" using primary key columns */
  eventCourtsByPk?: Maybe<EventCourts>;
  /** fetch data from the table: "event_faqs" */
  eventFaqs: Array<EventFaqs>;
  /** fetch aggregated fields from the table: "event_faqs" */
  eventFaqsAggregate: EventFaqsAggregate;
  /** fetch data from the table: "event_faqs" using primary key columns */
  eventFaqsByPk?: Maybe<EventFaqs>;
  /** fetch data from the table: "event_game_scores" */
  eventGameScores: Array<EventGameScores>;
  /** fetch aggregated fields from the table: "event_game_scores" */
  eventGameScoresAggregate: EventGameScoresAggregate;
  /** fetch data from the table: "event_game_scores" using primary key columns */
  eventGameScoresByPk?: Maybe<EventGameScores>;
  /** fetch data from the table: "event_group_formats" */
  eventGroupFormats: Array<EventGroupFormats>;
  /** fetch aggregated fields from the table: "event_group_formats" */
  eventGroupFormatsAggregate: EventGroupFormatsAggregate;
  /** fetch data from the table: "event_group_formats" using primary key columns */
  eventGroupFormatsByPk?: Maybe<EventGroupFormats>;
  /** fetch data from the table: "event_group_pools" */
  eventGroupPools: Array<EventGroupPools>;
  /** fetch aggregated fields from the table: "event_group_pools" */
  eventGroupPoolsAggregate: EventGroupPoolsAggregate;
  /** fetch data from the table: "event_group_pools" using primary key columns */
  eventGroupPoolsByPk?: Maybe<EventGroupPools>;
  /** fetch data from the table: "event_group_registration_statuses" */
  eventGroupRegistrationStatuses: Array<EventGroupRegistrationStatuses>;
  /** fetch aggregated fields from the table: "event_group_registration_statuses" */
  eventGroupRegistrationStatusesAggregate: EventGroupRegistrationStatusesAggregate;
  /** fetch data from the table: "event_group_registration_statuses" using primary key columns */
  eventGroupRegistrationStatusesByPk?: Maybe<EventGroupRegistrationStatuses>;
  /** fetch data from the table: "event_group_registrations" */
  eventGroupRegistrations: Array<EventGroupRegistrations>;
  /** fetch aggregated fields from the table: "event_group_registrations" */
  eventGroupRegistrationsAggregate: EventGroupRegistrationsAggregate;
  /** fetch data from the table: "event_group_registrations" using primary key columns */
  eventGroupRegistrationsByPk?: Maybe<EventGroupRegistrations>;
  /** fetch data from the table: "event_group_sequence_seeding" */
  eventGroupSequenceSeeding: Array<EventGroupSequenceSeeding>;
  /** fetch aggregated fields from the table: "event_group_sequence_seeding" */
  eventGroupSequenceSeedingAggregate: EventGroupSequenceSeedingAggregate;
  /** fetch data from the table: "event_group_sequence_seeding" using primary key columns */
  eventGroupSequenceSeedingByPk?: Maybe<EventGroupSequenceSeeding>;
  /** fetch data from the table: "event_group_sequences" */
  eventGroupSequences: Array<EventGroupSequences>;
  /** fetch aggregated fields from the table: "event_group_sequences" */
  eventGroupSequencesAggregate: EventGroupSequencesAggregate;
  /** fetch data from the table: "event_group_sequences" using primary key columns */
  eventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** fetch data from the table: "event_groups" */
  eventGroups: Array<EventGroups>;
  /** fetch aggregated fields from the table: "event_groups" */
  eventGroupsAggregate: EventGroupsAggregate;
  /** fetch data from the table: "event_groups" using primary key columns */
  eventGroupsByPk?: Maybe<EventGroups>;
  /** fetch data from the table: "event_invitation_statuses" */
  eventInvitationStatuses: Array<EventInvitationStatuses>;
  /** fetch aggregated fields from the table: "event_invitation_statuses" */
  eventInvitationStatusesAggregate: EventInvitationStatusesAggregate;
  /** fetch data from the table: "event_invitation_statuses" using primary key columns */
  eventInvitationStatusesByPk?: Maybe<EventInvitationStatuses>;
  /** fetch data from the table: "event_invitations" */
  eventInvitations: Array<EventInvitations>;
  /** fetch aggregated fields from the table: "event_invitations" */
  eventInvitationsAggregate: EventInvitationsAggregate;
  /** fetch data from the table: "event_invitations" using primary key columns */
  eventInvitationsByPk?: Maybe<EventInvitations>;
  /** fetch data from the table: "event_listing_fees" */
  eventListingFees: Array<EventListingFees>;
  /** fetch aggregated fields from the table: "event_listing_fees" */
  eventListingFeesAggregate: EventListingFeesAggregate;
  /** fetch data from the table: "event_listing_fees" using primary key columns */
  eventListingFeesByPk?: Maybe<EventListingFees>;
  /** fetch data from the table: "event_match_games" */
  eventMatchGames: Array<EventMatchGames>;
  /** fetch aggregated fields from the table: "event_match_games" */
  eventMatchGamesAggregate: EventMatchGamesAggregate;
  /** fetch data from the table: "event_match_games" using primary key columns */
  eventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** fetch data from the table: "event_matches" */
  eventMatches: Array<EventMatches>;
  /** fetch aggregated fields from the table: "event_matches" */
  eventMatchesAggregate: EventMatchesAggregate;
  /** fetch data from the table: "event_matches" using primary key columns */
  eventMatchesByPk?: Maybe<EventMatches>;
  /** fetch data from the table: "event_matches_teams" */
  eventMatchesTeams: Array<EventMatchesTeams>;
  /** fetch aggregated fields from the table: "event_matches_teams" */
  eventMatchesTeamsAggregate: EventMatchesTeamsAggregate;
  /** fetch data from the table: "event_matches_teams" using primary key columns */
  eventMatchesTeamsByPk?: Maybe<EventMatchesTeams>;
  /** fetch data from the table: "event_organizer_account_types" */
  eventOrganizerAccountTypes: Array<EventOrganizerAccountTypes>;
  /** fetch aggregated fields from the table: "event_organizer_account_types" */
  eventOrganizerAccountTypesAggregate: EventOrganizerAccountTypesAggregate;
  /** fetch data from the table: "event_organizer_account_types" using primary key columns */
  eventOrganizerAccountTypesByPk?: Maybe<EventOrganizerAccountTypes>;
  /** fetch data from the table: "event_pool_rounds" */
  eventPoolRounds: Array<EventPoolRounds>;
  /** fetch aggregated fields from the table: "event_pool_rounds" */
  eventPoolRoundsAggregate: EventPoolRoundsAggregate;
  /** fetch data from the table: "event_pool_rounds" using primary key columns */
  eventPoolRoundsByPk?: Maybe<EventPoolRounds>;
  /** fetch data from the table: "event_pools_teams" */
  eventPoolsTeams: Array<EventPoolsTeams>;
  /** fetch aggregated fields from the table: "event_pools_teams" */
  eventPoolsTeamsAggregate: EventPoolsTeamsAggregate;
  /** fetch data from the table: "event_pools_teams" using primary key columns */
  eventPoolsTeamsByPk?: Maybe<EventPoolsTeams>;
  /** fetch data from the table: "event_privacy" */
  eventPrivacy: Array<EventPrivacy>;
  /** fetch aggregated fields from the table: "event_privacy" */
  eventPrivacyAggregate: EventPrivacyAggregate;
  /** fetch data from the table: "event_privacy" using primary key columns */
  eventPrivacyByPk?: Maybe<EventPrivacy>;
  /** fetch data from the table: "event_registration_details" */
  eventRegistrationDetails: Array<EventRegistrationDetails>;
  /** fetch aggregated fields from the table: "event_registration_details" */
  eventRegistrationDetailsAggregate: EventRegistrationDetailsAggregate;
  /** fetch data from the table: "event_registration_details" using primary key columns */
  eventRegistrationDetailsByPk?: Maybe<EventRegistrationDetails>;
  /** fetch data from the table: "event_registrations" */
  eventRegistrations: Array<EventRegistrations>;
  /** fetch aggregated fields from the table: "event_registrations" */
  eventRegistrationsAggregate: EventRegistrationsAggregate;
  /** fetch data from the table: "event_registrations" using primary key columns */
  eventRegistrationsByPk?: Maybe<EventRegistrations>;
  /** fetch data from the table: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasons: Array<EventSequenceCompleteReasons>;
  /** fetch aggregated fields from the table: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasonsAggregate: EventSequenceCompleteReasonsAggregate;
  /** fetch data from the table: "event_sequence_complete_reasons" using primary key columns */
  eventSequenceCompleteReasonsByPk?: Maybe<EventSequenceCompleteReasons>;
  /** fetch data from the table: "event_sponsors" */
  eventSponsors: Array<EventSponsors>;
  /** fetch aggregated fields from the table: "event_sponsors" */
  eventSponsorsAggregate: EventSponsorsAggregate;
  /** fetch data from the table: "event_sponsors" using primary key columns */
  eventSponsorsByPk?: Maybe<EventSponsors>;
  /** fetch data from the table: "event_statuses" */
  eventStatuses: Array<EventStatuses>;
  /** fetch aggregated fields from the table: "event_statuses" */
  eventStatusesAggregate: EventStatusesAggregate;
  /** fetch data from the table: "event_statuses" using primary key columns */
  eventStatusesByPk?: Maybe<EventStatuses>;
  /** fetch data from the table: "event_team_member_statuses" */
  eventTeamMemberStatuses: Array<EventTeamMemberStatuses>;
  /** fetch aggregated fields from the table: "event_team_member_statuses" */
  eventTeamMemberStatusesAggregate: EventTeamMemberStatusesAggregate;
  /** fetch data from the table: "event_team_member_statuses" using primary key columns */
  eventTeamMemberStatusesByPk?: Maybe<EventTeamMemberStatuses>;
  /** fetch data from the table: "event_team_members" */
  eventTeamMembers: Array<EventTeamMembers>;
  /** fetch aggregated fields from the table: "event_team_members" */
  eventTeamMembersAggregate: EventTeamMembersAggregate;
  /** fetch data from the table: "event_team_members" using primary key columns */
  eventTeamMembersByPk?: Maybe<EventTeamMembers>;
  /** fetch data from the table: "event_teams" */
  eventTeams: Array<EventTeams>;
  /** fetch aggregated fields from the table: "event_teams" */
  eventTeamsAggregate: EventTeamsAggregate;
  /** fetch data from the table: "event_teams" using primary key columns */
  eventTeamsByPk?: Maybe<EventTeams>;
  /** fetch data from the table: "event_transaction_item_types" */
  eventTransactionItemTypes: Array<EventTransactionItemTypes>;
  /** fetch aggregated fields from the table: "event_transaction_item_types" */
  eventTransactionItemTypesAggregate: EventTransactionItemTypesAggregate;
  /** fetch data from the table: "event_transaction_item_types" using primary key columns */
  eventTransactionItemTypesByPk?: Maybe<EventTransactionItemTypes>;
  /** fetch data from the table: "event_transaction_items" */
  eventTransactionItems: Array<EventTransactionItems>;
  /** fetch aggregated fields from the table: "event_transaction_items" */
  eventTransactionItemsAggregate: EventTransactionItemsAggregate;
  /** fetch data from the table: "event_transaction_items" using primary key columns */
  eventTransactionItemsByPk?: Maybe<EventTransactionItems>;
  /** fetch data from the table: "event_transactions" */
  eventTransactions: Array<EventTransactions>;
  /** fetch aggregated fields from the table: "event_transactions" */
  eventTransactionsAggregate: EventTransactionsAggregate;
  /** fetch data from the table: "event_transactions" using primary key columns */
  eventTransactionsByPk?: Maybe<EventTransactions>;
  /** fetch data from the table: "event_types" */
  eventTypes: Array<EventTypes>;
  /** fetch aggregated fields from the table: "event_types" */
  eventTypesAggregate: EventTypesAggregate;
  /** fetch data from the table: "event_types" using primary key columns */
  eventTypesByPk?: Maybe<EventTypes>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  eventsAggregate: EventsAggregate;
  /** fetch data from the table: "events" using primary key columns */
  eventsByPk?: Maybe<Events>;
  /** fetch data from the table: "follow_statuses" */
  followStatuses: Array<FollowStatuses>;
  /** fetch aggregated fields from the table: "follow_statuses" */
  followStatusesAggregate: FollowStatusesAggregate;
  /** fetch data from the table: "follow_statuses" using primary key columns */
  followStatusesByPk?: Maybe<FollowStatuses>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch aggregated fields from the table: "gender" */
  genderAggregate: GenderAggregate;
  /** fetch data from the table: "gender" using primary key columns */
  genderByPk?: Maybe<Gender>;
  /** fetch data from the table: "group_comment_votes" */
  groupCommentVotes: Array<GroupCommentVotes>;
  /** fetch aggregated fields from the table: "group_comment_votes" */
  groupCommentVotesAggregate: GroupCommentVotesAggregate;
  /** fetch data from the table: "group_comment_votes" using primary key columns */
  groupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** fetch data from the table: "group_members" */
  groupMembers: Array<GroupMembers>;
  /** fetch aggregated fields from the table: "group_members" */
  groupMembersAggregate: GroupMembersAggregate;
  /** fetch data from the table: "group_members" using primary key columns */
  groupMembersByPk?: Maybe<GroupMembers>;
  /** fetch data from the table: "group_thread_comment_files" */
  groupThreadCommentFiles: Array<GroupThreadCommentFiles>;
  /** fetch aggregated fields from the table: "group_thread_comment_files" */
  groupThreadCommentFilesAggregate: GroupThreadCommentFilesAggregate;
  /** fetch data from the table: "group_thread_comment_files" using primary key columns */
  groupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** fetch data from the table: "group_thread_comments" */
  groupThreadComments: Array<GroupThreadComments>;
  /** fetch aggregated fields from the table: "group_thread_comments" */
  groupThreadCommentsAggregate: GroupThreadCommentsAggregate;
  /** fetch data from the table: "group_thread_comments" using primary key columns */
  groupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** fetch data from the table: "group_threads" */
  groupThreads: Array<GroupThreads>;
  /** fetch aggregated fields from the table: "group_threads" */
  groupThreadsAggregate: GroupThreadsAggregate;
  /** fetch data from the table: "group_threads" using primary key columns */
  groupThreadsByPk?: Maybe<GroupThreads>;
  /** fetch data from the table: "group_venues" */
  groupVenues: Array<GroupVenues>;
  /** fetch aggregated fields from the table: "group_venues" */
  groupVenuesAggregate: GroupVenuesAggregate;
  /** fetch data from the table: "group_venues" using primary key columns */
  groupVenuesByPk?: Maybe<GroupVenues>;
  /** An array relationship */
  groups: Array<Groups>;
  /** An aggregate relationship */
  groupsAggregate: GroupsAggregate;
  /** fetch data from the table: "groups" using primary key columns */
  groupsByPk?: Maybe<Groups>;
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  /** An aggregate relationship */
  groupsPlaySessionsAggregate: GroupsPlaySessionsAggregate;
  /** fetch data from the table: "groups_play_sessions" using primary key columns */
  groupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** fetch data from the table: "lesson_equipment" */
  lessonEquipment: Array<LessonEquipment>;
  /** fetch aggregated fields from the table: "lesson_equipment" */
  lessonEquipmentAggregate: LessonEquipmentAggregate;
  /** fetch data from the table: "lesson_equipment" using primary key columns */
  lessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** fetch data from the table: "lesson_equipment_options" */
  lessonEquipmentOptions: Array<LessonEquipmentOptions>;
  /** fetch aggregated fields from the table: "lesson_equipment_options" */
  lessonEquipmentOptionsAggregate: LessonEquipmentOptionsAggregate;
  /** fetch data from the table: "lesson_equipment_options" using primary key columns */
  lessonEquipmentOptionsByPk?: Maybe<LessonEquipmentOptions>;
  /** fetch data from the table: "lesson_order_items" */
  lessonOrderItems: Array<LessonOrderItems>;
  /** fetch aggregated fields from the table: "lesson_order_items" */
  lessonOrderItemsAggregate: LessonOrderItemsAggregate;
  /** fetch data from the table: "lesson_order_items" using primary key columns */
  lessonOrderItemsByPk?: Maybe<LessonOrderItems>;
  /** fetch data from the table: "lesson_orders" */
  lessonOrders: Array<LessonOrders>;
  /** fetch aggregated fields from the table: "lesson_orders" */
  lessonOrdersAggregate: LessonOrdersAggregate;
  /** fetch data from the table: "lesson_orders" using primary key columns */
  lessonOrdersByPk?: Maybe<LessonOrders>;
  /** fetch data from the table: "lesson_participant_statuses" */
  lessonParticipantStatuses: Array<LessonParticipantStatuses>;
  /** fetch aggregated fields from the table: "lesson_participant_statuses" */
  lessonParticipantStatusesAggregate: LessonParticipantStatusesAggregate;
  /** fetch data from the table: "lesson_participant_statuses" using primary key columns */
  lessonParticipantStatusesByPk?: Maybe<LessonParticipantStatuses>;
  /** fetch data from the table: "lesson_participants" */
  lessonParticipants: Array<LessonParticipants>;
  /** fetch aggregated fields from the table: "lesson_participants" */
  lessonParticipantsAggregate: LessonParticipantsAggregate;
  /** fetch data from the table: "lesson_participants" using primary key columns */
  lessonParticipantsByPk?: Maybe<LessonParticipants>;
  /** fetch data from the table: "lesson_privacy" */
  lessonPrivacy: Array<LessonPrivacy>;
  /** fetch aggregated fields from the table: "lesson_privacy" */
  lessonPrivacyAggregate: LessonPrivacyAggregate;
  /** fetch data from the table: "lesson_privacy" using primary key columns */
  lessonPrivacyByPk?: Maybe<LessonPrivacy>;
  /** fetch data from the table: "lesson_statuses" */
  lessonStatuses: Array<LessonStatuses>;
  /** fetch aggregated fields from the table: "lesson_statuses" */
  lessonStatusesAggregate: LessonStatusesAggregate;
  /** fetch data from the table: "lesson_statuses" using primary key columns */
  lessonStatusesByPk?: Maybe<LessonStatuses>;
  /** An array relationship */
  lessonTemplates: Array<LessonTemplates>;
  /** An aggregate relationship */
  lessonTemplatesAggregate: LessonTemplatesAggregate;
  /** fetch data from the table: "lesson_templates" using primary key columns */
  lessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** fetch data from the table: "lesson_times" */
  lessonTimes: Array<LessonTimes>;
  /** fetch aggregated fields from the table: "lesson_times" */
  lessonTimesAggregate: LessonTimesAggregate;
  /** fetch data from the table: "lesson_times" using primary key columns */
  lessonTimesByPk?: Maybe<LessonTimes>;
  /** fetch data from the table: "lesson_types" */
  lessonTypes: Array<LessonTypes>;
  /** fetch aggregated fields from the table: "lesson_types" */
  lessonTypesAggregate: LessonTypesAggregate;
  /** fetch data from the table: "lesson_types" using primary key columns */
  lessonTypesByPk?: Maybe<LessonTypes>;
  /** fetch data from the table: "lesson_waitlist_statuses" */
  lessonWaitlistStatuses: Array<LessonWaitlistStatuses>;
  /** fetch aggregated fields from the table: "lesson_waitlist_statuses" */
  lessonWaitlistStatusesAggregate: LessonWaitlistStatusesAggregate;
  /** fetch data from the table: "lesson_waitlist_statuses" using primary key columns */
  lessonWaitlistStatusesByPk?: Maybe<LessonWaitlistStatuses>;
  /** fetch data from the table: "lesson_waitlists" */
  lessonWaitlists: Array<LessonWaitlists>;
  /** fetch aggregated fields from the table: "lesson_waitlists" */
  lessonWaitlistsAggregate: LessonWaitlistsAggregate;
  /** fetch data from the table: "lesson_waitlists" using primary key columns */
  lessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** An array relationship */
  lessons: Array<Lessons>;
  /** An aggregate relationship */
  lessonsAggregate: LessonsAggregate;
  /** fetch data from the table: "lessons" using primary key columns */
  lessonsByPk?: Maybe<Lessons>;
  /** fetch data from the table: "match_selection_criteria" */
  matchSelectionCriteria: Array<MatchSelectionCriteria>;
  /** fetch aggregated fields from the table: "match_selection_criteria" */
  matchSelectionCriteriaAggregate: MatchSelectionCriteriaAggregate;
  /** fetch data from the table: "match_selection_criteria" using primary key columns */
  matchSelectionCriteriaByPk?: Maybe<MatchSelectionCriteria>;
  /** fetch data from the table: "notification_action_types" */
  notificationActionTypes: Array<NotificationActionTypes>;
  /** fetch aggregated fields from the table: "notification_action_types" */
  notificationActionTypesAggregate: NotificationActionTypesAggregate;
  /** fetch data from the table: "notification_action_types" using primary key columns */
  notificationActionTypesByPk?: Maybe<NotificationActionTypes>;
  /** fetch data from the table: "notification_statuses" */
  notificationStatuses: Array<NotificationStatuses>;
  /** fetch aggregated fields from the table: "notification_statuses" */
  notificationStatusesAggregate: NotificationStatusesAggregate;
  /** fetch data from the table: "notification_statuses" using primary key columns */
  notificationStatusesByPk?: Maybe<NotificationStatuses>;
  /** fetch data from the table: "order_statuses" */
  orderStatuses: Array<OrderStatuses>;
  /** fetch aggregated fields from the table: "order_statuses" */
  orderStatusesAggregate: OrderStatusesAggregate;
  /** fetch data from the table: "order_statuses" using primary key columns */
  orderStatusesByPk?: Maybe<OrderStatuses>;
  /** fetch data from the table: "payment_fulfillment_channels" */
  paymentFulfillmentChannels: Array<PaymentFulfillmentChannels>;
  /** fetch aggregated fields from the table: "payment_fulfillment_channels" */
  paymentFulfillmentChannelsAggregate: PaymentFulfillmentChannelsAggregate;
  /** fetch data from the table: "payment_fulfillment_channels" using primary key columns */
  paymentFulfillmentChannelsByPk?: Maybe<PaymentFulfillmentChannels>;
  /** fetch data from the table: "payment_processors" */
  paymentProcessors: Array<PaymentProcessors>;
  /** fetch aggregated fields from the table: "payment_processors" */
  paymentProcessorsAggregate: PaymentProcessorsAggregate;
  /** fetch data from the table: "payment_processors" using primary key columns */
  paymentProcessorsByPk?: Maybe<PaymentProcessors>;
  /** fetch data from the table: "pickleball_rating_scales" */
  pickleballRatingScales: Array<PickleballRatingScales>;
  /** fetch aggregated fields from the table: "pickleball_rating_scales" */
  pickleballRatingScalesAggregate: PickleballRatingScalesAggregate;
  /** fetch data from the table: "pickleball_rating_scales" using primary key columns */
  pickleballRatingScalesByPk?: Maybe<PickleballRatingScales>;
  /** fetch data from the table: "play_session_comments" */
  playSessionComments: Array<PlaySessionComments>;
  /** fetch aggregated fields from the table: "play_session_comments" */
  playSessionCommentsAggregate: PlaySessionCommentsAggregate;
  /** fetch data from the table: "play_session_comments" using primary key columns */
  playSessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** fetch data from the table: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatuses: Array<PlaySessionCourtBookingStatuses>;
  /** fetch aggregated fields from the table: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatusesAggregate: PlaySessionCourtBookingStatusesAggregate;
  /** fetch data from the table: "play_session_court_booking_statuses" using primary key columns */
  playSessionCourtBookingStatusesByPk?: Maybe<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table: "play_session_formats" */
  playSessionFormats: Array<PlaySessionFormats>;
  /** fetch aggregated fields from the table: "play_session_formats" */
  playSessionFormatsAggregate: PlaySessionFormatsAggregate;
  /** fetch data from the table: "play_session_formats" using primary key columns */
  playSessionFormatsByPk?: Maybe<PlaySessionFormats>;
  /** fetch data from the table: "play_session_match_competitiveness" */
  playSessionMatchCompetitiveness: Array<PlaySessionMatchCompetitiveness>;
  /** fetch aggregated fields from the table: "play_session_match_competitiveness" */
  playSessionMatchCompetitivenessAggregate: PlaySessionMatchCompetitivenessAggregate;
  /** fetch data from the table: "play_session_match_competitiveness" using primary key columns */
  playSessionMatchCompetitivenessByPk?: Maybe<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table: "play_session_participant_statuses" */
  playSessionParticipantStatuses: Array<PlaySessionParticipantStatuses>;
  /** fetch aggregated fields from the table: "play_session_participant_statuses" */
  playSessionParticipantStatusesAggregate: PlaySessionParticipantStatusesAggregate;
  /** fetch data from the table: "play_session_participant_statuses" using primary key columns */
  playSessionParticipantStatusesByPk?: Maybe<PlaySessionParticipantStatuses>;
  /** fetch data from the table: "play_session_participants" */
  playSessionParticipants: Array<PlaySessionParticipants>;
  /** fetch aggregated fields from the table: "play_session_participants" */
  playSessionParticipantsAggregate: PlaySessionParticipantsAggregate;
  /** fetch data from the table: "play_session_participants" using primary key columns */
  playSessionParticipantsByPk?: Maybe<PlaySessionParticipants>;
  /** fetch data from the table: "play_session_privacy" */
  playSessionPrivacy: Array<PlaySessionPrivacy>;
  /** fetch aggregated fields from the table: "play_session_privacy" */
  playSessionPrivacyAggregate: PlaySessionPrivacyAggregate;
  /** fetch data from the table: "play_session_privacy" using primary key columns */
  playSessionPrivacyByPk?: Maybe<PlaySessionPrivacy>;
  /** fetch data from the table: "play_session_statuses" */
  playSessionStatuses: Array<PlaySessionStatuses>;
  /** fetch aggregated fields from the table: "play_session_statuses" */
  playSessionStatusesAggregate: PlaySessionStatusesAggregate;
  /** fetch data from the table: "play_session_statuses" using primary key columns */
  playSessionStatusesByPk?: Maybe<PlaySessionStatuses>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  /** fetch data from the table: "play_sessions" using primary key columns */
  playSessionsByPk?: Maybe<PlaySessions>;
  /** fetch data from the table: "scoring_format" */
  scoringFormat: Array<ScoringFormat>;
  /** fetch aggregated fields from the table: "scoring_format" */
  scoringFormatAggregate: ScoringFormatAggregate;
  /** fetch data from the table: "scoring_format" using primary key columns */
  scoringFormatByPk?: Maybe<ScoringFormat>;
  /** fetch data from the table: "signup_requests" */
  signupRequests: Array<SignupRequests>;
  /** fetch aggregated fields from the table: "signup_requests" */
  signupRequestsAggregate: SignupRequestsAggregate;
  /** fetch data from the table: "signup_requests" using primary key columns */
  signupRequestsByPk?: Maybe<SignupRequests>;
  /** fetch data from the table: "skill_levels" */
  skillLevels: Array<SkillLevels>;
  /** fetch aggregated fields from the table: "skill_levels" */
  skillLevelsAggregate: SkillLevelsAggregate;
  /** fetch data from the table: "skill_levels" using primary key columns */
  skillLevelsByPk?: Maybe<SkillLevels>;
  /** fetch data from the table: "sports" */
  sports: Array<Sports>;
  /** fetch aggregated fields from the table: "sports" */
  sportsAggregate: SportsAggregate;
  /** fetch data from the table: "sports" using primary key columns */
  sportsByPk?: Maybe<Sports>;
  /** An array relationship */
  stripeCharges: Array<StripeCharges>;
  /** An aggregate relationship */
  stripeChargesAggregate: StripeChargesAggregate;
  /** fetch data from the table: "stripe_charges" using primary key columns */
  stripeChargesByPk?: Maybe<StripeCharges>;
  /** fetch data from the table: "stripe_payment_intents" */
  stripePaymentIntents: Array<StripePaymentIntents>;
  /** fetch aggregated fields from the table: "stripe_payment_intents" */
  stripePaymentIntentsAggregate: StripePaymentIntentsAggregate;
  /** fetch data from the table: "stripe_payment_intents" using primary key columns */
  stripePaymentIntentsByPk?: Maybe<StripePaymentIntents>;
  /** fetch data from the table: "team_types" */
  teamTypes: Array<TeamTypes>;
  /** fetch aggregated fields from the table: "team_types" */
  teamTypesAggregate: TeamTypesAggregate;
  /** fetch data from the table: "team_types" using primary key columns */
  teamTypesByPk?: Maybe<TeamTypes>;
  /** fetch data from the table: "tennis_rating_scales" */
  tennisRatingScales: Array<TennisRatingScales>;
  /** fetch aggregated fields from the table: "tennis_rating_scales" */
  tennisRatingScalesAggregate: TennisRatingScalesAggregate;
  /** fetch data from the table: "tennis_rating_scales" using primary key columns */
  tennisRatingScalesByPk?: Maybe<TennisRatingScales>;
  /** fetch data from the table: "user_auth_identities" */
  userAuthIdentities: Array<UserAuthIdentities>;
  /** fetch aggregated fields from the table: "user_auth_identities" */
  userAuthIdentitiesAggregate: UserAuthIdentitiesAggregate;
  /** fetch data from the table: "user_auth_identities" using primary key columns */
  userAuthIdentitiesByPk?: Maybe<UserAuthIdentities>;
  /** fetch data from the table: "user_coach_services" */
  userCoachServices: Array<UserCoachServices>;
  /** fetch aggregated fields from the table: "user_coach_services" */
  userCoachServicesAggregate: UserCoachServicesAggregate;
  /** fetch data from the table: "user_coach_services" using primary key columns */
  userCoachServicesByPk?: Maybe<UserCoachServices>;
  /** fetch data from the table: "user_communication_preferences" */
  userCommunicationPreferences: Array<UserCommunicationPreferences>;
  /** fetch aggregated fields from the table: "user_communication_preferences" */
  userCommunicationPreferencesAggregate: UserCommunicationPreferencesAggregate;
  /** fetch data from the table: "user_communication_preferences" using primary key columns */
  userCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** fetch data from the table: "user_credit_cards" */
  userCreditCards: Array<UserCreditCards>;
  /** fetch aggregated fields from the table: "user_credit_cards" */
  userCreditCardsAggregate: UserCreditCardsAggregate;
  /** fetch data from the table: "user_credit_cards" using primary key columns */
  userCreditCardsByPk?: Maybe<UserCreditCards>;
  /** fetch data from the table: "user_custom_courts" */
  userCustomCourts: Array<UserCustomCourts>;
  /** fetch aggregated fields from the table: "user_custom_courts" */
  userCustomCourtsAggregate: UserCustomCourtsAggregate;
  /** fetch data from the table: "user_custom_courts" using primary key columns */
  userCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** fetch data from the table: "user_follows" */
  userFollows: Array<UserFollows>;
  /** fetch aggregated fields from the table: "user_follows" */
  userFollowsAggregate: UserFollowsAggregate;
  /** fetch data from the table: "user_follows" using primary key columns */
  userFollowsByPk?: Maybe<UserFollows>;
  /** fetch data from the table: "user_image_log" */
  userImageLog: Array<UserImageLog>;
  /** fetch aggregated fields from the table: "user_image_log" */
  userImageLogAggregate: UserImageLogAggregate;
  /** fetch data from the table: "user_image_log" using primary key columns */
  userImageLogByPk?: Maybe<UserImageLog>;
  /** fetch data from the table: "user_notification_details" */
  userNotificationDetails: Array<UserNotificationDetails>;
  /** fetch aggregated fields from the table: "user_notification_details" */
  userNotificationDetailsAggregate: UserNotificationDetailsAggregate;
  /** fetch data from the table: "user_notification_details" using primary key columns */
  userNotificationDetailsByPk?: Maybe<UserNotificationDetails>;
  /** fetch data from the table: "user_notification_entities" */
  userNotificationEntities: Array<UserNotificationEntities>;
  /** fetch aggregated fields from the table: "user_notification_entities" */
  userNotificationEntitiesAggregate: UserNotificationEntitiesAggregate;
  /** fetch data from the table: "user_notification_entities" using primary key columns */
  userNotificationEntitiesByPk?: Maybe<UserNotificationEntities>;
  /** An array relationship */
  userNotifications: Array<UserNotifications>;
  /** An aggregate relationship */
  userNotificationsAggregate: UserNotificationsAggregate;
  /** fetch data from the table: "user_notifications" using primary key columns */
  userNotificationsByPk?: Maybe<UserNotifications>;
  /** fetch data from the table: "user_profiles" */
  userProfiles: Array<UserProfiles>;
  /** fetch aggregated fields from the table: "user_profiles" */
  userProfilesAggregate: UserProfilesAggregate;
  /** fetch data from the table: "user_registration_details" */
  userRegistrationDetails: Array<UserRegistrationDetails>;
  /** fetch aggregated fields from the table: "user_registration_details" */
  userRegistrationDetailsAggregate: UserRegistrationDetailsAggregate;
  /** fetch data from the table: "user_registration_details" using primary key columns */
  userRegistrationDetailsByPk?: Maybe<UserRegistrationDetails>;
  /** fetch data from the table: "user_terms_of_service" */
  userTermsOfService: Array<UserTermsOfService>;
  /** fetch aggregated fields from the table: "user_terms_of_service" */
  userTermsOfServiceAggregate: UserTermsOfServiceAggregate;
  /** fetch data from the table: "user_terms_of_service" using primary key columns */
  userTermsOfServiceByPk?: Maybe<UserTermsOfService>;
  /** An array relationship */
  usernameLogs: Array<UsernameLogs>;
  /** An aggregate relationship */
  usernameLogsAggregate: UsernameLogsAggregate;
  /** fetch data from the table: "username_logs" using primary key columns */
  usernameLogsByPk?: Maybe<UsernameLogs>;
  /** fetch data from the table: "usernames_active" */
  usernamesActive: Array<UsernamesActive>;
  /** fetch aggregated fields from the table: "usernames_active" */
  usernamesActiveAggregate: UsernamesActiveAggregate;
  /** An array relationship */
  usernamesClaimed: Array<UsernamesClaimed>;
  /** An aggregate relationship */
  usernamesClaimedAggregate: UsernamesClaimedAggregate;
  /** fetch data from the table: "usernames_claimed" using primary key columns */
  usernamesClaimedByPk?: Maybe<UsernamesClaimed>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  usersAggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table: "users_coach_qualifications" */
  usersCoachQualifications: Array<UsersCoachQualifications>;
  /** fetch aggregated fields from the table: "users_coach_qualifications" */
  usersCoachQualificationsAggregate: UsersCoachQualificationsAggregate;
  /** fetch data from the table: "users_coach_qualifications" using primary key columns */
  usersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** fetch data from the table: "venue_access_types" */
  venueAccessTypes: Array<VenueAccessTypes>;
  /** fetch aggregated fields from the table: "venue_access_types" */
  venueAccessTypesAggregate: VenueAccessTypesAggregate;
  /** fetch data from the table: "venue_access_types" using primary key columns */
  venueAccessTypesByPk?: Maybe<VenueAccessTypes>;
  /** fetch data from the table: "venue_amenities" */
  venueAmenities: Array<VenueAmenities>;
  /** fetch aggregated fields from the table: "venue_amenities" */
  venueAmenitiesAggregate: VenueAmenitiesAggregate;
  /** fetch data from the table: "venue_amenities" using primary key columns */
  venueAmenitiesByPk?: Maybe<VenueAmenities>;
  /** fetch data from the table: "venue_court_surfaces" */
  venueCourtSurfaces: Array<VenueCourtSurfaces>;
  /** fetch aggregated fields from the table: "venue_court_surfaces" */
  venueCourtSurfacesAggregate: VenueCourtSurfacesAggregate;
  /** fetch data from the table: "venue_court_surfaces" using primary key columns */
  venueCourtSurfacesByPk?: Maybe<VenueCourtSurfaces>;
  /** fetch data from the table: "venue_facility_types" */
  venueFacilityTypes: Array<VenueFacilityTypes>;
  /** fetch aggregated fields from the table: "venue_facility_types" */
  venueFacilityTypesAggregate: VenueFacilityTypesAggregate;
  /** fetch data from the table: "venue_facility_types" using primary key columns */
  venueFacilityTypesByPk?: Maybe<VenueFacilityTypes>;
  /** fetch data from the table: "venue_follows" */
  venueFollows: Array<VenueFollows>;
  /** fetch aggregated fields from the table: "venue_follows" */
  venueFollowsAggregate: VenueFollowsAggregate;
  /** fetch data from the table: "venue_follows" using primary key columns */
  venueFollowsByPk?: Maybe<VenueFollows>;
  /** fetch data from the table: "venue_images" */
  venueImages: Array<VenueImages>;
  /** fetch aggregated fields from the table: "venue_images" */
  venueImagesAggregate: VenueImagesAggregate;
  /** fetch data from the table: "venue_images" using primary key columns */
  venueImagesByPk?: Maybe<VenueImages>;
  /** fetch data from the table: "venue_lines" */
  venueLines: Array<VenueLines>;
  /** fetch aggregated fields from the table: "venue_lines" */
  venueLinesAggregate: VenueLinesAggregate;
  /** fetch data from the table: "venue_lines" using primary key columns */
  venueLinesByPk?: Maybe<VenueLines>;
  /** fetch data from the table: "venue_nets" */
  venueNets: Array<VenueNets>;
  /** fetch aggregated fields from the table: "venue_nets" */
  venueNetsAggregate: VenueNetsAggregate;
  /** fetch data from the table: "venue_nets" using primary key columns */
  venueNetsByPk?: Maybe<VenueNets>;
  /** An array relationship */
  venues: Array<Venues>;
  /** An aggregate relationship */
  venuesAggregate: VenuesAggregate;
  /** fetch data from the table: "venues" using primary key columns */
  venuesByPk?: Maybe<Venues>;
  /** fetch data from the table: "welcome_email_configuration" */
  welcomeEmailConfiguration: Array<WelcomeEmailConfiguration>;
  /** fetch aggregated fields from the table: "welcome_email_configuration" */
  welcomeEmailConfigurationAggregate: WelcomeEmailConfigurationAggregate;
  /** fetch data from the table: "welcome_email_configuration" using primary key columns */
  welcomeEmailConfigurationByPk?: Maybe<WelcomeEmailConfiguration>;
  /** fetch data from the table: "win_reasons" */
  winReasons: Array<WinReasons>;
  /** fetch aggregated fields from the table: "win_reasons" */
  winReasonsAggregate: WinReasonsAggregate;
  /** fetch data from the table: "win_reasons" using primary key columns */
  winReasonsByPk?: Maybe<WinReasons>;
};


export type Query_RootAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<AmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AmenitiesOrderBy>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Query_RootAmenitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AmenitiesOrderBy>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Query_RootAmenitiesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootAppPersonasArgs = {
  distinctOn?: InputMaybe<Array<AppPersonasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPersonasOrderBy>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Query_RootAppPersonasAggregateArgs = {
  distinctOn?: InputMaybe<Array<AppPersonasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPersonasOrderBy>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Query_RootAppPersonasByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootAppPingsArgs = {
  distinctOn?: InputMaybe<Array<AppPingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPingsOrderBy>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Query_RootAppPingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AppPingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPingsOrderBy>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Query_RootAppPingsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBallTypesArgs = {
  distinctOn?: InputMaybe<Array<BallTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BallTypesOrderBy>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Query_RootBallTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<BallTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BallTypesOrderBy>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Query_RootBallTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCitiesArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Query_RootCitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Query_RootCitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCoachQualificationGroupsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationGroupsOrderBy>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Query_RootCoachQualificationGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationGroupsOrderBy>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Query_RootCoachQualificationGroupsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCoachQualificationStatusesArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationStatusesOrderBy>>;
  where?: InputMaybe<CoachQualificationStatusesBoolExp>;
};


export type Query_RootCoachQualificationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationStatusesOrderBy>>;
  where?: InputMaybe<CoachQualificationStatusesBoolExp>;
};


export type Query_RootCoachQualificationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationsOrderBy>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Query_RootCoachQualificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationsOrderBy>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Query_RootCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCoachStatusArgs = {
  distinctOn?: InputMaybe<Array<CoachStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachStatusOrderBy>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Query_RootCoachStatusAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachStatusOrderBy>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Query_RootCoachStatusByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCommentVoteArgs = {
  distinctOn?: InputMaybe<Array<CommentVoteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentVoteOrderBy>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Query_RootCommentVoteAggregateArgs = {
  distinctOn?: InputMaybe<Array<CommentVoteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentVoteOrderBy>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Query_RootCommentVoteByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCommunicationPreferenceStatusesArgs = {
  distinctOn?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommunicationPreferenceStatusesOrderBy>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Query_RootCommunicationPreferenceStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommunicationPreferenceStatusesOrderBy>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Query_RootCommunicationPreferenceStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCompetitionFormatsArgs = {
  distinctOn?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionFormatsOrderBy>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Query_RootCompetitionFormatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionFormatsOrderBy>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Query_RootCompetitionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCompetitionGenderArgs = {
  distinctOn?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionGenderOrderBy>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Query_RootCompetitionGenderAggregateArgs = {
  distinctOn?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionGenderOrderBy>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Query_RootCompetitionGenderByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootCountriesArgs = {
  distinctOn?: InputMaybe<Array<CountriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Query_RootCountriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CountriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Query_RootCountriesByPkArgs = {
  id: Scalars['String'];
};


export type Query_RootCountrySubdivisionsArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Query_RootCountrySubdivisionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Query_RootCountrySubdivisionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CourtSurfacesOrderBy>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Query_RootCourtSurfacesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CourtSurfacesOrderBy>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Query_RootCourtSurfacesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventContactDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventContactDetailsOrderBy>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Query_RootEventContactDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventContactDetailsOrderBy>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Query_RootEventContactDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventCourtStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtStatusesOrderBy>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Query_RootEventCourtStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtStatusesOrderBy>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Query_RootEventCourtStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Query_RootEventCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Query_RootEventCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventFaqsArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Query_RootEventFaqsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Query_RootEventFaqsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGameScoresArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Query_RootEventGameScoresAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Query_RootEventGameScoresByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupFormatsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupFormatsOrderBy>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Query_RootEventGroupFormatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupFormatsOrderBy>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Query_RootEventGroupFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventGroupPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Query_RootEventGroupPoolsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Query_RootEventGroupPoolsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupRegistrationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationStatusesOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Query_RootEventGroupRegistrationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationStatusesOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Query_RootEventGroupRegistrationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventGroupRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Query_RootEventGroupRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Query_RootEventGroupRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupSequenceSeedingArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Query_RootEventGroupSequenceSeedingAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Query_RootEventGroupSequenceSeedingByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupSequencesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Query_RootEventGroupSequencesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Query_RootEventGroupSequencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventGroupsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Query_RootEventGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Query_RootEventGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventInvitationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationStatusesOrderBy>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Query_RootEventInvitationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationStatusesOrderBy>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Query_RootEventInvitationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Query_RootEventInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Query_RootEventInvitationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventListingFeesArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Query_RootEventListingFeesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Query_RootEventListingFeesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventMatchGamesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Query_RootEventMatchGamesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Query_RootEventMatchGamesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Query_RootEventMatchesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Query_RootEventMatchesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventMatchesTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Query_RootEventMatchesTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Query_RootEventMatchesTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventOrganizerAccountTypesArgs = {
  distinctOn?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventOrganizerAccountTypesOrderBy>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Query_RootEventOrganizerAccountTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventOrganizerAccountTypesOrderBy>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Query_RootEventOrganizerAccountTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventPoolRoundsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Query_RootEventPoolRoundsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Query_RootEventPoolRoundsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventPoolsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Query_RootEventPoolsTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Query_RootEventPoolsTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventPrivacyArgs = {
  distinctOn?: InputMaybe<Array<EventPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPrivacyOrderBy>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Query_RootEventPrivacyAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPrivacyOrderBy>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Query_RootEventPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventRegistrationDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationDetailsOrderBy>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Query_RootEventRegistrationDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationDetailsOrderBy>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Query_RootEventRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Query_RootEventRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Query_RootEventRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventSequenceCompleteReasonsArgs = {
  distinctOn?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSequenceCompleteReasonsOrderBy>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Query_RootEventSequenceCompleteReasonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSequenceCompleteReasonsOrderBy>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Query_RootEventSequenceCompleteReasonsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventSponsorsArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Query_RootEventSponsorsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Query_RootEventSponsorsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventStatusesOrderBy>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Query_RootEventStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventStatusesOrderBy>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Query_RootEventStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventTeamMemberStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMemberStatusesOrderBy>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Query_RootEventTeamMemberStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMemberStatusesOrderBy>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Query_RootEventTeamMemberStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventTeamMembersArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Query_RootEventTeamMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Query_RootEventTeamMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Query_RootEventTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Query_RootEventTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTransactionItemTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemTypesOrderBy>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Query_RootEventTransactionItemTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemTypesOrderBy>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Query_RootEventTransactionItemTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Query_RootEventTransactionItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Query_RootEventTransactionItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTransactionsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Query_RootEventTransactionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Query_RootEventTransactionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEventTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTypesOrderBy>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Query_RootEventTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTypesOrderBy>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Query_RootEventTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootEventsArgs = {
  distinctOn?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Query_RootEventsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Query_RootEventsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootFollowStatusesArgs = {
  distinctOn?: InputMaybe<Array<FollowStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FollowStatusesOrderBy>>;
  where?: InputMaybe<FollowStatusesBoolExp>;
};


export type Query_RootFollowStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FollowStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FollowStatusesOrderBy>>;
  where?: InputMaybe<FollowStatusesBoolExp>;
};


export type Query_RootFollowStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootGenderArgs = {
  distinctOn?: InputMaybe<Array<GenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GenderOrderBy>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Query_RootGenderAggregateArgs = {
  distinctOn?: InputMaybe<Array<GenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GenderOrderBy>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Query_RootGenderByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootGroupCommentVotesArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Query_RootGroupCommentVotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Query_RootGroupCommentVotesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupMembersArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Query_RootGroupMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Query_RootGroupMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupThreadCommentFilesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Query_RootGroupThreadCommentFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Query_RootGroupThreadCommentFilesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupThreadCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Query_RootGroupThreadCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Query_RootGroupThreadCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupThreadsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Query_RootGroupThreadsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Query_RootGroupThreadsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupVenuesArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Query_RootGroupVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Query_RootGroupVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Query_RootGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Query_RootGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Query_RootGroupsPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Query_RootGroupsPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonEquipmentArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Query_RootLessonEquipmentAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Query_RootLessonEquipmentByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonEquipmentOptionsArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOptionsOrderBy>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Query_RootLessonEquipmentOptionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOptionsOrderBy>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Query_RootLessonEquipmentOptionsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonOrderItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Query_RootLessonOrderItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Query_RootLessonOrderItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonOrdersArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Query_RootLessonOrdersAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Query_RootLessonOrdersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantStatusesOrderBy>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Query_RootLessonParticipantStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantStatusesOrderBy>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Query_RootLessonParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonParticipantsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Query_RootLessonParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Query_RootLessonParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonPrivacyArgs = {
  distinctOn?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonPrivacyOrderBy>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Query_RootLessonPrivacyAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonPrivacyOrderBy>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Query_RootLessonPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonStatusesOrderBy>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Query_RootLessonStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonStatusesOrderBy>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Query_RootLessonStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonTemplatesArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Query_RootLessonTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Query_RootLessonTemplatesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonTimesArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Query_RootLessonTimesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Query_RootLessonTimesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonTypesArgs = {
  distinctOn?: InputMaybe<Array<LessonTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTypesOrderBy>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Query_RootLessonTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTypesOrderBy>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Query_RootLessonTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonWaitlistStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistStatusesOrderBy>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Query_RootLessonWaitlistStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistStatusesOrderBy>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Query_RootLessonWaitlistStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootLessonWaitlistsArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Query_RootLessonWaitlistsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Query_RootLessonWaitlistsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Query_RootLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Query_RootLessonsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootMatchSelectionCriteriaArgs = {
  distinctOn?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MatchSelectionCriteriaOrderBy>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Query_RootMatchSelectionCriteriaAggregateArgs = {
  distinctOn?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MatchSelectionCriteriaOrderBy>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Query_RootMatchSelectionCriteriaByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootNotificationActionTypesArgs = {
  distinctOn?: InputMaybe<Array<NotificationActionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationActionTypesOrderBy>>;
  where?: InputMaybe<NotificationActionTypesBoolExp>;
};


export type Query_RootNotificationActionTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationActionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationActionTypesOrderBy>>;
  where?: InputMaybe<NotificationActionTypesBoolExp>;
};


export type Query_RootNotificationActionTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootNotificationStatusesArgs = {
  distinctOn?: InputMaybe<Array<NotificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationStatusesOrderBy>>;
  where?: InputMaybe<NotificationStatusesBoolExp>;
};


export type Query_RootNotificationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationStatusesOrderBy>>;
  where?: InputMaybe<NotificationStatusesBoolExp>;
};


export type Query_RootNotificationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootOrderStatusesArgs = {
  distinctOn?: InputMaybe<Array<OrderStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrderStatusesOrderBy>>;
  where?: InputMaybe<OrderStatusesBoolExp>;
};


export type Query_RootOrderStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<OrderStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrderStatusesOrderBy>>;
  where?: InputMaybe<OrderStatusesBoolExp>;
};


export type Query_RootOrderStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPaymentFulfillmentChannelsArgs = {
  distinctOn?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentFulfillmentChannelsOrderBy>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Query_RootPaymentFulfillmentChannelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentFulfillmentChannelsOrderBy>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Query_RootPaymentFulfillmentChannelsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPaymentProcessorsArgs = {
  distinctOn?: InputMaybe<Array<PaymentProcessorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentProcessorsOrderBy>>;
  where?: InputMaybe<PaymentProcessorsBoolExp>;
};


export type Query_RootPaymentProcessorsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PaymentProcessorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentProcessorsOrderBy>>;
  where?: InputMaybe<PaymentProcessorsBoolExp>;
};


export type Query_RootPaymentProcessorsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPickleballRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PickleballRatingScalesOrderBy>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Query_RootPickleballRatingScalesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PickleballRatingScalesOrderBy>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Query_RootPickleballRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlaySessionCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Query_RootPlaySessionCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Query_RootPlaySessionCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlaySessionCourtBookingStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCourtBookingStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Query_RootPlaySessionCourtBookingStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCourtBookingStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Query_RootPlaySessionCourtBookingStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionFormatsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionFormatsOrderBy>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Query_RootPlaySessionFormatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionFormatsOrderBy>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Query_RootPlaySessionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionMatchCompetitivenessArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionMatchCompetitivenessOrderBy>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Query_RootPlaySessionMatchCompetitivenessAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionMatchCompetitivenessOrderBy>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Query_RootPlaySessionMatchCompetitivenessByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Query_RootPlaySessionParticipantStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Query_RootPlaySessionParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionParticipantsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Query_RootPlaySessionParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Query_RootPlaySessionParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlaySessionPrivacyArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionPrivacyOrderBy>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Query_RootPlaySessionPrivacyAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionPrivacyOrderBy>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Query_RootPlaySessionPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Query_RootPlaySessionStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Query_RootPlaySessionStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Query_RootPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Query_RootPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootScoringFormatArgs = {
  distinctOn?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ScoringFormatOrderBy>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Query_RootScoringFormatAggregateArgs = {
  distinctOn?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ScoringFormatOrderBy>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Query_RootScoringFormatByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootSignupRequestsArgs = {
  distinctOn?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SignupRequestsOrderBy>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Query_RootSignupRequestsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SignupRequestsOrderBy>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Query_RootSignupRequestsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSkillLevelsArgs = {
  distinctOn?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkillLevelsOrderBy>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Query_RootSkillLevelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkillLevelsOrderBy>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Query_RootSkillLevelsByPkArgs = {
  id: Scalars['String'];
};


export type Query_RootSportsArgs = {
  distinctOn?: InputMaybe<Array<SportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SportsOrderBy>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Query_RootSportsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SportsOrderBy>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Query_RootSportsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootStripeChargesArgs = {
  distinctOn?: InputMaybe<Array<StripeChargesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripeChargesOrderBy>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};


export type Query_RootStripeChargesAggregateArgs = {
  distinctOn?: InputMaybe<Array<StripeChargesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripeChargesOrderBy>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};


export type Query_RootStripeChargesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootStripePaymentIntentsArgs = {
  distinctOn?: InputMaybe<Array<StripePaymentIntentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripePaymentIntentsOrderBy>>;
  where?: InputMaybe<StripePaymentIntentsBoolExp>;
};


export type Query_RootStripePaymentIntentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<StripePaymentIntentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripePaymentIntentsOrderBy>>;
  where?: InputMaybe<StripePaymentIntentsBoolExp>;
};


export type Query_RootStripePaymentIntentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootTeamTypesArgs = {
  distinctOn?: InputMaybe<Array<TeamTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TeamTypesOrderBy>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Query_RootTeamTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TeamTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TeamTypesOrderBy>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Query_RootTeamTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootTennisRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TennisRatingScalesOrderBy>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Query_RootTennisRatingScalesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TennisRatingScalesOrderBy>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Query_RootTennisRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserAuthIdentitiesArgs = {
  distinctOn?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserAuthIdentitiesOrderBy>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


export type Query_RootUserAuthIdentitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserAuthIdentitiesOrderBy>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


export type Query_RootUserAuthIdentitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Query_RootUserCoachServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Query_RootUserCoachServicesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCommunicationPreferencesArgs = {
  distinctOn?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCommunicationPreferencesOrderBy>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Query_RootUserCommunicationPreferencesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCommunicationPreferencesOrderBy>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Query_RootUserCommunicationPreferencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCreditCardsArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Query_RootUserCreditCardsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Query_RootUserCreditCardsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserCustomCourtsArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Query_RootUserCustomCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Query_RootUserCustomCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserFollowsArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Query_RootUserFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Query_RootUserFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserImageLogArgs = {
  distinctOn?: InputMaybe<Array<UserImageLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserImageLogOrderBy>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Query_RootUserImageLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserImageLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserImageLogOrderBy>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Query_RootUserImageLogByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserNotificationDetailsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationDetailsOrderBy>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Query_RootUserNotificationDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationDetailsOrderBy>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Query_RootUserNotificationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserNotificationEntitiesArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationEntitiesOrderBy>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Query_RootUserNotificationEntitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationEntitiesOrderBy>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Query_RootUserNotificationEntitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Query_RootUserNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Query_RootUserNotificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserProfilesArgs = {
  distinctOn?: InputMaybe<Array<UserProfilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserProfilesOrderBy>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Query_RootUserProfilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserProfilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserProfilesOrderBy>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Query_RootUserRegistrationDetailsArgs = {
  distinctOn?: InputMaybe<Array<UserRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserRegistrationDetailsOrderBy>>;
  where?: InputMaybe<UserRegistrationDetailsBoolExp>;
};


export type Query_RootUserRegistrationDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserRegistrationDetailsOrderBy>>;
  where?: InputMaybe<UserRegistrationDetailsBoolExp>;
};


export type Query_RootUserRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUserTermsOfServiceArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Query_RootUserTermsOfServiceAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Query_RootUserTermsOfServiceByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsernameLogsArgs = {
  distinctOn?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernameLogsOrderBy>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


export type Query_RootUsernameLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernameLogsOrderBy>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


export type Query_RootUsernameLogsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsernamesActiveArgs = {
  distinctOn?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesActiveOrderBy>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Query_RootUsernamesActiveAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesActiveOrderBy>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Query_RootUsernamesClaimedArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Query_RootUsernamesClaimedAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Query_RootUsernamesClaimedByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsersCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Query_RootUsersCoachQualificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Query_RootUsersCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueAccessTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAccessTypesOrderBy>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Query_RootVenueAccessTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAccessTypesOrderBy>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Query_RootVenueAccessTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenueAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Query_RootVenueAmenitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Query_RootVenueAmenitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Query_RootVenueCourtSurfacesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Query_RootVenueCourtSurfacesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueFacilityTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFacilityTypesOrderBy>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Query_RootVenueFacilityTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFacilityTypesOrderBy>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Query_RootVenueFacilityTypesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenueFollowsArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Query_RootVenueFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Query_RootVenueFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueImagesArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Query_RootVenueImagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Query_RootVenueImagesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVenueLinesArgs = {
  distinctOn?: InputMaybe<Array<VenueLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueLinesOrderBy>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Query_RootVenueLinesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueLinesOrderBy>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Query_RootVenueLinesByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenueNetsArgs = {
  distinctOn?: InputMaybe<Array<VenueNetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueNetsOrderBy>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Query_RootVenueNetsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueNetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueNetsOrderBy>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Query_RootVenueNetsByPkArgs = {
  value: Scalars['String'];
};


export type Query_RootVenuesArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Query_RootVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Query_RootVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWelcomeEmailConfigurationArgs = {
  distinctOn?: InputMaybe<Array<WelcomeEmailConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WelcomeEmailConfigurationOrderBy>>;
  where?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
};


export type Query_RootWelcomeEmailConfigurationAggregateArgs = {
  distinctOn?: InputMaybe<Array<WelcomeEmailConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WelcomeEmailConfigurationOrderBy>>;
  where?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
};


export type Query_RootWelcomeEmailConfigurationByPkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWinReasonsArgs = {
  distinctOn?: InputMaybe<Array<WinReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WinReasonsOrderBy>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};


export type Query_RootWinReasonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<WinReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WinReasonsOrderBy>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};


export type Query_RootWinReasonsByPkArgs = {
  value: Scalars['String'];
};

export type St_D_Within_Geography_Input = {
  distance: Scalars['Float'];
  from: Scalars['geography'];
  use_spheroid?: InputMaybe<Scalars['Boolean']>;
};

export type St_D_Within_Input = {
  distance: Scalars['Float'];
  from: Scalars['geometry'];
};

export type StripeChargesAggregateBoolExpBool_And = {
  arguments: StripeChargesSelectColumnStripeChargesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StripeChargesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type StripeChargesAggregateBoolExpBool_Or = {
  arguments: StripeChargesSelectColumnStripeChargesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StripeChargesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type StripeChargesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StripeChargesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StripeChargesBoolExp>;
  predicate: IntComparisonExp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "amenities" */
  amenities: Array<Amenities>;
  /** fetch aggregated fields from the table: "amenities" */
  amenitiesAggregate: AmenitiesAggregate;
  /** fetch data from the table: "amenities" using primary key columns */
  amenitiesByPk?: Maybe<Amenities>;
  /** fetch data from the table in a streaming manner: "amenities" */
  amenitiesStream: Array<Amenities>;
  /** fetch data from the table: "app_personas" */
  appPersonas: Array<AppPersonas>;
  /** fetch aggregated fields from the table: "app_personas" */
  appPersonasAggregate: AppPersonasAggregate;
  /** fetch data from the table: "app_personas" using primary key columns */
  appPersonasByPk?: Maybe<AppPersonas>;
  /** fetch data from the table in a streaming manner: "app_personas" */
  appPersonasStream: Array<AppPersonas>;
  /** fetch data from the table: "app_pings" */
  appPings: Array<AppPings>;
  /** fetch aggregated fields from the table: "app_pings" */
  appPingsAggregate: AppPingsAggregate;
  /** fetch data from the table: "app_pings" using primary key columns */
  appPingsByPk?: Maybe<AppPings>;
  /** fetch data from the table in a streaming manner: "app_pings" */
  appPingsStream: Array<AppPings>;
  /** fetch data from the table: "ball_types" */
  ballTypes: Array<BallTypes>;
  /** fetch aggregated fields from the table: "ball_types" */
  ballTypesAggregate: BallTypesAggregate;
  /** fetch data from the table: "ball_types" using primary key columns */
  ballTypesByPk?: Maybe<BallTypes>;
  /** fetch data from the table in a streaming manner: "ball_types" */
  ballTypesStream: Array<BallTypes>;
  /** An array relationship */
  cities: Array<Cities>;
  /** An aggregate relationship */
  citiesAggregate: CitiesAggregate;
  /** fetch data from the table: "cities" using primary key columns */
  citiesByPk?: Maybe<Cities>;
  /** fetch data from the table in a streaming manner: "cities" */
  citiesStream: Array<Cities>;
  /** fetch data from the table: "coach_qualification_groups" */
  coachQualificationGroups: Array<CoachQualificationGroups>;
  /** fetch aggregated fields from the table: "coach_qualification_groups" */
  coachQualificationGroupsAggregate: CoachQualificationGroupsAggregate;
  /** fetch data from the table: "coach_qualification_groups" using primary key columns */
  coachQualificationGroupsByPk?: Maybe<CoachQualificationGroups>;
  /** fetch data from the table in a streaming manner: "coach_qualification_groups" */
  coachQualificationGroupsStream: Array<CoachQualificationGroups>;
  /** fetch data from the table: "coach_qualification_statuses" */
  coachQualificationStatuses: Array<CoachQualificationStatuses>;
  /** fetch aggregated fields from the table: "coach_qualification_statuses" */
  coachQualificationStatusesAggregate: CoachQualificationStatusesAggregate;
  /** fetch data from the table: "coach_qualification_statuses" using primary key columns */
  coachQualificationStatusesByPk?: Maybe<CoachQualificationStatuses>;
  /** fetch data from the table in a streaming manner: "coach_qualification_statuses" */
  coachQualificationStatusesStream: Array<CoachQualificationStatuses>;
  /** fetch data from the table: "coach_qualifications" */
  coachQualifications: Array<CoachQualifications>;
  /** fetch aggregated fields from the table: "coach_qualifications" */
  coachQualificationsAggregate: CoachQualificationsAggregate;
  /** fetch data from the table: "coach_qualifications" using primary key columns */
  coachQualificationsByPk?: Maybe<CoachQualifications>;
  /** fetch data from the table in a streaming manner: "coach_qualifications" */
  coachQualificationsStream: Array<CoachQualifications>;
  /** fetch data from the table: "coach_status" */
  coachStatus: Array<CoachStatus>;
  /** fetch aggregated fields from the table: "coach_status" */
  coachStatusAggregate: CoachStatusAggregate;
  /** fetch data from the table: "coach_status" using primary key columns */
  coachStatusByPk?: Maybe<CoachStatus>;
  /** fetch data from the table in a streaming manner: "coach_status" */
  coachStatusStream: Array<CoachStatus>;
  /** fetch data from the table: "comment_vote" */
  commentVote: Array<CommentVote>;
  /** fetch aggregated fields from the table: "comment_vote" */
  commentVoteAggregate: CommentVoteAggregate;
  /** fetch data from the table: "comment_vote" using primary key columns */
  commentVoteByPk?: Maybe<CommentVote>;
  /** fetch data from the table in a streaming manner: "comment_vote" */
  commentVoteStream: Array<CommentVote>;
  /** fetch data from the table: "communication_preference_statuses" */
  communicationPreferenceStatuses: Array<CommunicationPreferenceStatuses>;
  /** fetch aggregated fields from the table: "communication_preference_statuses" */
  communicationPreferenceStatusesAggregate: CommunicationPreferenceStatusesAggregate;
  /** fetch data from the table: "communication_preference_statuses" using primary key columns */
  communicationPreferenceStatusesByPk?: Maybe<CommunicationPreferenceStatuses>;
  /** fetch data from the table in a streaming manner: "communication_preference_statuses" */
  communicationPreferenceStatusesStream: Array<CommunicationPreferenceStatuses>;
  /** fetch data from the table: "competition_formats" */
  competitionFormats: Array<CompetitionFormats>;
  /** fetch aggregated fields from the table: "competition_formats" */
  competitionFormatsAggregate: CompetitionFormatsAggregate;
  /** fetch data from the table: "competition_formats" using primary key columns */
  competitionFormatsByPk?: Maybe<CompetitionFormats>;
  /** fetch data from the table in a streaming manner: "competition_formats" */
  competitionFormatsStream: Array<CompetitionFormats>;
  /** fetch data from the table: "competition_gender" */
  competitionGender: Array<CompetitionGender>;
  /** fetch aggregated fields from the table: "competition_gender" */
  competitionGenderAggregate: CompetitionGenderAggregate;
  /** fetch data from the table: "competition_gender" using primary key columns */
  competitionGenderByPk?: Maybe<CompetitionGender>;
  /** fetch data from the table in a streaming manner: "competition_gender" */
  competitionGenderStream: Array<CompetitionGender>;
  /** fetch data from the table: "countries" */
  countries: Array<Countries>;
  /** fetch aggregated fields from the table: "countries" */
  countriesAggregate: CountriesAggregate;
  /** fetch data from the table: "countries" using primary key columns */
  countriesByPk?: Maybe<Countries>;
  /** fetch data from the table in a streaming manner: "countries" */
  countriesStream: Array<Countries>;
  /** fetch data from the table: "country_subdivisions" */
  countrySubdivisions: Array<CountrySubdivisions>;
  /** fetch aggregated fields from the table: "country_subdivisions" */
  countrySubdivisionsAggregate: CountrySubdivisionsAggregate;
  /** fetch data from the table: "country_subdivisions" using primary key columns */
  countrySubdivisionsByPk?: Maybe<CountrySubdivisions>;
  /** fetch data from the table in a streaming manner: "country_subdivisions" */
  countrySubdivisionsStream: Array<CountrySubdivisions>;
  /** fetch data from the table: "court_surfaces" */
  courtSurfaces: Array<CourtSurfaces>;
  /** fetch aggregated fields from the table: "court_surfaces" */
  courtSurfacesAggregate: CourtSurfacesAggregate;
  /** fetch data from the table: "court_surfaces" using primary key columns */
  courtSurfacesByPk?: Maybe<CourtSurfaces>;
  /** fetch data from the table in a streaming manner: "court_surfaces" */
  courtSurfacesStream: Array<CourtSurfaces>;
  /** fetch data from the table: "event_contact_details" */
  eventContactDetails: Array<EventContactDetails>;
  /** fetch aggregated fields from the table: "event_contact_details" */
  eventContactDetailsAggregate: EventContactDetailsAggregate;
  /** fetch data from the table: "event_contact_details" using primary key columns */
  eventContactDetailsByPk?: Maybe<EventContactDetails>;
  /** fetch data from the table in a streaming manner: "event_contact_details" */
  eventContactDetailsStream: Array<EventContactDetails>;
  /** fetch data from the table: "event_court_statuses" */
  eventCourtStatuses: Array<EventCourtStatuses>;
  /** fetch aggregated fields from the table: "event_court_statuses" */
  eventCourtStatusesAggregate: EventCourtStatusesAggregate;
  /** fetch data from the table: "event_court_statuses" using primary key columns */
  eventCourtStatusesByPk?: Maybe<EventCourtStatuses>;
  /** fetch data from the table in a streaming manner: "event_court_statuses" */
  eventCourtStatusesStream: Array<EventCourtStatuses>;
  /** fetch data from the table: "event_courts" */
  eventCourts: Array<EventCourts>;
  /** fetch aggregated fields from the table: "event_courts" */
  eventCourtsAggregate: EventCourtsAggregate;
  /** fetch data from the table: "event_courts" using primary key columns */
  eventCourtsByPk?: Maybe<EventCourts>;
  /** fetch data from the table in a streaming manner: "event_courts" */
  eventCourtsStream: Array<EventCourts>;
  /** fetch data from the table: "event_faqs" */
  eventFaqs: Array<EventFaqs>;
  /** fetch aggregated fields from the table: "event_faqs" */
  eventFaqsAggregate: EventFaqsAggregate;
  /** fetch data from the table: "event_faqs" using primary key columns */
  eventFaqsByPk?: Maybe<EventFaqs>;
  /** fetch data from the table in a streaming manner: "event_faqs" */
  eventFaqsStream: Array<EventFaqs>;
  /** fetch data from the table: "event_game_scores" */
  eventGameScores: Array<EventGameScores>;
  /** fetch aggregated fields from the table: "event_game_scores" */
  eventGameScoresAggregate: EventGameScoresAggregate;
  /** fetch data from the table: "event_game_scores" using primary key columns */
  eventGameScoresByPk?: Maybe<EventGameScores>;
  /** fetch data from the table in a streaming manner: "event_game_scores" */
  eventGameScoresStream: Array<EventGameScores>;
  /** fetch data from the table: "event_group_formats" */
  eventGroupFormats: Array<EventGroupFormats>;
  /** fetch aggregated fields from the table: "event_group_formats" */
  eventGroupFormatsAggregate: EventGroupFormatsAggregate;
  /** fetch data from the table: "event_group_formats" using primary key columns */
  eventGroupFormatsByPk?: Maybe<EventGroupFormats>;
  /** fetch data from the table in a streaming manner: "event_group_formats" */
  eventGroupFormatsStream: Array<EventGroupFormats>;
  /** fetch data from the table: "event_group_pools" */
  eventGroupPools: Array<EventGroupPools>;
  /** fetch aggregated fields from the table: "event_group_pools" */
  eventGroupPoolsAggregate: EventGroupPoolsAggregate;
  /** fetch data from the table: "event_group_pools" using primary key columns */
  eventGroupPoolsByPk?: Maybe<EventGroupPools>;
  /** fetch data from the table in a streaming manner: "event_group_pools" */
  eventGroupPoolsStream: Array<EventGroupPools>;
  /** fetch data from the table: "event_group_registration_statuses" */
  eventGroupRegistrationStatuses: Array<EventGroupRegistrationStatuses>;
  /** fetch aggregated fields from the table: "event_group_registration_statuses" */
  eventGroupRegistrationStatusesAggregate: EventGroupRegistrationStatusesAggregate;
  /** fetch data from the table: "event_group_registration_statuses" using primary key columns */
  eventGroupRegistrationStatusesByPk?: Maybe<EventGroupRegistrationStatuses>;
  /** fetch data from the table in a streaming manner: "event_group_registration_statuses" */
  eventGroupRegistrationStatusesStream: Array<EventGroupRegistrationStatuses>;
  /** fetch data from the table: "event_group_registrations" */
  eventGroupRegistrations: Array<EventGroupRegistrations>;
  /** fetch aggregated fields from the table: "event_group_registrations" */
  eventGroupRegistrationsAggregate: EventGroupRegistrationsAggregate;
  /** fetch data from the table: "event_group_registrations" using primary key columns */
  eventGroupRegistrationsByPk?: Maybe<EventGroupRegistrations>;
  /** fetch data from the table in a streaming manner: "event_group_registrations" */
  eventGroupRegistrationsStream: Array<EventGroupRegistrations>;
  /** fetch data from the table: "event_group_sequence_seeding" */
  eventGroupSequenceSeeding: Array<EventGroupSequenceSeeding>;
  /** fetch aggregated fields from the table: "event_group_sequence_seeding" */
  eventGroupSequenceSeedingAggregate: EventGroupSequenceSeedingAggregate;
  /** fetch data from the table: "event_group_sequence_seeding" using primary key columns */
  eventGroupSequenceSeedingByPk?: Maybe<EventGroupSequenceSeeding>;
  /** fetch data from the table in a streaming manner: "event_group_sequence_seeding" */
  eventGroupSequenceSeedingStream: Array<EventGroupSequenceSeeding>;
  /** fetch data from the table: "event_group_sequences" */
  eventGroupSequences: Array<EventGroupSequences>;
  /** fetch aggregated fields from the table: "event_group_sequences" */
  eventGroupSequencesAggregate: EventGroupSequencesAggregate;
  /** fetch data from the table: "event_group_sequences" using primary key columns */
  eventGroupSequencesByPk?: Maybe<EventGroupSequences>;
  /** fetch data from the table in a streaming manner: "event_group_sequences" */
  eventGroupSequencesStream: Array<EventGroupSequences>;
  /** fetch data from the table: "event_groups" */
  eventGroups: Array<EventGroups>;
  /** fetch aggregated fields from the table: "event_groups" */
  eventGroupsAggregate: EventGroupsAggregate;
  /** fetch data from the table: "event_groups" using primary key columns */
  eventGroupsByPk?: Maybe<EventGroups>;
  /** fetch data from the table in a streaming manner: "event_groups" */
  eventGroupsStream: Array<EventGroups>;
  /** fetch data from the table: "event_invitation_statuses" */
  eventInvitationStatuses: Array<EventInvitationStatuses>;
  /** fetch aggregated fields from the table: "event_invitation_statuses" */
  eventInvitationStatusesAggregate: EventInvitationStatusesAggregate;
  /** fetch data from the table: "event_invitation_statuses" using primary key columns */
  eventInvitationStatusesByPk?: Maybe<EventInvitationStatuses>;
  /** fetch data from the table in a streaming manner: "event_invitation_statuses" */
  eventInvitationStatusesStream: Array<EventInvitationStatuses>;
  /** fetch data from the table: "event_invitations" */
  eventInvitations: Array<EventInvitations>;
  /** fetch aggregated fields from the table: "event_invitations" */
  eventInvitationsAggregate: EventInvitationsAggregate;
  /** fetch data from the table: "event_invitations" using primary key columns */
  eventInvitationsByPk?: Maybe<EventInvitations>;
  /** fetch data from the table in a streaming manner: "event_invitations" */
  eventInvitationsStream: Array<EventInvitations>;
  /** fetch data from the table: "event_listing_fees" */
  eventListingFees: Array<EventListingFees>;
  /** fetch aggregated fields from the table: "event_listing_fees" */
  eventListingFeesAggregate: EventListingFeesAggregate;
  /** fetch data from the table: "event_listing_fees" using primary key columns */
  eventListingFeesByPk?: Maybe<EventListingFees>;
  /** fetch data from the table in a streaming manner: "event_listing_fees" */
  eventListingFeesStream: Array<EventListingFees>;
  /** fetch data from the table: "event_match_games" */
  eventMatchGames: Array<EventMatchGames>;
  /** fetch aggregated fields from the table: "event_match_games" */
  eventMatchGamesAggregate: EventMatchGamesAggregate;
  /** fetch data from the table: "event_match_games" using primary key columns */
  eventMatchGamesByPk?: Maybe<EventMatchGames>;
  /** fetch data from the table in a streaming manner: "event_match_games" */
  eventMatchGamesStream: Array<EventMatchGames>;
  /** fetch data from the table: "event_matches" */
  eventMatches: Array<EventMatches>;
  /** fetch aggregated fields from the table: "event_matches" */
  eventMatchesAggregate: EventMatchesAggregate;
  /** fetch data from the table: "event_matches" using primary key columns */
  eventMatchesByPk?: Maybe<EventMatches>;
  /** fetch data from the table in a streaming manner: "event_matches" */
  eventMatchesStream: Array<EventMatches>;
  /** fetch data from the table: "event_matches_teams" */
  eventMatchesTeams: Array<EventMatchesTeams>;
  /** fetch aggregated fields from the table: "event_matches_teams" */
  eventMatchesTeamsAggregate: EventMatchesTeamsAggregate;
  /** fetch data from the table: "event_matches_teams" using primary key columns */
  eventMatchesTeamsByPk?: Maybe<EventMatchesTeams>;
  /** fetch data from the table in a streaming manner: "event_matches_teams" */
  eventMatchesTeamsStream: Array<EventMatchesTeams>;
  /** fetch data from the table: "event_organizer_account_types" */
  eventOrganizerAccountTypes: Array<EventOrganizerAccountTypes>;
  /** fetch aggregated fields from the table: "event_organizer_account_types" */
  eventOrganizerAccountTypesAggregate: EventOrganizerAccountTypesAggregate;
  /** fetch data from the table: "event_organizer_account_types" using primary key columns */
  eventOrganizerAccountTypesByPk?: Maybe<EventOrganizerAccountTypes>;
  /** fetch data from the table in a streaming manner: "event_organizer_account_types" */
  eventOrganizerAccountTypesStream: Array<EventOrganizerAccountTypes>;
  /** fetch data from the table: "event_pool_rounds" */
  eventPoolRounds: Array<EventPoolRounds>;
  /** fetch aggregated fields from the table: "event_pool_rounds" */
  eventPoolRoundsAggregate: EventPoolRoundsAggregate;
  /** fetch data from the table: "event_pool_rounds" using primary key columns */
  eventPoolRoundsByPk?: Maybe<EventPoolRounds>;
  /** fetch data from the table in a streaming manner: "event_pool_rounds" */
  eventPoolRoundsStream: Array<EventPoolRounds>;
  /** fetch data from the table: "event_pools_teams" */
  eventPoolsTeams: Array<EventPoolsTeams>;
  /** fetch aggregated fields from the table: "event_pools_teams" */
  eventPoolsTeamsAggregate: EventPoolsTeamsAggregate;
  /** fetch data from the table: "event_pools_teams" using primary key columns */
  eventPoolsTeamsByPk?: Maybe<EventPoolsTeams>;
  /** fetch data from the table in a streaming manner: "event_pools_teams" */
  eventPoolsTeamsStream: Array<EventPoolsTeams>;
  /** fetch data from the table: "event_privacy" */
  eventPrivacy: Array<EventPrivacy>;
  /** fetch aggregated fields from the table: "event_privacy" */
  eventPrivacyAggregate: EventPrivacyAggregate;
  /** fetch data from the table: "event_privacy" using primary key columns */
  eventPrivacyByPk?: Maybe<EventPrivacy>;
  /** fetch data from the table in a streaming manner: "event_privacy" */
  eventPrivacyStream: Array<EventPrivacy>;
  /** fetch data from the table: "event_registration_details" */
  eventRegistrationDetails: Array<EventRegistrationDetails>;
  /** fetch aggregated fields from the table: "event_registration_details" */
  eventRegistrationDetailsAggregate: EventRegistrationDetailsAggregate;
  /** fetch data from the table: "event_registration_details" using primary key columns */
  eventRegistrationDetailsByPk?: Maybe<EventRegistrationDetails>;
  /** fetch data from the table in a streaming manner: "event_registration_details" */
  eventRegistrationDetailsStream: Array<EventRegistrationDetails>;
  /** fetch data from the table: "event_registrations" */
  eventRegistrations: Array<EventRegistrations>;
  /** fetch aggregated fields from the table: "event_registrations" */
  eventRegistrationsAggregate: EventRegistrationsAggregate;
  /** fetch data from the table: "event_registrations" using primary key columns */
  eventRegistrationsByPk?: Maybe<EventRegistrations>;
  /** fetch data from the table in a streaming manner: "event_registrations" */
  eventRegistrationsStream: Array<EventRegistrations>;
  /** fetch data from the table: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasons: Array<EventSequenceCompleteReasons>;
  /** fetch aggregated fields from the table: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasonsAggregate: EventSequenceCompleteReasonsAggregate;
  /** fetch data from the table: "event_sequence_complete_reasons" using primary key columns */
  eventSequenceCompleteReasonsByPk?: Maybe<EventSequenceCompleteReasons>;
  /** fetch data from the table in a streaming manner: "event_sequence_complete_reasons" */
  eventSequenceCompleteReasonsStream: Array<EventSequenceCompleteReasons>;
  /** fetch data from the table: "event_sponsors" */
  eventSponsors: Array<EventSponsors>;
  /** fetch aggregated fields from the table: "event_sponsors" */
  eventSponsorsAggregate: EventSponsorsAggregate;
  /** fetch data from the table: "event_sponsors" using primary key columns */
  eventSponsorsByPk?: Maybe<EventSponsors>;
  /** fetch data from the table in a streaming manner: "event_sponsors" */
  eventSponsorsStream: Array<EventSponsors>;
  /** fetch data from the table: "event_statuses" */
  eventStatuses: Array<EventStatuses>;
  /** fetch aggregated fields from the table: "event_statuses" */
  eventStatusesAggregate: EventStatusesAggregate;
  /** fetch data from the table: "event_statuses" using primary key columns */
  eventStatusesByPk?: Maybe<EventStatuses>;
  /** fetch data from the table in a streaming manner: "event_statuses" */
  eventStatusesStream: Array<EventStatuses>;
  /** fetch data from the table: "event_team_member_statuses" */
  eventTeamMemberStatuses: Array<EventTeamMemberStatuses>;
  /** fetch aggregated fields from the table: "event_team_member_statuses" */
  eventTeamMemberStatusesAggregate: EventTeamMemberStatusesAggregate;
  /** fetch data from the table: "event_team_member_statuses" using primary key columns */
  eventTeamMemberStatusesByPk?: Maybe<EventTeamMemberStatuses>;
  /** fetch data from the table in a streaming manner: "event_team_member_statuses" */
  eventTeamMemberStatusesStream: Array<EventTeamMemberStatuses>;
  /** fetch data from the table: "event_team_members" */
  eventTeamMembers: Array<EventTeamMembers>;
  /** fetch aggregated fields from the table: "event_team_members" */
  eventTeamMembersAggregate: EventTeamMembersAggregate;
  /** fetch data from the table: "event_team_members" using primary key columns */
  eventTeamMembersByPk?: Maybe<EventTeamMembers>;
  /** fetch data from the table in a streaming manner: "event_team_members" */
  eventTeamMembersStream: Array<EventTeamMembers>;
  /** fetch data from the table: "event_teams" */
  eventTeams: Array<EventTeams>;
  /** fetch aggregated fields from the table: "event_teams" */
  eventTeamsAggregate: EventTeamsAggregate;
  /** fetch data from the table: "event_teams" using primary key columns */
  eventTeamsByPk?: Maybe<EventTeams>;
  /** fetch data from the table in a streaming manner: "event_teams" */
  eventTeamsStream: Array<EventTeams>;
  /** fetch data from the table: "event_transaction_item_types" */
  eventTransactionItemTypes: Array<EventTransactionItemTypes>;
  /** fetch aggregated fields from the table: "event_transaction_item_types" */
  eventTransactionItemTypesAggregate: EventTransactionItemTypesAggregate;
  /** fetch data from the table: "event_transaction_item_types" using primary key columns */
  eventTransactionItemTypesByPk?: Maybe<EventTransactionItemTypes>;
  /** fetch data from the table in a streaming manner: "event_transaction_item_types" */
  eventTransactionItemTypesStream: Array<EventTransactionItemTypes>;
  /** fetch data from the table: "event_transaction_items" */
  eventTransactionItems: Array<EventTransactionItems>;
  /** fetch aggregated fields from the table: "event_transaction_items" */
  eventTransactionItemsAggregate: EventTransactionItemsAggregate;
  /** fetch data from the table: "event_transaction_items" using primary key columns */
  eventTransactionItemsByPk?: Maybe<EventTransactionItems>;
  /** fetch data from the table in a streaming manner: "event_transaction_items" */
  eventTransactionItemsStream: Array<EventTransactionItems>;
  /** fetch data from the table: "event_transactions" */
  eventTransactions: Array<EventTransactions>;
  /** fetch aggregated fields from the table: "event_transactions" */
  eventTransactionsAggregate: EventTransactionsAggregate;
  /** fetch data from the table: "event_transactions" using primary key columns */
  eventTransactionsByPk?: Maybe<EventTransactions>;
  /** fetch data from the table in a streaming manner: "event_transactions" */
  eventTransactionsStream: Array<EventTransactions>;
  /** fetch data from the table: "event_types" */
  eventTypes: Array<EventTypes>;
  /** fetch aggregated fields from the table: "event_types" */
  eventTypesAggregate: EventTypesAggregate;
  /** fetch data from the table: "event_types" using primary key columns */
  eventTypesByPk?: Maybe<EventTypes>;
  /** fetch data from the table in a streaming manner: "event_types" */
  eventTypesStream: Array<EventTypes>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  eventsAggregate: EventsAggregate;
  /** fetch data from the table: "events" using primary key columns */
  eventsByPk?: Maybe<Events>;
  /** fetch data from the table in a streaming manner: "events" */
  eventsStream: Array<Events>;
  /** fetch data from the table: "follow_statuses" */
  followStatuses: Array<FollowStatuses>;
  /** fetch aggregated fields from the table: "follow_statuses" */
  followStatusesAggregate: FollowStatusesAggregate;
  /** fetch data from the table: "follow_statuses" using primary key columns */
  followStatusesByPk?: Maybe<FollowStatuses>;
  /** fetch data from the table in a streaming manner: "follow_statuses" */
  followStatusesStream: Array<FollowStatuses>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch aggregated fields from the table: "gender" */
  genderAggregate: GenderAggregate;
  /** fetch data from the table: "gender" using primary key columns */
  genderByPk?: Maybe<Gender>;
  /** fetch data from the table in a streaming manner: "gender" */
  genderStream: Array<Gender>;
  /** fetch data from the table: "group_comment_votes" */
  groupCommentVotes: Array<GroupCommentVotes>;
  /** fetch aggregated fields from the table: "group_comment_votes" */
  groupCommentVotesAggregate: GroupCommentVotesAggregate;
  /** fetch data from the table: "group_comment_votes" using primary key columns */
  groupCommentVotesByPk?: Maybe<GroupCommentVotes>;
  /** fetch data from the table in a streaming manner: "group_comment_votes" */
  groupCommentVotesStream: Array<GroupCommentVotes>;
  /** fetch data from the table: "group_members" */
  groupMembers: Array<GroupMembers>;
  /** fetch aggregated fields from the table: "group_members" */
  groupMembersAggregate: GroupMembersAggregate;
  /** fetch data from the table: "group_members" using primary key columns */
  groupMembersByPk?: Maybe<GroupMembers>;
  /** fetch data from the table in a streaming manner: "group_members" */
  groupMembersStream: Array<GroupMembers>;
  /** fetch data from the table: "group_thread_comment_files" */
  groupThreadCommentFiles: Array<GroupThreadCommentFiles>;
  /** fetch aggregated fields from the table: "group_thread_comment_files" */
  groupThreadCommentFilesAggregate: GroupThreadCommentFilesAggregate;
  /** fetch data from the table: "group_thread_comment_files" using primary key columns */
  groupThreadCommentFilesByPk?: Maybe<GroupThreadCommentFiles>;
  /** fetch data from the table in a streaming manner: "group_thread_comment_files" */
  groupThreadCommentFilesStream: Array<GroupThreadCommentFiles>;
  /** fetch data from the table: "group_thread_comments" */
  groupThreadComments: Array<GroupThreadComments>;
  /** fetch aggregated fields from the table: "group_thread_comments" */
  groupThreadCommentsAggregate: GroupThreadCommentsAggregate;
  /** fetch data from the table: "group_thread_comments" using primary key columns */
  groupThreadCommentsByPk?: Maybe<GroupThreadComments>;
  /** fetch data from the table in a streaming manner: "group_thread_comments" */
  groupThreadCommentsStream: Array<GroupThreadComments>;
  /** fetch data from the table: "group_threads" */
  groupThreads: Array<GroupThreads>;
  /** fetch aggregated fields from the table: "group_threads" */
  groupThreadsAggregate: GroupThreadsAggregate;
  /** fetch data from the table: "group_threads" using primary key columns */
  groupThreadsByPk?: Maybe<GroupThreads>;
  /** fetch data from the table in a streaming manner: "group_threads" */
  groupThreadsStream: Array<GroupThreads>;
  /** fetch data from the table: "group_venues" */
  groupVenues: Array<GroupVenues>;
  /** fetch aggregated fields from the table: "group_venues" */
  groupVenuesAggregate: GroupVenuesAggregate;
  /** fetch data from the table: "group_venues" using primary key columns */
  groupVenuesByPk?: Maybe<GroupVenues>;
  /** fetch data from the table in a streaming manner: "group_venues" */
  groupVenuesStream: Array<GroupVenues>;
  /** An array relationship */
  groups: Array<Groups>;
  /** An aggregate relationship */
  groupsAggregate: GroupsAggregate;
  /** fetch data from the table: "groups" using primary key columns */
  groupsByPk?: Maybe<Groups>;
  /** An array relationship */
  groupsPlaySessions: Array<GroupsPlaySessions>;
  /** An aggregate relationship */
  groupsPlaySessionsAggregate: GroupsPlaySessionsAggregate;
  /** fetch data from the table: "groups_play_sessions" using primary key columns */
  groupsPlaySessionsByPk?: Maybe<GroupsPlaySessions>;
  /** fetch data from the table in a streaming manner: "groups_play_sessions" */
  groupsPlaySessionsStream: Array<GroupsPlaySessions>;
  /** fetch data from the table in a streaming manner: "groups" */
  groupsStream: Array<Groups>;
  /** fetch data from the table: "lesson_equipment" */
  lessonEquipment: Array<LessonEquipment>;
  /** fetch aggregated fields from the table: "lesson_equipment" */
  lessonEquipmentAggregate: LessonEquipmentAggregate;
  /** fetch data from the table: "lesson_equipment" using primary key columns */
  lessonEquipmentByPk?: Maybe<LessonEquipment>;
  /** fetch data from the table: "lesson_equipment_options" */
  lessonEquipmentOptions: Array<LessonEquipmentOptions>;
  /** fetch aggregated fields from the table: "lesson_equipment_options" */
  lessonEquipmentOptionsAggregate: LessonEquipmentOptionsAggregate;
  /** fetch data from the table: "lesson_equipment_options" using primary key columns */
  lessonEquipmentOptionsByPk?: Maybe<LessonEquipmentOptions>;
  /** fetch data from the table in a streaming manner: "lesson_equipment_options" */
  lessonEquipmentOptionsStream: Array<LessonEquipmentOptions>;
  /** fetch data from the table in a streaming manner: "lesson_equipment" */
  lessonEquipmentStream: Array<LessonEquipment>;
  /** fetch data from the table: "lesson_order_items" */
  lessonOrderItems: Array<LessonOrderItems>;
  /** fetch aggregated fields from the table: "lesson_order_items" */
  lessonOrderItemsAggregate: LessonOrderItemsAggregate;
  /** fetch data from the table: "lesson_order_items" using primary key columns */
  lessonOrderItemsByPk?: Maybe<LessonOrderItems>;
  /** fetch data from the table in a streaming manner: "lesson_order_items" */
  lessonOrderItemsStream: Array<LessonOrderItems>;
  /** fetch data from the table: "lesson_orders" */
  lessonOrders: Array<LessonOrders>;
  /** fetch aggregated fields from the table: "lesson_orders" */
  lessonOrdersAggregate: LessonOrdersAggregate;
  /** fetch data from the table: "lesson_orders" using primary key columns */
  lessonOrdersByPk?: Maybe<LessonOrders>;
  /** fetch data from the table in a streaming manner: "lesson_orders" */
  lessonOrdersStream: Array<LessonOrders>;
  /** fetch data from the table: "lesson_participant_statuses" */
  lessonParticipantStatuses: Array<LessonParticipantStatuses>;
  /** fetch aggregated fields from the table: "lesson_participant_statuses" */
  lessonParticipantStatusesAggregate: LessonParticipantStatusesAggregate;
  /** fetch data from the table: "lesson_participant_statuses" using primary key columns */
  lessonParticipantStatusesByPk?: Maybe<LessonParticipantStatuses>;
  /** fetch data from the table in a streaming manner: "lesson_participant_statuses" */
  lessonParticipantStatusesStream: Array<LessonParticipantStatuses>;
  /** fetch data from the table: "lesson_participants" */
  lessonParticipants: Array<LessonParticipants>;
  /** fetch aggregated fields from the table: "lesson_participants" */
  lessonParticipantsAggregate: LessonParticipantsAggregate;
  /** fetch data from the table: "lesson_participants" using primary key columns */
  lessonParticipantsByPk?: Maybe<LessonParticipants>;
  /** fetch data from the table in a streaming manner: "lesson_participants" */
  lessonParticipantsStream: Array<LessonParticipants>;
  /** fetch data from the table: "lesson_privacy" */
  lessonPrivacy: Array<LessonPrivacy>;
  /** fetch aggregated fields from the table: "lesson_privacy" */
  lessonPrivacyAggregate: LessonPrivacyAggregate;
  /** fetch data from the table: "lesson_privacy" using primary key columns */
  lessonPrivacyByPk?: Maybe<LessonPrivacy>;
  /** fetch data from the table in a streaming manner: "lesson_privacy" */
  lessonPrivacyStream: Array<LessonPrivacy>;
  /** fetch data from the table: "lesson_statuses" */
  lessonStatuses: Array<LessonStatuses>;
  /** fetch aggregated fields from the table: "lesson_statuses" */
  lessonStatusesAggregate: LessonStatusesAggregate;
  /** fetch data from the table: "lesson_statuses" using primary key columns */
  lessonStatusesByPk?: Maybe<LessonStatuses>;
  /** fetch data from the table in a streaming manner: "lesson_statuses" */
  lessonStatusesStream: Array<LessonStatuses>;
  /** An array relationship */
  lessonTemplates: Array<LessonTemplates>;
  /** An aggregate relationship */
  lessonTemplatesAggregate: LessonTemplatesAggregate;
  /** fetch data from the table: "lesson_templates" using primary key columns */
  lessonTemplatesByPk?: Maybe<LessonTemplates>;
  /** fetch data from the table in a streaming manner: "lesson_templates" */
  lessonTemplatesStream: Array<LessonTemplates>;
  /** fetch data from the table: "lesson_times" */
  lessonTimes: Array<LessonTimes>;
  /** fetch aggregated fields from the table: "lesson_times" */
  lessonTimesAggregate: LessonTimesAggregate;
  /** fetch data from the table: "lesson_times" using primary key columns */
  lessonTimesByPk?: Maybe<LessonTimes>;
  /** fetch data from the table in a streaming manner: "lesson_times" */
  lessonTimesStream: Array<LessonTimes>;
  /** fetch data from the table: "lesson_types" */
  lessonTypes: Array<LessonTypes>;
  /** fetch aggregated fields from the table: "lesson_types" */
  lessonTypesAggregate: LessonTypesAggregate;
  /** fetch data from the table: "lesson_types" using primary key columns */
  lessonTypesByPk?: Maybe<LessonTypes>;
  /** fetch data from the table in a streaming manner: "lesson_types" */
  lessonTypesStream: Array<LessonTypes>;
  /** fetch data from the table: "lesson_waitlist_statuses" */
  lessonWaitlistStatuses: Array<LessonWaitlistStatuses>;
  /** fetch aggregated fields from the table: "lesson_waitlist_statuses" */
  lessonWaitlistStatusesAggregate: LessonWaitlistStatusesAggregate;
  /** fetch data from the table: "lesson_waitlist_statuses" using primary key columns */
  lessonWaitlistStatusesByPk?: Maybe<LessonWaitlistStatuses>;
  /** fetch data from the table in a streaming manner: "lesson_waitlist_statuses" */
  lessonWaitlistStatusesStream: Array<LessonWaitlistStatuses>;
  /** fetch data from the table: "lesson_waitlists" */
  lessonWaitlists: Array<LessonWaitlists>;
  /** fetch aggregated fields from the table: "lesson_waitlists" */
  lessonWaitlistsAggregate: LessonWaitlistsAggregate;
  /** fetch data from the table: "lesson_waitlists" using primary key columns */
  lessonWaitlistsByPk?: Maybe<LessonWaitlists>;
  /** fetch data from the table in a streaming manner: "lesson_waitlists" */
  lessonWaitlistsStream: Array<LessonWaitlists>;
  /** An array relationship */
  lessons: Array<Lessons>;
  /** An aggregate relationship */
  lessonsAggregate: LessonsAggregate;
  /** fetch data from the table: "lessons" using primary key columns */
  lessonsByPk?: Maybe<Lessons>;
  /** fetch data from the table in a streaming manner: "lessons" */
  lessonsStream: Array<Lessons>;
  /** fetch data from the table: "match_selection_criteria" */
  matchSelectionCriteria: Array<MatchSelectionCriteria>;
  /** fetch aggregated fields from the table: "match_selection_criteria" */
  matchSelectionCriteriaAggregate: MatchSelectionCriteriaAggregate;
  /** fetch data from the table: "match_selection_criteria" using primary key columns */
  matchSelectionCriteriaByPk?: Maybe<MatchSelectionCriteria>;
  /** fetch data from the table in a streaming manner: "match_selection_criteria" */
  matchSelectionCriteriaStream: Array<MatchSelectionCriteria>;
  /** fetch data from the table: "notification_action_types" */
  notificationActionTypes: Array<NotificationActionTypes>;
  /** fetch aggregated fields from the table: "notification_action_types" */
  notificationActionTypesAggregate: NotificationActionTypesAggregate;
  /** fetch data from the table: "notification_action_types" using primary key columns */
  notificationActionTypesByPk?: Maybe<NotificationActionTypes>;
  /** fetch data from the table in a streaming manner: "notification_action_types" */
  notificationActionTypesStream: Array<NotificationActionTypes>;
  /** fetch data from the table: "notification_statuses" */
  notificationStatuses: Array<NotificationStatuses>;
  /** fetch aggregated fields from the table: "notification_statuses" */
  notificationStatusesAggregate: NotificationStatusesAggregate;
  /** fetch data from the table: "notification_statuses" using primary key columns */
  notificationStatusesByPk?: Maybe<NotificationStatuses>;
  /** fetch data from the table in a streaming manner: "notification_statuses" */
  notificationStatusesStream: Array<NotificationStatuses>;
  /** fetch data from the table: "order_statuses" */
  orderStatuses: Array<OrderStatuses>;
  /** fetch aggregated fields from the table: "order_statuses" */
  orderStatusesAggregate: OrderStatusesAggregate;
  /** fetch data from the table: "order_statuses" using primary key columns */
  orderStatusesByPk?: Maybe<OrderStatuses>;
  /** fetch data from the table in a streaming manner: "order_statuses" */
  orderStatusesStream: Array<OrderStatuses>;
  /** fetch data from the table: "payment_fulfillment_channels" */
  paymentFulfillmentChannels: Array<PaymentFulfillmentChannels>;
  /** fetch aggregated fields from the table: "payment_fulfillment_channels" */
  paymentFulfillmentChannelsAggregate: PaymentFulfillmentChannelsAggregate;
  /** fetch data from the table: "payment_fulfillment_channels" using primary key columns */
  paymentFulfillmentChannelsByPk?: Maybe<PaymentFulfillmentChannels>;
  /** fetch data from the table in a streaming manner: "payment_fulfillment_channels" */
  paymentFulfillmentChannelsStream: Array<PaymentFulfillmentChannels>;
  /** fetch data from the table: "payment_processors" */
  paymentProcessors: Array<PaymentProcessors>;
  /** fetch aggregated fields from the table: "payment_processors" */
  paymentProcessorsAggregate: PaymentProcessorsAggregate;
  /** fetch data from the table: "payment_processors" using primary key columns */
  paymentProcessorsByPk?: Maybe<PaymentProcessors>;
  /** fetch data from the table in a streaming manner: "payment_processors" */
  paymentProcessorsStream: Array<PaymentProcessors>;
  /** fetch data from the table: "pickleball_rating_scales" */
  pickleballRatingScales: Array<PickleballRatingScales>;
  /** fetch aggregated fields from the table: "pickleball_rating_scales" */
  pickleballRatingScalesAggregate: PickleballRatingScalesAggregate;
  /** fetch data from the table: "pickleball_rating_scales" using primary key columns */
  pickleballRatingScalesByPk?: Maybe<PickleballRatingScales>;
  /** fetch data from the table in a streaming manner: "pickleball_rating_scales" */
  pickleballRatingScalesStream: Array<PickleballRatingScales>;
  /** fetch data from the table: "play_session_comments" */
  playSessionComments: Array<PlaySessionComments>;
  /** fetch aggregated fields from the table: "play_session_comments" */
  playSessionCommentsAggregate: PlaySessionCommentsAggregate;
  /** fetch data from the table: "play_session_comments" using primary key columns */
  playSessionCommentsByPk?: Maybe<PlaySessionComments>;
  /** fetch data from the table in a streaming manner: "play_session_comments" */
  playSessionCommentsStream: Array<PlaySessionComments>;
  /** fetch data from the table: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatuses: Array<PlaySessionCourtBookingStatuses>;
  /** fetch aggregated fields from the table: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatusesAggregate: PlaySessionCourtBookingStatusesAggregate;
  /** fetch data from the table: "play_session_court_booking_statuses" using primary key columns */
  playSessionCourtBookingStatusesByPk?: Maybe<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table in a streaming manner: "play_session_court_booking_statuses" */
  playSessionCourtBookingStatusesStream: Array<PlaySessionCourtBookingStatuses>;
  /** fetch data from the table: "play_session_formats" */
  playSessionFormats: Array<PlaySessionFormats>;
  /** fetch aggregated fields from the table: "play_session_formats" */
  playSessionFormatsAggregate: PlaySessionFormatsAggregate;
  /** fetch data from the table: "play_session_formats" using primary key columns */
  playSessionFormatsByPk?: Maybe<PlaySessionFormats>;
  /** fetch data from the table in a streaming manner: "play_session_formats" */
  playSessionFormatsStream: Array<PlaySessionFormats>;
  /** fetch data from the table: "play_session_match_competitiveness" */
  playSessionMatchCompetitiveness: Array<PlaySessionMatchCompetitiveness>;
  /** fetch aggregated fields from the table: "play_session_match_competitiveness" */
  playSessionMatchCompetitivenessAggregate: PlaySessionMatchCompetitivenessAggregate;
  /** fetch data from the table: "play_session_match_competitiveness" using primary key columns */
  playSessionMatchCompetitivenessByPk?: Maybe<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table in a streaming manner: "play_session_match_competitiveness" */
  playSessionMatchCompetitivenessStream: Array<PlaySessionMatchCompetitiveness>;
  /** fetch data from the table: "play_session_participant_statuses" */
  playSessionParticipantStatuses: Array<PlaySessionParticipantStatuses>;
  /** fetch aggregated fields from the table: "play_session_participant_statuses" */
  playSessionParticipantStatusesAggregate: PlaySessionParticipantStatusesAggregate;
  /** fetch data from the table: "play_session_participant_statuses" using primary key columns */
  playSessionParticipantStatusesByPk?: Maybe<PlaySessionParticipantStatuses>;
  /** fetch data from the table in a streaming manner: "play_session_participant_statuses" */
  playSessionParticipantStatusesStream: Array<PlaySessionParticipantStatuses>;
  /** fetch data from the table: "play_session_participants" */
  playSessionParticipants: Array<PlaySessionParticipants>;
  /** fetch aggregated fields from the table: "play_session_participants" */
  playSessionParticipantsAggregate: PlaySessionParticipantsAggregate;
  /** fetch data from the table: "play_session_participants" using primary key columns */
  playSessionParticipantsByPk?: Maybe<PlaySessionParticipants>;
  /** fetch data from the table in a streaming manner: "play_session_participants" */
  playSessionParticipantsStream: Array<PlaySessionParticipants>;
  /** fetch data from the table: "play_session_privacy" */
  playSessionPrivacy: Array<PlaySessionPrivacy>;
  /** fetch aggregated fields from the table: "play_session_privacy" */
  playSessionPrivacyAggregate: PlaySessionPrivacyAggregate;
  /** fetch data from the table: "play_session_privacy" using primary key columns */
  playSessionPrivacyByPk?: Maybe<PlaySessionPrivacy>;
  /** fetch data from the table in a streaming manner: "play_session_privacy" */
  playSessionPrivacyStream: Array<PlaySessionPrivacy>;
  /** fetch data from the table: "play_session_statuses" */
  playSessionStatuses: Array<PlaySessionStatuses>;
  /** fetch aggregated fields from the table: "play_session_statuses" */
  playSessionStatusesAggregate: PlaySessionStatusesAggregate;
  /** fetch data from the table: "play_session_statuses" using primary key columns */
  playSessionStatusesByPk?: Maybe<PlaySessionStatuses>;
  /** fetch data from the table in a streaming manner: "play_session_statuses" */
  playSessionStatusesStream: Array<PlaySessionStatuses>;
  /** An array relationship */
  playSessions: Array<PlaySessions>;
  /** An aggregate relationship */
  playSessionsAggregate: PlaySessionsAggregate;
  /** fetch data from the table: "play_sessions" using primary key columns */
  playSessionsByPk?: Maybe<PlaySessions>;
  /** fetch data from the table in a streaming manner: "play_sessions" */
  playSessionsStream: Array<PlaySessions>;
  /** fetch data from the table: "scoring_format" */
  scoringFormat: Array<ScoringFormat>;
  /** fetch aggregated fields from the table: "scoring_format" */
  scoringFormatAggregate: ScoringFormatAggregate;
  /** fetch data from the table: "scoring_format" using primary key columns */
  scoringFormatByPk?: Maybe<ScoringFormat>;
  /** fetch data from the table in a streaming manner: "scoring_format" */
  scoringFormatStream: Array<ScoringFormat>;
  /** fetch data from the table: "signup_requests" */
  signupRequests: Array<SignupRequests>;
  /** fetch aggregated fields from the table: "signup_requests" */
  signupRequestsAggregate: SignupRequestsAggregate;
  /** fetch data from the table: "signup_requests" using primary key columns */
  signupRequestsByPk?: Maybe<SignupRequests>;
  /** fetch data from the table in a streaming manner: "signup_requests" */
  signupRequestsStream: Array<SignupRequests>;
  /** fetch data from the table: "skill_levels" */
  skillLevels: Array<SkillLevels>;
  /** fetch aggregated fields from the table: "skill_levels" */
  skillLevelsAggregate: SkillLevelsAggregate;
  /** fetch data from the table: "skill_levels" using primary key columns */
  skillLevelsByPk?: Maybe<SkillLevels>;
  /** fetch data from the table in a streaming manner: "skill_levels" */
  skillLevelsStream: Array<SkillLevels>;
  /** fetch data from the table: "sports" */
  sports: Array<Sports>;
  /** fetch aggregated fields from the table: "sports" */
  sportsAggregate: SportsAggregate;
  /** fetch data from the table: "sports" using primary key columns */
  sportsByPk?: Maybe<Sports>;
  /** fetch data from the table in a streaming manner: "sports" */
  sportsStream: Array<Sports>;
  /** An array relationship */
  stripeCharges: Array<StripeCharges>;
  /** An aggregate relationship */
  stripeChargesAggregate: StripeChargesAggregate;
  /** fetch data from the table: "stripe_charges" using primary key columns */
  stripeChargesByPk?: Maybe<StripeCharges>;
  /** fetch data from the table in a streaming manner: "stripe_charges" */
  stripeChargesStream: Array<StripeCharges>;
  /** fetch data from the table: "stripe_payment_intents" */
  stripePaymentIntents: Array<StripePaymentIntents>;
  /** fetch aggregated fields from the table: "stripe_payment_intents" */
  stripePaymentIntentsAggregate: StripePaymentIntentsAggregate;
  /** fetch data from the table: "stripe_payment_intents" using primary key columns */
  stripePaymentIntentsByPk?: Maybe<StripePaymentIntents>;
  /** fetch data from the table in a streaming manner: "stripe_payment_intents" */
  stripePaymentIntentsStream: Array<StripePaymentIntents>;
  /** fetch data from the table: "team_types" */
  teamTypes: Array<TeamTypes>;
  /** fetch aggregated fields from the table: "team_types" */
  teamTypesAggregate: TeamTypesAggregate;
  /** fetch data from the table: "team_types" using primary key columns */
  teamTypesByPk?: Maybe<TeamTypes>;
  /** fetch data from the table in a streaming manner: "team_types" */
  teamTypesStream: Array<TeamTypes>;
  /** fetch data from the table: "tennis_rating_scales" */
  tennisRatingScales: Array<TennisRatingScales>;
  /** fetch aggregated fields from the table: "tennis_rating_scales" */
  tennisRatingScalesAggregate: TennisRatingScalesAggregate;
  /** fetch data from the table: "tennis_rating_scales" using primary key columns */
  tennisRatingScalesByPk?: Maybe<TennisRatingScales>;
  /** fetch data from the table in a streaming manner: "tennis_rating_scales" */
  tennisRatingScalesStream: Array<TennisRatingScales>;
  /** fetch data from the table: "user_auth_identities" */
  userAuthIdentities: Array<UserAuthIdentities>;
  /** fetch aggregated fields from the table: "user_auth_identities" */
  userAuthIdentitiesAggregate: UserAuthIdentitiesAggregate;
  /** fetch data from the table: "user_auth_identities" using primary key columns */
  userAuthIdentitiesByPk?: Maybe<UserAuthIdentities>;
  /** fetch data from the table in a streaming manner: "user_auth_identities" */
  userAuthIdentitiesStream: Array<UserAuthIdentities>;
  /** fetch data from the table: "user_coach_services" */
  userCoachServices: Array<UserCoachServices>;
  /** fetch aggregated fields from the table: "user_coach_services" */
  userCoachServicesAggregate: UserCoachServicesAggregate;
  /** fetch data from the table: "user_coach_services" using primary key columns */
  userCoachServicesByPk?: Maybe<UserCoachServices>;
  /** fetch data from the table in a streaming manner: "user_coach_services" */
  userCoachServicesStream: Array<UserCoachServices>;
  /** fetch data from the table: "user_communication_preferences" */
  userCommunicationPreferences: Array<UserCommunicationPreferences>;
  /** fetch aggregated fields from the table: "user_communication_preferences" */
  userCommunicationPreferencesAggregate: UserCommunicationPreferencesAggregate;
  /** fetch data from the table: "user_communication_preferences" using primary key columns */
  userCommunicationPreferencesByPk?: Maybe<UserCommunicationPreferences>;
  /** fetch data from the table in a streaming manner: "user_communication_preferences" */
  userCommunicationPreferencesStream: Array<UserCommunicationPreferences>;
  /** fetch data from the table: "user_credit_cards" */
  userCreditCards: Array<UserCreditCards>;
  /** fetch aggregated fields from the table: "user_credit_cards" */
  userCreditCardsAggregate: UserCreditCardsAggregate;
  /** fetch data from the table: "user_credit_cards" using primary key columns */
  userCreditCardsByPk?: Maybe<UserCreditCards>;
  /** fetch data from the table in a streaming manner: "user_credit_cards" */
  userCreditCardsStream: Array<UserCreditCards>;
  /** fetch data from the table: "user_custom_courts" */
  userCustomCourts: Array<UserCustomCourts>;
  /** fetch aggregated fields from the table: "user_custom_courts" */
  userCustomCourtsAggregate: UserCustomCourtsAggregate;
  /** fetch data from the table: "user_custom_courts" using primary key columns */
  userCustomCourtsByPk?: Maybe<UserCustomCourts>;
  /** fetch data from the table in a streaming manner: "user_custom_courts" */
  userCustomCourtsStream: Array<UserCustomCourts>;
  /** fetch data from the table: "user_follows" */
  userFollows: Array<UserFollows>;
  /** fetch aggregated fields from the table: "user_follows" */
  userFollowsAggregate: UserFollowsAggregate;
  /** fetch data from the table: "user_follows" using primary key columns */
  userFollowsByPk?: Maybe<UserFollows>;
  /** fetch data from the table in a streaming manner: "user_follows" */
  userFollowsStream: Array<UserFollows>;
  /** fetch data from the table: "user_image_log" */
  userImageLog: Array<UserImageLog>;
  /** fetch aggregated fields from the table: "user_image_log" */
  userImageLogAggregate: UserImageLogAggregate;
  /** fetch data from the table: "user_image_log" using primary key columns */
  userImageLogByPk?: Maybe<UserImageLog>;
  /** fetch data from the table in a streaming manner: "user_image_log" */
  userImageLogStream: Array<UserImageLog>;
  /** fetch data from the table: "user_notification_details" */
  userNotificationDetails: Array<UserNotificationDetails>;
  /** fetch aggregated fields from the table: "user_notification_details" */
  userNotificationDetailsAggregate: UserNotificationDetailsAggregate;
  /** fetch data from the table: "user_notification_details" using primary key columns */
  userNotificationDetailsByPk?: Maybe<UserNotificationDetails>;
  /** fetch data from the table in a streaming manner: "user_notification_details" */
  userNotificationDetailsStream: Array<UserNotificationDetails>;
  /** fetch data from the table: "user_notification_entities" */
  userNotificationEntities: Array<UserNotificationEntities>;
  /** fetch aggregated fields from the table: "user_notification_entities" */
  userNotificationEntitiesAggregate: UserNotificationEntitiesAggregate;
  /** fetch data from the table: "user_notification_entities" using primary key columns */
  userNotificationEntitiesByPk?: Maybe<UserNotificationEntities>;
  /** fetch data from the table in a streaming manner: "user_notification_entities" */
  userNotificationEntitiesStream: Array<UserNotificationEntities>;
  /** An array relationship */
  userNotifications: Array<UserNotifications>;
  /** An aggregate relationship */
  userNotificationsAggregate: UserNotificationsAggregate;
  /** fetch data from the table: "user_notifications" using primary key columns */
  userNotificationsByPk?: Maybe<UserNotifications>;
  /** fetch data from the table in a streaming manner: "user_notifications" */
  userNotificationsStream: Array<UserNotifications>;
  /** fetch data from the table: "user_profiles" */
  userProfiles: Array<UserProfiles>;
  /** fetch aggregated fields from the table: "user_profiles" */
  userProfilesAggregate: UserProfilesAggregate;
  /** fetch data from the table in a streaming manner: "user_profiles" */
  userProfilesStream: Array<UserProfiles>;
  /** fetch data from the table: "user_registration_details" */
  userRegistrationDetails: Array<UserRegistrationDetails>;
  /** fetch aggregated fields from the table: "user_registration_details" */
  userRegistrationDetailsAggregate: UserRegistrationDetailsAggregate;
  /** fetch data from the table: "user_registration_details" using primary key columns */
  userRegistrationDetailsByPk?: Maybe<UserRegistrationDetails>;
  /** fetch data from the table in a streaming manner: "user_registration_details" */
  userRegistrationDetailsStream: Array<UserRegistrationDetails>;
  /** fetch data from the table: "user_terms_of_service" */
  userTermsOfService: Array<UserTermsOfService>;
  /** fetch aggregated fields from the table: "user_terms_of_service" */
  userTermsOfServiceAggregate: UserTermsOfServiceAggregate;
  /** fetch data from the table: "user_terms_of_service" using primary key columns */
  userTermsOfServiceByPk?: Maybe<UserTermsOfService>;
  /** fetch data from the table in a streaming manner: "user_terms_of_service" */
  userTermsOfServiceStream: Array<UserTermsOfService>;
  /** An array relationship */
  usernameLogs: Array<UsernameLogs>;
  /** An aggregate relationship */
  usernameLogsAggregate: UsernameLogsAggregate;
  /** fetch data from the table: "username_logs" using primary key columns */
  usernameLogsByPk?: Maybe<UsernameLogs>;
  /** fetch data from the table in a streaming manner: "username_logs" */
  usernameLogsStream: Array<UsernameLogs>;
  /** fetch data from the table: "usernames_active" */
  usernamesActive: Array<UsernamesActive>;
  /** fetch aggregated fields from the table: "usernames_active" */
  usernamesActiveAggregate: UsernamesActiveAggregate;
  /** fetch data from the table in a streaming manner: "usernames_active" */
  usernamesActiveStream: Array<UsernamesActive>;
  /** An array relationship */
  usernamesClaimed: Array<UsernamesClaimed>;
  /** An aggregate relationship */
  usernamesClaimedAggregate: UsernamesClaimedAggregate;
  /** fetch data from the table: "usernames_claimed" using primary key columns */
  usernamesClaimedByPk?: Maybe<UsernamesClaimed>;
  /** fetch data from the table in a streaming manner: "usernames_claimed" */
  usernamesClaimedStream: Array<UsernamesClaimed>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  usersAggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table: "users_coach_qualifications" */
  usersCoachQualifications: Array<UsersCoachQualifications>;
  /** fetch aggregated fields from the table: "users_coach_qualifications" */
  usersCoachQualificationsAggregate: UsersCoachQualificationsAggregate;
  /** fetch data from the table: "users_coach_qualifications" using primary key columns */
  usersCoachQualificationsByPk?: Maybe<UsersCoachQualifications>;
  /** fetch data from the table in a streaming manner: "users_coach_qualifications" */
  usersCoachQualificationsStream: Array<UsersCoachQualifications>;
  /** fetch data from the table in a streaming manner: "users" */
  usersStream: Array<Users>;
  /** fetch data from the table: "venue_access_types" */
  venueAccessTypes: Array<VenueAccessTypes>;
  /** fetch aggregated fields from the table: "venue_access_types" */
  venueAccessTypesAggregate: VenueAccessTypesAggregate;
  /** fetch data from the table: "venue_access_types" using primary key columns */
  venueAccessTypesByPk?: Maybe<VenueAccessTypes>;
  /** fetch data from the table in a streaming manner: "venue_access_types" */
  venueAccessTypesStream: Array<VenueAccessTypes>;
  /** fetch data from the table: "venue_amenities" */
  venueAmenities: Array<VenueAmenities>;
  /** fetch aggregated fields from the table: "venue_amenities" */
  venueAmenitiesAggregate: VenueAmenitiesAggregate;
  /** fetch data from the table: "venue_amenities" using primary key columns */
  venueAmenitiesByPk?: Maybe<VenueAmenities>;
  /** fetch data from the table in a streaming manner: "venue_amenities" */
  venueAmenitiesStream: Array<VenueAmenities>;
  /** fetch data from the table: "venue_court_surfaces" */
  venueCourtSurfaces: Array<VenueCourtSurfaces>;
  /** fetch aggregated fields from the table: "venue_court_surfaces" */
  venueCourtSurfacesAggregate: VenueCourtSurfacesAggregate;
  /** fetch data from the table: "venue_court_surfaces" using primary key columns */
  venueCourtSurfacesByPk?: Maybe<VenueCourtSurfaces>;
  /** fetch data from the table in a streaming manner: "venue_court_surfaces" */
  venueCourtSurfacesStream: Array<VenueCourtSurfaces>;
  /** fetch data from the table: "venue_facility_types" */
  venueFacilityTypes: Array<VenueFacilityTypes>;
  /** fetch aggregated fields from the table: "venue_facility_types" */
  venueFacilityTypesAggregate: VenueFacilityTypesAggregate;
  /** fetch data from the table: "venue_facility_types" using primary key columns */
  venueFacilityTypesByPk?: Maybe<VenueFacilityTypes>;
  /** fetch data from the table in a streaming manner: "venue_facility_types" */
  venueFacilityTypesStream: Array<VenueFacilityTypes>;
  /** fetch data from the table: "venue_follows" */
  venueFollows: Array<VenueFollows>;
  /** fetch aggregated fields from the table: "venue_follows" */
  venueFollowsAggregate: VenueFollowsAggregate;
  /** fetch data from the table: "venue_follows" using primary key columns */
  venueFollowsByPk?: Maybe<VenueFollows>;
  /** fetch data from the table in a streaming manner: "venue_follows" */
  venueFollowsStream: Array<VenueFollows>;
  /** fetch data from the table: "venue_images" */
  venueImages: Array<VenueImages>;
  /** fetch aggregated fields from the table: "venue_images" */
  venueImagesAggregate: VenueImagesAggregate;
  /** fetch data from the table: "venue_images" using primary key columns */
  venueImagesByPk?: Maybe<VenueImages>;
  /** fetch data from the table in a streaming manner: "venue_images" */
  venueImagesStream: Array<VenueImages>;
  /** fetch data from the table: "venue_lines" */
  venueLines: Array<VenueLines>;
  /** fetch aggregated fields from the table: "venue_lines" */
  venueLinesAggregate: VenueLinesAggregate;
  /** fetch data from the table: "venue_lines" using primary key columns */
  venueLinesByPk?: Maybe<VenueLines>;
  /** fetch data from the table in a streaming manner: "venue_lines" */
  venueLinesStream: Array<VenueLines>;
  /** fetch data from the table: "venue_nets" */
  venueNets: Array<VenueNets>;
  /** fetch aggregated fields from the table: "venue_nets" */
  venueNetsAggregate: VenueNetsAggregate;
  /** fetch data from the table: "venue_nets" using primary key columns */
  venueNetsByPk?: Maybe<VenueNets>;
  /** fetch data from the table in a streaming manner: "venue_nets" */
  venueNetsStream: Array<VenueNets>;
  /** An array relationship */
  venues: Array<Venues>;
  /** An aggregate relationship */
  venuesAggregate: VenuesAggregate;
  /** fetch data from the table: "venues" using primary key columns */
  venuesByPk?: Maybe<Venues>;
  /** fetch data from the table in a streaming manner: "venues" */
  venuesStream: Array<Venues>;
  /** fetch data from the table: "welcome_email_configuration" */
  welcomeEmailConfiguration: Array<WelcomeEmailConfiguration>;
  /** fetch aggregated fields from the table: "welcome_email_configuration" */
  welcomeEmailConfigurationAggregate: WelcomeEmailConfigurationAggregate;
  /** fetch data from the table: "welcome_email_configuration" using primary key columns */
  welcomeEmailConfigurationByPk?: Maybe<WelcomeEmailConfiguration>;
  /** fetch data from the table in a streaming manner: "welcome_email_configuration" */
  welcomeEmailConfigurationStream: Array<WelcomeEmailConfiguration>;
  /** fetch data from the table: "win_reasons" */
  winReasons: Array<WinReasons>;
  /** fetch aggregated fields from the table: "win_reasons" */
  winReasonsAggregate: WinReasonsAggregate;
  /** fetch data from the table: "win_reasons" using primary key columns */
  winReasonsByPk?: Maybe<WinReasons>;
  /** fetch data from the table in a streaming manner: "win_reasons" */
  winReasonsStream: Array<WinReasons>;
};


export type Subscription_RootAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<AmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AmenitiesOrderBy>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Subscription_RootAmenitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AmenitiesOrderBy>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Subscription_RootAmenitiesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootAmenitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<AmenitiesStreamCursorInput>>;
  where?: InputMaybe<AmenitiesBoolExp>;
};


export type Subscription_RootAppPersonasArgs = {
  distinctOn?: InputMaybe<Array<AppPersonasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPersonasOrderBy>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Subscription_RootAppPersonasAggregateArgs = {
  distinctOn?: InputMaybe<Array<AppPersonasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPersonasOrderBy>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Subscription_RootAppPersonasByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootAppPersonasStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<AppPersonasStreamCursorInput>>;
  where?: InputMaybe<AppPersonasBoolExp>;
};


export type Subscription_RootAppPingsArgs = {
  distinctOn?: InputMaybe<Array<AppPingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPingsOrderBy>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Subscription_RootAppPingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AppPingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AppPingsOrderBy>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Subscription_RootAppPingsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAppPingsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<AppPingsStreamCursorInput>>;
  where?: InputMaybe<AppPingsBoolExp>;
};


export type Subscription_RootBallTypesArgs = {
  distinctOn?: InputMaybe<Array<BallTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BallTypesOrderBy>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Subscription_RootBallTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<BallTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BallTypesOrderBy>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Subscription_RootBallTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootBallTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<BallTypesStreamCursorInput>>;
  where?: InputMaybe<BallTypesBoolExp>;
};


export type Subscription_RootCitiesArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Subscription_RootCitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Subscription_RootCitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CitiesStreamCursorInput>>;
  where?: InputMaybe<CitiesBoolExp>;
};


export type Subscription_RootCoachQualificationGroupsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationGroupsOrderBy>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Subscription_RootCoachQualificationGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationGroupsOrderBy>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Subscription_RootCoachQualificationGroupsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCoachQualificationGroupsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachQualificationGroupsStreamCursorInput>>;
  where?: InputMaybe<CoachQualificationGroupsBoolExp>;
};


export type Subscription_RootCoachQualificationStatusesArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationStatusesOrderBy>>;
  where?: InputMaybe<CoachQualificationStatusesBoolExp>;
};


export type Subscription_RootCoachQualificationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationStatusesOrderBy>>;
  where?: InputMaybe<CoachQualificationStatusesBoolExp>;
};


export type Subscription_RootCoachQualificationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCoachQualificationStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachQualificationStatusesStreamCursorInput>>;
  where?: InputMaybe<CoachQualificationStatusesBoolExp>;
};


export type Subscription_RootCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationsOrderBy>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Subscription_RootCoachQualificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachQualificationsOrderBy>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Subscription_RootCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCoachQualificationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachQualificationsStreamCursorInput>>;
  where?: InputMaybe<CoachQualificationsBoolExp>;
};


export type Subscription_RootCoachStatusArgs = {
  distinctOn?: InputMaybe<Array<CoachStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachStatusOrderBy>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Subscription_RootCoachStatusAggregateArgs = {
  distinctOn?: InputMaybe<Array<CoachStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CoachStatusOrderBy>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Subscription_RootCoachStatusByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCoachStatusStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CoachStatusStreamCursorInput>>;
  where?: InputMaybe<CoachStatusBoolExp>;
};


export type Subscription_RootCommentVoteArgs = {
  distinctOn?: InputMaybe<Array<CommentVoteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentVoteOrderBy>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Subscription_RootCommentVoteAggregateArgs = {
  distinctOn?: InputMaybe<Array<CommentVoteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentVoteOrderBy>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Subscription_RootCommentVoteByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCommentVoteStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CommentVoteStreamCursorInput>>;
  where?: InputMaybe<CommentVoteBoolExp>;
};


export type Subscription_RootCommunicationPreferenceStatusesArgs = {
  distinctOn?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommunicationPreferenceStatusesOrderBy>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Subscription_RootCommunicationPreferenceStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CommunicationPreferenceStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommunicationPreferenceStatusesOrderBy>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Subscription_RootCommunicationPreferenceStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCommunicationPreferenceStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CommunicationPreferenceStatusesStreamCursorInput>>;
  where?: InputMaybe<CommunicationPreferenceStatusesBoolExp>;
};


export type Subscription_RootCompetitionFormatsArgs = {
  distinctOn?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionFormatsOrderBy>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Subscription_RootCompetitionFormatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CompetitionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionFormatsOrderBy>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Subscription_RootCompetitionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCompetitionFormatsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CompetitionFormatsStreamCursorInput>>;
  where?: InputMaybe<CompetitionFormatsBoolExp>;
};


export type Subscription_RootCompetitionGenderArgs = {
  distinctOn?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionGenderOrderBy>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Subscription_RootCompetitionGenderAggregateArgs = {
  distinctOn?: InputMaybe<Array<CompetitionGenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CompetitionGenderOrderBy>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Subscription_RootCompetitionGenderByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCompetitionGenderStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CompetitionGenderStreamCursorInput>>;
  where?: InputMaybe<CompetitionGenderBoolExp>;
};


export type Subscription_RootCountriesArgs = {
  distinctOn?: InputMaybe<Array<CountriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Subscription_RootCountriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CountriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Subscription_RootCountriesByPkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootCountriesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CountriesStreamCursorInput>>;
  where?: InputMaybe<CountriesBoolExp>;
};


export type Subscription_RootCountrySubdivisionsArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Subscription_RootCountrySubdivisionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CountrySubdivisionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountrySubdivisionsOrderBy>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Subscription_RootCountrySubdivisionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCountrySubdivisionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CountrySubdivisionsStreamCursorInput>>;
  where?: InputMaybe<CountrySubdivisionsBoolExp>;
};


export type Subscription_RootCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CourtSurfacesOrderBy>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Subscription_RootCourtSurfacesAggregateArgs = {
  distinctOn?: InputMaybe<Array<CourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CourtSurfacesOrderBy>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Subscription_RootCourtSurfacesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootCourtSurfacesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<CourtSurfacesStreamCursorInput>>;
  where?: InputMaybe<CourtSurfacesBoolExp>;
};


export type Subscription_RootEventContactDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventContactDetailsOrderBy>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Subscription_RootEventContactDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventContactDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventContactDetailsOrderBy>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Subscription_RootEventContactDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventContactDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventContactDetailsStreamCursorInput>>;
  where?: InputMaybe<EventContactDetailsBoolExp>;
};


export type Subscription_RootEventCourtStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtStatusesOrderBy>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Subscription_RootEventCourtStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtStatusesOrderBy>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Subscription_RootEventCourtStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventCourtStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventCourtStatusesStreamCursorInput>>;
  where?: InputMaybe<EventCourtStatusesBoolExp>;
};


export type Subscription_RootEventCourtsArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Subscription_RootEventCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventCourtsOrderBy>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Subscription_RootEventCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventCourtsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventCourtsStreamCursorInput>>;
  where?: InputMaybe<EventCourtsBoolExp>;
};


export type Subscription_RootEventFaqsArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Subscription_RootEventFaqsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventFaqsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventFaqsOrderBy>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Subscription_RootEventFaqsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventFaqsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventFaqsStreamCursorInput>>;
  where?: InputMaybe<EventFaqsBoolExp>;
};


export type Subscription_RootEventGameScoresArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Subscription_RootEventGameScoresAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGameScoresSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGameScoresOrderBy>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Subscription_RootEventGameScoresByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGameScoresStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGameScoresStreamCursorInput>>;
  where?: InputMaybe<EventGameScoresBoolExp>;
};


export type Subscription_RootEventGroupFormatsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupFormatsOrderBy>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Subscription_RootEventGroupFormatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupFormatsOrderBy>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Subscription_RootEventGroupFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventGroupFormatsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupFormatsStreamCursorInput>>;
  where?: InputMaybe<EventGroupFormatsBoolExp>;
};


export type Subscription_RootEventGroupPoolsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Subscription_RootEventGroupPoolsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupPoolsOrderBy>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Subscription_RootEventGroupPoolsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupPoolsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupPoolsStreamCursorInput>>;
  where?: InputMaybe<EventGroupPoolsBoolExp>;
};


export type Subscription_RootEventGroupRegistrationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationStatusesOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Subscription_RootEventGroupRegistrationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationStatusesOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Subscription_RootEventGroupRegistrationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventGroupRegistrationStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupRegistrationStatusesStreamCursorInput>>;
  where?: InputMaybe<EventGroupRegistrationStatusesBoolExp>;
};


export type Subscription_RootEventGroupRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Subscription_RootEventGroupRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupRegistrationsOrderBy>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Subscription_RootEventGroupRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupRegistrationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupRegistrationsStreamCursorInput>>;
  where?: InputMaybe<EventGroupRegistrationsBoolExp>;
};


export type Subscription_RootEventGroupSequenceSeedingArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Subscription_RootEventGroupSequenceSeedingAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequenceSeedingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequenceSeedingOrderBy>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Subscription_RootEventGroupSequenceSeedingByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupSequenceSeedingStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupSequenceSeedingStreamCursorInput>>;
  where?: InputMaybe<EventGroupSequenceSeedingBoolExp>;
};


export type Subscription_RootEventGroupSequencesArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Subscription_RootEventGroupSequencesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupSequencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupSequencesOrderBy>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Subscription_RootEventGroupSequencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupSequencesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupSequencesStreamCursorInput>>;
  where?: InputMaybe<EventGroupSequencesBoolExp>;
};


export type Subscription_RootEventGroupsArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Subscription_RootEventGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventGroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventGroupsOrderBy>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Subscription_RootEventGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventGroupsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventGroupsStreamCursorInput>>;
  where?: InputMaybe<EventGroupsBoolExp>;
};


export type Subscription_RootEventInvitationStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationStatusesOrderBy>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Subscription_RootEventInvitationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationStatusesOrderBy>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Subscription_RootEventInvitationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventInvitationStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventInvitationStatusesStreamCursorInput>>;
  where?: InputMaybe<EventInvitationStatusesBoolExp>;
};


export type Subscription_RootEventInvitationsArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Subscription_RootEventInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventInvitationsOrderBy>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Subscription_RootEventInvitationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventInvitationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventInvitationsStreamCursorInput>>;
  where?: InputMaybe<EventInvitationsBoolExp>;
};


export type Subscription_RootEventListingFeesArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Subscription_RootEventListingFeesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventListingFeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventListingFeesOrderBy>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Subscription_RootEventListingFeesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventListingFeesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventListingFeesStreamCursorInput>>;
  where?: InputMaybe<EventListingFeesBoolExp>;
};


export type Subscription_RootEventMatchGamesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Subscription_RootEventMatchGamesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchGamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchGamesOrderBy>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Subscription_RootEventMatchGamesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventMatchGamesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventMatchGamesStreamCursorInput>>;
  where?: InputMaybe<EventMatchGamesBoolExp>;
};


export type Subscription_RootEventMatchesArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Subscription_RootEventMatchesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesOrderBy>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Subscription_RootEventMatchesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventMatchesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventMatchesStreamCursorInput>>;
  where?: InputMaybe<EventMatchesBoolExp>;
};


export type Subscription_RootEventMatchesTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Subscription_RootEventMatchesTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventMatchesTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventMatchesTeamsOrderBy>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Subscription_RootEventMatchesTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventMatchesTeamsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventMatchesTeamsStreamCursorInput>>;
  where?: InputMaybe<EventMatchesTeamsBoolExp>;
};


export type Subscription_RootEventOrganizerAccountTypesArgs = {
  distinctOn?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventOrganizerAccountTypesOrderBy>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Subscription_RootEventOrganizerAccountTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventOrganizerAccountTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventOrganizerAccountTypesOrderBy>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Subscription_RootEventOrganizerAccountTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventOrganizerAccountTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventOrganizerAccountTypesStreamCursorInput>>;
  where?: InputMaybe<EventOrganizerAccountTypesBoolExp>;
};


export type Subscription_RootEventPoolRoundsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Subscription_RootEventPoolRoundsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolRoundsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolRoundsOrderBy>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Subscription_RootEventPoolRoundsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventPoolRoundsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventPoolRoundsStreamCursorInput>>;
  where?: InputMaybe<EventPoolRoundsBoolExp>;
};


export type Subscription_RootEventPoolsTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Subscription_RootEventPoolsTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPoolsTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPoolsTeamsOrderBy>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Subscription_RootEventPoolsTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventPoolsTeamsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventPoolsTeamsStreamCursorInput>>;
  where?: InputMaybe<EventPoolsTeamsBoolExp>;
};


export type Subscription_RootEventPrivacyArgs = {
  distinctOn?: InputMaybe<Array<EventPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPrivacyOrderBy>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Subscription_RootEventPrivacyAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventPrivacyOrderBy>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Subscription_RootEventPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventPrivacyStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventPrivacyStreamCursorInput>>;
  where?: InputMaybe<EventPrivacyBoolExp>;
};


export type Subscription_RootEventRegistrationDetailsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationDetailsOrderBy>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Subscription_RootEventRegistrationDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationDetailsOrderBy>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Subscription_RootEventRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventRegistrationDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventRegistrationDetailsStreamCursorInput>>;
  where?: InputMaybe<EventRegistrationDetailsBoolExp>;
};


export type Subscription_RootEventRegistrationsArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Subscription_RootEventRegistrationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventRegistrationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventRegistrationsOrderBy>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Subscription_RootEventRegistrationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventRegistrationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventRegistrationsStreamCursorInput>>;
  where?: InputMaybe<EventRegistrationsBoolExp>;
};


export type Subscription_RootEventSequenceCompleteReasonsArgs = {
  distinctOn?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSequenceCompleteReasonsOrderBy>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Subscription_RootEventSequenceCompleteReasonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventSequenceCompleteReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSequenceCompleteReasonsOrderBy>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Subscription_RootEventSequenceCompleteReasonsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventSequenceCompleteReasonsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventSequenceCompleteReasonsStreamCursorInput>>;
  where?: InputMaybe<EventSequenceCompleteReasonsBoolExp>;
};


export type Subscription_RootEventSponsorsArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Subscription_RootEventSponsorsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventSponsorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventSponsorsOrderBy>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Subscription_RootEventSponsorsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventSponsorsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventSponsorsStreamCursorInput>>;
  where?: InputMaybe<EventSponsorsBoolExp>;
};


export type Subscription_RootEventStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventStatusesOrderBy>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Subscription_RootEventStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventStatusesOrderBy>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Subscription_RootEventStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventStatusesStreamCursorInput>>;
  where?: InputMaybe<EventStatusesBoolExp>;
};


export type Subscription_RootEventTeamMemberStatusesArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMemberStatusesOrderBy>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Subscription_RootEventTeamMemberStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMemberStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMemberStatusesOrderBy>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Subscription_RootEventTeamMemberStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventTeamMemberStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTeamMemberStatusesStreamCursorInput>>;
  where?: InputMaybe<EventTeamMemberStatusesBoolExp>;
};


export type Subscription_RootEventTeamMembersArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Subscription_RootEventTeamMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamMembersOrderBy>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Subscription_RootEventTeamMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTeamMembersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTeamMembersStreamCursorInput>>;
  where?: InputMaybe<EventTeamMembersBoolExp>;
};


export type Subscription_RootEventTeamsArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Subscription_RootEventTeamsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTeamsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTeamsOrderBy>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Subscription_RootEventTeamsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTeamsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTeamsStreamCursorInput>>;
  where?: InputMaybe<EventTeamsBoolExp>;
};


export type Subscription_RootEventTransactionItemTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemTypesOrderBy>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Subscription_RootEventTransactionItemTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemTypesOrderBy>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Subscription_RootEventTransactionItemTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventTransactionItemTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTransactionItemTypesStreamCursorInput>>;
  where?: InputMaybe<EventTransactionItemTypesBoolExp>;
};


export type Subscription_RootEventTransactionItemsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Subscription_RootEventTransactionItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionItemsOrderBy>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Subscription_RootEventTransactionItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTransactionItemsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTransactionItemsStreamCursorInput>>;
  where?: InputMaybe<EventTransactionItemsBoolExp>;
};


export type Subscription_RootEventTransactionsArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Subscription_RootEventTransactionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTransactionsOrderBy>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Subscription_RootEventTransactionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventTransactionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTransactionsStreamCursorInput>>;
  where?: InputMaybe<EventTransactionsBoolExp>;
};


export type Subscription_RootEventTypesArgs = {
  distinctOn?: InputMaybe<Array<EventTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTypesOrderBy>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Subscription_RootEventTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventTypesOrderBy>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Subscription_RootEventTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootEventTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventTypesStreamCursorInput>>;
  where?: InputMaybe<EventTypesBoolExp>;
};


export type Subscription_RootEventsArgs = {
  distinctOn?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Subscription_RootEventsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Subscription_RootEventsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootEventsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<EventsStreamCursorInput>>;
  where?: InputMaybe<EventsBoolExp>;
};


export type Subscription_RootFollowStatusesArgs = {
  distinctOn?: InputMaybe<Array<FollowStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FollowStatusesOrderBy>>;
  where?: InputMaybe<FollowStatusesBoolExp>;
};


export type Subscription_RootFollowStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FollowStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FollowStatusesOrderBy>>;
  where?: InputMaybe<FollowStatusesBoolExp>;
};


export type Subscription_RootFollowStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootFollowStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<FollowStatusesStreamCursorInput>>;
  where?: InputMaybe<FollowStatusesBoolExp>;
};


export type Subscription_RootGenderArgs = {
  distinctOn?: InputMaybe<Array<GenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GenderOrderBy>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Subscription_RootGenderAggregateArgs = {
  distinctOn?: InputMaybe<Array<GenderSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GenderOrderBy>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Subscription_RootGenderByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootGenderStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GenderStreamCursorInput>>;
  where?: InputMaybe<GenderBoolExp>;
};


export type Subscription_RootGroupCommentVotesArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Subscription_RootGroupCommentVotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupCommentVotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupCommentVotesOrderBy>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Subscription_RootGroupCommentVotesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupCommentVotesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupCommentVotesStreamCursorInput>>;
  where?: InputMaybe<GroupCommentVotesBoolExp>;
};


export type Subscription_RootGroupMembersArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Subscription_RootGroupMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupMembersOrderBy>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Subscription_RootGroupMembersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupMembersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupMembersStreamCursorInput>>;
  where?: InputMaybe<GroupMembersBoolExp>;
};


export type Subscription_RootGroupThreadCommentFilesArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Subscription_RootGroupThreadCommentFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentFilesOrderBy>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Subscription_RootGroupThreadCommentFilesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupThreadCommentFilesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupThreadCommentFilesStreamCursorInput>>;
  where?: InputMaybe<GroupThreadCommentFilesBoolExp>;
};


export type Subscription_RootGroupThreadCommentsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Subscription_RootGroupThreadCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadCommentsOrderBy>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Subscription_RootGroupThreadCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupThreadCommentsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupThreadCommentsStreamCursorInput>>;
  where?: InputMaybe<GroupThreadCommentsBoolExp>;
};


export type Subscription_RootGroupThreadsArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Subscription_RootGroupThreadsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupThreadsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupThreadsOrderBy>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Subscription_RootGroupThreadsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupThreadsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupThreadsStreamCursorInput>>;
  where?: InputMaybe<GroupThreadsBoolExp>;
};


export type Subscription_RootGroupVenuesArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Subscription_RootGroupVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupVenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupVenuesOrderBy>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Subscription_RootGroupVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupVenuesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupVenuesStreamCursorInput>>;
  where?: InputMaybe<GroupVenuesBoolExp>;
};


export type Subscription_RootGroupsArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Subscription_RootGroupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Subscription_RootGroupsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupsPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Subscription_RootGroupsPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<GroupsPlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GroupsPlaySessionsOrderBy>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Subscription_RootGroupsPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGroupsPlaySessionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupsPlaySessionsStreamCursorInput>>;
  where?: InputMaybe<GroupsPlaySessionsBoolExp>;
};


export type Subscription_RootGroupsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<GroupsStreamCursorInput>>;
  where?: InputMaybe<GroupsBoolExp>;
};


export type Subscription_RootLessonEquipmentArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Subscription_RootLessonEquipmentAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOrderBy>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Subscription_RootLessonEquipmentByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonEquipmentOptionsArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOptionsOrderBy>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Subscription_RootLessonEquipmentOptionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonEquipmentOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonEquipmentOptionsOrderBy>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Subscription_RootLessonEquipmentOptionsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonEquipmentOptionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonEquipmentOptionsStreamCursorInput>>;
  where?: InputMaybe<LessonEquipmentOptionsBoolExp>;
};


export type Subscription_RootLessonEquipmentStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonEquipmentStreamCursorInput>>;
  where?: InputMaybe<LessonEquipmentBoolExp>;
};


export type Subscription_RootLessonOrderItemsArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Subscription_RootLessonOrderItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrderItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrderItemsOrderBy>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Subscription_RootLessonOrderItemsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonOrderItemsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonOrderItemsStreamCursorInput>>;
  where?: InputMaybe<LessonOrderItemsBoolExp>;
};


export type Subscription_RootLessonOrdersArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Subscription_RootLessonOrdersAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonOrdersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonOrdersOrderBy>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Subscription_RootLessonOrdersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonOrdersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonOrdersStreamCursorInput>>;
  where?: InputMaybe<LessonOrdersBoolExp>;
};


export type Subscription_RootLessonParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantStatusesOrderBy>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Subscription_RootLessonParticipantStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantStatusesOrderBy>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Subscription_RootLessonParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonParticipantStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonParticipantStatusesStreamCursorInput>>;
  where?: InputMaybe<LessonParticipantStatusesBoolExp>;
};


export type Subscription_RootLessonParticipantsArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Subscription_RootLessonParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonParticipantsOrderBy>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Subscription_RootLessonParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonParticipantsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonParticipantsStreamCursorInput>>;
  where?: InputMaybe<LessonParticipantsBoolExp>;
};


export type Subscription_RootLessonPrivacyArgs = {
  distinctOn?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonPrivacyOrderBy>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Subscription_RootLessonPrivacyAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonPrivacyOrderBy>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Subscription_RootLessonPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonPrivacyStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonPrivacyStreamCursorInput>>;
  where?: InputMaybe<LessonPrivacyBoolExp>;
};


export type Subscription_RootLessonStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonStatusesOrderBy>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Subscription_RootLessonStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonStatusesOrderBy>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Subscription_RootLessonStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonStatusesStreamCursorInput>>;
  where?: InputMaybe<LessonStatusesBoolExp>;
};


export type Subscription_RootLessonTemplatesArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Subscription_RootLessonTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTemplatesOrderBy>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Subscription_RootLessonTemplatesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonTemplatesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonTemplatesStreamCursorInput>>;
  where?: InputMaybe<LessonTemplatesBoolExp>;
};


export type Subscription_RootLessonTimesArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Subscription_RootLessonTimesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTimesOrderBy>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Subscription_RootLessonTimesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonTimesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonTimesStreamCursorInput>>;
  where?: InputMaybe<LessonTimesBoolExp>;
};


export type Subscription_RootLessonTypesArgs = {
  distinctOn?: InputMaybe<Array<LessonTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTypesOrderBy>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Subscription_RootLessonTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonTypesOrderBy>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Subscription_RootLessonTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonTypesStreamCursorInput>>;
  where?: InputMaybe<LessonTypesBoolExp>;
};


export type Subscription_RootLessonWaitlistStatusesArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistStatusesOrderBy>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Subscription_RootLessonWaitlistStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistStatusesOrderBy>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Subscription_RootLessonWaitlistStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLessonWaitlistStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonWaitlistStatusesStreamCursorInput>>;
  where?: InputMaybe<LessonWaitlistStatusesBoolExp>;
};


export type Subscription_RootLessonWaitlistsArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Subscription_RootLessonWaitlistsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonWaitlistsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonWaitlistsOrderBy>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Subscription_RootLessonWaitlistsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonWaitlistsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonWaitlistsStreamCursorInput>>;
  where?: InputMaybe<LessonWaitlistsBoolExp>;
};


export type Subscription_RootLessonsArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Subscription_RootLessonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LessonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LessonsOrderBy>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Subscription_RootLessonsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLessonsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<LessonsStreamCursorInput>>;
  where?: InputMaybe<LessonsBoolExp>;
};


export type Subscription_RootMatchSelectionCriteriaArgs = {
  distinctOn?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MatchSelectionCriteriaOrderBy>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Subscription_RootMatchSelectionCriteriaAggregateArgs = {
  distinctOn?: InputMaybe<Array<MatchSelectionCriteriaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MatchSelectionCriteriaOrderBy>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Subscription_RootMatchSelectionCriteriaByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootMatchSelectionCriteriaStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<MatchSelectionCriteriaStreamCursorInput>>;
  where?: InputMaybe<MatchSelectionCriteriaBoolExp>;
};


export type Subscription_RootNotificationActionTypesArgs = {
  distinctOn?: InputMaybe<Array<NotificationActionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationActionTypesOrderBy>>;
  where?: InputMaybe<NotificationActionTypesBoolExp>;
};


export type Subscription_RootNotificationActionTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationActionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationActionTypesOrderBy>>;
  where?: InputMaybe<NotificationActionTypesBoolExp>;
};


export type Subscription_RootNotificationActionTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootNotificationActionTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<NotificationActionTypesStreamCursorInput>>;
  where?: InputMaybe<NotificationActionTypesBoolExp>;
};


export type Subscription_RootNotificationStatusesArgs = {
  distinctOn?: InputMaybe<Array<NotificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationStatusesOrderBy>>;
  where?: InputMaybe<NotificationStatusesBoolExp>;
};


export type Subscription_RootNotificationStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationStatusesOrderBy>>;
  where?: InputMaybe<NotificationStatusesBoolExp>;
};


export type Subscription_RootNotificationStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootNotificationStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<NotificationStatusesStreamCursorInput>>;
  where?: InputMaybe<NotificationStatusesBoolExp>;
};


export type Subscription_RootOrderStatusesArgs = {
  distinctOn?: InputMaybe<Array<OrderStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrderStatusesOrderBy>>;
  where?: InputMaybe<OrderStatusesBoolExp>;
};


export type Subscription_RootOrderStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<OrderStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrderStatusesOrderBy>>;
  where?: InputMaybe<OrderStatusesBoolExp>;
};


export type Subscription_RootOrderStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootOrderStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<OrderStatusesStreamCursorInput>>;
  where?: InputMaybe<OrderStatusesBoolExp>;
};


export type Subscription_RootPaymentFulfillmentChannelsArgs = {
  distinctOn?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentFulfillmentChannelsOrderBy>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Subscription_RootPaymentFulfillmentChannelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PaymentFulfillmentChannelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentFulfillmentChannelsOrderBy>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Subscription_RootPaymentFulfillmentChannelsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPaymentFulfillmentChannelsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PaymentFulfillmentChannelsStreamCursorInput>>;
  where?: InputMaybe<PaymentFulfillmentChannelsBoolExp>;
};


export type Subscription_RootPaymentProcessorsArgs = {
  distinctOn?: InputMaybe<Array<PaymentProcessorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentProcessorsOrderBy>>;
  where?: InputMaybe<PaymentProcessorsBoolExp>;
};


export type Subscription_RootPaymentProcessorsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PaymentProcessorsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentProcessorsOrderBy>>;
  where?: InputMaybe<PaymentProcessorsBoolExp>;
};


export type Subscription_RootPaymentProcessorsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPaymentProcessorsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PaymentProcessorsStreamCursorInput>>;
  where?: InputMaybe<PaymentProcessorsBoolExp>;
};


export type Subscription_RootPickleballRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PickleballRatingScalesOrderBy>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Subscription_RootPickleballRatingScalesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PickleballRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PickleballRatingScalesOrderBy>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Subscription_RootPickleballRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPickleballRatingScalesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PickleballRatingScalesStreamCursorInput>>;
  where?: InputMaybe<PickleballRatingScalesBoolExp>;
};


export type Subscription_RootPlaySessionCommentsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Subscription_RootPlaySessionCommentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCommentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCommentsOrderBy>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Subscription_RootPlaySessionCommentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlaySessionCommentsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionCommentsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionCommentsBoolExp>;
};


export type Subscription_RootPlaySessionCourtBookingStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCourtBookingStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Subscription_RootPlaySessionCourtBookingStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionCourtBookingStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionCourtBookingStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Subscription_RootPlaySessionCourtBookingStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionCourtBookingStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionCourtBookingStatusesStreamCursorInput>>;
  where?: InputMaybe<PlaySessionCourtBookingStatusesBoolExp>;
};


export type Subscription_RootPlaySessionFormatsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionFormatsOrderBy>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Subscription_RootPlaySessionFormatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionFormatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionFormatsOrderBy>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Subscription_RootPlaySessionFormatsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionFormatsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionFormatsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionFormatsBoolExp>;
};


export type Subscription_RootPlaySessionMatchCompetitivenessArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionMatchCompetitivenessOrderBy>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Subscription_RootPlaySessionMatchCompetitivenessAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionMatchCompetitivenessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionMatchCompetitivenessOrderBy>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Subscription_RootPlaySessionMatchCompetitivenessByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionMatchCompetitivenessStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionMatchCompetitivenessStreamCursorInput>>;
  where?: InputMaybe<PlaySessionMatchCompetitivenessBoolExp>;
};


export type Subscription_RootPlaySessionParticipantStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Subscription_RootPlaySessionParticipantStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Subscription_RootPlaySessionParticipantStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionParticipantStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionParticipantStatusesStreamCursorInput>>;
  where?: InputMaybe<PlaySessionParticipantStatusesBoolExp>;
};


export type Subscription_RootPlaySessionParticipantsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Subscription_RootPlaySessionParticipantsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionParticipantsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionParticipantsOrderBy>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Subscription_RootPlaySessionParticipantsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlaySessionParticipantsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionParticipantsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionParticipantsBoolExp>;
};


export type Subscription_RootPlaySessionPrivacyArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionPrivacyOrderBy>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Subscription_RootPlaySessionPrivacyAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionPrivacySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionPrivacyOrderBy>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Subscription_RootPlaySessionPrivacyByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionPrivacyStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionPrivacyStreamCursorInput>>;
  where?: InputMaybe<PlaySessionPrivacyBoolExp>;
};


export type Subscription_RootPlaySessionStatusesArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Subscription_RootPlaySessionStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionStatusesOrderBy>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Subscription_RootPlaySessionStatusesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootPlaySessionStatusesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionStatusesStreamCursorInput>>;
  where?: InputMaybe<PlaySessionStatusesBoolExp>;
};


export type Subscription_RootPlaySessionsArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Subscription_RootPlaySessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PlaySessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlaySessionsOrderBy>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Subscription_RootPlaySessionsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlaySessionsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<PlaySessionsStreamCursorInput>>;
  where?: InputMaybe<PlaySessionsBoolExp>;
};


export type Subscription_RootScoringFormatArgs = {
  distinctOn?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ScoringFormatOrderBy>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Subscription_RootScoringFormatAggregateArgs = {
  distinctOn?: InputMaybe<Array<ScoringFormatSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ScoringFormatOrderBy>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Subscription_RootScoringFormatByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootScoringFormatStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<ScoringFormatStreamCursorInput>>;
  where?: InputMaybe<ScoringFormatBoolExp>;
};


export type Subscription_RootSignupRequestsArgs = {
  distinctOn?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SignupRequestsOrderBy>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Subscription_RootSignupRequestsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SignupRequestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SignupRequestsOrderBy>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Subscription_RootSignupRequestsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSignupRequestsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<SignupRequestsStreamCursorInput>>;
  where?: InputMaybe<SignupRequestsBoolExp>;
};


export type Subscription_RootSkillLevelsArgs = {
  distinctOn?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkillLevelsOrderBy>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Subscription_RootSkillLevelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SkillLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SkillLevelsOrderBy>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Subscription_RootSkillLevelsByPkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootSkillLevelsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<SkillLevelsStreamCursorInput>>;
  where?: InputMaybe<SkillLevelsBoolExp>;
};


export type Subscription_RootSportsArgs = {
  distinctOn?: InputMaybe<Array<SportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SportsOrderBy>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Subscription_RootSportsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SportsOrderBy>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Subscription_RootSportsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootSportsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<SportsStreamCursorInput>>;
  where?: InputMaybe<SportsBoolExp>;
};


export type Subscription_RootStripeChargesArgs = {
  distinctOn?: InputMaybe<Array<StripeChargesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripeChargesOrderBy>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};


export type Subscription_RootStripeChargesAggregateArgs = {
  distinctOn?: InputMaybe<Array<StripeChargesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripeChargesOrderBy>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};


export type Subscription_RootStripeChargesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootStripeChargesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<StripeChargesStreamCursorInput>>;
  where?: InputMaybe<StripeChargesBoolExp>;
};


export type Subscription_RootStripePaymentIntentsArgs = {
  distinctOn?: InputMaybe<Array<StripePaymentIntentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripePaymentIntentsOrderBy>>;
  where?: InputMaybe<StripePaymentIntentsBoolExp>;
};


export type Subscription_RootStripePaymentIntentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<StripePaymentIntentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StripePaymentIntentsOrderBy>>;
  where?: InputMaybe<StripePaymentIntentsBoolExp>;
};


export type Subscription_RootStripePaymentIntentsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootStripePaymentIntentsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<StripePaymentIntentsStreamCursorInput>>;
  where?: InputMaybe<StripePaymentIntentsBoolExp>;
};


export type Subscription_RootTeamTypesArgs = {
  distinctOn?: InputMaybe<Array<TeamTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TeamTypesOrderBy>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Subscription_RootTeamTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TeamTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TeamTypesOrderBy>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Subscription_RootTeamTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootTeamTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<TeamTypesStreamCursorInput>>;
  where?: InputMaybe<TeamTypesBoolExp>;
};


export type Subscription_RootTennisRatingScalesArgs = {
  distinctOn?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TennisRatingScalesOrderBy>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Subscription_RootTennisRatingScalesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TennisRatingScalesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TennisRatingScalesOrderBy>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Subscription_RootTennisRatingScalesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootTennisRatingScalesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<TennisRatingScalesStreamCursorInput>>;
  where?: InputMaybe<TennisRatingScalesBoolExp>;
};


export type Subscription_RootUserAuthIdentitiesArgs = {
  distinctOn?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserAuthIdentitiesOrderBy>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


export type Subscription_RootUserAuthIdentitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserAuthIdentitiesOrderBy>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


export type Subscription_RootUserAuthIdentitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserAuthIdentitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserAuthIdentitiesStreamCursorInput>>;
  where?: InputMaybe<UserAuthIdentitiesBoolExp>;
};


export type Subscription_RootUserCoachServicesArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Subscription_RootUserCoachServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCoachServicesOrderBy>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Subscription_RootUserCoachServicesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCoachServicesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCoachServicesStreamCursorInput>>;
  where?: InputMaybe<UserCoachServicesBoolExp>;
};


export type Subscription_RootUserCommunicationPreferencesArgs = {
  distinctOn?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCommunicationPreferencesOrderBy>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Subscription_RootUserCommunicationPreferencesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCommunicationPreferencesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCommunicationPreferencesOrderBy>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Subscription_RootUserCommunicationPreferencesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCommunicationPreferencesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCommunicationPreferencesStreamCursorInput>>;
  where?: InputMaybe<UserCommunicationPreferencesBoolExp>;
};


export type Subscription_RootUserCreditCardsArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Subscription_RootUserCreditCardsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCreditCardsOrderBy>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Subscription_RootUserCreditCardsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCreditCardsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCreditCardsStreamCursorInput>>;
  where?: InputMaybe<UserCreditCardsBoolExp>;
};


export type Subscription_RootUserCustomCourtsArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Subscription_RootUserCustomCourtsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserCustomCourtsOrderBy>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Subscription_RootUserCustomCourtsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserCustomCourtsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserCustomCourtsStreamCursorInput>>;
  where?: InputMaybe<UserCustomCourtsBoolExp>;
};


export type Subscription_RootUserFollowsArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Subscription_RootUserFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserFollowsOrderBy>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Subscription_RootUserFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserFollowsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserFollowsStreamCursorInput>>;
  where?: InputMaybe<UserFollowsBoolExp>;
};


export type Subscription_RootUserImageLogArgs = {
  distinctOn?: InputMaybe<Array<UserImageLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserImageLogOrderBy>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Subscription_RootUserImageLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserImageLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserImageLogOrderBy>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Subscription_RootUserImageLogByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserImageLogStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserImageLogStreamCursorInput>>;
  where?: InputMaybe<UserImageLogBoolExp>;
};


export type Subscription_RootUserNotificationDetailsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationDetailsOrderBy>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Subscription_RootUserNotificationDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationDetailsOrderBy>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Subscription_RootUserNotificationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserNotificationDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserNotificationDetailsStreamCursorInput>>;
  where?: InputMaybe<UserNotificationDetailsBoolExp>;
};


export type Subscription_RootUserNotificationEntitiesArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationEntitiesOrderBy>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Subscription_RootUserNotificationEntitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationEntitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationEntitiesOrderBy>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Subscription_RootUserNotificationEntitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserNotificationEntitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserNotificationEntitiesStreamCursorInput>>;
  where?: InputMaybe<UserNotificationEntitiesBoolExp>;
};


export type Subscription_RootUserNotificationsArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Subscription_RootUserNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserNotificationsOrderBy>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Subscription_RootUserNotificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserNotificationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserNotificationsStreamCursorInput>>;
  where?: InputMaybe<UserNotificationsBoolExp>;
};


export type Subscription_RootUserProfilesArgs = {
  distinctOn?: InputMaybe<Array<UserProfilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserProfilesOrderBy>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Subscription_RootUserProfilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserProfilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserProfilesOrderBy>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Subscription_RootUserProfilesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserProfilesStreamCursorInput>>;
  where?: InputMaybe<UserProfilesBoolExp>;
};


export type Subscription_RootUserRegistrationDetailsArgs = {
  distinctOn?: InputMaybe<Array<UserRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserRegistrationDetailsOrderBy>>;
  where?: InputMaybe<UserRegistrationDetailsBoolExp>;
};


export type Subscription_RootUserRegistrationDetailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRegistrationDetailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserRegistrationDetailsOrderBy>>;
  where?: InputMaybe<UserRegistrationDetailsBoolExp>;
};


export type Subscription_RootUserRegistrationDetailsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserRegistrationDetailsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserRegistrationDetailsStreamCursorInput>>;
  where?: InputMaybe<UserRegistrationDetailsBoolExp>;
};


export type Subscription_RootUserTermsOfServiceArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Subscription_RootUserTermsOfServiceAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserTermsOfServiceOrderBy>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Subscription_RootUserTermsOfServiceByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUserTermsOfServiceStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UserTermsOfServiceStreamCursorInput>>;
  where?: InputMaybe<UserTermsOfServiceBoolExp>;
};


export type Subscription_RootUsernameLogsArgs = {
  distinctOn?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernameLogsOrderBy>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


export type Subscription_RootUsernameLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernameLogsOrderBy>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


export type Subscription_RootUsernameLogsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsernameLogsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsernameLogsStreamCursorInput>>;
  where?: InputMaybe<UsernameLogsBoolExp>;
};


export type Subscription_RootUsernamesActiveArgs = {
  distinctOn?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesActiveOrderBy>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Subscription_RootUsernamesActiveAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernamesActiveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesActiveOrderBy>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Subscription_RootUsernamesActiveStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsernamesActiveStreamCursorInput>>;
  where?: InputMaybe<UsernamesActiveBoolExp>;
};


export type Subscription_RootUsernamesClaimedArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Subscription_RootUsernamesClaimedAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsernamesClaimedOrderBy>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Subscription_RootUsernamesClaimedByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsernamesClaimedStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsernamesClaimedStreamCursorInput>>;
  where?: InputMaybe<UsernamesClaimedBoolExp>;
};


export type Subscription_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsersCoachQualificationsArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Subscription_RootUsersCoachQualificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersCoachQualificationsOrderBy>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Subscription_RootUsersCoachQualificationsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsersCoachQualificationsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsersCoachQualificationsStreamCursorInput>>;
  where?: InputMaybe<UsersCoachQualificationsBoolExp>;
};


export type Subscription_RootUsersStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<UsersStreamCursorInput>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootVenueAccessTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAccessTypesOrderBy>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Subscription_RootVenueAccessTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueAccessTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAccessTypesOrderBy>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Subscription_RootVenueAccessTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueAccessTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueAccessTypesStreamCursorInput>>;
  where?: InputMaybe<VenueAccessTypesBoolExp>;
};


export type Subscription_RootVenueAmenitiesArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Subscription_RootVenueAmenitiesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueAmenitiesOrderBy>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Subscription_RootVenueAmenitiesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueAmenitiesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueAmenitiesStreamCursorInput>>;
  where?: InputMaybe<VenueAmenitiesBoolExp>;
};


export type Subscription_RootVenueCourtSurfacesArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Subscription_RootVenueCourtSurfacesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueCourtSurfacesOrderBy>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Subscription_RootVenueCourtSurfacesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueCourtSurfacesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueCourtSurfacesStreamCursorInput>>;
  where?: InputMaybe<VenueCourtSurfacesBoolExp>;
};


export type Subscription_RootVenueFacilityTypesArgs = {
  distinctOn?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFacilityTypesOrderBy>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Subscription_RootVenueFacilityTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueFacilityTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFacilityTypesOrderBy>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Subscription_RootVenueFacilityTypesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueFacilityTypesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueFacilityTypesStreamCursorInput>>;
  where?: InputMaybe<VenueFacilityTypesBoolExp>;
};


export type Subscription_RootVenueFollowsArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Subscription_RootVenueFollowsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueFollowsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueFollowsOrderBy>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Subscription_RootVenueFollowsByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueFollowsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueFollowsStreamCursorInput>>;
  where?: InputMaybe<VenueFollowsBoolExp>;
};


export type Subscription_RootVenueImagesArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Subscription_RootVenueImagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueImagesOrderBy>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Subscription_RootVenueImagesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenueImagesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueImagesStreamCursorInput>>;
  where?: InputMaybe<VenueImagesBoolExp>;
};


export type Subscription_RootVenueLinesArgs = {
  distinctOn?: InputMaybe<Array<VenueLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueLinesOrderBy>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Subscription_RootVenueLinesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueLinesOrderBy>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Subscription_RootVenueLinesByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueLinesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueLinesStreamCursorInput>>;
  where?: InputMaybe<VenueLinesBoolExp>;
};


export type Subscription_RootVenueNetsArgs = {
  distinctOn?: InputMaybe<Array<VenueNetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueNetsOrderBy>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Subscription_RootVenueNetsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenueNetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenueNetsOrderBy>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Subscription_RootVenueNetsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootVenueNetsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenueNetsStreamCursorInput>>;
  where?: InputMaybe<VenueNetsBoolExp>;
};


export type Subscription_RootVenuesArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Subscription_RootVenuesAggregateArgs = {
  distinctOn?: InputMaybe<Array<VenuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Subscription_RootVenuesByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVenuesStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<VenuesStreamCursorInput>>;
  where?: InputMaybe<VenuesBoolExp>;
};


export type Subscription_RootWelcomeEmailConfigurationArgs = {
  distinctOn?: InputMaybe<Array<WelcomeEmailConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WelcomeEmailConfigurationOrderBy>>;
  where?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
};


export type Subscription_RootWelcomeEmailConfigurationAggregateArgs = {
  distinctOn?: InputMaybe<Array<WelcomeEmailConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WelcomeEmailConfigurationOrderBy>>;
  where?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
};


export type Subscription_RootWelcomeEmailConfigurationByPkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootWelcomeEmailConfigurationStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<WelcomeEmailConfigurationStreamCursorInput>>;
  where?: InputMaybe<WelcomeEmailConfigurationBoolExp>;
};


export type Subscription_RootWinReasonsArgs = {
  distinctOn?: InputMaybe<Array<WinReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WinReasonsOrderBy>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};


export type Subscription_RootWinReasonsAggregateArgs = {
  distinctOn?: InputMaybe<Array<WinReasonsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WinReasonsOrderBy>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};


export type Subscription_RootWinReasonsByPkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootWinReasonsStreamArgs = {
  batchSize: Scalars['Int'];
  cursor: Array<InputMaybe<WinReasonsStreamCursorInput>>;
  where?: InputMaybe<WinReasonsBoolExp>;
};

export type UserAuthIdentitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserAuthIdentitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserAuthIdentitiesBoolExp>;
  predicate: IntComparisonExp;
};

export type UserCoachServicesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserCoachServicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserCoachServicesBoolExp>;
  predicate: IntComparisonExp;
};

export type UserCreditCardsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserCreditCardsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserCreditCardsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserCustomCourtsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserCustomCourtsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserCustomCourtsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserFollowsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserFollowsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserFollowsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserNotificationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserNotificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserNotificationsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserTermsOfServiceAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserTermsOfServiceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UserTermsOfServiceBoolExp>;
  predicate: IntComparisonExp;
};

export type UsernameLogsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UsernameLogsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UsernameLogsBoolExp>;
  predicate: IntComparisonExp;
};

export type UsernamesClaimedAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UsernamesClaimedSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UsernamesClaimedBoolExp>;
  predicate: IntComparisonExp;
};

export type UsersCoachQualificationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UsersCoachQualificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<UsersCoachQualificationsBoolExp>;
  predicate: IntComparisonExp;
};

export type VenueAmenitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<VenueAmenitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenueAmenitiesBoolExp>;
  predicate: IntComparisonExp;
};

export type VenueCourtSurfacesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<VenueCourtSurfacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenueCourtSurfacesBoolExp>;
  predicate: IntComparisonExp;
};

export type VenueImagesAggregateBoolExpBool_And = {
  arguments: VenueImagesSelectColumnVenueImagesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenueImagesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VenueImagesAggregateBoolExpBool_Or = {
  arguments: VenueImagesSelectColumnVenueImagesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenueImagesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VenueImagesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<VenueImagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenueImagesBoolExp>;
  predicate: IntComparisonExp;
};

export type VenuesAggregateBoolExpBool_And = {
  arguments: VenuesSelectColumnVenuesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenuesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VenuesAggregateBoolExpBool_Or = {
  arguments: VenuesSelectColumnVenuesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenuesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VenuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<VenuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<VenuesBoolExp>;
  predicate: IntComparisonExp;
};

export type InsertUserMutationVariables = Exact<{
  id: Scalars['uuid'];
  email: Scalars['String'];
  firebaseId: Scalars['String'];
  stripeCustomerId: Scalars['String'];
  identityData?: InputMaybe<Array<UserAuthIdentitiesInsertInput> | UserAuthIdentitiesInsertInput>;
  latestAuthProvider: Scalars['String'];
  originalAuthProvider: Scalars['String'];
  fullName: Scalars['String'];
  preferredName: Scalars['String'];
  coachStatus: CoachStatusEnum;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  fullDetails?: InputMaybe<Scalars['jsonb']>;
  ip?: InputMaybe<Scalars['String']>;
  platform?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  claimData?: InputMaybe<Array<UsernamesClaimedInsertInput> | UsernamesClaimedInsertInput>;
  logData?: InputMaybe<Array<UsernameLogsInsertInput> | UsernameLogsInsertInput>;
  latitude?: InputMaybe<Scalars['numeric']>;
  longitude?: InputMaybe<Scalars['numeric']>;
  activeCityId?: InputMaybe<Scalars['uuid']>;
  geometry?: InputMaybe<Scalars['geography']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  eventOrganizerAccountType?: InputMaybe<EventOrganizerAccountTypesEnum>;
}>;


export type InsertUserMutation = { __typename?: 'mutation_root', insertUsersOne?: { __typename?: 'Users', id: any, firebaseId: string, email: string, stripeCustomerId: string, updatedAt: any, createdAt: any, latitude?: any | null, longitude?: any | null, fullName: string, phoneNumber?: string | null, eventOrganizerAccountType: EventOrganizerAccountTypesEnum, activeCity?: { __typename?: 'Cities', id: any, name: string, countrySubdivision: { __typename?: 'CountrySubdivisions', id: any, name: string } } | null } | null };

export type InsertUserCommunicationPreferencesMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type InsertUserCommunicationPreferencesMutation = { __typename?: 'mutation_root', insertUserCommunicationPreferencesOne?: { __typename?: 'UserCommunicationPreferences', id: any } | null };

export type UpadateUsernameMutationVariables = Exact<{
  id: Scalars['uuid'];
  username: Scalars['String'];
}>;


export type UpadateUsernameMutation = { __typename?: 'mutation_root', updateUsersByPk?: { __typename?: 'Users', id: any, username?: string | null } | null, insertUsernamesClaimedOne?: { __typename?: 'UsernamesClaimed', id: any } | null, insertUsernameLogsOne?: { __typename?: 'UsernameLogs', id: any, currentUsername: string } | null };

export type CheckUsernameAvailabilityQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type CheckUsernameAvailabilityQuery = { __typename?: 'query_root', usernamesActive: Array<{ __typename?: 'UsernamesActive', username?: string | null }>, usernamesClaimed: Array<{ __typename?: 'UsernamesClaimed', id: any, username: string }> };

export type GetRecentSignupRequestQueryVariables = Exact<{
  email: Scalars['String'];
}>;


export type GetRecentSignupRequestQuery = { __typename?: 'query_root', signupRequests: Array<{ __typename?: 'SignupRequests', accountType: string, createdAt: any, deletedAt?: any | null, email: string, id: any, ip: string, updatedAt: any, username: string, fullName: string, preferredName: string, zip: string, timezone: string, region: string, platform: string, fullDetails?: any | null, country: string, city: string, latitude?: any | null, longitude?: any | null, cityId?: any | null, eventOrganizerAccountType?: EventOrganizerAccountTypesEnum | null, phoneNumber?: string | null }>, welcomeEmailConfiguration: Array<{ __typename?: 'WelcomeEmailConfiguration', email: string, id: any, template?: string | null }> };
